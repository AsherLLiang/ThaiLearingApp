This file is a merged representation of the entire codebase, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
.claude/
  settings.local.json
app/
  (auth)/
    _layout.tsx
    forgot-password.tsx
    login.tsx
    register.tsx
  (dev)/
    _layout.tsx
    playground.tsx
    viewer.tsx
  (tabs)/
    _layout.tsx
    courses.tsx
    index.tsx
    profile.tsx
  alphabet/
    [lessonId].tsx
    index.tsx
    test.tsx
  learning/
    _layout.tsx
    index.tsx
    setup.tsx
  _layout.tsx
  review-modal.tsx
assets/
  images/
    courses/
      thai_alphabet.png
      ThaiBase_1.png
      ThaiBase_2.png
      ThaiBase_3.png
      ThaiBase_4.png
  adaptive-icon.png
  favicon.png
  icon.png
  splash-icon.png
cloudbase/
  functions/
    alphabet/
      handlers/
        getAllLetters.js
        getLetterTest.js
        passLetterTest.js
        submitLetterTest.js
      utils/
        constants.js
        database.js
        index.js
        memoryEngine.js
        response.js
        sm2.js
        validators.js
      index.js
      package.json
    learn-vocab/
      handlers/
        getReviewStatistics.js
        getSkippedWords.js
        getTodayWords.js
        getVocabularyDetail.js
        getVocabularyList.js
        toggleSkipWord.js
        updateMastery.js
      utils/
        constants.js
        database.js
        index.js
        memoryEngine.js
        response.js
        sm2.js
        validators.js
      index.js
      package.json
    memory-engine/
      config/
        alphabetLessonConfig.js
      handlers/
        checkModuleAccess.js
        getAlphabetLessons.js
        getTodayMemories.js
        getUserProgress.js
        submitMemoryResult.js
        submitRoundEvaluation.js
      utils/
        constants.js
        database.js
        index.js
        memoryEngine.js
        response.js
        sm2.js
        validators.js
      index.js
      package.json
    shared/
      constants.js
      database.js
      index.js
      memoryEngine.js
      package.json
      response.js
      sm2.js
      validators.js
    storage-download/
      index.js
      package.json
    user-login/
      index.js
      package.json
    user-register/
      index.js
      package.json
    user-reset-password/
      index.js
      package.json
    user-update-profile/
      index.js
      package.json
  cloudbaserc.json
  fix-cloud-functions.sh
  package.json
  test-all-apis.sh
  test-comprehensive.sh
docs/
  project-freeze/
    ai-module-spec.md
    alphabet-module-spec.md
    backend-memory-engine-spec.md
    courses-and-learningstore-spec.md
    database_schema.md
    frontend-shell-module-spec.md
    PROJECT_OVERVIEW_SPEC.md
    README.md
    vocabulary-module-spec.md
  PRONUNCIATION_RESTORATION_FROZEN.md
  PRONUNCIATION_RESTORATION_MODULE_SPEC_FROZEN_v1.0.md
scripts/
  getAudioJsonFromWeb.js
  getVocabJsonFromWeb.js
src/
  components/
    common/
      Button.tsx
      Card.tsx
      FloatingBubbles.tsx
      GlassCard.tsx
      LanguageSwitcher.tsx
      ListContainer.tsx
      ThaiPatternBackground.tsx
    courses/
      AlphabetCourseCard.tsx
      CourseCard.tsx
      CourseSelectionModal.tsx
    learning/
      alphabet/
        AlphabetCompletionView.tsx
        AlphabetLearningEngineView.tsx
        AlphabetLearningView.tsx
        AlphabetReviewView.tsx
        AspiratedContrastQuestion.tsx
        MiniReviewQuestion.tsx
        PhonicsRuleCard.tsx
        RoundCompletionView.tsx
        SessionRecoveryCard.tsx
      ModuleLockedScreen.tsx
      NewWordView.tsx
      ReviewWordView.tsx
  config/
    alphabet/
      alphabetQuestionGenerator.ts
      alphabetQuestionTypes.ts
      lessonMetadata.config.ts
      lettersSequence.ts
      phonicsRules.config.ts
    api.endpoints.ts
    backend.config.ts
    constants.ts
  constants/
    colors.ts
    typography.ts
  dev/
    mocks/
      phonicsRule.mock.ts
    registry.ts
  entities/
    enums/
      LearningPhase.enum.ts
      QualityScore.enum.ts
      QuestionType.enum.ts
    types/
      alphabet.types.ts
      alphabetGameTypes.ts
      api.types.ts
      course.ts
      entities.ts
      learning.ts
      letter.types.ts
      memory.types.ts
      phonicsRule.types.ts
      storage.types.ts
      test.types.ts
      user.ts
      vocabulary.types.ts
  hooks/
    useAlphabetLearningEngine.ts
    useModuleAccess.ts
  i18n/
    locales/
      en.ts
      zh.ts
    index.ts
  stores/
    alphabetStore.ts
    languageStore.ts
    learningPreferenceStore.ts
    learningStore.ts
    moduleAccessStore.ts
    moduleAccessStore.ts.backup
    storageStore.ts
    userStore.ts
    vocabularyStore.ts
  utils/
    alphabet/
      audioHelper.ts
      buildAlphabetQueue.ts
    alphabetQuestionTypeAssigner.ts
    apiClient.ts
    lettersDistractorEngine.ts
    lettersQuestionGenerator.ts
    ModuleGuard.tsx
    validation.ts
.gitignore
.nvmrc
.skip-template
app.json
babel.config.js
CLAUDE.md
cloudbaserc.json
convert-json-to-jsonl-but-keep-json.js
global.css
index.ts
package.json
README.md
repomix-output.xml
tailwind.config.js
tsconfig.json
```

# Files

## File: repomix-output.xml
````xml
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
app/
  (auth)/
    _layout.tsx
    forgot-password.tsx
    login.tsx
    register.tsx
  (dev)/
    _layout.tsx
    playground.tsx
    viewer.tsx
  (tabs)/
    _layout.tsx
    courses.tsx
    index.tsx
    profile.tsx
  alphabet/
    [lessonId].tsx
    index.tsx
    test.tsx
  learning/
    _layout.tsx
    index.tsx
    setup.tsx
  _layout.tsx
  review-modal.tsx
assets/
  images/
    courses/
      thai_alphabet.png
      ThaiBase_1.png
      ThaiBase_2.png
      ThaiBase_3.png
      ThaiBase_4.png
  adaptive-icon.png
  favicon.png
  icon.png
  splash-icon.png
cloudbase/
  functions/
    alphabet/
      handlers/
        getAllLetters.js
        getLetterTest.js
        passLetterTest.js
        submitLetterTest.js
      utils/
        constants.js
        database.js
        index.js
        memoryEngine.js
        response.js
        sm2.js
        validators.js
      index.js
      package.json
    learn-vocab/
      handlers/
        getReviewStatistics.js
        getSkippedWords.js
        getTodayWords.js
        getVocabularyDetail.js
        getVocabularyList.js
        toggleSkipWord.js
        updateMastery.js
      utils/
        constants.js
        database.js
        index.js
        memoryEngine.js
        response.js
        sm2.js
        validators.js
      index.js
      package.json
    memory-engine/
      config/
        alphabetLessonConfig.js
      handlers/
        checkModuleAccess.js
        getAlphabetLessons.js
        getTodayMemories.js
        getUserProgress.js
        submitMemoryResult.js
        submitRoundEvaluation.js
      utils/
        constants.js
        database.js
        index.js
        memoryEngine.js
        response.js
        sm2.js
        validators.js
      index.js
      package.json
    shared/
      constants.js
      database.js
      index.js
      memoryEngine.js
      package.json
      response.js
      sm2.js
      validators.js
    storage-download/
      index.js
      package.json
    user-login/
      index.js
      package.json
    user-register/
      index.js
      package.json
    user-reset-password/
      index.js
      package.json
    user-update-profile/
      index.js
      package.json
  cloudbaserc.json
  fix-cloud-functions.sh
  package.json
  test-all-apis.sh
  test-comprehensive.sh
docs/
  project-freeze/
    ai-module-spec.md
    alphabet-module-spec.md
    backend-memory-engine-spec.md
    courses-and-learningstore-spec.md
    database_schema.md
    frontend-shell-module-spec.md
    PROJECT_OVERVIEW_SPEC.md
    README.md
    vocabulary-module-spec.md
  PRONUNCIATION_RESTORATION_FROZEN.md
  PRONUNCIATION_RESTORATION_MODULE_SPEC_FROZEN_v1.0.md
scripts/
  getAudioJsonFromWeb.js
  getVocabJsonFromWeb.js
src/
  components/
    common/
      Button.tsx
      Card.tsx
      FloatingBubbles.tsx
      GlassCard.tsx
      LanguageSwitcher.tsx
      ListContainer.tsx
      ThaiPatternBackground.tsx
    courses/
      AlphabetCourseCard.tsx
      CourseCard.tsx
      CourseSelectionModal.tsx
    learning/
      alphabet/
        AlphabetCompletionView.tsx
        AlphabetLearningEngineView.tsx
        AlphabetLearningView.tsx
        AlphabetReviewView.tsx
        AspiratedContrastQuestion.tsx
        MiniReviewQuestion.tsx
        PhonicsRuleCard.tsx
        RoundCompletionView.tsx
        SessionRecoveryCard.tsx
      ModuleLockedScreen.tsx
      NewWordView.tsx
      ReviewWordView.tsx
  config/
    alphabet/
      alphabetQuestionGenerator.ts
      alphabetQuestionTypes.ts
      lessonMetadata.config.ts
      lettersSequence.ts
      phonicsRules.config.ts
    api.endpoints.ts
    backend.config.ts
    constants.ts
  constants/
    colors.ts
    typography.ts
  dev/
    mocks/
      phonicsRule.mock.ts
    registry.ts
  entities/
    enums/
      LearningPhase.enum.ts
      QualityScore.enum.ts
      QuestionType.enum.ts
    types/
      alphabet.types.ts
      alphabetGameTypes.ts
      api.types.ts
      course.ts
      entities.ts
      learning.ts
      letter.types.ts
      memory.types.ts
      phonicsRule.types.ts
      storage.types.ts
      test.types.ts
      user.ts
      vocabulary.types.ts
  hooks/
    useAlphabetLearningEngine.ts
    useModuleAccess.ts
  i18n/
    locales/
      en.ts
      zh.ts
    index.ts
  stores/
    alphabetStore.ts
    languageStore.ts
    learningPreferenceStore.ts
    learningStore.ts
    moduleAccessStore.ts
    moduleAccessStore.ts.backup
    storageStore.ts
    userStore.ts
    vocabularyStore.ts
  utils/
    alphabet/
      audioHelper.ts
      buildAlphabetQueue.ts
    alphabetQuestionTypeAssigner.ts
    apiClient.ts
    lettersDistractorEngine.ts
    lettersQuestionGenerator.ts
    ModuleGuard.tsx
    validation.ts
.gitignore
.nvmrc
.skip-template
app.json
babel.config.js
CLAUDE.md
cloudbaserc.json
convert-json-to-jsonl-but-keep-json.js
global.css
index.ts
package.json
README.md
tailwind.config.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/(dev)/_layout.tsx">
import { Stack } from 'expo-router';
import React from 'react';
import { View, Text } from 'react-native';

export default function DevLayout() {
    // ğŸ›¡ï¸ æ ¸å¿ƒå®‰å…¨ç½‘ï¼šç”Ÿäº§ç¯å¢ƒç›´æ¥è¿”å› nullï¼Œç¡®ä¿è·¯ç”±ä¸å¯è¾¾
    if (!__DEV__) {
        return null;
    }

    return (
        <Stack
            screenOptions={{
                headerStyle: {
                    backgroundColor: '#F5F5F5',
                },
                headerTintColor: '#333',
                headerTitleStyle: {
                    fontWeight: 'bold',
                },
            }}
        >
            <Stack.Screen
                name="playground"
                options={{
                    title: 'ğŸ› ï¸ Playground',
                    headerLargeTitle: true,
                }}
            />
            <Stack.Screen
                name="viewer"
                options={{
                    title: 'Component Viewer',
                    presentation: 'modal', // æ¨¡æ€å±•ç¤ºæ„Ÿè§‰æ›´åƒç‹¬ç«‹çš„ Debug ç¯å¢ƒ
                }}
            />
        </Stack>
    );
}
</file>

<file path="app/(dev)/playground.tsx">
import React from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import { useRouter } from 'expo-router';
import { COMPONENT_REGISTRY } from '@/src/dev/registry';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { ChevronRight, FlaskConical, ChevronLeft } from 'lucide-react-native';

export default function PlaygroundScreen() {
    const router = useRouter();

    if (!__DEV__) return null;

    return (
        <ScrollView style={styles.container} contentContainerStyle={styles.content}>
            <View style={styles.header}>
                <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 12 }}>
                    <TouchableOpacity
                        onPress={() => router.back()}
                        style={{ marginRight: 12, padding: 4 }}
                    >
                        <ChevronLeft size={24} color={Colors.ink} />
                    </TouchableOpacity>
                    <Text style={{ fontFamily: Typography.notoSerifBold, fontSize: 24, color: Colors.ink }}>
                        Dev Playground
                    </Text>
                </View>
                <Text style={styles.description}>
                    UI ç»„ä»¶éš”ç¦»å¼€å‘ç¯å¢ƒã€‚æ­¤å¤„åˆ—å‡ºçš„ç»„ä»¶ä½¿ç”¨ Mock æ•°æ®ç‹¬ç«‹è¿è¡Œï¼Œä¸è§¦å‘çœŸå®ä¸šåŠ¡é€»è¾‘ã€‚
                </Text>
            </View>

            {COMPONENT_REGISTRY.map((component) => (
                <View key={component.id} style={styles.section}>
                    <View style={styles.sectionHeader}>
                        <Text style={styles.sectionTitle}>{component.name}</Text>
                        <Text style={styles.categoryBadge}>{component.category}</Text>
                    </View>

                    <View style={styles.card}>
                        {component.variants.map((variant, index) => (
                            <TouchableOpacity
                                key={variant.id}
                                style={[
                                    styles.item,
                                    index < component.variants.length - 1 && styles.borderBottom,
                                ]}
                                onPress={() => {
                                    router.push({
                                        pathname: '/(dev)/viewer',
                                        params: {
                                            componentId: component.id,
                                            variantId: variant.id,
                                            mockId: variant.mockId,
                                        },
                                    });
                                }}
                            >
                                <View style={styles.itemIcon}>
                                    <FlaskConical size={16} color={Colors.thaiGold} />
                                </View>
                                <Text style={styles.itemText}>{variant.name}</Text>
                                <ChevronRight size={16} color={Colors.taupe} />
                            </TouchableOpacity>
                        ))}
                    </View>
                </View>
            ))}
        </ScrollView>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#F2F2F7', // iOS Grouped Background color
    },
    content: {
        padding: 16,
        paddingBottom: 40,
    },
    header: {
        marginBottom: 24,
    },
    description: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.taupe,
        lineHeight: 20,
    },
    section: {
        marginBottom: 24,
    },
    sectionHeader: {
        flexDirection: 'row',
        alignItems: 'center',
        marginBottom: 8,
        paddingHorizontal: 4,
        justifyContent: 'space-between',
    },
    sectionTitle: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 13,
        color: '#666',
        textTransform: 'uppercase',
    },
    categoryBadge: {
        fontSize: 10,
        color: Colors.white,
        backgroundColor: Colors.taupe,
        paddingHorizontal: 6,
        paddingVertical: 2,
        borderRadius: 4,
        overflow: 'hidden',
    },
    card: {
        backgroundColor: Colors.white,
        borderRadius: 10,
        overflow: 'hidden',
    },
    item: {
        flexDirection: 'row',
        alignItems: 'center',
        padding: 16,
        backgroundColor: Colors.white,
    },
    borderBottom: {
        borderBottomWidth: StyleSheet.hairlineWidth,
        borderBottomColor: '#C6C6C8',
        marginLeft: 16, // iOS style separator inset
    },
    itemIcon: {
        marginRight: 12,
    },
    itemText: {
        flex: 1,
        fontFamily: Typography.notoSerifRegular,
        fontSize: 16,
        color: Colors.ink,
    },
});
</file>

<file path="app/(dev)/viewer.tsx">
import React from 'react';
import { View, Text, StyleSheet, SafeAreaView, ScrollView } from 'react-native';
import { useLocalSearchParams } from 'expo-router';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

// Components
import { PhonicsRuleCard } from '@/src/components/learning/alphabet/PhonicsRuleCard';

// Mocks
import { MOCK_PHONICS_RULES } from '@/src/dev/mocks/phonicsRule.mock';

export default function ComponentViewer() {
    const { componentId, variantId, mockId } = useLocalSearchParams<{
        componentId: string;
        variantId: string;
        mockId: string;
    }>();

    if (!__DEV__) return null;

    const renderContent = () => {
        switch (componentId) {
            case 'PhonicsRuleCard': {
                const rule = MOCK_PHONICS_RULES[mockId];
                if (!rule) return <ErrorState message={`Mock ID not found: ${mockId}`} />;

                return (
                    <PhonicsRuleCard
                        rule={rule}
                        onComplete={() => console.log('âœ… [Dev] onComplete triggered')}
                        showCloseButton={true}
                        onClose={() => console.log('âŒ [Dev] onClose triggered')}
                    />
                );
            }
            default:
                return <ErrorState message={`Component ID not found: ${componentId}`} />;
        }
    };

    return (
        <View style={styles.container}>
            {/* å±…ä¸­å®¹å™¨ï¼Œæ¨¡æ‹Ÿ Modal æ•ˆæœ */}
            <View style={styles.stage}>
                {renderContent()}
            </View>

            <View style={styles.debugPanel}>
                <Text style={styles.debugText}>Component: {componentId}</Text>
                <Text style={styles.debugText}>Variant: {variantId}</Text>
                <Text style={styles.debugText}>Mock Data: {mockId}</Text>
            </View>
        </View>
    );
}

function ErrorState({ message }: { message: string }) {
    return (
        <View style={styles.errorContainer}>
            <Text style={styles.errorText}>{message}</Text>
        </View>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#333', // æ·±è‰²èƒŒæ™¯çªå‡ºç»„ä»¶
    },
    stage: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
    },
    debugPanel: {
        backgroundColor: '#000',
        padding: 12,
        borderTopWidth: 1,
        borderTopColor: '#444',
    },
    debugText: {
        color: '#0F0',
        fontFamily: 'Menlo',
        fontSize: 12,
        marginBottom: 4,
    },
    errorContainer: {
        padding: 20,
        backgroundColor: Colors.error,
        borderRadius: 8,
    },
    errorText: {
        color: Colors.white,
        fontFamily: Typography.notoSerifBold,
    },
});
</file>

<file path="app/learning/_layout.tsx">
import { Stack } from "expo-router";

export default function LearningLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }} />
  );
}
</file>

<file path="cloudbase/functions/alphabet/handlers/getAllLetters.js">
// âœ… è·å–æ‰€æœ‰å­—æ¯ï¼ˆç”¨äºå‰ç«¯ç”Ÿæˆæµ‹è¯•é¢˜ï¼‰
const { createResponse } = require('../utils/response');

/**
 * è·å–æ‰€æœ‰å­—æ¯æ•°æ®
 * @param {Object} db - æ•°æ®åº“å®ä¾‹
 * @returns {Promise} è¿”å›æ‰€æœ‰å­—æ¯æ•°æ®
 */
async function getAllLetters(db) {
    try {
        // ä» letters é›†åˆè·å–æ‰€æœ‰å­—æ¯
        const res = await db.collection('letters')
            .limit(1000) // è®¾ç½®ä¸€ä¸ªè¶³å¤Ÿå¤§çš„é™åˆ¶ï¼ˆå­—æ¯æ€»æ•°çº¦ 80 ä¸ªï¼‰
            .get();

        return createResponse(true, {
            total: res.data.length,
            letters: res.data
        }, 'è·å–å­—æ¯æˆåŠŸ');
    } catch (error) {
        console.error('[getAllLetters] æŸ¥è¯¢å¤±è´¥:', error);
        return createResponse(false, null, 'è·å–å­—æ¯å¤±è´¥', 'DB_ERROR');
    }
}

module.exports = getAllLetters;
</file>

<file path="cloudbase/functions/alphabet/utils/database.js">
const cloud = require('wx-server-sdk');

cloud.init({
    env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();
const _ = db.command;

const collections = {
    users: db.collection('users'),
    vocabulary: db.collection('vocabulary'),
    letters: db.collection('letters'),
    sentences: db.collection('sentences'),
    memory_status: db.collection('memory_status'),
    user_progress: db.collection('user_progress'),
    user_vocabulary_progress: db.collection('user_vocabulary_progress')
};

module.exports = {
    db,
    _,
    userCollection: collections.users,
    vocabularyCollection: collections.vocabulary,
    letterCollection: collections.letters,
    sentenceCollection: collections.sentences,
    memoryStatusCollection: collections.memory_status,
    userProgressCollection: collections.user_progress,
    progressCollection: collections.user_vocabulary_progress,
    collections
};
</file>

<file path="cloudbase/functions/alphabet/utils/index.js">
/**
 * Shared Utilities Package Entry Point
 * 
 * ç»Ÿä¸€å¯¼å‡ºæ‰€æœ‰å…±äº«æ¨¡å—
 * ä½¿ç”¨æ–¹å¼: const { response, constants, sm2 } = require('@thai-app/shared');
 */

'use strict';

module.exports = {
    // å“åº”æ ¼å¼åŒ–æ¨¡å—
    response: require('./response'),

    // å¸¸é‡å®šä¹‰æ¨¡å—
    constants: require('./constants'),

    // SM-2 ç®—æ³•æ¨¡å—
    sm2: require('./sm2'),

    // å‚æ•°éªŒè¯æ¨¡å—
    validators: require('./validators'),

    // ç»Ÿä¸€è®°å¿†å¼•æ“æ¨¡å—
    memoryEngine: require('./memoryEngine'),

    // æ•°æ®åº“è¿æ¥æ¨¡å—
    database: require('./database')
};
</file>

<file path="cloudbase/functions/alphabet/utils/sm2.js">
/**
 * SM-2 é—´éš”é‡å¤ç®—æ³•æ¨¡å—ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
 * 
 * åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–:
 * - æ—©æœŸå¤ä¹ é—´éš”æ›´å¯†é›†: 1â†’2â†’4â†’7â†’14 å¤©
 * - "æ¨¡ç³Š"çŠ¶æ€ç¼©çŸ­é—´éš”è€Œéç»´æŒä¸å˜
 * - "é™Œç”Ÿ"çŠ¶æ€é‡ç½®å¤ä¹ è¿›åº¦
 * 
 * ç®—æ³•è®ºæ–‡: https://www.supermemo.com/en/archives1990-2015/english/ol/sm2
 */

'use strict';

const { MasteryLevel, SM2_PARAMS, EARLY_INTERVALS } = require('./constants');

/**
 * å°†æŒæ¡ç¨‹åº¦æ˜ å°„åˆ° SM-2 Quality å€¼
 * 
 * SM-2 Quality å®šä¹‰:
 * 0 - å®Œå…¨ä¸è®°å¾—
 * 1 - é”™è¯¯å›ç­”ï¼Œä½†çœ‹åˆ°æ­£ç¡®ç­”æ¡ˆåæƒ³èµ·
 * 2 - é”™è¯¯å›ç­”ï¼Œæ­£ç¡®ç­”æ¡ˆçœ‹èµ·æ¥å¾ˆç†Ÿæ‚‰
 * 3 - æ­£ç¡®å›ç­”ï¼Œä½†å›°éš¾è¾ƒå¤§
 * 4 - æ­£ç¡®å›ç­”ï¼Œæœ‰äº›çŠ¹è±«
 * 5 - æ­£ç¡®å›ç­”ï¼Œæ¯«æ— å›°éš¾
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦
 * @returns {number} Qualityå€¼ (1-5)
 */
function masteryToQuality(mastery) {
    switch (mastery) {
        case MasteryLevel.UNFAMILIAR:
            return 1;  // å®Œå…¨ä¸è®°å¾—
        case MasteryLevel.FUZZY:
            return 3;  // æœ‰å°è±¡ä½†ä¸ç¡®å®š
        case MasteryLevel.REMEMBERED:
            return 5;  // å®Œå…¨è®°å¾—
        default:
            return 1;
    }
}

/**
 * è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸï¼ˆä¼˜åŒ–ç‰ˆ SM-2 ç®—æ³•ï¼‰
 * 
 * æ”¹è¿›ç‚¹:
 * 1. æ—©æœŸé˜¶æ®µï¼ˆå‰5æ¬¡ï¼‰ä½¿ç”¨å›ºå®šçš„æ¸è¿›é—´éš” [1,2,4,7,14]
 * 2. "æ¨¡ç³Š"æ—¶ç¼©çŸ­é—´éš”è€Œéç»´æŒä¸å˜
 * 3. "é™Œç”Ÿ"æ—¶å®Œå…¨é‡ç½®å¤ä¹ è¿›åº¦
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦: å¿˜è®°/æ¨¡ç³Š/è®¤è¯†
 * @param {number} currentInterval - å½“å‰å¤ä¹ é—´éš”ï¼ˆå¤©ï¼‰
 * @param {number} easinessFactor - ç®€æ˜“åº¦å› å­ï¼ˆ1.3-2.5+ï¼‰
 * @param {number} reviewCount - å·²å¤ä¹ æ¬¡æ•°
 * @returns {Object} ç®—æ³•è®¡ç®—ç»“æœ
 * 
 * @example
 * const result = calculateSM2Optimized('è®¤è¯†', 2, 2.5, 1);
 * // {
 * //   nextInterval: 4,
 * //   nextEasinessFactor: 2.6,
 * //   nextReviewDate: "2025-12-01T10:00:00Z",
 * //   shouldResetCount: false
 * // }
 * */
function calculateSM2Optimized(
    mastery,
    currentInterval = 1,
    easinessFactor = SM2_PARAMS.INITIAL_EASINESS_FACTOR,
    reviewCount = 0
) {
    let nextInterval = currentInterval;
    let nextEF = easinessFactor;
    let shouldResetCount = false;

    const quality = masteryToQuality(mastery);

    // ==================== æ ¸å¿ƒç®—æ³•é€»è¾‘ ====================

    if (quality < 3) {
        // ========== å¿˜è®°: å®Œå…¨é‡ç½® ==========
        // ç”¨æˆ·å®Œå…¨ä¸è®°å¾—ï¼Œéœ€è¦ä»å¤´å¼€å§‹å­¦ä¹ 
        nextInterval = 1;
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF - 0.2);
        shouldResetCount = true;

    } else if (quality === 3) {
        // ========== æ¨¡ç³Š: ç¼©çŸ­é—´éš”ï¼ŒåŠ å¼ºå¤ä¹  ==========
        // æ”¹è¿›: ä¸æ˜¯ç»´æŒä¸å˜ï¼Œè€Œæ˜¯ç¼©çŸ­20%
        nextInterval = Math.max(1, Math.round(currentInterval * SM2_PARAMS.FUZZY_MULTIPLIER));
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF - 0.1);

    } else {
        // ========== è®°å¾—: ä½¿ç”¨ä¼˜åŒ–çš„é—´éš”åºåˆ— ==========
        if (reviewCount < EARLY_INTERVALS.length) {
            // æ—©æœŸé˜¶æ®µ: ä½¿ç”¨é¢„å®šä¹‰çš„æ¸è¿›é—´éš”
            // è¿™æ˜¯å…³é”®æ”¹è¿›: 1â†’2â†’4â†’7â†’14 è€ŒéåŸç‰ˆçš„ 1â†’6
            nextInterval = EARLY_INTERVALS[reviewCount];
        } else {
            // åæœŸé˜¶æ®µ: ä½¿ç”¨ EF è®¡ç®—æŒ‡æ•°å¢é•¿
            nextInterval = Math.round(currentInterval * nextEF);
        }

        // æé«˜ç®€æ˜“åº¦ (æ ‡å‡† SM-2 å…¬å¼)
        nextEF = nextEF + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF);
    }

    // é™åˆ¶æœ€å¤§é—´éš”
    nextInterval = Math.min(nextInterval, SM2_PARAMS.MAX_INTERVAL_DAYS);

    // è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸ
    const nextReviewDate = new Date();
    nextReviewDate.setDate(nextReviewDate.getDate() + nextInterval);

    // è®¡ç®—æ–°çš„å¤ä¹ æ¬¡æ•°
    const newRepetitions = shouldResetCount ? 0 : reviewCount + 1;

    return {
        // === å…¼å®¹ memoryEngine.js çš„æ—§æ¥å£ ===
        interval: nextInterval,
        easinessFactor: parseFloat(nextEF.toFixed(2)),
        repetitions: newRepetitions,

        // === æ–°æ¥å£ï¼ˆä¿ç•™ä¾›æœªæ¥ä½¿ç”¨ï¼‰===
        nextInterval,
        nextEasinessFactor: parseFloat(nextEF.toFixed(2)),
        nextReviewDate: nextReviewDate.toISOString(),
        shouldResetCount,
    };
}

/**
 * ç”Ÿæˆé¢„è®¡å¤ä¹ æ—¶é—´çº¿
 * 
 * ç”¨äºå‰ç«¯å±•ç¤ºæœªæ¥çš„å¤ä¹ è®¡åˆ’
 * 
 * @param {number} currentReviewCount - å½“å‰å¤ä¹ æ¬¡æ•°
 * @param {number} maxItems - è¿”å›çš„æ—¶é—´çº¿é¡¹æ•° (é»˜è®¤5)
 * @returns {Array} æœªæ¥å¤ä¹ è®¡åˆ’
 * 
 * @example
 * generateReviewTimeline(2);
 * // [
 * //   { reviewNumber: 3, intervalDays: 4 },
 * //   { reviewNumber: 4, intervalDays: 7 },
 * //   { reviewNumber: 5, intervalDays: 14 },
 * //   ...
 * // ]
 */
function generateReviewTimeline(currentReviewCount, maxItems = 5) {
    const timeline = [];
    let interval = 1;
    let ef = SM2_PARAMS.INITIAL_EASINESS_FACTOR;

    for (let i = currentReviewCount; i < currentReviewCount + maxItems; i++) {
        if (i < EARLY_INTERVALS.length) {
            interval = EARLY_INTERVALS[i];
        } else {
            interval = Math.round(interval * ef);
        }
        interval = Math.min(interval, SM2_PARAMS.MAX_INTERVAL_DAYS);

        timeline.push({
            reviewNumber: i + 1,
            intervalDays: interval,
        });
    }

    return timeline;
}

/**
 * è·å–ä»Šå¤©çš„æ—¶é—´èŒƒå›´ (UTC)
 * 
 * @returns {Object} { startOfDay, endOfDay, timestamp }
 */
function getTodayRange() {
    const now = new Date();
    const startOfDay = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate(),
        0, 0, 0, 0
    ));
    const endOfDay = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate() + 1,
        0, 0, 0, 0
    ));

    return {
        startOfDay: startOfDay.toISOString(),
        endOfDay: endOfDay.toISOString(),
        timestamp: now.toISOString(),
    };
}

/**
 * è·å–ç®—æ³•ä¿¡æ¯ (ç”¨äºå‰ç«¯å±•ç¤º)
 * 
 * @returns {Object} ç®—æ³•å…ƒä¿¡æ¯
 */
function getAlgorithmInfo() {
    return {
        name: 'Optimized SM-2',
        version: '1.1.0',
        earlyIntervals: EARLY_INTERVALS,
        maxInterval: SM2_PARAMS.MAX_INTERVAL_DAYS,
        description: 'åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–çš„é—´éš”é‡å¤ç®—æ³•',
    };
}

module.exports = {
    calculateSM2Optimized,
    generateReviewTimeline,
    getTodayRange,
    getAlgorithmInfo,
    masteryToQuality,
};
</file>

<file path="cloudbase/functions/alphabet/utils/validators.js">
/**
 * å‚æ•°éªŒè¯æ¨¡å—
 * 
 * ç”¨æˆ·ã€è¯æ±‡éªŒè¯åŠé€šç”¨éªŒè¯å·¥å…·
 */

'use strict';

const { userCollection, vocabularyCollection } = require('./database');
const { MasteryLevel } = require('./constants');

/**
 * éªŒè¯ç”¨æˆ·æ˜¯å¦å­˜åœ¨
 * 
 * @param {string} userId - ç”¨æˆ·ID
 * @returns {Promise<Object|null>} ç”¨æˆ·å¯¹è±¡æˆ– null
 */
async function validateUser(userId) {
    if (!userId || typeof userId !== 'string') {
        return null;
    }

    try {
        const { data } = await userCollection
            .where({ userId })
            .limit(1)
            .get();

        return data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('[validateUser] Error:', error);
        return null;
    }
}

/**
 * éªŒè¯è¯æ±‡æ˜¯å¦å­˜åœ¨
 * 
 * @param {string} vocabularyId - è¯æ±‡ID
 * @returns {Promise<Object|null>} è¯æ±‡å¯¹è±¡æˆ– null
 */
async function validateVocabulary(vocabularyId) {
    if (!vocabularyId || typeof vocabularyId !== 'string') {
        return null;
    }

    try {
        const { data } = await vocabularyCollection
            .where({ vocabularyId })
            .limit(1)
            .get();

        return data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('[validateVocabulary] Error:', error);
        return null;
    }
}

/**
 * éªŒè¯æŒæ¡ç¨‹åº¦æ˜¯å¦æœ‰æ•ˆ
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦
 * @returns {boolean} æ˜¯å¦æœ‰æ•ˆ
 */
function isValidMastery(mastery) {
    const validValues = Object.values(MasteryLevel);
    return validValues.includes(mastery);
}

/**
 * éªŒè¯å¹¶è§„èŒƒåŒ–åˆ†é¡µå‚æ•°
 * 
 * @param {number} limit - é™åˆ¶æ•°é‡
 * @param {number} offset - åç§»é‡
 * @param {number} maxLimit - æœ€å¤§é™åˆ¶ (é»˜è®¤100)
 * @returns {Object} éªŒè¯åçš„åˆ†é¡µå‚æ•°
 */
function validatePagination(limit, offset, maxLimit = 100) {
    return {
        limit: Math.min(Math.max(1, parseInt(limit) || 20), maxLimit),
        offset: Math.max(0, parseInt(offset) || 0),
    };
}

/**
 * éªŒè¯å¿…å¡«å­—ç¬¦ä¸²å‚æ•°
 * 
 * @param {string} value - å‚æ•°å€¼
 * @param {string} name - å‚æ•°å (ç”¨äºé”™è¯¯æ¶ˆæ¯)
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateRequiredString(value, name) {
    if (!value || typeof value !== 'string' || value.trim() === '') {
        return {
            valid: false,
            error: `${name} æ˜¯å¿…å¡«å‚æ•°ä¸”ä¸èƒ½ä¸ºç©º`,
        };
    }
    return { valid: true };
}

/**
 * éªŒè¯å¸ƒå°”å‚æ•°
 * 
 * @param {any} value - å‚æ•°å€¼
 * @param {string} name - å‚æ•°å
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateBoolean(value, name) {
    if (typeof value !== 'boolean') {
        return {
            valid: false,
            error: `${name} å¿…é¡»æ˜¯å¸ƒå°”å€¼`,
        };
    }
    return { valid: true };
}
/**
 * é€šç”¨å‚æ•°éªŒè¯å‡½æ•°
 * 
 * @param {Object} params - éœ€è¦éªŒè¯çš„å‚æ•°å¯¹è±¡
 * @param {Array<string>} requiredFields - å¿…éœ€å­—æ®µåˆ—è¡¨
 * @returns {Object} { isValid: boolean, message?: string }
 */
function validateParams(params, requiredFields) {
    const missing = [];

    for (const field of requiredFields) {
        if (params[field] === undefined || params[field] === null || params[field] === '') {
            missing.push(field);
        }
    }

    if (missing.length > 0) {
        return {
            isValid: false,
            message: `ç¼ºå°‘å¿…å¡«å‚æ•°: ${missing.join(', ')}`
        };
    }

    return { isValid: true };
}

module.exports = {
    validateUser,
    validateVocabulary,
    isValidMastery,
    validatePagination,
    validateRequiredString,
    validateBoolean,
    validateParams,
};
</file>

<file path="cloudbase/functions/learn-vocab/utils/index.js">
/**
 * Shared Utilities Package Entry Point
 * 
 * ç»Ÿä¸€å¯¼å‡ºæ‰€æœ‰å…±äº«æ¨¡å—
 * ä½¿ç”¨æ–¹å¼: const { response, constants, sm2 } = require('@thai-app/shared');
 */

'use strict';

module.exports = {
    // å“åº”æ ¼å¼åŒ–æ¨¡å—
    response: require('./response'),

    // å¸¸é‡å®šä¹‰æ¨¡å—
    constants: require('./constants'),

    // SM-2 ç®—æ³•æ¨¡å—
    sm2: require('./sm2'),

    // å‚æ•°éªŒè¯æ¨¡å—
    validators: require('./validators'),

    // ç»Ÿä¸€è®°å¿†å¼•æ“æ¨¡å—
    memoryEngine: require('./memoryEngine'),

    // æ•°æ®åº“è¿æ¥æ¨¡å—
    database: require('./database')
};
</file>

<file path="cloudbase/functions/memory-engine/config/alphabetLessonConfig.js">
'use strict';

/**
 * Alphabet lesson & phonics rule config for backend.
 *
 * æ³¨æ„ï¼š
 * - LESSON_METADATA / PHONICS_RULES ä½œä¸ºæœ¬åœ° fallbackï¼›
 * - ä¼˜å…ˆä» DB é›†åˆ alphabet_lessons / phonics_rules ä¸­è¯»å–ï¼Œ
 *   è¯»ä¸åˆ°æˆ–å‡ºé”™æ—¶å†é€€å›æœ¬åœ°å¸¸é‡ï¼Œé¿å…å‰åç«¯æ•°æ®æ¼‚ç§»ã€‚
 */

// ==================== Lesson Metadata (7 è¯¾) - æœ¬åœ°å¤‡ä»½ ====================

const LESSON_METADATA = {
  lesson1: {
    lessonId: 'lesson1',
    title: 'ç¬¬ä¸€è¯¾:åŸºç¡€æ‹¼è¯»èƒ½åŠ›',
    description: 'æŒæ¡æœ€åŸºç¡€çš„ä¸­è¾…éŸ³å’Œå¸¸è§å…ƒéŸ³,å»ºç«‹CVæ‹¼è¯»æ¦‚å¿µ',
    consonants: ['à¸', 'à¸”', 'à¸•', 'à¸™', 'à¸¡'],
    vowels: ['à¸²', 'à¸°', 'à¸´'],
    tones: [],
    phonicsRuleId: 'rule_1_cv_structure',
    totalCount: 8,
    minPassRate: 0.95,
    miniReviewInterval: 3,
    order: 1,
  },

  lesson2: {
    lessonId: 'lesson2',
    title: 'ç¬¬äºŒè¯¾:å‰ç½®å…ƒéŸ³ç³»ç»Ÿ',
    description: 'å­¦ä¹ å‰ç½®å…ƒéŸ³(à¹€ à¹ à¹‚)å’Œæ›´å¤šé«˜é¢‘è¾…éŸ³',
    consonants: ['à¸š', 'à¸›', 'à¸£', 'à¸¥', 'à¸§', 'à¸¢'],
    vowels: ['à¹€', 'à¹', 'à¹‚', 'à¸­'],
    tones: [],
    phonicsRuleId: 'rule_2_leading_vowel',
    totalCount: 10,
    minPassRate: 0.9,
    miniReviewInterval: 3,
    order: 2,
  },

  lesson3: {
    lessonId: 'lesson3',
    title: 'ç¬¬ä¸‰è¯¾:å£°è°ƒå…¥é—¨',
    description: 'æŒæ¡é€æ°”/ä¸é€æ°”å¯¹æ¯”,å¼•å…¥åŸºç¡€å£°è°ƒç³»ç»Ÿ',
    consonants: ['à¸‚', 'à¸–', 'à¸œ', 'à¸ª', 'à¸«'],
    vowels: ['à¸°', 'à¸¸', 'à¸¹'],
    tones: ['à¹ˆ', 'à¹‰'],
    phonicsRuleId: 'rule_3_tone_basics',
    totalCount: 10,
    minPassRate: 0.9,
    miniReviewInterval: 3,
    order: 3,
  },

  lesson4: {
    lessonId: 'lesson4',
    title: 'ç¬¬å››è¯¾:è¾…éŸ³ç±»ä¸å£°è°ƒ',
    description: 'ç†è§£é«˜/ä¸­/ä½è¾…éŸ³å¯¹å£°è°ƒçš„å½±å“,æŒæ¡å®Œæ•´å£°è°ƒç³»ç»Ÿ',
    consonants: ['à¸„', 'à¸—', 'à¸', 'à¸Š', 'à¸ˆ', 'à¸‡'],
    vowels: ['à¹„', 'à¹ƒ', 'à¹€à¸­à¸²', 'à¸­à¸³'],
    tones: ['à¹Š', 'à¹‹'],
    phonicsRuleId: 'rule_4_consonant_class_tones',
    totalCount: 12,
    minPassRate: 0.85,
    miniReviewInterval: 3,
    order: 4,
  },

  lesson5: {
    lessonId: 'lesson5',
    title: 'ç¬¬äº”è¯¾:å¤åˆå…ƒéŸ³ç³»ç»Ÿ',
    description: 'æŒæ¡ä¸‰åˆå…ƒéŸ³(à¹€à¸­à¸µà¸¢ à¹€à¸­à¸·à¸­ à¸­à¸±à¸§)ç­‰å¤æ‚å…ƒéŸ³ç»„åˆ',
    consonants: ['à¸‹', 'à¸‰', 'à¸', 'à¸Ÿ', 'à¸¨', 'à¸©', 'à¸®', 'à¸­'],
    vowels: ['à¹€à¸­à¸µà¸¢', 'à¹€à¸­à¸·à¸­', 'à¸­à¸±à¸§', 'à¹€à¸­à¸­', 'à¸·', 'à¸¶'],
    tones: [],
    phonicsRuleId: 'rule_5_compound_vowels',
    totalCount: 14,
    minPassRate: 0.85,
    miniReviewInterval: 3,
    order: 5,
  },

  lesson6: {
    lessonId: 'lesson6',
    title: 'ç¬¬å…­è¯¾:å®Œæ•´è¦†ç›–(å¸¸ç”¨è¿›é˜¶)',
    description: 'è¡¥å……å¸¸ç”¨è¿›é˜¶è¾…éŸ³ä¸å¤åˆå…ƒéŸ³,æŒæ¡ç‰¹æ®Šè§„åˆ™(å¦‚ à¸« à¸™à¸³ ç­‰)',
    consonants: ['à¸‘', 'à¸’', 'à¸“', 'à¸ ', 'à¸˜', 'à¸Œ', 'à¸', 'à¸¬', 'à¸', 'à¸', 'à¸'],
    vowels: ['à¸­à¸²à¸¢', 'à¸­à¸¸à¸¢', 'à¹€à¸­à¸¢', 'à¹‚à¸­à¸¢', 'à¸­à¸­à¸¢'],
    tones: [],
    phonicsRuleId: 'rule_6_special_cases',
    totalCount: 19,
    minPassRate: 0.9,
    miniReviewInterval: 4,
    order: 6,
  },

  lesson7: {
    lessonId: 'lesson7',
    title: 'ç¬¬ä¸ƒè¯¾:ç½•ç”¨å­—æ¯ä¸ç‰¹æ®Šå…ƒéŸ³',
    description: 'é›†ä¸­å­¦ä¹ ç°ä»£æ³°è¯­ä¸­è¾ƒå°‘ä½¿ç”¨çš„è¾…éŸ³ä¸å¤æ‚å…ƒéŸ³,ç”¨äºé˜…è¯»å¤æ–‡ä¸ç‰¹æ®Šä¸“æœ‰åè¯',
    consonants: ['à¸ƒ', 'à¸…'],
    vowels: ['à¸¤', 'à¸¤à¹…', 'à¸¦', 'à¸¦à¹…', 'à¹à¸­à¸°', 'à¹‚à¸­à¸°', 'à¹€à¸­à¸°', 'à¹€à¸­à¸²à¸°'],
    tones: [],
    phonicsRuleId: 'rule_6_special_cases',
    totalCount: 10,
    minPassRate: 0.8,
    miniReviewInterval: 4,
    order: 7,
  },
};

// ==================== Phonics Rules (6 æ¡) - æœ¬åœ°å¤‡ä»½ ====================

const PHONICS_RULES = {
  rule_1_cv_structure: {
    id: 'rule_1_cv_structure',
    lessonId: 'lesson1',
    title: 'æ‹¼è¯»è§„åˆ™ 1: è¾…éŸ³+å…ƒéŸ³',
    content: [
      'âœ… æ³°è¯­éŸ³èŠ‚ = è¾…éŸ³(C) + å…ƒéŸ³(V)',
      'âœ… å…ƒéŸ³å¯åœ¨è¾…éŸ³å‰/å/ä¸Š/ä¸‹',
      'âœ… ä¾‹: à¸ + à¸² = à¸à¸² [ka:] (ä¹Œé¸¦)',
      '',
      'ğŸ¯ è®°å¿†å£è¯€: å…ˆè¯»è¾…éŸ³,å†è¯»å…ƒéŸ³',
    ],
    interactiveExample: {
      consonant: 'à¸',
      vowel: 'à¸²',
      syllable: 'à¸à¸²',
      pronunciation: 'ka:',
      audioUrl:
        'https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/word-ka.mp3',
    },
    duration: 30,
    order: 1,
  },

  rule_2_leading_vowel: {
    id: 'rule_2_leading_vowel',
    lessonId: 'lesson2',
    title: 'æ‹¼è¯»è§„åˆ™ 2: å‰ç½®å…ƒéŸ³',
    content: [
      'âš ï¸ å†™åœ¨è¾…éŸ³å‰,è¯»åœ¨è¾…éŸ³å',
      '',
      'âœ… à¹€à¸ = [ke:] ä¸æ˜¯ [ek]',
      'âœ… à¹à¸¡ = [mÉ›:] ä¸æ˜¯ [É›m]',
      'âœ… à¹‚à¸£ = [ro:] ä¸æ˜¯ [or]',
      '',
      'ğŸ¯ è®°å¿†å£è¯€: çœ‹åˆ° à¹€ à¹ à¹‚,å…ˆè¯»è¾…éŸ³å†è¯»å…ƒéŸ³',
    ],
    interactiveExample: {
      consonant: 'à¸',
      vowel: 'à¹€',
      syllable: 'à¹€à¸',
      pronunciation: 'ke:',
      audioUrl:
        'https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/syllable-ke.mp3',
    },
    duration: 30,
    order: 2,
  },

  rule_3_tone_basics: {
    id: 'rule_3_tone_basics',
    lessonId: 'lesson3',
    title: 'æ‹¼è¯»è§„åˆ™ 3: å£°è°ƒå…¥é—¨',
    content: [
      'ğŸµ æ³°è¯­5ä¸ªå£°è°ƒ:',
      '  1. ä¸­å¹³è°ƒ Â¯ (å¦‚: à¸à¸² [ka:Â¯])',
      '  2. ä½é™è°ƒ ` (å¦‚: à¸à¹ˆà¸² [kÃ :])',
      '  3. é™è°ƒ Ë† (å¦‚: à¸à¹‰à¸² [kÃ¢:])',
      '  4. é«˜è°ƒ Â´ (å¦‚: à¸à¹Šà¸² [kÃ¡:])',
      '  5. å‡è°ƒ Ë‡ (å¦‚: à¸à¹‹à¸² [kÇ:])',
      '',
      'ğŸ“Œ å£°è°ƒç”±4ä¸ªå› ç´ å†³å®š:',
      '  â€¢ è¾…éŸ³ç±»(é«˜/ä¸­/ä½)',
      '  â€¢ å…ƒéŸ³é•¿çŸ­',
      '  â€¢ å£°è°ƒç¬¦å·(à¹ˆ à¹‰ à¹Š à¹‹)',
      '  â€¢ éŸ³èŠ‚ç±»å‹(Live/Dead)',
    ],
    visualChart: {
      columns: ['è¾…éŸ³ç±»', 'é•¿+æ— ', 'çŸ­+æ— ', 'à¹ˆ', 'à¹‰'],
      rows: [
        ['ä¸­è¾…éŸ³', 'Â¯', '`', '`', 'Ë†'],
        ['é«˜è¾…éŸ³', 'Â´', '`', '`', 'Ë†'],
      ],
      interactive: true,
    },
    duration: 45,
    order: 3,
  },

  rule_4_consonant_class_tones: {
    id: 'rule_4_consonant_class_tones',
    lessonId: 'lesson4',
    title: 'æ‹¼è¯»è§„åˆ™ 4: è¾…éŸ³ç±»ä¸å£°è°ƒ',
    content: [
      'ğŸ”‘ æ ¸å¿ƒæ¦‚å¿µ: åŒæ ·çš„å…ƒéŸ³+ç¬¦å·,ä¸åŒè¾…éŸ³ç±» â†’ ä¸åŒå£°è°ƒ',
      '',
      'ä¾‹: à¸² + æ— ç¬¦å·',
      '  â€¢ à¸ + à¸² = à¸à¸² [ä¸­å¹³Â¯] (ä¸­è¾…éŸ³)',
      '  â€¢ à¸‚ + à¸² = à¸‚à¸² [å‡è°ƒÂ´] (é«˜è¾…éŸ³)',
      '  â€¢ à¸„ + à¸² = à¸„à¸² [ä¸­å¹³Â¯] (ä½è¾…éŸ³)',
      '',
      'ğŸ¯ å­¦ä¹ ç­–ç•¥:',
      '  1. å…ˆè®°è¾…éŸ³ç±»(é«˜/ä¸­/ä½)',
      '  2. å†æŸ¥å£°è°ƒè¡¨',
      '  3. å¤šå¬å¤šç»ƒ,å½¢æˆç›´è§‰',
    ],
    visualChart: {
      columns: ['è¾…éŸ³ç±»', 'é•¿+æ— ', 'çŸ­+æ— ', 'à¹ˆ', 'à¹‰', 'à¹Š', 'à¹‹'],
      rows: [
        ['ä¸­è¾…éŸ³', 'Â¯', '`', '`', 'Ë†', 'Â´', 'Ë‡'],
        ['é«˜è¾…éŸ³', 'Â´', '`', '`', 'Ë†', '-', '-'],
        ['ä½è¾…éŸ³', 'Â¯', 'Â´', 'Ë†', 'Â´', '-', '-'],
      ],
      interactive: true,
    },
    duration: 45,
    order: 4,
  },

  rule_5_compound_vowels: {
    id: 'rule_5_compound_vowels',
    lessonId: 'lesson5',
    title: 'æ‹¼è¯»è§„åˆ™ 5: å¤åˆå…ƒéŸ³',
    content: [
      'ğŸ”— å¤åˆå…ƒéŸ³ = 2-3ä¸ªå…ƒéŸ³ç¬¦å·ç»„åˆ',
      '',
      'âœ… à¹€à¸­à¸µà¸¢ [ia]: à¹€ + à¸µ + à¸¢',
      '   ä¾‹: à¹€à¸¡à¸µà¸¢ [mia] (å¦»å­)',
      '',
      'âœ… à¹€à¸­à¸·à¸­ [É¯a]: à¹€ + à¸· + à¸­',
      '   ä¾‹: à¹€à¸¡à¸·à¸­à¸‡ [mÉ¯aÅ‹] (åŸå¸‚)',
      '',
      'âœ… à¸­à¸±à¸§ [ua]: à¸± + à¸§',
      '   ä¾‹: à¸„à¸§à¸²à¸¢ [khwaËy] (æ°´ç‰›)',
      '',
      'ğŸ“Œ æ‹¼è¯»æŠ€å·§: å…ˆè¯»è¾…éŸ³,å†æ»‘è¿‡æ•´ä¸ªå¤åˆå…ƒéŸ³',
    ],
    interactiveExample: {
      consonant: 'à¸¡',
      vowel: 'à¹€à¸­à¸µà¸¢',
      syllable: 'à¹€à¸¡à¸µà¸¢',
      pronunciation: 'mia',
      audioUrl:
        'https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/word-mia.mp3',
    },
    duration: 30,
    order: 5,
  },

  rule_6_special_cases: {
    id: 'rule_6_special_cases',
    lessonId: 'lesson6',
    title: 'æ‹¼è¯»è§„åˆ™ 6: ç‰¹æ®Šè§„åˆ™',
    content: [
      'ğŸ”¸ à¸: ä½œå£°æ¯è¯» [y],ä½œå°¾éŸ³è¯» [n]',
      '   ä¾‹: à¸à¸²à¸•à¸´ [yÃ¢Ët] (äº²æˆš), à¸«à¸à¸´à¸‡ [yÇÅ‹] (å¥³äºº)',
      '',
      'ğŸ”¸ à¸¤/à¸¦: æ¢µæ–‡ä¸“ç”¨,ç°ä»£æ³°è¯­å°‘è§',
      '   ä¾‹: à¸¤à¸”à¸¹ [rÉ¯ÌdÃ¹Ë] (å­£èŠ‚)',
      '',
      'ğŸ”¸ à¸« + ä½è¾…éŸ³: å˜é«˜è°ƒè§„åˆ™',
      '   ä¾‹: à¸«à¸™à¸¹ [nÇ”Ë] = à¸«(é™éŸ³) + à¸™à¸¹ (å˜é«˜è°ƒ)',
      '',
      'ğŸ”¸ à¹„/à¹ƒ: åŒéŸ³ä¸åŒå½¢,à¹ƒä»…28ä¸ªè¯',
      '   ä¾‹: à¹ƒà¸à¸¥à¹‰ [klÃ¢y] (è¿‘), à¹„à¸à¸¥ [klay] (è¿œ)',
    ],
    duration: 40,
    order: 6,
  },
};

/**
 * ä» DB è¯»å–è¯¾ç¨‹å…ƒæ•°æ®ï¼Œå¤±è´¥æ—¶å›é€€åˆ°æœ¬åœ° LESSON_METADATAã€‚
 * @param {object} db - cloud.database() å®ä¾‹
 * @param {string} lessonId
 * @returns {Promise<object|null>}
 */
async function getLessonMetadataFromDb(db, lessonId) {
  if (!lessonId) return null;

  try {
    const col = db.collection('alphabet_lessons');
    const res = await col.doc(lessonId).get();
    if (res && res.data && res.data.length > 0) {
      return res.data[0];
    }
  } catch (err) {
    console.warn(
      '[alphabetLessonConfig] getLessonMetadataFromDb error:',
      lessonId,
      err && err.message,
    );
  }

  return LESSON_METADATA[lessonId] || null;
}

/**
 * ä» DB è¯»å–æŸè¯¾å¯¹åº”çš„æ‹¼è¯»è§„åˆ™ï¼Œå¤±è´¥æ—¶å›é€€åˆ°æœ¬åœ° PHONICS_RULESã€‚
 * @param {object} db - cloud.database() å®ä¾‹
 * @param {string} lessonId
 * @returns {Promise<object|null>}
 */
async function getPhonicsRuleByLessonFromDb(db, lessonId) {
  if (!lessonId) return null;

  try {
    const col = db.collection('phonics_rules');
    const res = await col
      .where({ lessonId })
      .limit(1)
      .get();

    if (res && res.data && res.data.length > 0) {
      return res.data[0];
    }
  } catch (err) {
    console.warn(
      '[alphabetLessonConfig] getPhonicsRuleByLessonFromDb error:',
      lessonId,
      err && err.message,
    );
  }

  const fallback = Object.values(PHONICS_RULES).find(
    (r) => r.lessonId === lessonId,
  );
  return fallback || null;
}

module.exports = {
  LESSON_METADATA,
  PHONICS_RULES,
  getLessonMetadataFromDb,
  getPhonicsRuleByLessonFromDb,
};
</file>

<file path="cloudbase/functions/memory-engine/handlers/getAlphabetLessons.js">
'use strict';

/**
 * è·å–å­—æ¯è¯¾ç¨‹å…ƒæ•°æ®åˆ—è¡¨
 *
 * è®¾è®¡ç›®æ ‡ï¼š
 * - ä½œä¸ºå‰ç«¯ã€Œå­—æ¯è¯¾ç¨‹æ€»è§ˆã€é¡µçš„æ•°æ®æºï¼›
 * - ä¼˜å…ˆä» DB é›†åˆ alphabet_lessons è¯»å–ï¼Œå¤±è´¥æ—¶å›é€€åˆ°æœ¬åœ° LESSON_METADATAï¼›
 * - è¿”å›ç»“æ„ä¸å‰ç«¯ LessonMetadata ç±»å‹å…¼å®¹ã€‚
 */

const { createResponse } = require('../utils/response');
const { LESSON_METADATA } = require('../config/alphabetLessonConfig');

/**
 * @param {object} db    cloud.database()
 * @param {object} params ç›®å‰æœªä½¿ç”¨ï¼Œé¢„ç•™è¿‡æ»¤/åˆ†é¡µ
 */
async function getAlphabetLessons(db, params) {
  try {
    let lessons = [];

    try {
      const col = db.collection('alphabet_lessons');
      const res = await col.orderBy('order', 'asc').get();
      if (res && Array.isArray(res.data) && res.data.length > 0) {
        lessons = res.data;
      }
    } catch (err) {
      console.warn('[getAlphabetLessons] DB æŸ¥è¯¢å¤±è´¥ï¼Œå°†ä½¿ç”¨æœ¬åœ° LESSON_METADATA ä½œä¸ºå›é€€:', err.message);
    }

    if (!lessons.length) {
      lessons = Object.values(LESSON_METADATA).sort(
        (a, b) => (a.order || 0) - (b.order || 0),
      );
    }

    return createResponse(true, { lessons }, 'è·å–å­—æ¯è¯¾ç¨‹åˆ—è¡¨æˆåŠŸ');
  } catch (error) {
    console.error('[getAlphabetLessons] error:', error);
    return createResponse(
      false,
      null,
      error.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      'SERVER_ERROR',
    );
  }
}

module.exports = getAlphabetLessons;
</file>

<file path="cloudbase/functions/memory-engine/utils/index.js">
/**
 * Shared Utilities Package Entry Point
 * 
 * ç»Ÿä¸€å¯¼å‡ºæ‰€æœ‰å…±äº«æ¨¡å—
 * ä½¿ç”¨æ–¹å¼: const { response, constants, sm2 } = require('@thai-app/shared');
 */

'use strict';

module.exports = {
    // å“åº”æ ¼å¼åŒ–æ¨¡å—
    response: require('./response'),

    // å¸¸é‡å®šä¹‰æ¨¡å—
    constants: require('./constants'),

    // SM-2 ç®—æ³•æ¨¡å—
    sm2: require('./sm2'),

    // å‚æ•°éªŒè¯æ¨¡å—
    validators: require('./validators'),

    // ç»Ÿä¸€è®°å¿†å¼•æ“æ¨¡å—
    memoryEngine: require('./memoryEngine'),

    // æ•°æ®åº“è¿æ¥æ¨¡å—
    database: require('./database')
};
</file>

<file path="cloudbase/functions/shared/constants.js">
/**
 * å¸¸é‡å®šä¹‰æ¨¡å—
 * 
 * ä¸å‰ç«¯ src/config/constants.ts ä¿æŒä¸€è‡´çš„è®¾è®¡é£æ ¼
 * é›†ä¸­ç®¡ç†æ‰€æœ‰äº‘å‡½æ•°å¸¸é‡
 */

'use strict';

// ==================== æ•°æ®åº“é›†åˆåç§° ====================
// ä¸å‰ç«¯ COLLECTIONS ä¿æŒä¸€è‡´
const COLLECTIONS = {
  USERS: 'users',
  VOCABULARY: 'vocabulary',
  USER_VOCABULARY_PROGRESS: 'user_vocabulary_progress',
  LETTERS: 'letters',
  USER_ALPHABET_PROGRESS: 'user_alphabet_progress',
  LETTER_TEST_BANK: 'letter_test_bank',
  COURSES: 'courses',
  LESSONS: 'lessons',
  PROGRESS: 'progress',
};

// ==================== æŒæ¡ç¨‹åº¦ ====================
// ä½¿ç”¨ä¸­æ–‡å€¼ï¼Œä¾¿äºå‰ç«¯ç›´æ¥æ˜¾ç¤º
const MasteryLevel = Object.freeze({
  UNFAMILIAR: 'é™Œç”Ÿ',
  FUZZY: 'æ¨¡ç³Š',
  REMEMBERED: 'è®°å¾—',
});

// ==================== å­¦ä¹ ç­‰çº§ ====================
// ä¸å‰ç«¯ LEVELS ä¿æŒä¸€è‡´
const LEVELS = Object.freeze({
  BEGINNER_A: 'BEGINNER_A',
  BEGINNER_B: 'BEGINNER_B',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED',
});

// ==================== SM-2 ç®—æ³•å‚æ•° ====================
// ä¼˜åŒ–ç‰ˆå‚æ•°ï¼ŒåŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿
const SM2_PARAMS = Object.freeze({
  INITIAL_EASINESS_FACTOR: 2.5,   // åˆå§‹ç®€æ˜“åº¦
  MIN_EASINESS_FACTOR: 1.3,       // æœ€å°ç®€æ˜“åº¦
  MAX_INTERVAL_DAYS: 180,         // æœ€å¤§é—´éš”ï¼ˆå¤©ï¼‰
  FUZZY_MULTIPLIER: 0.8,          // "æ¨¡ç³Š"æ—¶é—´éš”ç¼©çŸ­æ¯”ä¾‹
});

// ==================== æ—©æœŸå¤ä¹ é—´éš”åºåˆ— ====================
// åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–: 1â†’2â†’4â†’7â†’14 å¤©
const EARLY_INTERVALS = Object.freeze([1, 2, 4, 7, 14]);

// ==================== æ¯æ—¥å­¦ä¹ é…ç½® ====================
const DAILY_LEARNING_CONFIG = Object.freeze({
  MAX_NEW_WORDS: 10,              // æ¯æ—¥æ–°è¯ä¸Šé™
  MAX_REVIEW_WORDS: 20,           // æ¯æ—¥å¤ä¹ ä¸Šé™
  TOTAL_WORDS_LIMIT: 30,          // æ¯æ—¥æ€»è¯æ•°ä¸Šé™
});

// ==================== é”™è¯¯ç  ====================
// ç»Ÿä¸€é”™è¯¯ç å®šä¹‰
const ErrorCodes = Object.freeze({
  SUCCESS: 'SUCCESS',
  USER_NOT_FOUND: 'USER_NOT_FOUND',
  VOCABULARY_NOT_FOUND: 'VOCABULARY_NOT_FOUND',
  INVALID_PARAMS: 'INVALID_PARAMS',
  INVALID_MASTERY: 'INVALID_MASTERY',
  UNKNOWN_ACTION: 'UNKNOWN_ACTION',
  SERVER_ERROR: 'SERVER_ERROR',
});

// ==================== é”™è¯¯æ¶ˆæ¯ ====================
// ä¸å‰ç«¯ ERROR_MESSAGES é£æ ¼ä¸€è‡´
const ERROR_MESSAGES = Object.freeze({
  USER_NOT_FOUND: 'ç”¨æˆ·ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥ç”¨æˆ·IDæˆ–é‡æ–°ç™»å½•',
  VOCABULARY_NOT_FOUND: 'è¯æ±‡ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥è¯æ±‡ID',
  INVALID_PARAMS: 'å‚æ•°æ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥è¾“å…¥',
  INVALID_MASTERY: 'æ— æ•ˆçš„æŒæ¡ç¨‹åº¦ï¼Œå…è®¸å€¼: é™Œç”Ÿ/æ¨¡ç³Š/è®°å¾—',
  UNKNOWN_ACTION: 'æœªçŸ¥æ“ä½œç±»å‹',
  SERVER_ERROR: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•',
});

// ==================== æ”¯æŒçš„ Actions ====================
const SUPPORTED_ACTIONS = Object.freeze([
  'getTodayWords',
  'updateMastery',
  'toggleSkipWord',
  'getVocabularyDetail',
  'getReviewStatistics',
  'getVocabularyList',
  'getSkippedWords',
  'getLetterTest',
  'submitLetterTest',
  'passLetterTest',
  'getTodayMemories',
  'submitMemoryResult',
  'checkModuleAccess',
  'getUserProgress'
]);

module.exports = {
  // é›†åˆ
  COLLECTIONS,

  // æšä¸¾
  MasteryLevel,
  LEVELS,
  ErrorCodes,

  // ç®—æ³•å‚æ•°
  SM2_PARAMS,
  EARLY_INTERVALS,

  // é…ç½®
  DAILY_LEARNING_CONFIG,

  // æ¶ˆæ¯
  ERROR_MESSAGES,
  SUPPORTED_ACTIONS,
};
</file>

<file path="cloudbase/functions/shared/database.js">
const cloud = require('wx-server-sdk');

cloud.init({
    env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();
const _ = db.command;

const collections = {
    users: db.collection('users'),
    vocabulary: db.collection('vocabulary'),
    letters: db.collection('letters'),
    sentences: db.collection('sentences'),
    memory_status: db.collection('memory_status'),
    user_progress: db.collection('user_progress'),
    user_vocabulary_progress: db.collection('user_vocabulary_progress')
};

module.exports = {
    db,
    _,
    userCollection: collections.users,
    vocabularyCollection: collections.vocabulary,
    letterCollection: collections.letters,
    sentenceCollection: collections.sentences,
    memoryStatusCollection: collections.memory_status,
    userProgressCollection: collections.user_progress,
    progressCollection: collections.user_vocabulary_progress,
    collections
};
</file>

<file path="cloudbase/functions/shared/index.js">
/**
 * Shared Utilities Package Entry Point
 * 
 * ç»Ÿä¸€å¯¼å‡ºæ‰€æœ‰å…±äº«æ¨¡å—
 * ä½¿ç”¨æ–¹å¼: const { response, constants, sm2 } = require('@thai-app/shared');
 */

'use strict';

module.exports = {
    // å“åº”æ ¼å¼åŒ–æ¨¡å—
    response: require('./response'),

    // å¸¸é‡å®šä¹‰æ¨¡å—
    constants: require('./constants'),

    // SM-2 ç®—æ³•æ¨¡å—
    sm2: require('./sm2'),

    // å‚æ•°éªŒè¯æ¨¡å—
    validators: require('./validators'),

    // ç»Ÿä¸€è®°å¿†å¼•æ“æ¨¡å—
    memoryEngine: require('./memoryEngine'),

    // æ•°æ®åº“è¿æ¥æ¨¡å—
    database: require('./database')
};
</file>

<file path="cloudbase/functions/shared/memoryEngine.js">
/**
 * ç»Ÿä¸€è®°å¿†å¼•æ“æ ¸å¿ƒæ¨¡å—
 * æ”¯æŒå­—æ¯/å•è¯/å¥å­çš„ç»Ÿä¸€è®°å¿†ç®¡ç†
 * 
 * ä¿®å¤ï¼šwx-server-sdk ä¸æ”¯æŒ getOne()ï¼Œæ”¹ç”¨ get() + data[0]
 */

const { calculateSM2Optimized } = require('./sm2');

/**
 * åˆ›å»ºæ–°çš„è®°å¿†è®°å½•
 */
async function createMemoryRecord(db, userId, entityType, entityId, isLocked = false) {

    // éªŒè¯å‚æ•°
    if (!userId || !entityType || !entityId) {
        console.error('[createMemoryRecord] å‚æ•°ç¼ºå¤±:', { userId, entityType, entityId });
        throw new Error('userId, entityType, entityId éƒ½æ˜¯å¿…éœ€å‚æ•°');
    }

    const now = new Date();
    const nextReviewAt = isLocked ? null : new Date(now.getTime() + 24 * 60 * 60 * 1000).toISOString();

    const memoryRecord = {
        userId,
        entityType,
        entityId,
        masteryLevel: 0.0,
        reviewStage: 0,
        easinessFactor: 2.5,
        intervalDays: 1,
        lastReviewAt: null,
        nextReviewAt,
        correctCount: 0,
        wrongCount: 0,
        streakCorrect: 0,
        isLocked,
        createdAt: now.toISOString(),
        updatedAt: now.toISOString()
    };

    try {
        // å°è¯•æ’å…¥
        const result = await db.collection('memory_status').add(memoryRecord);

        console.log('[createMemoryRecord] åˆ›å»ºæˆåŠŸ:', { userId, entityType, entityId });

        return {
            _id: result._id,
            ...memoryRecord
        };
    } catch (error) {
        // å¦‚æœæ˜¯é‡å¤é”®é”™è¯¯ï¼ŒæŸ¥è¯¢å¹¶è¿”å›ç°æœ‰è®°å½•
        if (error.errCode === -502001 || error.message.includes('duplicate key')) {
            console.log('[createMemoryRecord] è®°å½•å·²å­˜åœ¨ï¼ŒæŸ¥è¯¢è¿”å›:', { userId, entityType, entityId });

            const existingResult = await db.collection('memory_status')
                .where({ userId, entityType, entityId })
                .get();

            if (existingResult.data && existingResult.data.length > 0) {
                return existingResult.data[0];
            }
        }

        // å…¶ä»–é”™è¯¯ç»§ç»­æŠ›å‡º
        console.error('[createMemoryRecord] åˆ›å»ºå¤±è´¥:', error);
        throw error;
    }
}

/**
 * è·å–æˆ–åˆ›å»ºè®°å¿†è®°å½•
 * ä¿®å¤ï¼šä½¿ç”¨ get() ä»£æ›¿ getOne()
 */
async function getOrCreateMemory(db, userId, entityType, entityId, isLocked = false) {
    // 1. å°è¯•æŸ¥è¯¢ç°æœ‰è®°å½•
    const existingMemory = await db.collection('memory_status')
        .where({
            userId,
            entityType,
            entityId
        })
        .get();

    // 2. å¦‚æœå­˜åœ¨,ç›´æ¥è¿”å›ç¬¬ä¸€æ¡
    if (existingMemory.data && existingMemory.data.length > 0) {
        return existingMemory.data[0];
    }

    // 3. ä¸å­˜åœ¨åˆ™åˆ›å»ºæ–°è®°å½•
    return await createMemoryRecord(db, userId, entityType, entityId, isLocked);
}

/**
 * æ›´æ–°è®°å¿†çŠ¶æ€(ç­”é¢˜åè°ƒç”¨)
 */
async function updateMemoryAfterReview(db, userId, entityType, entityId, quality) {
    console.log('ã€æµ‹è¯•ã€‘updateMemoryAfterReview è¢«è°ƒç”¨äº†ï¼', { userId, quality });
    console.log('=== [updateMemoryAfterReview] å¼€å§‹ ===');
    console.log('å‚æ•°:', JSON.stringify({ userId, entityType, entityId, quality }));

    try {
        // 1. è·å–å½“å‰è®°å¿†è®°å½•
        console.log('æ­¥éª¤1: è·å–è®°å¿†è®°å½•');
        const memory = await getOrCreateMemory(db, userId, entityType, entityId);
        console.log('è®°å¿†è®°å½•:', JSON.stringify(memory));

        // 2. æ˜ å°„è´¨é‡åˆ°SM-2è¯„åˆ†
        console.log('æ­¥éª¤2: æ˜ å°„è´¨é‡');
        const qualityMap = {
            'é™Œç”Ÿ': 1,
            'æ¨¡ç³Š': 3,
            'è®°å¾—': 5
        };
        const sm2Quality = qualityMap[quality] || 3;
        console.log('SM-2è´¨é‡:', sm2Quality);

        // 3. è®¡ç®—æ–°çš„SM-2å‚æ•°
        console.log('æ­¥éª¤3: è°ƒç”¨ calculateSM2Optimized');
        console.log('è°ƒç”¨å‚æ•°:', {
            quality,
            intervalDays: memory.intervalDays,
            easinessFactor: memory.easinessFactor,
            reviewStage: memory.reviewStage
        });

        const sm2Result = calculateSM2Optimized(
            quality,
            memory.intervalDays,
            memory.easinessFactor,
            memory.reviewStage
        );

        console.log('SM-2ç»“æœ:', JSON.stringify(sm2Result));

        // 4. æ›´æ–°æŒæ¡åº¦
        console.log('æ­¥éª¤4: è®¡ç®—æ–°æŒæ¡åº¦');
        let newMasteryLevel = memory.masteryLevel;
        if (quality === 'è®°å¾—') {
            newMasteryLevel = Math.min(1.0, memory.masteryLevel + 0.15);
        } else if (quality === 'æ¨¡ç³Š') {
            newMasteryLevel = Math.max(0.0, memory.masteryLevel + 0.05);
        } else {
            newMasteryLevel = Math.max(0.0, memory.masteryLevel - 0.2);
        }
        console.log('æ–°æŒæ¡åº¦:', newMasteryLevel);

        // 5. æ›´æ–°è¿èƒœå’Œè®¡æ•°
        console.log('æ­¥éª¤5: è®¡ç®—è¿èƒœ');
        const newStreakCorrect = quality === 'è®°å¾—' ? memory.streakCorrect + 1 : 0;
        const newCorrectCount = quality === 'è®°å¾—' ? memory.correctCount + 1 : memory.correctCount;
        const newWrongCount = quality === 'é™Œç”Ÿ' ? memory.wrongCount + 1 : memory.wrongCount;

        // 6. è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´
        console.log('æ­¥éª¤6: è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´');
        const now = new Date();
        const nextReviewAt = new Date(now.getTime() + sm2Result.interval * 24 * 60 * 60 * 1000);
        console.log('ä¸‹æ¬¡å¤ä¹ æ—¶é—´:', nextReviewAt);

        // 7. å‡†å¤‡æ›´æ–°æ•°æ®
        console.log('æ­¥éª¤7: å‡†å¤‡æ›´æ–°æ•°æ®åº“');
        const updateData = {
            masteryLevel: newMasteryLevel,
            reviewStage: sm2Result.repetitions,
            easinessFactor: sm2Result.easinessFactor,
            intervalDays: sm2Result.interval,
            lastReviewAt: now.toISOString(),
            nextReviewAt: nextReviewAt.toISOString(),
            correctCount: newCorrectCount,
            wrongCount: newWrongCount,
            streakCorrect: newStreakCorrect,
            updatedAt: now.toISOString()
        };

        console.log('æ›´æ–°æ•°æ®å¯¹è±¡:', JSON.stringify(updateData));

        // æ£€æŸ¥æ˜¯å¦æœ‰ undefined
        for (const [key, value] of Object.entries(updateData)) {
            if (value === undefined) {
                console.error(`âŒ å‘ç° undefined å€¼: ${key}`);
            }
        }

        // 8. æ‰§è¡Œæ›´æ–°
        console.log('æ­¥éª¤8: æ‰§è¡Œæ•°æ®åº“æ›´æ–°');
        await db.collection('memory_status')
            .where({
                userId,
                entityType,
                entityId
            })
            .update({
                data: updateData   // âœ… CloudBase å¿…é¡»è¿™æ ·å†™
            });

        console.log('âœ… æ›´æ–°æˆåŠŸ');

        return {
            entityId,
            entityType,
            masteryLevel: newMasteryLevel,
            reviewStage: sm2Result.repetitions,
            easinessFactor: sm2Result.easinessFactor,
            intervalDays: sm2Result.interval,
            nextReviewAt: nextReviewAt.toISOString(),
            correctCount: newCorrectCount,
            wrongCount: newWrongCount,
            streakCorrect: newStreakCorrect
        };

    } catch (error) {
        console.error('âŒ [updateMemoryAfterReview] é”™è¯¯:', error);
        console.error('é”™è¯¯å †æ ˆ:', error.stack);
        throw error;
    }
}

/**
 * è·å–ä»Šæ—¥å¾…å¤ä¹ çš„å®ä½“
 */
async function getTodayReviewEntities(db, userId, entityType, limit = 20) {
    const now = new Date();

    const result = await db.collection('memory_status')
        .where({
            userId,
            entityType,
            isLocked: false,
            nextReviewAt: db.command.lte(now)
        })
        .orderBy('nextReviewAt', 'asc')
        .limit(limit)
        .get();

    return result.data || [];
}

/**
 * æ£€æŸ¥å¹¶è§£é”ä¸‹ä¸€é˜¶æ®µå­¦ä¹ 
 */
// async function checkAndUnlockNextStage(db, userId) {

//   if (process.env.FORCE_UNLOCK === 'true') {
//     return {
//       allowed: true,
//       progress: 100,
//       stage: "all",
//       message: 'ã€è°ƒè¯•æ¨¡å¼ã€‘å¼ºåˆ¶è§£é”'
//     };
//   }

//   // ä¿®å¤ï¼šä½¿ç”¨ get() + data[0]
//   const progressResult = await db.collection('user_progress')
//     .where({ userId })
//     .get();

//   if (!progressResult.data || progressResult.data.length === 0) {
//     await initUserProgress(db, userId);
//     return {
//       unlocked: false,
//       stage: 'letter',
//       message: 'åˆå§‹åŒ–å­¦ä¹ è¿›åº¦æˆåŠŸ'
//     };
//   }

//   const progress = progressResult.data[0];

//   if (!progress.letterCompleted) {
//     const letterMemories = await db.collection('memory_status')
//       .where({
//         userId,
//         entityType: 'letter'
//       })
//       .get();

//     const totalLetters = 44;
//     const masteredLetters = letterMemories.data.filter(m => m.masteryLevel >= 0.7).length;
//     const letterProgress = masteredLetters / totalLetters;

//     if (letterProgress >= 0.95) {
//       await db.collection('user_progress').where({ userId }).update({
//         data: {
//           letterCompleted: true,
//           letterProgress: 1.0,
//           wordUnlocked: true,
//           currentStage: 'word',
//           updatedAt: new Date().toISOString()
//         }
//       });

//       await db.collection('memory_status')
//         .where({
//           userId,
//           entityType: 'word',
//           isLocked: true
//         })
//         .update({
//           data: {
//             isLocked: false,
//             nextReviewAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
//           }
//         });

//       return {
//         unlocked: true,
//         stage: 'word',
//         message: 'æ­å–œ!å­—æ¯å­¦ä¹ å®Œæˆ,å•è¯å­¦ä¹ å·²è§£é”!'
//       };
//     }

//     return {
//       unlocked: false,
//       stage: 'letter',
//       progress: letterProgress,
//       remaining: Math.ceil((0.95 - letterProgress) * totalLetters),
//       message: `è¿˜éœ€æŒæ¡ ${Math.ceil((0.95 - letterProgress) * totalLetters)} ä¸ªå­—æ¯`
//     };
//   }

//   return {
//     unlocked: false,
//     stage: progress.currentStage,
//     message: 'ç»§ç»­åŠ æ²¹!'
//   };
// }

/**
 * åˆå§‹åŒ–ç”¨æˆ·çš„å­¦ä¹ è¿›åº¦è®°å½•
 */
async function initUserProgress(db, userId) {
    const now = new Date();

    const progressRecord = {
        userId,
        letterCompleted: false,
        letterProgress: 0.0,
        wordUnlocked: false,
        wordProgress: 0.0,
        sentenceUnlocked: false,
        sentenceProgress: 0.0,
        articleUnlocked: false,
        currentStage: 'letter',
        totalStudyDays: 0,
        streakDays: 0,
        lastStudyDate: null,
        createdAt: now,
        updatedAt: now
    };

    await db.collection('user_progress').add(progressRecord);
    return progressRecord;
}

/**
 * æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™
 * ä¿®å¤ï¼šä½¿ç”¨ get() + data[0]
 */
async function checkModuleAccess(db, userId, moduleType) {

    // âœ…âœ…âœ…ã€è°ƒè¯•æ€»å¼€å…³ï¼šè·³è¿‡æ‰€æœ‰å­¦ä¹ é”ã€‘
    if (process.env.FORCE_UNLOCK === 'true') {
        console.warn('âš ï¸ FORCE_UNLOCK å·²å¼€å¯, å¼ºåˆ¶æ”¾è¡Œæ¨¡å—:', moduleType);
        return {
            allowed: true,
            progress: {
                letterCompleted: true,
                letterProgress: 1,
                wordUnlocked: true,
                sentenceUnlocked: true,
                articleUnlocked: true,
                currentStage: moduleType
            }
        };
    }

    const progressResult = await db.collection('user_progress')
        .where({ userId })
        .get();

    if (!progressResult.data || progressResult.data.length === 0) {
        return {
            allowed: false,
            errorCode: 'USER_PROGRESS_NOT_FOUND',
            message: 'ç”¨æˆ·å­¦ä¹ è¿›åº¦ä¸å­˜åœ¨,è¯·è”ç³»ç®¡ç†å‘˜'
        };
    }

    const progress = progressResult.data[0];

    // âœ… å­—æ¯æ¨¡å—æ°¸è¿œå…è®¸è®¿é—®
    if (moduleType === 'letter') {
        return {
            allowed: true,
            progress
        };
    }

    // âœ… å…¶ä»–æ‰€æœ‰æ¨¡å—åªä¾èµ– letterCompleted
    if (!progress.letterCompleted) {
        return {
            allowed: false,
            errorCode: 'MODULE_LOCKED',
            message: `è¯·å…ˆå®Œæˆå­—æ¯å­¦ä¹ ï¼ˆå½“å‰è¿›åº¦ï¼š${Math.round(progress.letterProgress * 100)}%ï¼‰`,
            progress
        };
    }

    // âœ… å­—æ¯å®Œæˆ â†’ å…¨éƒ¨æ¨¡å—æ”¾è¡Œ
    return {
        allowed: true,
        progress
    };
}

module.exports = {
    createMemoryRecord,
    getOrCreateMemory,
    updateMemoryAfterReview,
    getTodayReviewEntities,
    // checkAndUnlockNextStage,
    initUserProgress,
    checkModuleAccess
};
</file>

<file path="cloudbase/functions/shared/response.js">
/**
 * å“åº”æ ¼å¼åŒ–æ¨¡å—
 * 
 * ç»Ÿä¸€ API å“åº”æ ¼å¼
 * ä¸å‰ç«¯ ApiResponse<T> ç±»å‹å®šä¹‰ä¿æŒä¸€è‡´
 */

'use strict';

const { ErrorCodes, ERROR_MESSAGES } = require('./constants');

/**
 * åˆ›å»ºæ ‡å‡†åŒ– API å“åº”
 * 
 * å¯¹åº”å‰ç«¯ç±»å‹:
 * interface ApiResponse<T> {
 *   success: boolean;
 *   data?: T;
 *   message?: string;
 *   errorCode?: string;
 *   timestamp: string;
 * }
 * 
 * @param {boolean} success - æ˜¯å¦æˆåŠŸ
 * @param {Object} data - è¿”å›æ•°æ®
 * @param {string} message - æç¤ºæ¶ˆæ¯
 * @param {string} errorCode - é”™è¯¯ç 
 * @returns {Object} æ ‡å‡†åŒ–å“åº”å¯¹è±¡
 */
function createResponse(success, data = null, message = '', errorCode = null) {
  return {
    success,
    data,
    message,
    errorCode,
    timestamp: new Date().toISOString(),
  };
}

/**
 * åˆ›å»ºæˆåŠŸå“åº”
 * 
 * @param {Object} data - è¿”å›æ•°æ®
 * @param {string} message - æˆåŠŸæ¶ˆæ¯
 * @returns {Object} æˆåŠŸå“åº”å¯¹è±¡
 */
function successResponse(data, message = 'æ“ä½œæˆåŠŸ') {
  return createResponse(true, data, message, null);
}

/**
 * åˆ›å»ºé”™è¯¯å“åº”
 * 
 * @param {string} errorCode - é”™è¯¯ç  (æ¥è‡ª ErrorCodes)
 * @param {string} customMessage - è‡ªå®šä¹‰æ¶ˆæ¯ (å¯é€‰)
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function errorResponse(errorCode, customMessage = null) {
  const message = customMessage || ERROR_MESSAGES[errorCode] || 'æœªçŸ¥é”™è¯¯';
  return createResponse(false, null, message, errorCode);
}

/**
 * åˆ›å»ºå‚æ•°é”™è¯¯å“åº”
 * 
 * @param {string} detail - é”™è¯¯è¯¦æƒ…
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function invalidParamsResponse(detail) {
  return errorResponse(ErrorCodes.INVALID_PARAMS, detail);
}

/**
 * åˆ›å»ºç”¨æˆ·ä¸å­˜åœ¨å“åº”
 * 
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function userNotFoundResponse() {
  return errorResponse(ErrorCodes.USER_NOT_FOUND);
}

/**
 * åˆ›å»ºè¯æ±‡ä¸å­˜åœ¨å“åº”
 * 
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function vocabularyNotFoundResponse() {
  return errorResponse(ErrorCodes.VOCABULARY_NOT_FOUND);
}

/**
 * åˆ›å»ºæœåŠ¡å™¨é”™è¯¯å“åº”
 * 
 * @param {Error} error - é”™è¯¯å¯¹è±¡
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function serverErrorResponse(error) {
  // ç”Ÿäº§ç¯å¢ƒä¸æš´éœ²é”™è¯¯è¯¦æƒ…
  const message = process.env.NODE_ENV === 'development' 
    ? `æœåŠ¡å™¨é”™è¯¯: ${error.message}`
    : ERROR_MESSAGES.SERVER_ERROR;
  
  return errorResponse(ErrorCodes.SERVER_ERROR, message);
}

module.exports = {
  createResponse,
  successResponse,
  errorResponse,
  invalidParamsResponse,
  userNotFoundResponse,
  vocabularyNotFoundResponse,
  serverErrorResponse,
};
</file>

<file path="cloudbase/functions/shared/sm2.js">
/**
 * SM-2 é—´éš”é‡å¤ç®—æ³•æ¨¡å—ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
 * 
 * åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–:
 * - æ—©æœŸå¤ä¹ é—´éš”æ›´å¯†é›†: 1â†’2â†’4â†’7â†’14 å¤©
 * - "æ¨¡ç³Š"çŠ¶æ€ç¼©çŸ­é—´éš”è€Œéç»´æŒä¸å˜
 * - "é™Œç”Ÿ"çŠ¶æ€é‡ç½®å¤ä¹ è¿›åº¦
 * 
 * ç®—æ³•è®ºæ–‡: https://www.supermemo.com/en/archives1990-2015/english/ol/sm2
 */

'use strict';

const { MasteryLevel, SM2_PARAMS, EARLY_INTERVALS } = require('./constants');

/**
 * å°†æŒæ¡ç¨‹åº¦æ˜ å°„åˆ° SM-2 Quality å€¼
 * 
 * SM-2 Quality å®šä¹‰:
 * 0 - å®Œå…¨ä¸è®°å¾—
 * 1 - é”™è¯¯å›ç­”ï¼Œä½†çœ‹åˆ°æ­£ç¡®ç­”æ¡ˆåæƒ³èµ·
 * 2 - é”™è¯¯å›ç­”ï¼Œæ­£ç¡®ç­”æ¡ˆçœ‹èµ·æ¥å¾ˆç†Ÿæ‚‰
 * 3 - æ­£ç¡®å›ç­”ï¼Œä½†å›°éš¾è¾ƒå¤§
 * 4 - æ­£ç¡®å›ç­”ï¼Œæœ‰äº›çŠ¹è±«
 * 5 - æ­£ç¡®å›ç­”ï¼Œæ¯«æ— å›°éš¾
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦
 * @returns {number} Qualityå€¼ (1-5)
 */
function masteryToQuality(mastery) {
    switch (mastery) {
        case MasteryLevel.UNFAMILIAR:
            return 1;  // å®Œå…¨ä¸è®°å¾—
        case MasteryLevel.FUZZY:
            return 3;  // æœ‰å°è±¡ä½†ä¸ç¡®å®š
        case MasteryLevel.REMEMBERED:
            return 5;  // å®Œå…¨è®°å¾—
        default:
            return 1;
    }
}

/**
 * è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸï¼ˆä¼˜åŒ–ç‰ˆ SM-2 ç®—æ³•ï¼‰
 * 
 * æ”¹è¿›ç‚¹:
 * 1. æ—©æœŸé˜¶æ®µï¼ˆå‰5æ¬¡ï¼‰ä½¿ç”¨å›ºå®šçš„æ¸è¿›é—´éš” [1,2,4,7,14]
 * 2. "æ¨¡ç³Š"æ—¶ç¼©çŸ­é—´éš”è€Œéç»´æŒä¸å˜
 * 3. "é™Œç”Ÿ"æ—¶å®Œå…¨é‡ç½®å¤ä¹ è¿›åº¦
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦: å¿˜è®°/æ¨¡ç³Š/è®¤è¯†
 * @param {number} currentInterval - å½“å‰å¤ä¹ é—´éš”ï¼ˆå¤©ï¼‰
 * @param {number} easinessFactor - ç®€æ˜“åº¦å› å­ï¼ˆ1.3-2.5+ï¼‰
 * @param {number} reviewCount - å·²å¤ä¹ æ¬¡æ•°
 * @returns {Object} ç®—æ³•è®¡ç®—ç»“æœ
 * 
 * @example
 * const result = calculateSM2Optimized('è®¤è¯†', 2, 2.5, 1);
 * // {
 * //   nextInterval: 4,
 * //   nextEasinessFactor: 2.6,
 * //   nextReviewDate: "2025-12-01T10:00:00Z",
 * //   shouldResetCount: false
 * // }
 * */
function calculateSM2Optimized(
    mastery,
    currentInterval = 1,
    easinessFactor = SM2_PARAMS.INITIAL_EASINESS_FACTOR,
    reviewCount = 0
) {
    let nextInterval = currentInterval;
    let nextEF = easinessFactor;
    let shouldResetCount = false;

    const quality = masteryToQuality(mastery);

    // ==================== æ ¸å¿ƒç®—æ³•é€»è¾‘ ====================

    if (quality < 3) {
        // ========== å¿˜è®°: å®Œå…¨é‡ç½® ==========
        // ç”¨æˆ·å®Œå…¨ä¸è®°å¾—ï¼Œéœ€è¦ä»å¤´å¼€å§‹å­¦ä¹ 
        nextInterval = 1;
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF - 0.2);
        shouldResetCount = true;

    } else if (quality === 3) {
        // ========== æ¨¡ç³Š: ç¼©çŸ­é—´éš”ï¼ŒåŠ å¼ºå¤ä¹  ==========
        // æ”¹è¿›: ä¸æ˜¯ç»´æŒä¸å˜ï¼Œè€Œæ˜¯ç¼©çŸ­20%
        nextInterval = Math.max(1, Math.round(currentInterval * SM2_PARAMS.FUZZY_MULTIPLIER));
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF - 0.1);

    } else {
        // ========== è®°å¾—: ä½¿ç”¨ä¼˜åŒ–çš„é—´éš”åºåˆ— ==========
        if (reviewCount < EARLY_INTERVALS.length) {
            // æ—©æœŸé˜¶æ®µ: ä½¿ç”¨é¢„å®šä¹‰çš„æ¸è¿›é—´éš”
            // è¿™æ˜¯å…³é”®æ”¹è¿›: 1â†’2â†’4â†’7â†’14 è€ŒéåŸç‰ˆçš„ 1â†’6
            nextInterval = EARLY_INTERVALS[reviewCount];
        } else {
            // åæœŸé˜¶æ®µ: ä½¿ç”¨ EF è®¡ç®—æŒ‡æ•°å¢é•¿
            nextInterval = Math.round(currentInterval * nextEF);
        }

        // æé«˜ç®€æ˜“åº¦ (æ ‡å‡† SM-2 å…¬å¼)
        nextEF = nextEF + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF);
    }

    // é™åˆ¶æœ€å¤§é—´éš”
    nextInterval = Math.min(nextInterval, SM2_PARAMS.MAX_INTERVAL_DAYS);

    // è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸ
    const nextReviewDate = new Date();
    nextReviewDate.setDate(nextReviewDate.getDate() + nextInterval);

    // è®¡ç®—æ–°çš„å¤ä¹ æ¬¡æ•°
    const newRepetitions = shouldResetCount ? 0 : reviewCount + 1;

    return {
        // === å…¼å®¹ memoryEngine.js çš„æ—§æ¥å£ ===
        interval: nextInterval,
        easinessFactor: parseFloat(nextEF.toFixed(2)),
        repetitions: newRepetitions,

        // === æ–°æ¥å£ï¼ˆä¿ç•™ä¾›æœªæ¥ä½¿ç”¨ï¼‰===
        nextInterval,
        nextEasinessFactor: parseFloat(nextEF.toFixed(2)),
        nextReviewDate: nextReviewDate.toISOString(),
        shouldResetCount,
    };
}

/**
 * ç”Ÿæˆé¢„è®¡å¤ä¹ æ—¶é—´çº¿
 * 
 * ç”¨äºå‰ç«¯å±•ç¤ºæœªæ¥çš„å¤ä¹ è®¡åˆ’
 * 
 * @param {number} currentReviewCount - å½“å‰å¤ä¹ æ¬¡æ•°
 * @param {number} maxItems - è¿”å›çš„æ—¶é—´çº¿é¡¹æ•° (é»˜è®¤5)
 * @returns {Array} æœªæ¥å¤ä¹ è®¡åˆ’
 * 
 * @example
 * generateReviewTimeline(2);
 * // [
 * //   { reviewNumber: 3, intervalDays: 4 },
 * //   { reviewNumber: 4, intervalDays: 7 },
 * //   { reviewNumber: 5, intervalDays: 14 },
 * //   ...
 * // ]
 */
function generateReviewTimeline(currentReviewCount, maxItems = 5) {
    const timeline = [];
    let interval = 1;
    let ef = SM2_PARAMS.INITIAL_EASINESS_FACTOR;

    for (let i = currentReviewCount; i < currentReviewCount + maxItems; i++) {
        if (i < EARLY_INTERVALS.length) {
            interval = EARLY_INTERVALS[i];
        } else {
            interval = Math.round(interval * ef);
        }
        interval = Math.min(interval, SM2_PARAMS.MAX_INTERVAL_DAYS);

        timeline.push({
            reviewNumber: i + 1,
            intervalDays: interval,
        });
    }

    return timeline;
}

/**
 * è·å–ä»Šå¤©çš„æ—¶é—´èŒƒå›´ (UTC)
 * 
 * @returns {Object} { startOfDay, endOfDay, timestamp }
 */
function getTodayRange() {
    const now = new Date();
    const startOfDay = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate(),
        0, 0, 0, 0
    ));
    const endOfDay = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate() + 1,
        0, 0, 0, 0
    ));

    return {
        startOfDay: startOfDay.toISOString(),
        endOfDay: endOfDay.toISOString(),
        timestamp: now.toISOString(),
    };
}

/**
 * è·å–ç®—æ³•ä¿¡æ¯ (ç”¨äºå‰ç«¯å±•ç¤º)
 * 
 * @returns {Object} ç®—æ³•å…ƒä¿¡æ¯
 */
function getAlgorithmInfo() {
    return {
        name: 'Optimized SM-2',
        version: '1.1.0',
        earlyIntervals: EARLY_INTERVALS,
        maxInterval: SM2_PARAMS.MAX_INTERVAL_DAYS,
        description: 'åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–çš„é—´éš”é‡å¤ç®—æ³•',
    };
}

module.exports = {
    calculateSM2Optimized,
    generateReviewTimeline,
    getTodayRange,
    getAlgorithmInfo,
    masteryToQuality,
};
</file>

<file path="cloudbase/functions/shared/validators.js">
/**
 * å‚æ•°éªŒè¯æ¨¡å—
 * 
 * ç”¨æˆ·ã€è¯æ±‡éªŒè¯åŠé€šç”¨éªŒè¯å·¥å…·
 */

'use strict';

const { userCollection, vocabularyCollection } = require('./database');
const { MasteryLevel } = require('./constants');

/**
 * éªŒè¯ç”¨æˆ·æ˜¯å¦å­˜åœ¨
 * 
 * @param {string} userId - ç”¨æˆ·ID
 * @returns {Promise<Object|null>} ç”¨æˆ·å¯¹è±¡æˆ– null
 */
async function validateUser(userId) {
    if (!userId || typeof userId !== 'string') {
        return null;
    }

    try {
        const { data } = await userCollection
            .where({ userId })
            .limit(1)
            .get();

        return data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('[validateUser] Error:', error);
        return null;
    }
}

/**
 * éªŒè¯è¯æ±‡æ˜¯å¦å­˜åœ¨
 * 
 * @param {string} vocabularyId - è¯æ±‡ID
 * @returns {Promise<Object|null>} è¯æ±‡å¯¹è±¡æˆ– null
 */
async function validateVocabulary(vocabularyId) {
    if (!vocabularyId || typeof vocabularyId !== 'string') {
        return null;
    }

    try {
        const { data } = await vocabularyCollection
            .where({ vocabularyId })
            .limit(1)
            .get();

        return data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('[validateVocabulary] Error:', error);
        return null;
    }
}

/**
 * éªŒè¯æŒæ¡ç¨‹åº¦æ˜¯å¦æœ‰æ•ˆ
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦
 * @returns {boolean} æ˜¯å¦æœ‰æ•ˆ
 */
function isValidMastery(mastery) {
    const validValues = Object.values(MasteryLevel);
    return validValues.includes(mastery);
}

/**
 * éªŒè¯å¹¶è§„èŒƒåŒ–åˆ†é¡µå‚æ•°
 * 
 * @param {number} limit - é™åˆ¶æ•°é‡
 * @param {number} offset - åç§»é‡
 * @param {number} maxLimit - æœ€å¤§é™åˆ¶ (é»˜è®¤100)
 * @returns {Object} éªŒè¯åçš„åˆ†é¡µå‚æ•°
 */
function validatePagination(limit, offset, maxLimit = 100) {
    return {
        limit: Math.min(Math.max(1, parseInt(limit) || 20), maxLimit),
        offset: Math.max(0, parseInt(offset) || 0),
    };
}

/**
 * éªŒè¯å¿…å¡«å­—ç¬¦ä¸²å‚æ•°
 * 
 * @param {string} value - å‚æ•°å€¼
 * @param {string} name - å‚æ•°å (ç”¨äºé”™è¯¯æ¶ˆæ¯)
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateRequiredString(value, name) {
    if (!value || typeof value !== 'string' || value.trim() === '') {
        return {
            valid: false,
            error: `${name} æ˜¯å¿…å¡«å‚æ•°ä¸”ä¸èƒ½ä¸ºç©º`,
        };
    }
    return { valid: true };
}

/**
 * éªŒè¯å¸ƒå°”å‚æ•°
 * 
 * @param {any} value - å‚æ•°å€¼
 * @param {string} name - å‚æ•°å
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateBoolean(value, name) {
    if (typeof value !== 'boolean') {
        return {
            valid: false,
            error: `${name} å¿…é¡»æ˜¯å¸ƒå°”å€¼`,
        };
    }
    return { valid: true };
}
/**
 * é€šç”¨å‚æ•°éªŒè¯å‡½æ•°
 * 
 * @param {Object} params - éœ€è¦éªŒè¯çš„å‚æ•°å¯¹è±¡
 * @param {Array<string>} requiredFields - å¿…éœ€å­—æ®µåˆ—è¡¨
 * @returns {Object} { isValid: boolean, message?: string }
 */
function validateParams(params, requiredFields) {
    const missing = [];

    for (const field of requiredFields) {
        if (params[field] === undefined || params[field] === null || params[field] === '') {
            missing.push(field);
        }
    }

    if (missing.length > 0) {
        return {
            isValid: false,
            message: `ç¼ºå°‘å¿…å¡«å‚æ•°: ${missing.join(', ')}`
        };
    }

    return { isValid: true };
}

module.exports = {
    validateUser,
    validateVocabulary,
    isValidMastery,
    validatePagination,
    validateRequiredString,
    validateBoolean,
    validateParams,
};
</file>

<file path="cloudbase/functions/storage-download/index.js">
// functions/storage-download/index.js
'use strict';

const cloud = require('wx-server-sdk');
const { createResponse } = require('../shared/response'); // å¤ç”¨å·²æœ‰å·¥å…·

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV,
});

/**
 * HTTP å…¥å£
 * event.body å¯èƒ½æ˜¯ string / object
 */
exports.main = async (event, context) => {
  let body;

  try {
    body =
      typeof event.body === 'string'
        ? JSON.parse(event.body)
        : event.body || {};
  } catch (err) {
    console.error('[storage-download] è§£æ body å¤±è´¥:', err);
    return createResponse(false, null, 'è¯·æ±‚ä½“è§£æå¤±è´¥', 'PARSE_ERROR');
  }

  const { action } = body || {};
  if (!action) {
    return createResponse(false, null, 'ç¼ºå°‘ action å‚æ•°', 'MISSING_ACTION');
  }

  try {
    switch (action) {
      case 'getDownloadUrl':
        return await getDownloadUrl(body);
      case 'batchGetDownloadUrls':
        return await batchGetDownloadUrls(body);
      default:
        return createResponse(
          false,
          null,
          `ä¸æ”¯æŒçš„æ“ä½œ: ${action}`,
          'UNSUPPORTED_ACTION',
        );
    }
  } catch (error) {
    console.error('[storage-download] æœªæ•è·é”™è¯¯:', error);
    return createResponse(
      false,
      null,
      error.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      'SERVER_ERROR',
    );
  }
};

/**
 * å•æ–‡ä»¶ï¼šè·å–ä¸´æ—¶ä¸‹è½½é“¾æ¥
 * data.fileId éœ€æ˜¯ CloudBase çš„ fileIDï¼ˆcloud:// å¼€å¤´ï¼‰
 */
async function getDownloadUrl(data) {
  const { fileId, maxAge = 7200 } = data || {};

  if (!fileId) {
    return createResponse(false, null, 'ç¼ºå°‘ fileId å‚æ•°', 'INVALID_PARAMS');
  }

  try {
    const result = await cloud.getTempFileURL({
      fileList: [fileId],
      maxAge,
    });

    if (!result.fileList || result.fileList.length === 0) {
      return createResponse(false, null, 'æ–‡ä»¶ä¸å­˜åœ¨', 'FILE_NOT_FOUND');
    }

    const fileInfo = result.fileList[0];

    if (fileInfo.status !== 0) {
      return createResponse(
        false,
        null,
        fileInfo.errmsg || 'è·å–ä¸‹è½½é“¾æ¥å¤±è´¥',
        'DOWNLOAD_URL_ERROR',
      );
    }

    const now = Date.now();
    return createResponse(
      true,
      {
        fileId: fileInfo.fileID,
        downloadUrl: fileInfo.tempFileURL,
        maxAge,
        expiresAt: new Date(now + maxAge * 1000).toISOString(),
      },
      'è·å–ä¸‹è½½é“¾æ¥æˆåŠŸ',
    );
  } catch (error) {
    console.error('[getDownloadUrl] error:', error);
    return createResponse(
      false,
      null,
      error.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      'SERVER_ERROR',
    );
  }
}

/**
 * æ‰¹é‡ï¼šè·å–ä¸´æ—¶ä¸‹è½½é“¾æ¥ï¼ˆæœ€å¤š 50 ä¸ªï¼‰
 */
async function batchGetDownloadUrls(data) {
  const { fileIds, maxAge = 7200 } = data || {};

  if (!Array.isArray(fileIds) || fileIds.length === 0) {
    return createResponse(
      false,
      null,
      'fileIds å¿…é¡»æ˜¯éç©ºæ•°ç»„',
      'INVALID_PARAMS',
    );
  }

  if (fileIds.length > 50) {
    return createResponse(
      false,
      null,
      'å•æ¬¡æœ€å¤šæ”¯æŒ 50 ä¸ªæ–‡ä»¶',
      'TOO_MANY_FILES',
    );
  }

  try {
    const result = await cloud.getTempFileURL({
      fileList: fileIds,
      maxAge,
    });

    const files = (result.fileList || []).map((f) => ({
      fileId: f.fileID,
      downloadUrl: f.status === 0 ? f.tempFileURL : null,
      status: f.status === 0 ? 'success' : 'failed',
      error: f.status === 0 ? null : f.errmsg,
    }));

    const success = files.filter((f) => f.status === 'success').length;
    const now = Date.now();

    return createResponse(
      true,
      {
        files,
        summary: {
          total: files.length,
          success,
          failed: files.length - success,
        },
        maxAge,
        expiresAt: new Date(now + maxAge * 1000).toISOString(),
      },
      `è·å– ${success}/${files.length} ä¸ªæ–‡ä»¶ä¸‹è½½é“¾æ¥æˆåŠŸ`,
    );
  } catch (error) {
    console.error('[batchGetDownloadUrls] error:', error);
    return createResponse(
      false,
      null,
      error.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      'SERVER_ERROR',
    );
  }
}
</file>

<file path="cloudbase/functions/storage-download/package.json">
{
  "name": "storage-download",
  "version": "1.0.0",
  "description": "Storage download cloud function",
  "main": "index.js",
  "dependencies": {
    "wx-server-sdk": "~2.6.3",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2"
  }
}
</file>

<file path="cloudbase/functions/user-register/package.json">
{
  "name": "user-register",
  "version": "1.0.0",
  "description": "User registration cloud function",
  "main": "index.js",
  "dependencies": {
    "wx-server-sdk": "~2.6.3",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2"
  }
}
</file>

<file path="cloudbase/functions/user-reset-password/package.json">
{
  "name": "user-reset-password",
  "version": "1.0.0",
  "description": "User password reset cloud function",
  "main": "index.js",
  "dependencies": {
    "wx-server-sdk": "~2.6.3"
  }
}
</file>

<file path="cloudbase/functions/user-update-profile/package.json">
{
  "name": "user-update-profile",
  "version": "1.0.0",
  "description": "User profile update cloud function",
  "main": "index.js",
  "dependencies": {
    "wx-server-sdk": "~2.6.3"
  }
}
</file>

<file path="cloudbase/fix-cloud-functions.sh">
#!/bin/bash
set -e

echo "========================================="
echo "ğŸš€ Cloud Functions Automatic Cleanup Tool"
echo "========================================="

BASE_DIR="./cloudbase/functions"

echo ""
echo "ğŸ“Œ Step 1: åˆ é™¤æ‰€æœ‰ node_modules æ–‡ä»¶å¤¹..."
find $BASE_DIR -type d -name "node_modules" -prune -exec rm -rf {} +

echo "âœ” å·²åˆ é™¤æœ¬åœ° node_modules"

echo ""
echo "ğŸ“Œ Step 2: åˆ é™¤ä¸åº”è¯¥ä¸Šä¼ çš„æ–‡ä»¶ï¼ˆ.DS_Storeã€æ„å»ºäº§ç‰©ï¼‰"
find $BASE_DIR -name ".DS_Store" -delete
find $BASE_DIR -name "*.log" -delete
find $BASE_DIR -name "*.tmp" -delete
find $BASE_DIR -name "dist" -prune -exec rm -rf {} +
find $BASE_DIR -name ".turbo" -prune -exec rm -rf {} +

echo "âœ” æ¸…ç†å®Œæˆ"

echo ""
echo "ğŸ“Œ Step 3: è‡ªåŠ¨ä¸ºæ¯ä¸ªäº‘å‡½æ•°ç”Ÿæˆ package.json"

FUNCTIONS=$(find $BASE_DIR -maxdepth 1 -mindepth 1 -type d)

for FN in $FUNCTIONS; do
  if [ ! -f "$FN/index.js" ]; then
    echo "âš ï¸ è­¦å‘Š: $FN ç¼ºå°‘ index.jsï¼Œè·³è¿‡ package.json ç”Ÿæˆ"
    continue
  fi

  PKG="$FN/package.json"

  echo "ğŸ“¦ ç”Ÿæˆ package.json â†’ $PKG"

  cat > "$PKG" <<EOF
{
  "name": "$(basename $FN)",
  "version": "1.0.0",
  "description": "CloudBase Function: $(basename $FN)",
  "main": "index.js",
  "dependencies": {
    "wx-server-sdk": "^2.10.0"
  }
}
EOF

done

echo "âœ” package.json åˆ›å»ºå®Œæˆ"

echo ""
echo "ğŸ“Œ Step 4: ä¿®å¤ cloudbaserc.jsonï¼ˆè®¾ç½® runtime & å®‰è£…ä¾èµ–ï¼‰"

cat > cloudbaserc.json <<EOF
{
  "functions": [
    {
      "name": "alphabet",
      "timeout": 10,
      "runtime": "Nodejs18.15",
      "installDependency": true
    },
    {
      "name": "learn-vocab",
      "timeout": 10,
      "runtime": "Nodejs18.15",
      "installDependency": true
    },
    {
      "name": "memory-engine",
      "timeout": 10,
      "runtime": "Nodejs18.15",
      "installDependency": true
    }
  ]
}
EOF

echo "âœ” cloudbaserc.json å·²æ›´æ–°"

echo ""
echo "ğŸ“Œ Step 5: æ£€æŸ¥é”™è¯¯ require è·¯å¾„ï¼ˆè·¨å‡½æ•° require ä¼šå¯¼è‡´éƒ¨ç½²å¤±è´¥ï¼‰"

BAD_IMPORTS=$(grep -R "\.\./shared" -n $BASE_DIR || true)

if [ -n "$BAD_IMPORTS" ]; then
  echo "âŒ æ£€æµ‹åˆ°è·¨å‡½æ•° require é”™è¯¯:"
  echo "$BAD_IMPORTS"
  echo "â— è¯·å°† shared ä»£ç å¤åˆ¶åˆ°æ¯ä¸ªå‡½æ•° utils/ ä¸‹"
else
  echo "âœ” æœªæ£€æµ‹åˆ°è·¨å‡½æ•° require"
fi

echo ""
echo "========================================="
echo "ğŸ‰  Cloud Functions Cleanup Completed!"
echo "========================================="
</file>

<file path="cloudbase/package.json">
{
  "name": "cloudbase",
  "version": "1.0.0",
  "description": "",
  "main": "initAlphabetLessonsAndRules.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "wx-server-sdk": "^3.0.1"
  }
}
</file>

<file path="docs/project-freeze/courses-and-learningstore-spec.md">
# è¯¾ç¨‹å…¥å£ & LearningStore æœ€ç»ˆè§„æ ¼è¯´æ˜ï¼ˆCourses + LearningStore Spec, Freeze V2.0.1ï¼‰

> ç›®å½•ï¼š`docs/project-freeze/courses-and-learningstore-spec.md`  
> é€‚ç”¨èŒƒå›´ï¼š**Courses æ ‡ç­¾é¡µ + è¯¾ç¨‹é…ç½® JSON + LearningStore å…¨å±€å­¦ä¹ ç®¡ç†å±‚**  
> ç›®æ ‡ï¼šå†»ç»“è¯¾ç¨‹å…¥å£å±‚çš„èŒè´£åˆ’åˆ†ä¸æ•°æ®ç»“æ„ï¼Œä¸ºåç»­ Vocabulary / Alphabet / AI æ¨¡å—æä¾›ç¨³å®šå…¥å£ã€‚

---

## 1. æ¨¡å—å®šä½ä¸è¾¹ç•Œ

### 1.1 Courses æ¨¡å—èŒè´£

- ä¸€è‡´çš„è¯¾ç¨‹å…¥å£ï¼š
  - åœ¨ `app/(tabs)/courses.tsx` ä¸­å±•ç¤ºæ‰€æœ‰**å¯é€‰å­¦ä¹ é¡¹ç›®**ï¼š
    - å­—æ¯é¡¹ç›®ï¼š`assets/courses/alphabetCourses.json`ï¼›
    - å•è¯é¡¹ç›®ï¼š`assets/courses/courses.json`ï¼ˆåŸºç¡€æ³°è¯­ 1/2/3/4ï¼‰ã€‚
- ç»Ÿä¸€çš„â€œå¼€å§‹/ç»§ç»­å­¦ä¹ â€è¡Œä¸ºï¼š
  - å¯¹äºå•è¯è¯¾ç¨‹ï¼šæ ¹æ®æ˜¯å¦å·²è®¾ç½®æ¯æ—¥è®¡åˆ’ï¼Œè·³è½¬åˆ° `/learning` æˆ– `/learning/setup`ï¼›
  - å¯¹äºå­—æ¯è¯¾ç¨‹ï¼šè·³è½¬åˆ°å­—æ¯æ¨¡å—å…¥å£ `/alphabet`ï¼ˆå†ç”±å­—æ¯æ¨¡å—å†…éƒ¨å†³å®šåç»­æµç¨‹ï¼‰ã€‚
- å±•ç¤ºæ¯ä¸ªè¯¾ç¨‹çš„æ•´ä½“è¿›åº¦ï¼ˆå·²å®Œæˆå­—æ¯/å•è¯æ•°é‡ï¼‰ï¼Œæ•°æ®æ¥æºï¼š
  - `moduleAccessStore.userProgress`ï¼ˆåç«¯ `memory-engine.getUserProgress` / `learn-vocab`ï¼‰ã€‚

### 1.2 LearningStore èŒè´£ï¼ˆç›®æ ‡å½¢æ€ï¼‰

> è¯´æ˜ï¼šå½“å‰ `src/stores/learningStore.ts` æ˜¯æ—§ç‰ˆ demoï¼ŒåŒ…å«å¤§é‡å†™æ­»å€¼ã€‚  
> æœ¬è§„èŒƒæè¿°çš„æ˜¯ **ç›®æ ‡è®¾è®¡**ï¼Œåç»­éœ€è¦ refactor ä½¿å®ç°ä¸æœ¬è§„èŒƒå¯¹é½ã€‚

- å…¨å±€â€œå­¦ä¹ ä»ªè¡¨ç›˜â€çš„çŠ¶æ€æºï¼š
  - å½“å‰ä¸»è¯¾ç¨‹ `currentCourseId`ï¼ˆä¾‹å¦‚ `thai_1`ï¼‰ï¼›
  - å½“å‰å­—æ¯é¡¹ç›® `currentAlphabetProgramId`ï¼ˆä¾‹å¦‚ `alphabet` / `alphabet_core_v1`ï¼‰ï¼›
  - å…¨å±€ç»Ÿè®¡ï¼š`streakDays`, `totalStudyMinutes`, `lastStudyAt` ç­‰ã€‚
- ä¸å…·ä½“æ¨¡å—çš„å…³ç³»ï¼š
  - ä¸ç›´æ¥å‚ä¸å­—æ¯æˆ–å•è¯çš„ SRS é€»è¾‘ï¼›
  - åªè®°å½•â€œç”¨æˆ·æ­£åœ¨å­¦å“ªé—¨è¯¾â€å’Œâ€œæ•´ä½“å­¦äº†å¤šä¹…â€ç­‰å®è§‚ä¿¡æ¯ï¼›
  - é¦–é¡µ Hero Cardã€Profile æˆå°±ç³»ç»Ÿä»è¿™é‡Œè¯»å–ä¿¡æ¯ã€‚

### 1.3 æ¨¡å—è¾¹ç•Œ

- Courses æ¨¡å— **ä¸è´Ÿè´£**ï¼š
  - å†³å®šå…·ä½“å­—æ¯/å•è¯é˜Ÿåˆ—ï¼ˆäº¤ç»™ `alphabetStore` / `vocabularyStore` + `memory-engine`/`learn-vocab`ï¼‰ï¼›
  - ä¿®æ”¹ `memory_status` æˆ– `user_*_progress`ã€‚
- LearningStore **ä¸è´Ÿè´£**ï¼š
  - å•ä¸ªå­—æ¯/å•è¯çš„è¿›åº¦ï¼ˆå·²æŒæ¡å¤šå°‘ä¸ªå…·ä½“å®ä½“ï¼‰ï¼›
  - SRS ç®—æ³•æˆ–ä¸‹æ¬¡å¤ä¹ æ—¶é—´ã€‚

---

## 2. ç›¸å…³ä»£ç  / é…ç½®æ€»è§ˆ

### 2.1 è¯¾ç¨‹é…ç½® JSON

- `assets/courses/courses.json`ï¼ˆå•è¯è¯¾ç¨‹ï¼Œå¤§è¯¾ç¨‹ï¼‰

```json
[
  {
    "id": "thai_1",
    "source": "Thai_1",
    "title": "åŸºç¡€æ³°è¯­1",
    "description": "ä»é›¶å¼€å§‹å­¦ä¹ æ³°è¯­ï¼ŒæŒæ¡ä¸€ç‚¹ç‚¹è¯æ±‡ã€‚",
    "level": "å…¥é—¨",
    "image": "ThaiBase_1.png",
    "category": "word",
    "lessons": 20
  },
  ...
]
```

- `assets/courses/alphabetCourses.json`ï¼ˆå­—æ¯é¡¹ç›®ï¼Œå¤§è¯¾ç¨‹ï¼‰

```json
[
  {
    "id": "alphabet",
    "source": "alphabet",
    "title": "æ³°è¯­å­—æ¯è¡¨",
    "description": "ä»44ä¸ªè¾…éŸ³åˆ°å…ƒéŸ³ä¸å£°è°ƒï¼Œé€æ­¥æŒæ¡æ³°è¯­è¯»å†™åŸºç¡€ã€‚",
    "level": "å…¥é—¨",
    "image": "thai_alphabet.png",
    "category": "letter",
    "lessons": 44
  }
]
```

> çº¦å®šï¼š
> - `id`ï¼šç”¨äº UI å’Œæœ¬åœ°é€»è¾‘ï¼›
> - `source`ï¼šä¼ ç»™åç«¯ / vocabularyStore çš„è¯¾ç¨‹æºæ ‡è¯†ï¼ˆå¦‚ `Thai_1`ï¼‰ï¼›
> - `category`ï¼šå†³å®šæ¨¡å—ç±»å‹ï¼š
>   - `'letter'` â†’ å­—æ¯æ¨¡å—ï¼›
>   - `'word'`   â†’ è¯æ±‡æ¨¡å—ï¼›
>   - `'sentence'` / `'article'` é¢„ç•™ç»™åç»­æ¨¡å—ã€‚

### 2.2 Courses Screenï¼ˆapp/(tabs)/courses.tsxï¼‰

- æ ¸å¿ƒç±»å‹ï¼š

```ts
type CourseItem = {
  id: string;
  source: string;
  title: string;
  description: string;
  level: string;
  image: string;
  category: string;   // 'letter' | 'word' | ...
  lessons: number;
};

type CourseWithImage = CourseItem & {
  imageSource: ImageSourcePropType;
};
```

- è¯¾ç¨‹åˆ—è¡¨æ„é€ ï¼š

```ts
const COURSES: CourseWithImage[] = (
  [
    ...(alphabetCourses as CourseItem[]),
    ...(coursesData as CourseItem[]),
  ]
).map((course) => ({
  ...course,
  imageSource: COURSE_IMAGE_MAP[course.image] || COURSE_IMAGE_MAP.default,
}));
```

- ä¾èµ–çš„ Storeï¼š

```ts
const { currentCourseSource, startCourse } = useVocabularyStore();
const { hasDailyLimit } = useLearningPreferenceStore();
const { userProgress, getUserProgress } = useModuleAccessStore();
```

> æ³¨æ„ï¼šå½“å‰å®ç°ä¸­ **å°šæœªä½¿ç”¨ learningStore**ï¼›  
> åç»­å¯åœ¨æœ¬æ–‡ä»¶ä¸­å¢åŠ å¯¹ `useLearningStore` çš„è°ƒç”¨ï¼ˆè§ç¬¬ 4 èŠ‚ï¼‰ã€‚

### 2.3 AlphabetCourseCardï¼ˆsrc/components/courses/AlphabetCourseCard.tsxï¼‰

- Propsï¼š

```ts
interface AlphabetCourseCardProps {
  course: {
    id: string;
    source: string;
    title: string;
    description: string;
    level: string;
    imageSource: ImageSourcePropType;
    lessons: number;
  };
  isCurrent: boolean;
  progress?: {
    completed: number;
    total: number;
  };
}
```

- è¡Œä¸ºï¼š
  - å±•ç¤ºå°é¢å›¾ã€æ ‡é¢˜ã€ç­‰çº§ã€æè¿°ï¼›
  - è‹¥æœ‰ `progress`ï¼Œæ˜¾ç¤ºè¿›åº¦æ¡ä¸ â€œå·²å®Œæˆ/æ€»æ•°â€ï¼›
  - ç‚¹å‡»ã€Œå¼€å§‹å­¦ä¹  / ç»§ç»­å­¦ä¹ ã€æŒ‰é’®ï¼š

```ts
<Pressable
  style={[styles.startBtn, isCurrent && styles.activeStartBtn]}
  onPress={() => router.push('/alphabet')}
>
  <Text>å¼€å§‹å­¦ä¹  / ç»§ç»­å­¦ä¹ </Text>
</Pressable>
```

> å½“å‰ AlphabetCourseCard åªè´Ÿè´£ **è·³è½¬åˆ° `/alphabet`**ï¼Œ  
> ä¸è´Ÿè´£è®¾ç½®å½“å‰å­—æ¯ Program æˆ–è°ƒç”¨ learningStoreã€‚  
> è¿™éƒ¨åˆ†å°†åœ¨æœªæ¥ç‰ˆæœ¬ä¸­æ¥å…¥ `useLearningStore.setCurrentAlphabetProgram`ã€‚

### 2.4 LearningStoreï¼ˆå½“å‰å®ç° & ç›®æ ‡å·®å¼‚ï¼‰

- ç°æœ‰æ–‡ä»¶ï¼š`src/stores/learningStore.ts`

```ts
interface LearningState {
  currentCourse: Course | null;          // æ—§ï¼šæ•´ä¸ª Course å¯¹è±¡
  progress: LearningProgress | null;     // æ—§ï¼šåŒ…å«å„ç§å†™æ­»å­—æ®µ
  completedContent: string[];

  setCourse: (course: Course) => void;
  updateProgress: (contentType: string, score: number) => void;
  getCompletionRate: () => number;
  resetLearning: () => void;
}
```

> ç°çŠ¶é—®é¢˜ï¼š
> - `setCourse` ä¼šç”Ÿæˆä¸€ä»½å†™æ­»æ•°æ®ï¼ˆuserId='user_1', completedAlphabets=30 ç­‰ï¼‰ï¼Œä¸åæ˜ çœŸå®è¿›åº¦ï¼›
> - é¡¹ç›®ä¸­å‡ ä¹æœªä½¿ç”¨ `setCourse`ï¼Œä»…åœ¨ Profile é¡µè¯» `progress` åšæˆå°±å±•ç¤ºï¼›
> - ä¸ memory-engine / moduleAccessStore çš„çœŸå®è¿›åº¦æœ‰å‰²è£‚ã€‚

**ç›®æ ‡è®¾è®¡ï¼ˆå»ºè®®é‡æ„åå½¢æ€ï¼‰ï¼š**

```ts
interface LearningState {
  // å½“å‰â€œä¸»è¯¾ç¨‹â€ï¼Œç”¨äºé¦–é¡µ / Profile å±•ç¤º
  currentCourseId: string | null;              // å¦‚ 'thai_1'

  // å½“å‰å­—æ¯ Programï¼ˆå¤§è¯¾ç¨‹ï¼‰
  currentAlphabetProgramId: string | null;     // å¦‚ 'alphabet'

  // å…¨å±€å­¦ä¹ ç»Ÿè®¡
  streakDays: number;                          // è¿ç»­æ‰“å¡å¤©æ•°
  totalStudyMinutes: number;                   // æ€»å­¦ä¹ æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
  lastStudyAt: string | null;                  // æœ€è¿‘ä¸€æ¬¡å­¦ä¹ æ—¶é—´ ISO å­—ç¬¦ä¸²

  setCurrentCourse: (courseId: string) => void;
  setCurrentAlphabetProgram: (programId: string) => void;
  registerStudySession: (params: {
    module: 'letter' | 'word' | 'sentence' | 'article';
    minutes: number;
    finishedLessonId?: string;
  }) => void;

  resetLearningDashboard: () => void;
}
```

> é‡æ„åŸåˆ™ï¼š
> - LearningStore ä¸å†ä¿å­˜â€œè™šå‡çš„è¯¦ç»†è¿›åº¦â€ï¼›  
> - åªè´Ÿè´£**â€œå½“å‰åœ¨å­¦å“ªé—¨è¯¾ + å…¨å±€æ—¶é•¿/æ‰“å¡â€**ï¼›  
> - è¯¦ç»†è¿›åº¦ä»¥ `moduleAccessStore.userProgress` + `memory_status` / `user_*_progress` ä¸ºå‡†ã€‚

---

## 3. Courses é¡µé¢é€»è¾‘ä¸ Store äº¤äº’

### 3.1 åˆ†ç±» / æœç´¢ / è¿‡æ»¤

```ts
const CATEGORIES = [
  { id: 'all',    label: 'å…¨éƒ¨', icon: Grid },
  { id: 'letter', label: 'å­—æ¯', icon: Type },
  { id: 'word',   label: 'å•è¯', icon: BookOpen },
];

const [activeCategory, setActiveCategory] = useState('all');
const [searchQuery, setSearchQuery] = useState('');

const filteredCourses = useMemo(() => {
  return COURSES.filter(course => {
    const matchesCategory = activeCategory === 'all' || course.category === activeCategory;
    const matchesSearch =
      course.title.includes(searchQuery) || course.description.includes(searchQuery);
    return matchesCategory && matchesSearch;
  });
}, [activeCategory, searchQuery]);
```

- åˆ†ç±» Chip æ§åˆ¶ `activeCategory`ï¼›
- æœç´¢æ¡†æ§åˆ¶ `searchQuery`ï¼›
- `filteredCourses` æ˜¯ä¹‹åæ¸²æŸ“çš„å”¯ä¸€æ•°æ®æºã€‚

### 3.2 è¯¾ç¨‹è¿›åº¦ï¼ˆgetCourseProgressï¼‰

```ts
const { userProgress, getUserProgress } = useModuleAccessStore();

useEffect(() => {
  if (!userProgress) {
    getUserProgress().catch((err) => console.warn('Failed to fetch user progress', err));
  }
}, [userProgress, getUserProgress]);

const getModuleType = (course: CourseWithImage): ModuleType => {
  switch (course.category) {
    case 'letter':   return 'letter';
    case 'sentence': return 'sentence';
    case 'article':  return 'article';
    default:         return 'word';
  }
};

const getCourseProgress = (course: CourseWithImage) => {
  if (!userProgress) return undefined;
  const moduleType = getModuleType(course);
  if (moduleType === 'letter') {
    return {
      completed: userProgress.letterMasteredCount,
      total: userProgress.letterTotalCount || course.lessons,
    };
  }
  if (moduleType === 'word') {
    return {
      completed: userProgress.wordMasteredCount,
      total: userProgress.wordTotalCount || course.lessons,
    };
  }
  return undefined;
};
```

- è¯¾ç¨‹å¡ç‰‡ä¸Šçš„è¿›åº¦æ¡åªä½¿ç”¨ `userProgress` çš„èšåˆå­—æ®µï¼›
- ä¸å…³å¿ƒ memory-engine å†…éƒ¨çš„ç»†èŠ‚ï¼›  
- å¯¹ sentence/article ç±»å‹å½“å‰è¿”å› `undefined`ï¼Œå³æš‚ä¸æ˜¾ç¤ºè¿›åº¦ã€‚

### 3.3 å•è¯è¯¾ç¨‹ Start/Continue é€»è¾‘

```ts
const { currentCourseSource, startCourse } = useVocabularyStore();
const { hasDailyLimit } = useLearningPreferenceStore();

const getModuleType = (course): ModuleType => { ... }; // å¦‚ä¸Š

const handleStartLearning = (course: CourseWithImage) => {
  return () => {
    const moduleType = getModuleType(course);
    const needsDailySetup = !hasDailyLimit(moduleType);

    // è‹¥å½“å‰å·²ç»åœ¨å­¦åŒä¸€ä¸ª sourceï¼Œç›´æ¥è·³è½¬
    if (currentCourseSource === course.source) {
      router.push({
        pathname: needsDailySetup ? '/learning/setup' : '/learning',
        params: { module: moduleType, source: course.source },
      });
      return;
    }

    // å¦åˆ™å¼¹çª—ç¡®è®¤åˆ‡æ¢è¯¾ç¨‹
    setPendingCourse(course);
    setModalVisible(true);
  };
};

const proceedToCourse = async (course: CourseWithImage) => {
  const moduleType = getModuleType(course);
  const needsDailySetup = !hasDailyLimit(moduleType);

  await startCourse(course.source);  // vocabularyStore å†…éƒ¨ä¼šè®°ä½ currentCourseSource
  setModalVisible(false);
  setPendingCourse(null);

  router.push({
    pathname: needsDailySetup ? '/learning/setup' : '/learning',
    params: { module: moduleType, source: course.source },
  });
};
```

- `CourseCard`ï¼ˆå•è¯è¯¾ç¨‹å¡ç‰‡ï¼‰çš„ `onStart` ä¼šç»‘å®š `handleStartLearning(course)`ï¼›
- `startCourse(source)` æ˜¯è¯æ±‡æ¨¡å—çš„å…¥å£ï¼Œç”¨äºåˆå§‹åŒ–è¯æ±‡å­¦ä¹ ä¸Šä¸‹æ–‡ã€‚

### 3.4 å­—æ¯è¯¾ç¨‹ Start/Continue é€»è¾‘

```tsx
{filteredCourses.map((course) => {
  const isCurrent = currentCourseSource === course.source;
  const moduleType = getModuleType(course);
  const progress = getCourseProgress(course);

  // å­—æ¯è¯¾ç¨‹ï¼šä½¿ç”¨ AlphabetCourseCardï¼Œç›´æ¥è¿›å…¥ /alphabet æµç¨‹
  if (course.category === 'letter') {
    return (
      <AlphabetCourseCard
        key={course.id}
        course={course}
        isCurrent={isCurrent}
        progress={progress}
      />
    );
  }

  // å•è¯è¯¾ç¨‹ï¼šä½¿ç”¨æ ‡å‡† CourseCard
  ...
})}
```

- å½“å‰ `AlphabetCourseCard` ä¸è°ƒç”¨ `startCourse` æˆ– `learningStore`ï¼š
  - å®ƒåªåœ¨ç‚¹å‡»æ—¶ `router.push('/alphabet')`ï¼›
  - å­—æ¯æ¨¡å—å†…éƒ¨æ ¹æ®è‡ªèº« Store + memory-engine å†³å®šä»Šæ—¥è¯¾ç¨‹ã€‚

**å»ºè®®çš„æœªæ¥æ‰©å±•ï¼ˆä¸ LearningStore é›†æˆï¼‰ï¼š**

- åœ¨ `AlphabetCourseCard` çš„ç‚¹å‡» handler ä¸­å¢åŠ ï¼š

```ts
const { setCurrentAlphabetProgram } = useLearningStore();

onPress={() => {
  setCurrentAlphabetProgram(course.id);  // ä¾‹å¦‚ 'alphabet'
  router.push('/alphabet');
}}
```

- è¿™æ ·é¦–é¡µ / Profile å°±å¯ä»¥æ˜¾ç¤ºâ€œå½“å‰å­—æ¯é¡¹ç›®ï¼šæ³°è¯­å­—æ¯è¡¨â€ï¼Œå®ç°è·¨æ¨¡å—å…±äº«ã€‚

---

## 4. LearningStore ä¸å…¶ä»–æ¨¡å—çš„é›†æˆå»ºè®®

> æœ¬èŠ‚æè¿°çš„æ˜¯â€œç›®æ ‡é›†æˆæ–¹å¼â€ï¼Œå…·ä½“å®ç°éœ€ refactor ç°æœ‰ `learningStore`ã€‚

### 4.1 åœ¨ Courses é¡µä¸­è®¾ç½®å½“å‰è¯¾ç¨‹ / å­—æ¯é¡¹ç›®

- å•è¯è¯¾ç¨‹ï¼š

```ts
const { setCurrentCourse } = useLearningStore();

const proceedToCourse = async (course: CourseWithImage) => {
  const moduleType = getModuleType(course);
  const needsDailySetup = !hasDailyLimit(moduleType);

  await startCourse(course.source);
  setCurrentCourse(course.id);          // 'thai_1' / 'thai_2' ...

  router.push({
    pathname: needsDailySetup ? '/learning/setup' : '/learning',
    params: { module: moduleType, source: course.source },
  });
};
```

- å­—æ¯è¯¾ç¨‹ï¼š

```ts
<AlphabetCourseCard
  ...
  onPress={() => {
    setCurrentAlphabetProgram(course.id);  // 'alphabet'
    router.push('/alphabet');
  }}
/>
```

> æ³¨æ„ï¼šAlphabetCourseCard ç›®å‰æ²¡æœ‰ `onPress` propsï¼Œ  
> å¯ä»¥åœ¨é‡æ„æ—¶æ·»åŠ  `onStart`ï¼Œå’Œ `CourseCard` ä¿æŒä¸€è‡´ã€‚

### 4.2 åœ¨å­¦ä¹ ç»“æŸæ—¶æ›´æ–°æ‰“å¡ / æ—¶é•¿

- åœ¨å­—æ¯æ¨¡å— / å•è¯æ¨¡å—çš„â€œå®Œæˆä¸€è¯¾â€é€»è¾‘ä¸­è°ƒç”¨ï¼š

```ts
const { registerStudySession } = useLearningStore();

registerStudySession({
  module: 'letter',        // æˆ– 'word'
  minutes: sessionMinutes, // æœ¬æ¬¡å­¦ä¹ æ—¶é—´
  finishedLessonId: lessonId,
});
```

- `registerStudySession` å†…éƒ¨å¯ä»¥ï¼š
  - æ ¹æ® `lastStudyAt` ä¸å½“å‰æ—¶é—´åˆ¤æ–­æ˜¯å¦è·¨æ—¥ï¼š
    - è‹¥è·¨æ—¥åˆ™ streakDays++ï¼›
  - ç´¯åŠ  `totalStudyMinutes`ï¼›
  - æ›´æ–° `lastStudyAt` ä¸ºå½“å‰æ—¶é—´ã€‚

### 4.3 é¦–é¡µ / Profile ä¸­çš„ä½¿ç”¨æ–¹å¼ï¼ˆç¤ºæ„ï¼‰

- é¦–é¡µ HeroCardï¼š

```ts
const { currentCourseId, currentAlphabetProgramId, streakDays, totalStudyMinutes } = useLearningStore();

// é€šè¿‡ courses.json / alphabetCourses.json æŸ¥æ‰¾å½“å‰è¯¾ç¨‹ä¿¡æ¯ï¼š
const heroCourse = useMemo(
  () => courses.find(c => c.id === currentCourseId),
  [currentCourseId],
);
```

- Profile æˆå°±å‹‹ç« ï¼š
  - ä½¿ç”¨ `streakDays` å†³å®šæ˜¯å¦è§£é”â€œè¿ç»­å­¦ä¹  7 å¤©â€ç­‰å¾½ç« ï¼›
  - ä½¿ç”¨ `totalStudyMinutes` ç»Ÿè®¡æ€»å­¦ä¹ æ—¶é•¿æ®µä½ï¼ˆä¾‹å¦‚ 10 å°æ—¶ã€50 å°æ—¶ç­‰ï¼‰ã€‚

---

## 5. ASCII è°ƒç”¨å›¾æ€»è§ˆ

ä¸ºäº†æ–¹ä¾¿ä»æ•´ä½“ä¸Šç†è§£ Courses + LearningStore ä¸å…¶ä»–æ¨¡å—çš„å…³ç³»ï¼Œæœ¬èŠ‚ç»™å‡ºä¸€å¼ â€œæ¨ªå‘ ASCII è°ƒç”¨å›¾â€ã€‚

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç”¨æˆ·ç‚¹å‡» Courses Tab                                      â”‚
â”‚  app/(tabs)/courses.tsx                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â”‚ æ¸²æŸ“è¯¾ç¨‹åˆ—è¡¨ï¼ˆCOURSES: alphabetCourses + courses.jsonï¼‰
                â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ å­—æ¯è¯¾ç¨‹å¡ AlphabetCourseCard â”‚      â”‚ å•è¯è¯¾ç¨‹å¡ CourseCard      â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚ onPress                         â”‚ onStart
                â”‚                                 â”‚
                â–¼                                 â–¼
      router.push('/alphabet')          handleStartLearning(course)
                                               â”‚
                                               â–¼
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚ vocabularyStore.startCourse(source)â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                               â”‚
                                               â–¼
                          router.push('/learning' or '/learning/setup')

ï¼ˆæœªæ¥é›†æˆ LearningStore åï¼‰

  AlphabetCourseCard.onPress:
    setCurrentAlphabetProgram(course.id)  // è®°å½•å½“å‰å­—æ¯é¡¹ç›®
    router.push('/alphabet')

  proceedToCourseï¼ˆå•è¯ï¼‰:
    startCourse(course.source)
    setCurrentCourse(course.id)           // è®°å½•å½“å‰ä¸»è¯¾ç¨‹
    router.push('/learning...')
```

---

## 6. å®ç°ä¸æ‰©å±•æ³¨æ„äº‹é¡¹

1. **LearningStore åªåšâ€œä»ªè¡¨ç›˜â€ï¼Œä¸åš SRS**  
   - ç»†ç²’åº¦è¿›åº¦å’Œè®°å¿†æ›²çº¿å®Œå…¨äº¤ç»™ `memory-engine` + `alphabetStore` / `vocabularyStore`ï¼›
   - LearningStore ä¸ä¿å­˜â€œå®Œæˆå¤šå°‘å­—æ¯/å•è¯â€è¿™ç§æ˜ç»†ã€‚

2. **Courses é¡µåªè´Ÿè´£å…¥å£ï¼Œä¸åšä¸šåŠ¡å†³ç­–**  
   - è¯¾ç¨‹å¡ç‰‡åªå†³å®šè·³åˆ°å“ªä¸ªæ¨¡å—è·¯ç”±ï¼ˆ/alphabet /learningï¼‰ï¼Œå¹¶è°ƒç”¨å¯¹åº” Store çš„å…¥å£æ–¹æ³•ï¼›
   - å…·ä½“æ¨¡å—å†…éƒ¨å¦‚ä½•å­¦ä¹ ã€å¦‚ä½•è¯„ä¼°ç”±å„è‡ªæ¨¡å—çš„ Spec å†³å®šã€‚

3. **æ‰€æœ‰è¯¾ç¨‹é…ç½®ç»Ÿä¸€é›†ä¸­åœ¨ assets/courses ä¸‹**  
   - æ–°å¢è¯¾ç¨‹æ—¶ï¼Œå¿…é¡»ï¼š
     - åœ¨ `courses.json` æˆ– `alphabetCourses.json` ä¸­æ·»åŠ æ¡ç›®ï¼›
     - ç¡®ä¿ `image` èƒ½åœ¨ `COURSE_IMAGE_MAP` ä¸­æ‰¾åˆ°å¯¹åº”å›¾ç‰‡ï¼›
     - åœ¨æœ¬ Spec æ–‡æ¡£ä¸­å¤‡æ³¨æ–°å¢è¯¾ç¨‹çš„ç”¨é€”ã€‚

4. **æœªæ¥æ‰©å±• AI æ¨¡å—æ—¶ï¼Œä»é€šè¿‡ Courses é¡µå…¥å£**  
   - å¯åœ¨ `courses.json` ä¸­æ–°å¢ `category: 'ai'` çš„è¯¾ç¨‹é¡¹ç›®ï¼›
   - Courses é¡µæ ¹æ® category è·³è½¬åˆ° `/ai/...` è·¯ç”±ï¼Œå¹¶ä½¿ç”¨ç‹¬ç«‹çš„ aiStoreï¼›
   - ä¸æ”¹å˜æ—¢æœ‰ letter / word æµç¨‹ã€‚

---

æœ¬è§„æ ¼æ–‡æ¡£å†»ç»“äº† Courses + LearningStore åœ¨é¡¹ç›®ä¸­çš„è§’è‰²ã€æ•°æ®ç»“æ„ä¸è°ƒç”¨å…³ç³»ã€‚
</file>

<file path="docs/project-freeze/frontend-shell-module-spec.md">
# å‰ç«¯å£³å±‚ä¸å±•ç¤ºæ¨¡å—è§„æ ¼è¯´æ˜ï¼ˆFrontend Shell & Navigation Spec, Freeze V2.0.1ï¼‰

> ç›®å½•ï¼š`docs/project-freeze/frontend-shell-module-spec.md`  
> èŒƒå›´ï¼š`app/(tabs)/*`ã€é€šç”¨å¯¼èˆªã€é¦–é¡µå±•ç¤ºã€ç”¨æˆ·ä¸­å¿ƒä¸è®¾ç½®é¡µé¢ã€‚  
> ç›®æ ‡ï¼šå°†â€œApp å¤–å£³ + å¯¼èˆª + åŸºç¡€è®¾ç½®â€å•ç‹¬è§†ä¸ºä¸€ä¸ªæ¨¡å—ï¼Œå†»ç»“å…¶èŒè´£ä¸è¾¹ç•Œï¼Œé¿å…ä¸å…·ä½“å­¦ä¹ æ¨¡å—ï¼ˆå­—æ¯/è¯æ±‡ï¼‰çš„é€»è¾‘æ··æ·†ã€‚

---

## 1. æ¨¡å—å®šä½ä¸è¾¹ç•Œ

### 1.1 æ¨¡å—èŒè´£

- æä¾›ç»Ÿä¸€çš„ **ä¸»å¯¼èˆªä¸å¤–å£³å¸ƒå±€**ï¼š
  - åº•éƒ¨ Tab å¯¼èˆªï¼šHome / Courses / Profileï¼›
  - åç»­å¯æ‰©å±• Settings / AI ç­‰å…¥å£ï¼Œä½†ä¸åµŒå…¥ä¸šåŠ¡é€»è¾‘ã€‚
- æä¾› **é¦–é¡µæ€»è§ˆï¼ˆHomeï¼‰**ï¼š
  - æ˜¾ç¤ºå½“å‰ä¸»è¯¾ç¨‹ã€ä»Šæ—¥è¿›åº¦ç™¾åˆ†æ¯”ã€å­¦ä¹ æ°›å›´èƒŒæ™¯ä¸åŠ¨æ•ˆï¼›
  - æä¾›â€œç»§ç»­å­¦ä¹ â€å…¥å£ï¼ˆè·³è½¬åˆ° `/learning` æˆ– `/alphabet`ï¼‰ã€‚
- æä¾› **ç”¨æˆ·ä¸­å¿ƒï¼ˆProfileï¼‰**ï¼š
  - å±•ç¤ºç”¨æˆ·åŸºæœ¬ä¿¡æ¯ä¸æˆå°±å¾½ç« ï¼›
  - é›†ä¸­æ”¾ç½® App çº§è®¾ç½®é¡¹ï¼ˆè¯­è¨€ã€æ¯æ—¥å­¦ä¹ é‡ã€TTS é€‰æ‹©ç­‰ï¼‰ï¼›
  - æä¾›ç™»å‡ºæŒ‰é’®ã€‚
- ä¸å…¶ä»–æ¨¡å—çš„å…³ç³»ï¼š
  - åªä¾èµ–å®ƒä»¬æš´éœ²çš„â€œæ±‡æ€»ä¿¡æ¯â€ï¼ˆå¦‚ `userProgress`ã€`learningStore.progress`ï¼‰ï¼Œä¸ç›´æ¥ç®¡ç†å­¦ä¹ é˜Ÿåˆ—ã€SRS æˆ–è¯¾ç¨‹å†…éƒ¨çŠ¶æ€ã€‚

### 1.2 æ¨¡å—è¾¹ç•Œï¼ˆä¸åšä»€ä¹ˆï¼‰

- ä¸è´Ÿè´£ï¼š
  - å­—æ¯/è¯æ±‡/å¥å­å…·ä½“å­¦ä¹ æµç¨‹ï¼›  
  - è®°å¿†å¼•æ“è°ƒç”¨ï¼ˆ`getTodayMemories` / `submitMemoryResult` ç­‰ï¼‰ï¼›  
  - è¯¾ç¨‹è§£é”é€»è¾‘ï¼ˆç”± `memory-engine` + `moduleAccessStore` ç®¡ç†ï¼‰ã€‚
- ä¸ç›´æ¥è¯»å†™æ•°æ®åº“ï¼Œåªé€šè¿‡å·²æœ‰ Store / äº‘å‡½æ•°æ¥å£è·å–ç»Ÿè®¡ä¿¡æ¯ã€‚

---

## 2. ç›¸å…³ä»£ç æ–‡ä»¶æ€»è§ˆ

### 2.1 è·¯ç”±å±‚ï¼ˆapp/(tabs)ï¼‰

- `app/(tabs)/_layout.tsx`
  - å®šä¹‰ Tab å¯¼èˆªç»“æ„ï¼ŒåŒ…å«ï¼š
    - `index`ï¼ˆHomeï¼‰ã€`courses`ï¼ˆè¯¾ç¨‹ï¼‰ã€`profile`ï¼ˆç”¨æˆ·ä¸­å¿ƒï¼‰ã€‚  
  - è´Ÿè´£è®¾ç½® Tab å›¾æ ‡ã€æ ‡é¢˜ä¸é…è‰²ã€‚

- `app/(tabs)/index.tsx`ï¼ˆHomeScreenï¼‰
  - èŒè´£ï¼š
    - å±•ç¤ºâ€œä»Šæ—¥è¿›åº¦ + å½“å‰è¯¾ç¨‹â€çš„ Hero å¡ç‰‡ï¼›  
    - å±•ç¤ºæµ®åŠ¨å¤ä¹ æ°”æ³¡ï¼ˆç›®å‰åŸºäº `MOCK_REVIEWS`ï¼‰ï¼›  
    - å±•ç¤ºå­¦ä¹ ç»Ÿè®¡ï¼ˆè¿ç»­å¤©æ•° / æœ¬å‘¨å­¦ä¹ æ—¶é•¿ï¼‰å’Œè¿‘æœŸæˆå°±ã€‚
  - ä¾èµ–ï¼š
    - `useUserStore`ï¼šå½“å‰ç™»å½•ç”¨æˆ·æ˜µç§°ï¼›  
    - `useModuleAccessStore`ï¼š`userProgress`ï¼ˆletterProgress/wordProgress/sentenceProgress/articleProgressï¼‰ï¼›  
    - `FloatingBubbles` / `ThaiPatternBackground` ç­‰ UI ç»„ä»¶ã€‚
  - å½“å‰å®ç°ä¸­çš„ `getCurrentCourse()`ï¼š
    - å½“ `letterProgress < 0.8` â†’ æ¨è Alphabet æ¨¡å—ï¼›  
    - å¦åˆ™æŒ‰ `wordProgress` / `sentenceProgress` / `articleProgress` ä¾æ¬¡æ¨èåç»­æ¨¡å—ï¼›  
    - ç‚¹å‡» Hero å¡ç‰‡æ—¶ï¼Œæ ¹æ®å½“å‰æ¨èæ¨¡å—è·³è½¬åˆ° `/learning` å¹¶é™„å¸¦ `module` å‚æ•°ï¼ˆå­—æ¯æˆ–å•è¯ï¼‰ã€‚

- `app/(tabs)/courses.tsx`
  - å·²åœ¨ `courses-and-learningstore-spec.md` ä¸­è¯¦è¿°ï¼Œæ­¤å¤„ä½œä¸ºå£³å±‚çš„ä¸€éƒ¨åˆ†è¢«å¼•ç”¨ã€‚  

- `app/(tabs)/profile.tsx`ï¼ˆProfileScreenï¼‰
  - èŒè´£ï¼š
    - å±•ç¤ºç”¨æˆ·å¤´åƒ/æ˜µç§°ï¼ˆå½“å‰å¤´åƒä¸ºå ä½ç¬¦ï¼‰ï¼›  
    - å±•ç¤ºæˆå°±å¾½ç« åˆ—è¡¨ï¼ˆå¦‚è¿ç»­æ‰“å¡ 7 å¤©ç­‰ï¼‰ï¼›  
    - æä¾› App çº§è®¾ç½®å…¥å£ï¼›  
    - æä¾›æ³¨é”€æŒ‰é’®ã€‚
  - ä¾èµ–ï¼š
    - `useUserStore`ï¼šè·å–ç”¨æˆ·ä¿¡æ¯ä¸ `logout()`ï¼›  
    - `useLearningStore`ï¼šè¯»å– streakDays ç­‰å­¦ä¹ ç»Ÿè®¡ï¼ˆå½“å‰ä¸º demo æ•°æ®ï¼‰ï¼›  
    - `useModuleAccessStore`ï¼šè¯»å– `userProgress.dailyLimit`ï¼›  
    - `LanguageSwitcher`ï¼šåˆ‡æ¢ä¸­/æ³°/è‹±ç­‰ UI æ–‡æ¡ˆè¯­è¨€ã€‚

---

## 3. å½“å‰å·²å®ç°çš„å‰ç«¯å±•ç¤ºåŠŸèƒ½

### 3.1 HomeScreen åŠŸèƒ½ç‚¹

- é¡¶éƒ¨é—®å€™åŒºï¼š
  - æ˜¾ç¤ºâ€œàºªàº°àºšàº²àºàº”àºµ, {displayName}`â€é£æ ¼é—®å€™è¯­ï¼›
  - æ˜¾ç¤º `todayProgress` æ–‡æ¡ˆ + å½“å‰æ¨èè¯¾ç¨‹çš„å®Œæˆç™¾åˆ†æ¯”ã€‚
- æµ®åŠ¨å¤ä¹ æ°”æ³¡ï¼š
  - `FloatingBubbles` ç»„ä»¶åŸºäº `MOCK_REVIEWS` æ˜¾ç¤ºå­—æ¯å¡ç‰‡ï¼ˆå­—ç¬¦ +ç±»å‹ + dueInï¼‰ï¼›  
  - ç‚¹å‡»ä»»æ„æ°”æ³¡ â†’ æ‰“å¼€ `/review-modal`ï¼ˆæš‚æœªä¸è®°å¿†å¼•æ“å®Œå…¨æ¥å…¥ï¼‰ã€‚
- Hero è¯¾ç¨‹å¡ï¼š
  - å±•ç¤ºå½“å‰é˜¶æ®µè¯¾ç¨‹åç§°ï¼ˆå­—æ¯/å•è¯/å¥å­/æ–‡ç« ï¼‰ã€è¯¾ç¨‹ç­‰çº§æ ‡ç­¾åŠæ³°æ–‡çŸ­è¯­ï¼›  
  - æ˜¾ç¤ºâ€œç»§ç»­å­¦ä¹ â€å¤§æŒ‰é’®ï¼ˆå¸¦ Play iconï¼‰ï¼Œç‚¹å‡»åï¼š
    - è‹¥ `currentCourse.module === 'letter'` â†’ `router.push('/learning?module=letter')`ï¼›  
    - è‹¥ä¸ºè¯æ±‡/å¥å­/æ–‡ç«  â†’ `router.push('/learning')`ï¼ˆç›®å‰ä¸ºå ä½è¡Œä¸ºï¼‰ã€‚
- å­¦ä¹ ç»Ÿè®¡å¡ç‰‡ï¼š
  - æ˜¾ç¤ºå‡æ•°æ®ï¼šè¿ç»­å­¦ä¹ å¤©æ•°ï¼ˆ12ï¼‰ä¸æœ¬å‘¨å­¦ä¹ æ—¶é•¿ï¼ˆ4.5 å°æ—¶ï¼‰ï¼›  
  - åç»­å°†ä½¿ç”¨ `learningStore` çš„çœŸå®ç»Ÿè®¡å­—æ®µæ›¿ä»£ã€‚
- æœ€è¿‘æˆå°±åŒºåŸŸï¼š
  - å±•ç¤ºè‹¥å¹²â€œæŒæ¡å­—æ¯/å•è¯â€çš„å¡ç‰‡ï¼Œå ä½ UIã€‚

### 3.2 ProfileScreen åŠŸèƒ½ç‚¹

- ä¸ªäººä¿¡æ¯å¡ï¼š
  - æ˜¾ç¤ºå¤´åƒï¼ˆå½“å‰ä¸ºå­—æ¯ Lï¼‰ã€ç”¨æˆ·åã€ç®€ä»‹æ–‡æ¡ˆã€‚
- æˆå°±å¾½ç« åˆ—è¡¨ï¼š
  - é€šè¿‡æœ¬åœ° `achievements` æ•°ç»„é©±åŠ¨ï¼ŒåŒ…æ‹¬ï¼š
    - è¿ç»­æ‰“å¡ 7 å¤©ï¼ˆæ ¹æ® `learningStore.progress.streakDays` åˆ¤æ–­æ˜¯å¦è§£é”ï¼‰ï¼›  
    - å…¶ä»–æˆå°±å ä½ï¼ˆMasterã€Vocab100 ç­‰ï¼‰ã€‚
- è®¾ç½®å¡ç‰‡ï¼š
  - æ¯æ—¥æé†’å¼€å…³ï¼ˆæœ¬åœ° `dailyReminder` çŠ¶æ€ï¼Œæš‚æœªæ¥å…¥é€šçŸ¥æœåŠ¡ï¼‰ï¼›  
  - æ¯æ—¥å­¦ä¹ æ•°é‡è®¾ç½®ï¼š
    - å¼¹å‡º Alert ä¾›ç”¨æˆ·é€‰æ‹© 10/20/50 ä¸ªï¼›
    - æœ¬åœ°è°ƒç”¨ `useModuleAccessStore.setState` æ›´æ–° `userProgress.dailyLimit`ï¼ˆå‰ç«¯æ¨¡æ‹Ÿï¼‰ï¼›
  - TTS å¼•æ“é€‰æ‹©ï¼ˆç›®å‰å›ºå®šä¸º `Tencent TTS` æ–‡æ¡ˆï¼Œå°šæœªè·³è½¬åˆ°è¯¦æƒ…é¡µï¼‰ï¼›  
  - è¯­è¨€åˆ‡æ¢ï¼šåµŒå…¥ `LanguageSwitcher variant="full"` ç»„ä»¶ã€‚
- æ³¨é”€æŒ‰é’®ï¼š
  - è°ƒç”¨ `logout()` å¹¶ `router.replace('/(auth)/login')`ã€‚

---

## 4. æœªæ¥è§„åˆ’çš„å¤–å£³ä¸è®¾ç½®åŠŸèƒ½ï¼ˆä¸å½±å“å½“å‰å†»ç»“æ¨¡å—ï¼‰

> æœ¬èŠ‚ä»…åš**æ–¹å‘æ€§è§„åˆ’**ï¼Œå®é™…å¼€å‘å‰éœ€åœ¨æœ¬ spec ä¸­è¡¥å……å¯¹åº”å­—æ®µä¸è·¯ç”±ï¼Œå¹¶åœ¨é¡¹ç›®æ€»çº²ä¸­ç™»è®°ä¸ºæ–°ä»»åŠ¡ã€‚

### 4.1 å¯¼èˆªå±‚æ‰©å±•

- å¢åŠ  Settings ç‹¬ç«‹ Tab æˆ–å­è·¯ç”±ï¼š
  - ä¾‹å¦‚ï¼š`app/(tabs)/settings.tsx` æˆ– `app/settings/index.tsx`ï¼›  
  - Profile åªå±•ç¤ºç”¨æˆ·ä¿¡æ¯å’Œæˆå°±ï¼Œæ‰€æœ‰è®¾ç½®é¡¹é›†ä¸­åˆ° Settings é¡µé¢ã€‚
- åœ¨ HomeScreen ä¸­å¢åŠ â€œå¿«é€Ÿå…¥å£åŒºåŸŸâ€ï¼š
  - ä»Šæ—¥ä»»åŠ¡ï¼ˆå­—æ¯/å•è¯å¤ä¹ æ•°é‡ï¼‰ï¼›  
  - AI å‘éŸ³ç»ƒä¹ å…¥å£ï¼›  
  - å­—æ¯å¤ä¹ ä¸­å¿ƒ/è¯æ±‡å¤ä¹ ä¸­å¿ƒå…¥å£ã€‚

### 4.2 è®¾ç½®é¡¹æ‰©å±•

- å­¦ä¹ åå¥½ï¼š
  - æ¯æ—¥å­¦ä¹ ç›®æ ‡ï¼ˆå­—æ¯/å•è¯åˆ†å¼€è®¾ç½®ï¼‰ï¼›  
  - å¤ä¹ ä¼˜å…ˆçº§ï¼ˆæ˜¨æ—¥å¤ä¹ ä¼˜å…ˆ vs æ–°è¯ä¼˜å…ˆç­‰ï¼‰ã€‚
- éŸ³é¢‘ä¸ UIï¼š
  - TTS å¼•æ“é€‰æ‹©ï¼ˆTencent / CloudBase / æœ¬åœ°éŸ³é¢‘ä¼˜å…ˆçº§ï¼‰ï¼›  
  - è‡ªåŠ¨æ’­æ”¾é€‰é¡¹ï¼ˆè¿›å…¥é¢˜ç›®æ—¶æ˜¯å¦è‡ªåŠ¨æ’­æ”¾éŸ³é¢‘ï¼‰ï¼›  
  - ä¸»é¢˜æ¨¡å¼ï¼ˆæµ…è‰² / æ·±è‰²ï¼‰ã€‚
- é€šçŸ¥ä¸æé†’ï¼š
  - å­¦ä¹ æé†’æ—¶é—´ / é¢‘ç‡ï¼›  
  - è¿ç»­æ‰“å¡æé†’ã€‚

### 4.3 ç”¨æˆ·ä¸­å¿ƒæ‰©å±•

- å®Œæ•´å­¦ä¹ ç»Ÿè®¡é¡µï¼š
  - æ€»å­¦ä¹ æ—¶é•¿ã€å­¦ä¹ å¤©æ•°ã€å„æ¨¡å—æŒæ¡åº¦ç»Ÿè®¡ï¼ˆä» `user_progress` / `user_alphabet_progress` / `user_vocabulary_progress` æ¨å¯¼ï¼‰ï¼›  
  - é”™è¯¯æœ€å¤šçš„å­—æ¯/å•è¯ Top Nï¼Œç”¨ä½œ AI æ¨¡å—è¾“å…¥ã€‚  
- æˆå°±ç³»ç»Ÿï¼š
  - æŒ‰å­¦ä¹ è¡Œä¸ºï¼ˆå­—æ¯å®Œæˆã€è¯æ±‡æ•°ã€æ‰“å¡è¿ç»­å¤©æ•°ç­‰ï¼‰è‡ªåŠ¨è§£é”å¾½ç« ï¼›  
  - æˆå°±è¯¦æƒ…é¡µå±•ç¤ºè§£é”æ¡ä»¶ä¸è¾¾æˆæ—¥æœŸã€‚

---

## 5. å®æ–½æ³¨æ„äº‹é¡¹

1. å£³å±‚ç»„ä»¶ï¼ˆHome / Profile / Settingsï¼‰ä¸å¾—ç›´æ¥è°ƒç”¨è®°å¿†å¼•æ“ï¼Œåªèƒ½é€šè¿‡ Storeï¼ˆ`moduleAccessStore` / `learningStore` / `learningPreferenceStore` / `userStore`ï¼‰è¯»å–ç»Ÿè®¡æˆ–åŸºç¡€è®¾ç½®ã€‚  
2. æ‰€æœ‰æ–°å¢å…¨å±€è®¾ç½®é¡¹ï¼Œéƒ½éœ€è¦ï¼š
   - åœ¨æœ¬ spec ä¸­ç™»è®°ï¼›
   - åœ¨ç›¸åº” Store ä¸­å¢åŠ å­—æ®µä¸æ¥å£ï¼›
   - åœ¨å¿…è¦æ—¶æ‰©å±•åç«¯æ¥å£ï¼ˆä¾‹å¦‚å­˜å‚¨æ¯æ—¥å­¦ä¹ ç›®æ ‡ï¼‰ï¼Œå¹¶åœ¨ `backend-memory-engine-spec.md` æˆ–ç›¸å…³åç«¯ Spec ä¸­è¯´æ˜ã€‚  
3. å¯¼èˆªç»“æ„å˜æ›´ï¼ˆæ–°å¢ Tabã€è°ƒæ•´è·¯ç”±ï¼‰å¿…é¡»åŒæ­¥æ›´æ–°ï¼š
   - `app/(tabs)/_layout.tsx` ä»£ç ï¼›  
   - æœ¬ spec è·¯ç”±å°èŠ‚ï¼›  
   - `PROJECT_OVERVIEW_SPEC.md` ä¸­çš„æ¨¡å—è¡¨ä¸ä»»åŠ¡åˆ—è¡¨ã€‚

æœ¬è§„æ ¼å°†å‰ç«¯å£³å±‚çš„èŒè´£ä¸è¾¹ç•Œä»å­—æ¯/è¯æ±‡å­¦ä¹ é€»è¾‘ä¸­æŠ½ç¦»å‡ºæ¥ï¼Œä¿è¯å¯¼èˆªã€ç”¨æˆ·ä¸­å¿ƒä¸è®¾ç½®ç›¸å…³æ”¹åŠ¨ä¸ä¼šæ„å¤–å½±å“æ ¸å¿ƒå­¦ä¹ æ¨¡å—ã€‚***
</file>

<file path="docs/PRONUNCIATION_RESTORATION_FROZEN.md">
# å†»ç»“æ–‡æ¡£ï½œå‘éŸ³è¿˜åŸï¼ˆPronunciation Restorationï¼‰åŠŸèƒ½è§„èŒƒ v1.0

ï¼ˆæœ¬æ–‡ä»¶æ‰¿æ¥å‰æ–‡è®¾è®¡èƒŒæ™¯ã€åŠŸèƒ½è¾¹ç•Œã€æµæ°´çº¿ä¸å¯¹æ¥è§„èŒƒï¼‰

---

## 9. å…¸å‹ç¤ºä¾‹ï¼ˆå†»ç»“å‚è€ƒï¼‰

> ä»¥ä¸‹ç¤ºä¾‹ç”¨äº**è¡Œä¸ºå†»ç»“**ï¼Œä¸æ˜¯æ•™å­¦ç¤ºä¾‹  
> åç»­å®ç°å¿…é¡»ä¸è¿™äº›ç¤ºä¾‹åœ¨è§„åˆ™ç‰ˆæœ¬ä¸€è‡´çš„æƒ…å†µä¸‹è¾“å‡ºç›¸åŒç»“æœ

### 9.1 å•éŸ³èŠ‚

| è¾“å…¥ | è¾“å‡ºï¼ˆThaiï¼‰ | è¯´æ˜ |
|----|----|----|
| à¸à¸² | à¸à¸² | ç¬¬ä¸€è°ƒï¼Œä¸æ ‡ |
| à¸ˆà¸° | à¸ˆà¹ˆà¸° | å®é™…ä¸ºç¬¬äºŒè°ƒ |
| à¹‚à¸•à¹Šà¸° | à¹‚à¸•à¹Šà¸° | ç¬¬å››è°ƒï¼Œä¿ç•™ |
| à¹ƒà¸«à¸¡à¹ˆ | à¹ƒà¸«à¸¡à¹ˆ | æ‹¼å†™æœ‰ à¹ˆï¼Œä½†å®é™…ç¬¬ä¸€è°ƒï¼Œä¸æ ‡ |

### 9.2 å¤šéŸ³èŠ‚

| è¾“å…¥ | è¾“å‡ºï¼ˆThaiï¼‰ |
|----|----|
| à¸ à¸²à¸©à¸²à¹„à¸—à¸¢ | à¸à¸² à¸ªà¸² à¹„à¸— |
| à¸›à¸£à¸°à¹€à¸—à¸¨ | à¸›à¸ºà¸£à¸° à¹€à¸—à¸” |
| à¹€à¸‚à¹‰à¸²à¹ƒà¸ˆ | à¹€à¸‚à¹‰à¸² à¹ƒà¸ˆ |
| à¸—à¸£à¸²à¸š | à¸‹à¹‰à¸²à¸š |

### 9.3 å«å‡å¤è¾…éŸ³

| è¾“å…¥ | è¾“å‡ºï¼ˆThaiï¼‰ |
|----|----|
| à¸—à¸£à¸²à¸¢ | à¸‹à¹‰à¸²à¸¢ |
| à¸—à¸£à¸²à¸š | à¸‹à¹‰à¸²à¸š |

---

## 10. å¼‚å¸¸ä¸ä¾‹å¤–ç­–ç•¥ï¼ˆå†»ç»“ï¼‰

### 10.1 åŸåˆ™
- **è§„åˆ™ä¼˜å…ˆï¼Œè¯è¡¨å…œåº•**
- ä»»ä½•æ— æ³•ä»…é€šè¿‡ `pron_thai.json` å†³å®šçš„è¡Œä¸ºï¼š
  - å¿…é¡»è¿›å…¥ exception è¯è¡¨
  - ä¸å…è®¸åœ¨ä»£ç ä¸­ hardcode è¯­è¨€ç›´è§‰

### 10.2 Exception è¯è¡¨å»ºè®®
- æ–‡ä»¶å½¢å¼ï¼š`pron_thai.exceptions.jsonl`
- æ¯è¡Œä¸€ä¸ªè¯æ¡ï¼ŒåŒ…å«ï¼š
  - word
  - syllable_overrideï¼ˆå¯é€‰ï¼‰
  - tone_overrideï¼ˆå¯é€‰ï¼‰
  - noteï¼ˆä»…è¯´æ˜ï¼Œä¸å‚ä¸æ‰§è¡Œï¼‰

---

## 11. å˜æ›´ä¸æ‰©å±•çº¦æŸï¼ˆéå¸¸é‡è¦ï¼‰

### 11.1 å…è®¸çš„å˜æ›´
- å¢åŠ  exception è¯æ¡
- å¢åŠ æµ‹è¯•ç”¨ä¾‹
- ä¼˜åŒ–æ€§èƒ½ï¼ˆä¸æ”¹å˜ç»“æœï¼‰

### 11.2 ç¦æ­¢çš„å˜æ›´
- ä¿®æ”¹æ—¢æœ‰è§„åˆ™è¯­ä¹‰
- å¼•å…¥â€œè¯­è¨€ç›´è§‰â€è§„åˆ™
- ä¸ºæŸäº›è¯â€œä¸´æ—¶ç‰¹æ®Šå¤„ç†â€è€Œä¸å…¥è¯è¡¨
- æ”¹å˜å£°è°ƒæ˜¾å¼ç­–ç•¥ï¼ˆT1 ä¸æ ‡ï¼‰

---

## 12. å†»ç»“å£°æ˜ï¼ˆFinalï¼‰

è‡ªæœ¬æ–‡ä»¶å‘å¸ƒä¹‹æ—¥èµ·ï¼š

- **â€œå‘éŸ³è¿˜åŸï¼ˆPronunciation Restorationï¼‰â€åŠŸèƒ½çš„è®¾è®¡ç›®æ ‡ã€è¾¹ç•Œã€è¾“å‡ºå½¢å¼ã€è§„åˆ™æ¥æºä¸æ‰§è¡Œæµæ°´çº¿å…¨éƒ¨å†»ç»“**
- åç»­å¼€å‘å¿…é¡»ï¼š
  - ä»¥ `pron_thai.json` ä¸ºå”¯ä¸€è§„åˆ™æº
  - éµå¾ªé¡¹ç›®æ—¢æœ‰è„šæ‰‹æ¶ä¸æ¨¡å—åˆ†å±‚
  - ä¸å°†è¯¥åŠŸèƒ½å®ç°ä¸ºå­¤ç«‹ demo
- è‹¥æœªæ¥éœ€è¦æ‰©å±•ï¼ˆå¦‚ IPAã€æ–¹è¨€ã€TTSï¼‰ï¼Œå¿…é¡»ï¼š
  - æ–°å¢ç‹¬ç«‹æ¨¡å—
  - ä¸ç ´åæœ¬åŠŸèƒ½çš„æ—¢æœ‰è¡Œä¸º

> æœ¬å†»ç»“æ–‡æ¡£çš„ç›®æ ‡ä¸æ˜¯â€œåšå¾—æœ€å°‘â€ï¼Œ  
> è€Œæ˜¯ **ä¿è¯ç³»ç»Ÿåœ¨æ•´ä¸ªç”Ÿå‘½å‘¨æœŸå†…ï¼š  
> å¯æ§ã€å¯è¿½æº¯ã€å¯æŒç»­ã€ä¸å¤±çœŸã€‚**
</file>

<file path="docs/PRONUNCIATION_RESTORATION_MODULE_SPEC_FROZEN_v1.0.md">
# å†»ç»“è®¾è®¡æ–‡æ¡£ï½œå‘éŸ³è¿˜åŸæ¨¡å—ï¼ˆPronunciation Restoration Moduleï¼‰v1.0

> çŠ¶æ€ï¼š**å†»ç»“ï¼ˆFrozenï¼‰**  
> æ¨¡å—åï¼š`pronunciation-restoration`  
> å•ä¸€äº‹å®æºï¼ˆSSoTï¼‰ï¼š`pron_thai.json`  
> é€‚ç”¨èŒƒå›´ï¼šThaiLearnAppï¼ˆå‰ç«¯ / åç«¯ / AIï¼‰  

---

## 0. æ¨¡å—å®šä½ï¼ˆæ˜¯ä»€ä¹ˆï¼‰

æœ¬æ¨¡å—ä¸æ˜¯æ•™å­¦è§„åˆ™å±•ç¤ºå™¨ï¼Œè€Œæ˜¯**å‘éŸ³ç»“æœè¿˜åŸæ¨¡å—**ã€‚

å®ƒçš„èŒè´£æ˜¯ï¼š  
> å°†ä»»æ„æ³°è¯­æ‹¼å†™ï¼ˆå•è¯æˆ–çŸ­è¯­ï¼‰è½¬æ¢ä¸º  
> **â€œæ— éœ€ç”¨æˆ·æ€è€ƒä»»ä½•æ‹¼è¯»è§„åˆ™å³å¯ç›´æ¥æœ—è¯»çš„å‘éŸ³æ€è¡¨ç¤ºâ€**ã€‚

---

## 1. è¾“å‡ºæ•ˆæœç›®æ ‡ï¼ˆå¿…é¡»è¾¾åˆ°ï¼‰

### 1.1 ç”¨æˆ·ä¾§
- ç”¨æˆ·çœ‹åˆ°è¾“å‡ºå³å¯è¯»
- ä¸éœ€è¦çŸ¥é“ï¼š
  - ä¸­ / é«˜ / ä½è¾…éŸ³
  - æ¸…å°¾ / æµŠå°¾
  - æ ‡ 2 è¯» 3ã€æ ‡ 3 è¯» 4 ç­‰è§„åˆ™
- ç¬¬ä¸€è°ƒæ°¸è¿œä¸æ ‡ï¼Œå…¶ä½™ 4 è°ƒåªæ ‡**å®é™…å£°è°ƒ**

### 1.2 å·¥ç¨‹ä¾§
- è¾“å‡ºç»“æ„åŒ–ï¼Œå¯è¢« UI / åç«¯ / AI æ¶ˆè´¹
- åŒä¸€è§„åˆ™ç‰ˆæœ¬ä¸‹ç»“æœç¡®å®š

---

## 2. æœ¬æ¨¡å—å¼•å…¥å¹¶å†»ç»“çš„æ–°åŸåˆ™

### 2.1 å£°è°ƒç¬¦å·é‡å»ºåŸåˆ™
- æ°¸è¿œä¸ç›´æ¥å¤ç”¨åŸæ‹¼å†™ä¸­çš„å£°è°ƒç¬¦å·
- å¿…é¡»ï¼š
  1. ç§»é™¤å†å²å£°è°ƒç¬¦å·
  2. æ¨å¯¼å®é™…å£°è°ƒ
  3. æŒ‰å®é™…å£°è°ƒé‡å»ºç¬¦å·ï¼ˆT1 ä¸æ ‡ï¼‰

### 2.2 ç½—é©¬éŸ³ä»…ä¸ºæ¸²æŸ“å±‚
- ä¸å‚ä¸è§„åˆ™æ¨å¯¼
- ä»…åŸºäºå‘éŸ³æ€ç»“æœç”Ÿæˆ
- å¿…é¡»æ˜¾å¼æ ‡å£°è°ƒï¼ˆå»ºè®®æ•°å­—ï¼‰

### 2.3 éŸ³èŠ‚è¾¹ç•Œå³è¾“å‡ºå¥‘çº¦
- è¾“å‡ºæ³°æ–‡å¿…é¡»ä»¥ç©ºæ ¼åˆ†éš”éŸ³èŠ‚
- ç½—é©¬éŸ³ï¼ˆè‹¥æœ‰ï¼‰åŒæ ·æŒ‰éŸ³èŠ‚å¯¹é½

---

## 3. å•ä¸€äº‹å®æºï¼ˆSSoTï¼‰

- æ‰€æœ‰è§„åˆ™æ¥è‡ª `pron_thai.json`
- ä¸å…è®¸è¯­è¨€ç›´è§‰ç¡¬ç¼–ç 
- å…è®¸ç”Ÿæˆè¿è¡Œæ—¶è£å‰ªç‰ˆï¼Œä½†å¿…é¡»å¯è¿½æº¯

---

## 4. è¾“å…¥ / è¾“å‡ºå¥‘çº¦

### 4.1 è¾“å…¥
- `inputText: string`

### 4.2 è¾“å‡ºï¼ˆå»ºè®®å†»ç»“ï¼‰

```ts
type SyllableResult = {
  original: string;
  surface_base: string;
  tone: "T1" | "T2" | "T3" | "T4" | "T5";
  surface: string;
  roman?: string;
};

type PronRestoreResult = {
  input: string;
  syllables: SyllableResult[];
  output_thai: string;
  output_roman?: string;
};
```

---

## 5. æµæ°´çº¿ï¼ˆå†»ç»“ï¼‰

1. Normalize
2. Tokenize
3. Syllable Segmentation
4. Orthography Rewrite + å»å†å²å£°è°ƒ
5. Feature Extraction
6. Tone Resolution
7. Tone Explicit Render
8. Romanization Renderï¼ˆå¯é€‰ï¼‰
9. Join

---

## 6. å®ç°å»ºè®®ä¼ªä»£ç 

```ts
function restorePronunciation(input: string, opts): PronRestoreResult {
  const syllables = segment(input);
  const results = [];

  for (const s of syllables) {
    const base = rewriteAndStripTone(s);
    const tone = resolveTone(base);
    const surface = renderTone(base, tone);
    const roman = opts.roman ? renderRoman(base, tone) : undefined;

    results.push({ original: s, surface_base: base, tone, surface, roman });
  }

  return {
    input,
    syllables: results,
    output_thai: results.map(r => r.surface).join(" "),
    output_roman: opts.roman ? results.map(r => r.roman).join(" ") : undefined
  };
}
```

---

## 7. ç³»ç»Ÿå¯¹æ¥ï¼ˆé Demoï¼‰

- å‰ç«¯ï¼šè¯å¡ / å­¦ä¹  / å¤ä¹ ç»Ÿä¸€è°ƒç”¨
- åç«¯ï¼šè®°å½•ç»“æœä¸è§„åˆ™ç‰ˆæœ¬
- AIï¼šéŸ³èŠ‚ + å£°è°ƒä½œä¸ºè¯„æµ‹ç›®æ ‡

---

## 8. æµ‹è¯•ä¸éªŒæ”¶

- åŒä¸€è¾“å…¥ + åŒä¸€è§„åˆ™ç‰ˆæœ¬ â†’ å¿…é¡»è¾“å‡ºä¸€è‡´
- ä¸å‡ºç°å£°è°ƒè¯¯å¯¼
- ç”¨æˆ·ä»…æŒ‰è¾“å‡ºå³å¯è¯»

---

## 9. å†»ç»“å£°æ˜

æœ¬æ¨¡å—è®¾è®¡ã€åŸåˆ™ã€è¾“å‡ºå½¢å¼ä¸æµæ°´çº¿å…¨éƒ¨å†»ç»“ã€‚  
ä»»ä½•æ‰©å±•å¿…é¡»ä»¥æ–°æ¨¡å—å½¢å¼è¿›è¡Œï¼Œä¸ç ´åæœ¬æ¨¡å—è¡Œä¸ºã€‚
</file>

<file path="scripts/getAudioJsonFromWeb.js">
(function() {
    // 1. åŠ è½½ JSZip
    var script = document.createElement('script');
    script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
    document.head.appendChild(script);

    setTimeout(() => {
        if (typeof JSZip === 'undefined') return alert("åº“åŠ è½½å¤±è´¥");
        console.log("%cğŸš€ å¼€å§‹æŠ“å–å…¨é‡éŸ³é¢‘æ•°æ®...", "color: blue; font-weight: bold;");
        startScraping();
    }, 3000);

    async function startScraping() {
        const BASE_URL = "https://cdn.langeek.cn/thaik/corpus/thai/rv/BaseThai_4";
        const CATALOG_URL = `${BASE_URL}/p/O5G1e3lD7B0I2o6C9f8A4L1`;

        // A. è·å–ç›®å½•
        const catalogResp = await fetch(CATALOG_URL);
        const catalogData = await catalogResp.json();
        const uniqueLessons = [...new Set(catalogData.words.map(w => w.lessonNumber).filter(l => l))];
        uniqueLessons.sort((a, b) => parseFloat(a) - parseFloat(b));

        const zip = new JSZip();
        const folder = zip.folder("Audio_JSONL_Full");
        let count = 0;

        // B. éå†è¯¾ç¨‹
        for (const lessonId of uniqueLessons) {
            const bUrl = `${BASE_URL}/b/${lessonId}`;
            console.log(`â¬‡ï¸ ä¸‹è½½ç¬¬ ${lessonId} è¯¾éŸ³é¢‘...`);

            try {
                const res = await fetch(bUrl);
                if (res.ok) {
                    const rawData = await res.json();
                    let lines = [];

                    // --- ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šéå†æ‰€æœ‰åˆ†ç±» ---
                    // categories: words(å•è¯), sentences(ä¾‹å¥), dialogue(å¯¹è¯), cognates(åŒæºè¯)
                    const categories = ['words', 'sentences', 'dialogue', 'cognates'];

                    categories.forEach(cat => {
                        const mapData = rawData[cat] || {};
                        Object.entries(mapData).forEach(([key, base64Str]) => {
                            if (typeof base64Str === 'string' && base64Str.startsWith('data:audio')) {
                                lines.push(JSON.stringify({
                                    category: cat,   // æ ‡è®°åˆ†ç±»ï¼šwords, sentences...
                                    originalKey: key, // åŸå§‹Keyï¼š7_sentence_å®ç”¨åœºæ™¯1...
                                    content: base64Str // éŸ³é¢‘æ•°æ®
                                }));
                            }
                        });
                    });
                    // -------------------------------

                    if (lines.length > 0) {
                        folder.file(`${lessonId}.json`, lines.join('\n'));
                        count++;
                    }
                }
            } catch (e) {
                console.error(e);
            }
            await new Promise(r => setTimeout(r, 200));
        }

        // C. ä¸‹è½½
        const content = await zip.generateAsync({type: "blob"});
        const link = document.createElement("a");
        link.href = URL.createObjectURL(content);
        link.download = "Thai_4_Audio.zip";
        link.click();
        console.log("âœ… ä¸‹è½½å®Œæˆ");
    }
})();
</file>

<file path="scripts/getVocabJsonFromWeb.js">
//è¯¥è„šæœ¬ä»…é€‚ç”¨äºæµè§ˆå™¨æ§åˆ¶å°
//è¯¥è„šæœ¬ç”¨äºçˆ¬å–ç½‘ç«™ä¸Šçš„jsonæ–‡ä»¶

(function() {
    // 1. åŠ¨æ€åŠ è½½ JSZip åº“
    console.log("%câ³ æ­£åœ¨åŠ è½½ JSZip åº“...", "color: blue; font-weight: bold;");
    var script = document.createElement('script');
    script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
    document.head.appendChild(script);

    // 2. è®¾ç½®å®šæ—¶å™¨ï¼Œ3ç§’åæ‰§è¡Œä¸»é€»è¾‘
    setTimeout(function() {
        if (typeof JSZip === 'undefined') {
            console.error("âŒ JSZip åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–é‡æ–°è¿è¡Œä»£ç ã€‚");
            return;
        }
        console.log("%câœ… åº“åŠ è½½æˆåŠŸï¼3ç§’å·²åˆ°ï¼Œå¼€å§‹æ‰§è¡Œçˆ¬å–ä»»åŠ¡...", "color: green; font-weight: bold; font-size: 14px;");
        startScrapingTask();
    }, 3000);

    // 3. ä¸»ä»»åŠ¡é€»è¾‘
    async function startScrapingTask() {
        // ================= é…ç½®åŒºåŸŸ =================
        const BASE_URL = "https://cdn.langeek.cn/thaik/corpus/thai/rv/BaseThai_4";
        const CATALOG_URL = `${BASE_URL}/p/O5G1e3lD7B0I2o6C9f8A4L1`;
        // ===========================================

        try {
            // A. è·å–æ€»è¡¨
            console.log("1ï¸âƒ£ æ­£åœ¨è·å–è¯¾ç¨‹ç›®å½•...");
            const catalogResp = await fetch(CATALOG_URL);
            if (!catalogResp.ok) throw new Error(`æ€»è¡¨è·å–å¤±è´¥: ${catalogResp.status}`);
            const catalogData = await catalogResp.json();

            // B. æå–ç« èŠ‚å·
            const rawLessons = catalogData.words.map(w => w.lessonNumber).filter(l => l);
            const uniqueLessons = [...new Set(rawLessons)];
            uniqueLessons.sort((a, b) => parseFloat(a) - parseFloat(b));

            console.log(`âœ… ç›®å½•è·å–æˆåŠŸï¼å…±å‘ç° ${uniqueLessons.length} ä¸ªè¯¾ç¨‹ç« èŠ‚ã€‚`);

            // C. å‡†å¤‡ ZIP
            const zip = new JSZip();
            const folder = zip.folder("Thai_Vocab_JSONL");

            // D. å¾ªç¯ä¸‹è½½å¹¶è½¬æ¢æ ¼å¼
            let successCount = 0;
            
            for (let i = 0; i < uniqueLessons.length; i++) {
                const lessonId = uniqueLessons[i];
                const jUrl = `${BASE_URL}/j/${lessonId}`;
                
                console.log(`â¬‡ï¸ [${i + 1}/${uniqueLessons.length}] æ­£åœ¨å¤„ç†ç¬¬ ${lessonId} è¯¾...`);

                try {
                    const jResp = await fetch(jUrl);
                    if (jResp.ok) {
                        const rawContent = await jResp.json(); // å…ˆè§£æä¸ºå¯¹è±¡/æ•°ç»„
                        
                        let jsonlContent = "";

                        // --- æ ¸å¿ƒè½¬æ¢é€»è¾‘ï¼šè½¬ä¸º JSONL (NDJSON) ---
                        if (Array.isArray(rawContent)) {
                            // å¦‚æœæ˜¯æ•°ç»„ï¼ŒæŠŠæ¯ä¸€é¡¹è½¬ä¸ºå­—ç¬¦ä¸²ï¼Œç”¨æ¢è¡Œç¬¦è¿æ¥
                            // æ•ˆæœï¼š
                            // {"id":1, ...}
                            // {"id":2, ...}
                            jsonlContent = rawContent.map(item => JSON.stringify(item)).join('\n');
                        } else if (typeof rawContent === 'object') {
                            // å¦‚æœæ˜¯å•ä¸ªå¯¹è±¡ï¼Œç›´æ¥è½¬å­—ç¬¦ä¸²ï¼ˆæˆ–è€…æ£€æŸ¥æ˜¯å¦æœ‰å†…éƒ¨ listï¼‰
                            // æœ‰äº›ç»“æ„å¯èƒ½æ˜¯ { words: [...] }ï¼Œè¿™é‡Œåšä¸ªå…¼å®¹
                            if (rawContent.words && Array.isArray(rawContent.words)) {
                                jsonlContent = rawContent.words.map(item => JSON.stringify(item)).join('\n');
                            } else {
                                jsonlContent = JSON.stringify(rawContent);
                            }
                        } else {
                            // çº¯æ–‡æœ¬æˆ–å…¶ä»–
                            jsonlContent = String(rawContent);
                        }
                        // ----------------------------------------

                        // ä¿å­˜æ–‡ä»¶ï¼Œè™½ç„¶å†…å®¹æ˜¯ JSONLï¼Œä½†åç¼€ä¿æŒ .json (æ–¹ä¾¿ç¼–è¾‘å™¨è¯†åˆ«)
                        folder.file(`${lessonId}.json`, jsonlContent);
                        successCount++;
                    } else {
                        console.warn(`âš ï¸ è¯¾ç¨‹ ${lessonId} ä¸‹è½½å¤±è´¥ (Status: ${jResp.status})`);
                    }
                } catch (err) {
                    console.error(`âŒ è¯¾ç¨‹ ${lessonId} å¤„ç†å‡ºé”™:`, err);
                }

                // ç¨å¾®å»¶æ—¶ï¼Œé˜²æ­¢è¯·æ±‚è¿‡å¿«
                await new Promise(r => setTimeout(r, 200));
            }

            // E. æ‰“åŒ…ä¸‹è½½
            console.log("ğŸ“¦ æ­£åœ¨æ‰“åŒ…ä¸º ZIP...");
            const content = await zip.generateAsync({type: "blob"});
            
            const link = document.createElement("a");
            link.href = URL.createObjectURL(content);
            link.download = "Thai_4_Vocab.zip";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            console.log(`%cğŸ‰ å…¨éƒ¨å®Œæˆï¼å·²ä¸‹è½½ ${successCount} ä¸ª JSONL æ ¼å¼çš„æ–‡ä»¶ã€‚`, "color: green; font-size: 16px; font-weight: bold;");

        } catch (e) {
            console.error("âŒ å‘ç”Ÿä¸¥é‡é”™è¯¯:", e);
        }
    }
})();
</file>

<file path="src/components/common/Card.tsx">
import React from 'react';
import { View, StyleSheet, ViewStyle } from 'react-native';

interface CardProps {
  children: React.ReactNode;
  style?: ViewStyle;
}

export default function Card({ children, style }: CardProps) {
  return <View style={[styles.card, style]}>{children}</View>;
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: '#fff',
    padding: 15,
    borderRadius: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
});
</file>

<file path="src/components/common/LanguageSwitcher.tsx">
// src/components/LanguageSwitcher.tsx
import React from 'react';
import { View, Text, Pressable, StyleSheet } from 'react-native';
import { useTranslation } from 'react-i18next';
import { Globe } from 'lucide-react-native';
import { useLanguageStore, Language } from '@/src/stores/languageStore';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

interface LanguageSwitcherProps {
  variant?: 'compact' | 'full';
}

export const LanguageSwitcher: React.FC<LanguageSwitcherProps> = ({ variant = 'compact' }) => {
  const { t } = useTranslation();
  const { currentLanguage, changeLanguage } = useLanguageStore();

  const languages: { code: Language; label: string; flag: string }[] = [
    { code: 'zh', label: t('profile.chinese'), flag: 'ğŸ‡¨ğŸ‡³' },
    { code: 'en', label: t('profile.english'), flag: 'ğŸ‡ºğŸ‡¸' },
  ];

  if (variant === 'compact') {
    return (
      <Pressable
        style={styles.compactButton}
        onPress={() => changeLanguage(currentLanguage === 'zh' ? 'en' : 'zh')}
      >
        <Globe size={20} color={Colors.ink} />
        <Text style={styles.compactText}>
          {currentLanguage === 'zh' ? 'EN' : 'ä¸­'}
        </Text>
      </Pressable>
    );
  }

  return (
    <View style={styles.fullContainer}>
      <Text style={styles.fullTitle}>{t('profile.selectLanguage')}</Text>
      {languages.map((lang) => (
        <Pressable
          key={lang.code}
          style={[
            styles.languageOption,
            currentLanguage === lang.code && styles.languageOptionActive,
          ]}
          onPress={() => changeLanguage(lang.code)}
        >
          <View style={styles.languageLeft}>
            <Text style={styles.flag}>{lang.flag}</Text>
            <Text style={[
              styles.languageLabel,
              currentLanguage === lang.code && styles.languageLabelActive,
            ]}>
              {lang.label}
            </Text>
          </View>
          {currentLanguage === lang.code && (
            <Text style={styles.checkmark}>âœ“</Text>
          )}
        </Pressable>
      ))}
    </View>
  );
};

const styles = StyleSheet.create({
  compactButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: Colors.white,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: Colors.sand,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 4,
    elevation: 2,
  },
  compactText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    fontWeight: '600',
    color: Colors.ink,
  },
  fullContainer: {
    width: '100%',
  },
  fullTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    fontWeight: '600',
    color: Colors.ink,
    marginBottom: 12,
  },
  languageOption: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 16,
    paddingHorizontal: 20,
    backgroundColor: Colors.white,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: Colors.sand,
    marginBottom: 12,
  },
  languageOptionActive: {
    borderColor: Colors.thaiGold,
    backgroundColor: 'rgba(212, 175, 55, 0.05)',
  },
  languageLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  flag: {
    fontSize: 24,
  },
  languageLabel: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.ink,
  },
  languageLabelActive: {
    fontFamily: Typography.notoSerifBold,
    fontWeight: '600',
  },
  checkmark: {
    fontSize: 20,
    color: Colors.thaiGold,
  },
});
</file>

<file path="src/components/common/ListContainer.tsx">
import { View, Text } from "react-native";

export default function ListContainer() {
    return (
        <View>
            <Text>åˆ—è¡¨å®¹å™¨</Text>
        </View>
    )
}
</file>

<file path="src/components/common/ThaiPatternBackground.tsx">
// src/components/ThaiPatternBackground.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import Svg, { Defs, Pattern, Rect, G, Path } from 'react-native-svg';

interface ThaiPatternBackgroundProps {
  opacity?: number;
}

export const ThaiPatternBackground: React.FC<ThaiPatternBackgroundProps> = ({
  opacity = 0.15,
}) => {
  return (
    <View style={styles.container}>
      <Svg width="100%" height="100%" style={StyleSheet.absoluteFill}>
        <Defs>
          <Pattern
            id="thaiElephantPattern"
            x="0"
            y="0"
            width="40"
            height="40"
            patternUnits="userSpaceOnUse"
          >
            <G transform="scale(0.4) translate(10, 10)" opacity={opacity}>
              {/* Head and Trunk */}
              <Path
                d="M 20 20 Q 10 20 10 30 Q 10 45 25 45 L 25 55 Q 20 50 15 55"
                fill="none"
                stroke="#1A1A1A"
                strokeWidth="2.5"
              />
              {/* Ear */}
              <Path
                d="M 25 25 Q 35 15 40 25 Q 40 35 30 35"
                fill="none"
                stroke="#1A1A1A"
                strokeWidth="2.5"
              />
              {/* Back and Body */}
              <Path
                d="M 25 20 Q 40 10 55 25 Q 60 40 55 50 L 55 60"
                fill="none"
                stroke="#1A1A1A"
                strokeWidth="2.5"
              />
              {/* Legs */}
              <Path d="M 25 45 L 25 60" fill="none" stroke="#1A1A1A" strokeWidth="2.5" />
              <Path d="M 45 50 L 45 60" fill="none" stroke="#1A1A1A" strokeWidth="2.5" />
            </G>
          </Pattern>
        </Defs>
        <Rect width="100%" height="100%" fill="url(#thaiElephantPattern)" />
      </Svg>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    ...StyleSheet.absoluteFillObject,
    zIndex: 0,
    overflow: 'hidden',
  },
});
</file>

<file path="src/components/learning/alphabet/AlphabetCompletionView.tsx">
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView } from 'react-native';
import { CheckCircle, Trophy, Home } from 'lucide-react-native';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import type { RoundEvaluationState } from '@/src/entities/types/phonicsRule.types';

interface AlphabetCompletionViewProps {
    roundEvaluation?: RoundEvaluationState;
    onFinish: () => void;
}

export function AlphabetCompletionView({
    roundEvaluation,
    onFinish,
}: AlphabetCompletionViewProps) {
    const rounds = roundEvaluation?.rounds ?? [];
    const averageAccuracy =
        rounds.reduce((acc, r) => acc + r.accuracy, 0) / (rounds.length || 1);
    const isAllPassed = rounds.every((r) => r.passed);

    return (
        <View style={styles.container}>
            <ScrollView contentContainerStyle={styles.content}>
                {/* Header / Hero Section */}
                <View style={styles.heroSection}>
                    <View style={styles.iconContainer}>
                        {isAllPassed ? (
                            <Trophy size={64} color={Colors.thaiGold} strokeWidth={1.5} />
                        ) : (
                            <CheckCircle size={64} color={Colors.success} strokeWidth={1.5} />
                        )}
                    </View>

                    <Text style={styles.title}>Lesson Complete!</Text>
                    <Text style={styles.subtitle}>
                        {isAllPassed
                            ? 'Excellent work! You mastered this letter.'
                            : 'Good effort! Keep practicing to improve.'}
                    </Text>
                </View>

                {/* Stats Card */}
                <View style={styles.card}>
                    <Text style={styles.cardTitle}>Session Summary</Text>

                    {rounds.map((round) => (
                        <View key={round.roundNumber} style={styles.roundRow}>
                            <Text style={styles.roundLabel}>Round {round.roundNumber}</Text>
                            <View style={styles.statContainer}>
                                <Text
                                    style={[
                                        styles.accuracyText,
                                        { color: round.passed ? '#2A9D8F' : '#E63946' },
                                    ]}
                                >
                                    {(round.accuracy * 100).toFixed(0)}%
                                </Text>
                                <Text style={styles.statusLabel}>
                                    {round.passed ? 'PASSED' : 'RETRY'}
                                </Text>
                            </View>
                        </View>
                    ))}

                    <View style={styles.divider} />

                    <View style={styles.totalRow}>
                        <Text style={styles.totalLabel}>Average Accuracy</Text>
                        <Text style={styles.totalValue}>{(averageAccuracy * 100).toFixed(0)}%</Text>
                    </View>
                </View>
            </ScrollView>

            {/* Footer Action */}
            <View style={styles.footer}>
                <TouchableOpacity style={styles.primaryButton} onPress={onFinish}>
                    <Text style={styles.primaryButtonText}>Finish Lesson</Text>
                </TouchableOpacity>
            </View>
        </View>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: Colors.paper,
    },
    content: {
        padding: 24,
        paddingTop: 60,
        alignItems: 'center',
    },
    heroSection: {
        alignItems: 'center',
        marginBottom: 40,
    },
    iconContainer: {
        width: 120,
        height: 120,
        borderRadius: 60,
        backgroundColor: '#FFF9E6', // Light gold bg
        justifyContent: 'center',
        alignItems: 'center',
        marginBottom: 24,
        borderWidth: 4,
        borderColor: '#FFFFFF',
        shadowColor: '#D4AF37',
        shadowOffset: { width: 0, height: 8 },
        shadowOpacity: 0.15,
        shadowRadius: 16,
        elevation: 10,
    },
    title: {
        fontFamily: Typography.playfairBold,
        fontSize: 32,
        color: Colors.ink,
        marginBottom: 8,
        textAlign: 'center',
    },
    subtitle: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 16,
        color: Colors.taupe,
        textAlign: 'center',
        maxWidth: '80%',
        lineHeight: 24,
    },
    card: {
        width: '100%',
        backgroundColor: Colors.white,
        borderRadius: 24,
        padding: 24,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.06,
        shadowRadius: 12,
        elevation: 4,
        borderWidth: 1,
        borderColor: '#F0F0F0',
    },
    cardTitle: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 18,
        color: Colors.ink,
        marginBottom: 16,
        textAlign: 'left',
    },
    roundRow: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: 16,
    },
    roundLabel: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 16,
        color: Colors.ink,
    },
    statContainer: {
        flexDirection: 'row',
        alignItems: 'center',
        gap: 12,
    },
    accuracyText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
    },
    statusLabel: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 12,
        color: Colors.taupe,
        backgroundColor: '#F5F5F5',
        paddingHorizontal: 8,
        paddingVertical: 4,
        borderRadius: 6,
        overflow: 'hidden',
    },
    divider: {
        height: 1,
        backgroundColor: '#F0F0F0',
        marginVertical: 16,
    },
    totalRow: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
    },
    totalLabel: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.ink,
    },
    totalValue: {
        fontFamily: Typography.playfairBold,
        fontSize: 24,
        color: Colors.thaiGold,
    },
    footer: {
        padding: 24,
        paddingBottom: 40,
        backgroundColor: Colors.paper,
    },
    primaryButton: {
        backgroundColor: Colors.ink,
        height: 56,
        borderRadius: 100,
        justifyContent: 'center',
        alignItems: 'center',
        shadowColor: Colors.ink,
        shadowOffset: { width: 0, height: 8 },
        shadowOpacity: 0.2,
        shadowRadius: 16,
        elevation: 8,
    },
    primaryButtonText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 18,
        color: Colors.white,
    },
});
</file>

<file path="src/components/learning/alphabet/AspiratedContrastQuestion.tsx">
// src/components/learning/alphabet/AspiratedContrastQuestion.tsx

import React, { useState, useCallback, useRef, useEffect } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
} from 'react-native';
import { Audio } from 'expo-av';
import { Wind } from 'lucide-react-native';

import type { Letter } from '@/src/entities/types/letter.types';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

// ==================== Props æ¥å£ ====================

interface AspiratedContrastQuestionProps {
  /** ç›®æ ‡å­—æ¯ */
  target: Letter;
  
  /** å¯¹æ¯”å­—æ¯ç»„(æœ€å°å¯¹ç«‹ç»„) */
  contrasts: Letter[];
  
  /** ç­”é¢˜å›è°ƒ */
  onAnswer: (isCorrect: boolean) => void;
  
  /** ä¸‹ä¸€é¢˜å›è°ƒ */
  onNext: () => void;
}

// ==================== ä¸»ç»„ä»¶ ====================

export function AspiratedContrastQuestion({
  target,
  contrasts,
  onAnswer,
  onNext,
}: AspiratedContrastQuestionProps) {
  const [answered, setAnswered] = useState(false);
  const [selectedLetter, setSelectedLetter] = useState<string | null>(null);
  const [isPlayingTarget, setIsPlayingTarget] = useState(false);
  const [isPlayingContrast, setIsPlayingContrast] = useState<string | null>(null);
  
  const soundRef = useRef<Audio.Sound | null>(null);

  // æ‰€æœ‰é€‰é¡¹(ç›®æ ‡å­—æ¯+å¯¹æ¯”å­—æ¯)
  const allOptions = [target, ...contrasts];

  // ===== æ¸…ç†éŸ³é¢‘ =====
  useEffect(() => {
    return () => {
      if (soundRef.current) {
        soundRef.current.unloadAsync().catch(() => {});
        soundRef.current = null;
      }
    };
  }, []);

  // ===== æ’­æ”¾éŸ³é¢‘ =====
  const playAudio = useCallback(async (audioUrl: string, letterId: string) => {
    try {
      if (letterId === target._id) {
        setIsPlayingTarget(true);
      } else {
        setIsPlayingContrast(letterId);
      }

      if (soundRef.current) {
        await soundRef.current.unloadAsync();
        soundRef.current = null;
      }

      const { sound } = await Audio.Sound.createAsync(
        { uri: audioUrl },
        { shouldPlay: true }
      );

      soundRef.current = sound;

      sound.setOnPlaybackStatusUpdate((status) => {
        if (status.isLoaded && status.didJustFinish) {
          setIsPlayingTarget(false);
          setIsPlayingContrast(null);
        }
      });
    } catch (error) {
      console.warn('[AspiratedContrast] æ’­æ”¾å¤±è´¥:', error);
      setIsPlayingTarget(false);
      setIsPlayingContrast(null);
    }
  }, [target._id]);

  // ===== é€‰æ‹©ç­”æ¡ˆ =====
  const handleSelectLetter = useCallback(
    (letter: Letter) => {
      if (answered) return;

      setSelectedLetter(letter._id);
      setAnswered(true);

      const isCorrect = letter._id === target._id;
      onAnswer(isCorrect);
    },
    [answered, target._id, onAnswer]
  );

  // ===== åˆ¤æ–­æ˜¯å¦é€æ°” =====
  const isAspirated = (letter: Letter): boolean => {
    return letter.initialSound.includes('h');
  };

  return (
    <View style={styles.container}>
      {/* é¢˜å‹æ ‡é¢˜ */}
      <View style={styles.header}>
        <Wind size={24} color={Colors.thaiGold} />
        <Text style={styles.title}>é€æ°”éŸ³å¯¹æ¯”è®­ç»ƒ</Text>
      </View>

      {/* è¯´æ˜ */}
      <Text style={styles.instruction}>
        ğŸ”Š å…ˆæ’­æ”¾ç›®æ ‡éŸ³é¢‘,ç„¶åä»ä¸‹æ–¹é€‰é¡¹ä¸­é€‰æ‹©å¯¹åº”çš„å­—æ¯
      </Text>

      {/* ç›®æ ‡éŸ³é¢‘æ’­æ”¾ */}
      <TouchableOpacity
        style={styles.targetAudioButton}
        onPress={() => {
          const audioUrl =
            target.fullSoundUrl ||
            target.letterPronunciationUrl ||
            target.audioPath ||
            '';
          playAudio(audioUrl, target._id);
        }}
        disabled={isPlayingTarget}
        accessibilityRole="button"
        accessibilityLabel="æ’­æ”¾ç›®æ ‡å‘éŸ³"
      >
        {isPlayingTarget ? (
          <ActivityIndicator size="small" color={Colors.white} />
        ) : (
          <>
            <Text style={styles.targetAudioIcon}>ğŸ”Š</Text>
            <Text style={styles.targetAudioText}>æ’­æ”¾ç›®æ ‡å‘éŸ³</Text>
          </>
        )}
      </TouchableOpacity>

      {/* æç¤ºå¡ç‰‡ */}
      <View style={styles.hintCard}>
        <Text style={styles.hintTitle}>ğŸ’¡ åŒºåˆ†æŠ€å·§</Text>
        <Text style={styles.hintText}>
          â€¢ é€æ°”éŸ³: å‘éŸ³æ—¶æœ‰æ˜æ˜¾æ°”æµ (å¦‚ à¸‚ à¸– à¸œ)
        </Text>
        <Text style={styles.hintText}>
          â€¢ ä¸é€æ°”éŸ³: å‘éŸ³æ—¶æ°”æµè¾ƒå¼± (å¦‚ à¸ à¸” à¸š)
        </Text>
        <Text style={styles.hintText}>
          â€¢ ç”¨æ‰‹æ”¾åœ¨å˜´å‰æ„Ÿå—æ°”æµå¼ºåº¦!
        </Text>
      </View>

      {/* é€‰é¡¹(æœ€å°å¯¹ç«‹ç»„) */}
      <View style={styles.optionsContainer}>
        {allOptions.map((letter) => {
          const isSelected = selectedLetter === letter._id;
          const isCorrect = answered && letter._id === target._id;
          const isWrong = answered && isSelected && letter._id !== target._id;
          const isPlaying = isPlayingContrast === letter._id;

          return (
            <View key={letter._id} style={styles.optionWrapper}>
              {/* å­—æ¯å¡ç‰‡ */}
              <TouchableOpacity
                style={[
                  styles.optionCard,
                  isSelected && styles.optionSelected,
                  isCorrect && styles.optionCorrect,
                  isWrong && styles.optionWrong,
                ]}
                onPress={() => handleSelectLetter(letter)}
                disabled={answered}
                accessibilityRole="radio"
                accessibilityLabel={`å­—æ¯ ${letter.thaiChar}`}
                accessibilityState={{ selected: isSelected }}
              >
                <Text style={styles.optionChar}>{letter.thaiChar}</Text>
                <Text style={styles.optionName}>{letter.nameThai}</Text>
                
                {/* é€æ°”æ ‡è¯† */}
                {isAspirated(letter) && (
                  <View style={styles.aspiratedBadge}>
                    <Wind size={12} color={Colors.thaiGold} />
                    <Text style={styles.aspiratedText}>é€æ°”</Text>
                  </View>
                )}

                {/* åé¦ˆå›¾æ ‡ */}
                {answered && (
                  <View style={styles.feedbackIcon}>
                    {isCorrect && <Text style={styles.correctIcon}>âœ“</Text>}
                    {isWrong && <Text style={styles.wrongIcon}>âœ—</Text>}
                  </View>
                )}
              </TouchableOpacity>

              {/* æ’­æ”¾å¯¹æ¯”éŸ³é¢‘æŒ‰é’® */}
              <TouchableOpacity
                style={styles.playContrastButton}
                onPress={() => {
                  const audioUrl =
                    letter.fullSoundUrl ||
                    letter.letterPronunciationUrl ||
                    letter.audioPath ||
                    '';
                  playAudio(audioUrl, letter._id);
                }}
                disabled={isPlaying}
                accessibilityRole="button"
                accessibilityLabel={`æ’­æ”¾ ${letter.thaiChar} çš„å‘éŸ³`}
              >
                {isPlaying ? (
                  <ActivityIndicator size="small" color={Colors.thaiGold} />
                ) : (
                  <Text style={styles.playContrastIcon}>â–¶</Text>
                )}
              </TouchableOpacity>
            </View>
          );
        })}
      </View>

      {/* è§£é‡Š(ç­”é¢˜å) */}
      {answered && (
        <View style={styles.explanationCard}>
          <Text style={styles.explanationText}>
            âœ… æ­£ç¡®ç­”æ¡ˆ: {target.thaiChar} ({target.nameThai})
            {'\n'}
            {isAspirated(target)
              ? 'è¿™æ˜¯ä¸€ä¸ªé€æ°”éŸ³,å‘éŸ³æ—¶æœ‰æ˜æ˜¾æ°”æµ'
              : 'è¿™æ˜¯ä¸€ä¸ªä¸é€æ°”éŸ³,å‘éŸ³æ—¶æ°”æµè¾ƒå¼±'}
          </Text>
        </View>
      )}

      {/* ä¸‹ä¸€é¢˜æŒ‰é’® */}
      {answered && (
        <TouchableOpacity
          style={styles.nextButton}
          onPress={onNext}
          accessibilityRole="button"
          accessibilityLabel="ä¸‹ä¸€é¢˜"
        >
          <Text style={styles.nextButtonText}>ä¸‹ä¸€é¢˜ â†’</Text>
        </TouchableOpacity>
      )}
    </View>
  );
}

// ==================== æ ·å¼ ====================

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 24,
    backgroundColor: Colors.paper,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 16,
  },
  title: {
    fontFamily: Typography.playfairBold,
    fontSize: 22,
    color: Colors.ink,
    marginLeft: 12,
  },
  instruction: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
    textAlign: 'center',
    marginBottom: 20,
  },
  targetAudioButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: Colors.thaiGold,
    borderRadius: 12,
    padding: 16,
    marginBottom: 24,
    minHeight: 56,
  },
  targetAudioIcon: {
    fontSize: 24,
    marginRight: 8,
  },
  targetAudioText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
  },
  hintCard: {
    backgroundColor: '#FFF9E6',
    borderRadius: 12,
    padding: 16,
    marginBottom: 24,
  },
  hintTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    color: Colors.ink,
    marginBottom: 8,
  },
  hintText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 13,
    color: Colors.taupe,
    marginBottom: 4,
  },
  optionsContainer: {
    gap: 16,
    marginBottom: 20,
  },
  optionWrapper: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  optionCard: {
    flex: 1,
    backgroundColor: Colors.white,
    borderWidth: 2,
    borderColor: Colors.sand,
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    minHeight: 100,
  },
  optionSelected: {
    borderColor: Colors.thaiGold,
    backgroundColor: '#FFF9E6',
  },
  optionCorrect: {
    borderColor: '#2A9D8F',
    backgroundColor: '#E8F5F3',
  },
  optionWrong: {
    borderColor: '#E63946',
    backgroundColor: '#FFE8EA',
  },
  optionChar: {
    fontFamily: Typography.playfairBold,
    fontSize: 48,
    color: Colors.ink,
    marginBottom: 8,
  },
  optionName: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  aspiratedBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(212, 175, 55, 0.1)',
    borderRadius: 12,
    paddingHorizontal: 8,
    paddingVertical: 4,
    marginTop: 8,
  },
  aspiratedText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 10,
    color: Colors.thaiGold,
    marginLeft: 4,
  },
  feedbackIcon: {
    position: 'absolute',
    top: 8,
    right: 8,
  },
  correctIcon: {
    fontSize: 24,
    color: '#2A9D8F',
  },
  wrongIcon: {
    fontSize: 24,
    color: '#E63946',
  },
  playContrastButton: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: Colors.white,
    borderWidth: 2,
    borderColor: Colors.thaiGold,
    justifyContent: 'center',
    alignItems: 'center',
  },
  playContrastIcon: {
    fontSize: 16,
    color: Colors.thaiGold,
  },
  explanationCard: {
    backgroundColor: '#F0F8FF',
    borderRadius: 12,
    padding: 16,
    marginBottom: 20,
  },
  explanationText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    lineHeight: 20,
    color: Colors.ink,
  },
  nextButton: {
    backgroundColor: Colors.thaiGold,
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
  },
  nextButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
  },
});
</file>

<file path="src/components/learning/alphabet/MiniReviewQuestion.tsx">
// src/components/learning/alphabet/MiniReviewQuestion.tsx

import React, { useState, useCallback, useRef, useEffect } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
  ScrollView,
} from 'react-native';
import { Audio } from 'expo-av';
import { Volume2 } from 'lucide-react-native';

import type { MiniReviewQuestion as MiniReviewQuestionType } from '@/src/entities/types/phonicsRule.types';
import type { QuestionType } from '@/src/entities/enums/QuestionType.enum';
import {
  QUESTION_TYPE_LABELS,
  QUESTION_TYPE_ICONS,
} from '@/src/entities/enums/QuestionType.enum';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

// ==================== Props æ¥å£ ====================

interface MiniReviewQuestionProps {
  /** é¢˜ç›®æ•°æ® */
  question: MiniReviewQuestionType;
  
  /** ç­”é¢˜å›è°ƒ(isCorrect, questionType) */
  onAnswer: (isCorrect: boolean, type: QuestionType) => void;
  
  /** ä¸‹ä¸€é¢˜å›è°ƒ */
  onNext: () => void;
  
  /** è¿”å›å›è°ƒ(å¯é€‰) */
  onBack?: () => void;
}

// ==================== ä¸»ç»„ä»¶ ====================

export function MiniReviewQuestion({
  question,
  onAnswer,
  onNext,
  onBack,
}: MiniReviewQuestionProps) {
  const [answered, setAnswered] = useState(false);
  const [selectedOption, setSelectedOption] = useState<string | null>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const soundRef = useRef<Audio.Sound | null>(null);

  // ===== æ¸…ç†éŸ³é¢‘èµ„æº =====
  useEffect(() => {
    return () => {
      if (soundRef.current) {
        soundRef.current.unloadAsync().catch(() => {});
        soundRef.current = null;
      }
    };
  }, [question.id]); // é¢˜ç›®åˆ‡æ¢æ—¶æ¸…ç†

  // ===== æ’­æ”¾éŸ³é¢‘ =====
  const handlePlayAudio = useCallback(async () => {
    if (!question.audioUrl) return;

    try {
      setIsPlaying(true);

      if (soundRef.current) {
        await soundRef.current.replayAsync();
        setIsPlaying(false);
        return;
      }

      const { sound } = await Audio.Sound.createAsync(
        { uri: question.audioUrl },
        { shouldPlay: true }
      );

      soundRef.current = sound;

      sound.setOnPlaybackStatusUpdate((status) => {
        if (status.isLoaded && status.didJustFinish) {
          setIsPlaying(false);
        }
      });
    } catch (error) {
      console.warn('[MiniReviewQuestion] æ’­æ”¾éŸ³é¢‘å¤±è´¥:', error);
      setIsPlaying(false);
    }
  }, [question.audioUrl]);

  // ===== é€‰æ‹©ç­”æ¡ˆ =====
  const handleSelectOption = useCallback(
    (optionValue: string) => {
      if (answered) return;

      setSelectedOption(optionValue);
      setAnswered(true);

      const isCorrect = optionValue === question.correct;
      onAnswer(isCorrect, question.type);
    },
    [answered, question.correct, question.type, onAnswer]
  );

  // ===== æ¸²æŸ“å£°å­¦æç¤º =====
  const renderAcousticHint = () => {
    if (!question.acousticHint) return null;

    const { aspirated, voiceless, class: consonantClass } = question.acousticHint;

    return (
      <View style={styles.hintContainer}>
        <Text style={styles.hintTitle}>ğŸ’¡ æç¤º:</Text>
        {aspirated !== undefined && (
          <Text style={styles.hintText}>
            â€¢ {aspirated ? 'é€æ°”éŸ³ (aspirated)' : 'ä¸é€æ°”éŸ³ (unaspirated)'}
          </Text>
        )}
        {voiceless !== undefined && (
          <Text style={styles.hintText}>
            â€¢ {voiceless ? 'æ¸…éŸ³ (voiceless)' : 'æµŠéŸ³ (voiced)'}
          </Text>
        )}
        {consonantClass && (
          <Text style={styles.hintText}>
            â€¢ è¾…éŸ³ç±»: {consonantClass === 'high' ? 'é«˜è¾…éŸ³' : consonantClass === 'mid' ? 'ä¸­è¾…éŸ³' : 'ä½è¾…éŸ³'}
          </Text>
        )}
      </View>
    );
  };

  // ===== æ¸²æŸ“éŸ³é«˜å¯è§†åŒ– =====
  const renderPitchVisualization = () => {
    if (!question.pitchVisualization?.enable) return null;
    if (!answered && !question.pitchVisualization.showAfterAnswer) return null;

    const { curve } = question.pitchVisualization;

    return (
      <View style={styles.pitchContainer}>
        <Text style={styles.pitchTitle}>ğŸµ éŸ³é«˜æ›²çº¿</Text>
        <View style={styles.pitchChart}>
          {curve.map((height, index) => (
            <View
              key={index}
              style={[
                styles.pitchBar,
                { height: `${(height / 5) * 100}%` },
              ]}
            />
          ))}
        </View>
      </View>
    );
  };

  // ===== åˆ¤æ–­é¢˜å‹æ˜¯å¦éœ€è¦éŸ³é¢‘ =====
  const needsAudio = [
    'sound-to-letter',
    'aspirated-contrast',
    'vowel-length-contrast',
    'tone-perception',
  ].includes(question.type);

  return (
    <ScrollView
      style={styles.container}
      contentContainerStyle={styles.contentContainer}
    >
      {/* é¢˜å‹æ ‡é¢˜ */}
      <View style={styles.header}>
        <Text style={styles.typeIcon}>
          {QUESTION_TYPE_ICONS[question.type] || 'ğŸ“'}
        </Text>
        <Text style={styles.typeLabel}>
          {QUESTION_TYPE_LABELS[question.type]}
        </Text>
      </View>

      {/* é¢˜å¹² */}
      <Text style={styles.question}>{question.question}</Text>

      {/* å‰¯æ ‡é¢˜ */}
      {question.subtitle && (
        <Text style={styles.subtitle}>{question.subtitle}</Text>
      )}

      {/* éŸ³é¢‘æ’­æ”¾æŒ‰é’® */}
      {needsAudio && question.audioUrl && (
        <TouchableOpacity
          style={styles.audioButton}
          onPress={handlePlayAudio}
          disabled={isPlaying}
          accessibilityRole="button"
          accessibilityLabel="æ’­æ”¾å‘éŸ³"
        >
          {isPlaying ? (
            <ActivityIndicator size="small" color={Colors.white} />
          ) : (
            <>
              <Volume2 size={20} color={Colors.white} />
              <Text style={styles.audioButtonText}>æ’­æ”¾å‘éŸ³</Text>
            </>
          )}
        </TouchableOpacity>
      )}

      {/* å£°å­¦æç¤º(ç­”é¢˜å‰æ˜¾ç¤º) */}
      {!answered && renderAcousticHint()}

      {/* é€‰é¡¹ */}
      <View style={styles.optionsContainer}>
        {question.options.map((option, index) => {
          const isSelected = selectedOption === option.value;
          const isCorrect = answered && option.value === question.correct;
          const isWrong = answered && isSelected && option.value !== question.correct;

          return (
            <TouchableOpacity
              key={index}
              style={[
                styles.optionButton,
                isSelected && styles.optionSelected,
                isCorrect && styles.optionCorrect,
                isWrong && styles.optionWrong,
              ]}
              onPress={() => handleSelectOption(option.value)}
              disabled={answered}
              accessibilityRole="radio"
              accessibilityLabel={option.label}
              accessibilityState={{ selected: isSelected }}
            >
              <View style={styles.optionContent}>
                <Text
                  style={[
                    styles.optionLabel,
                    isSelected && styles.optionLabelSelected,
                  ]}
                >
                  {option.label}
                </Text>
                {option.example && (
                  <Text style={styles.optionExample}>{option.example}</Text>
                )}
              </View>
              {answered && (
                <Text style={styles.feedbackIcon}>
                  {isCorrect ? 'âœ“' : isWrong ? 'âœ—' : ''}
                </Text>
              )}
            </TouchableOpacity>
          );
        })}
      </View>

      {/* è§£é‡Š(ç­”é¢˜åæ˜¾ç¤º) */}
      {answered && question.explanation && (
        <View style={styles.explanationContainer}>
          <Text style={styles.explanationText}>
            ğŸ’¡ {question.explanation}
          </Text>
        </View>
      )}

      {/* éŸ³é«˜å¯è§†åŒ–(ç­”é¢˜åæ˜¾ç¤º) */}
      {answered && renderPitchVisualization()}

      {/* ä¸‹ä¸€é¢˜æŒ‰é’® */}
      {answered && (
        <TouchableOpacity
          style={styles.nextButton}
          onPress={onNext}
          accessibilityRole="button"
          accessibilityLabel="ä¸‹ä¸€é¢˜"
        >
          <Text style={styles.nextButtonText}>ä¸‹ä¸€é¢˜ â†’</Text>
        </TouchableOpacity>
      )}
    </ScrollView>
  );
}

// ==================== æ ·å¼ ====================

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.paper,
  },
  contentContainer: {
    padding: 24,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 20,
  },
  typeIcon: {
    fontSize: 24,
    marginRight: 8,
  },
  typeLabel: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 18,
    color: Colors.ink,
  },
  question: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 20,
    color: Colors.ink,
    textAlign: 'center',
    marginBottom: 12,
  },
  subtitle: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
    textAlign: 'center',
    marginBottom: 20,
  },
  audioButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: Colors.thaiGold,
    borderRadius: 12,
    padding: 14,
    marginBottom: 24,
    minHeight: 50,
  },
  audioButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
    marginLeft: 8,
  },
  hintContainer: {
    backgroundColor: '#FFF9E6',
    borderLeftWidth: 4,
    borderLeftColor: Colors.thaiGold,
    borderRadius: 8,
    padding: 16,
    marginBottom: 20,
  },
  hintTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    color: Colors.ink,
    marginBottom: 8,
  },
  hintText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 13,
    color: Colors.taupe,
    marginBottom: 4,
  },
  optionsContainer: {
    gap: 12,
    marginBottom: 20,
  },
  optionButton: {
    backgroundColor: Colors.white,
    borderWidth: 2,
    borderColor: Colors.sand,
    borderRadius: 12,
    padding: 16,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    minHeight: 60,
  },
  optionSelected: {
    borderColor: Colors.thaiGold,
    backgroundColor: '#FFF9E6',
  },
  optionCorrect: {
    borderColor: '#2A9D8F',
    backgroundColor: '#E8F5F3',
  },
  optionWrong: {
    borderColor: '#E63946',
    backgroundColor: '#FFE8EA',
  },
  optionContent: {
    flex: 1,
  },
  optionLabel: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 18,
    color: Colors.ink,
  },
  optionLabelSelected: {
    color: Colors.thaiGold,
  },
  optionExample: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 12,
    color: Colors.taupe,
    marginTop: 4,
  },
  feedbackIcon: {
    fontSize: 24,
    marginLeft: 12,
  },
  explanationContainer: {
    backgroundColor: '#F0F8FF',
    borderLeftWidth: 4,
    borderLeftColor: '#457B9D',
    borderRadius: 8,
    padding: 16,
    marginBottom: 20,
  },
  explanationText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    lineHeight: 20,
    color: Colors.ink,
  },
  pitchContainer: {
    backgroundColor: '#F5F5F5',
    borderRadius: 12,
    padding: 16,
    marginBottom: 20,
  },
  pitchTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    color: Colors.ink,
    marginBottom: 12,
    textAlign: 'center',
  },
  pitchChart: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    justifyContent: 'space-around',
    height: 100,
    backgroundColor: Colors.white,
    borderRadius: 8,
    padding: 12,
  },
  pitchBar: {
    width: 40,
    backgroundColor: Colors.thaiGold,
    borderRadius: 4,
  },
  nextButton: {
    backgroundColor: Colors.thaiGold,
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
  },
  nextButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
  },
});
</file>

<file path="src/components/learning/alphabet/RoundCompletionView.tsx">
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { CheckCircle2 } from 'lucide-react-native';

interface RoundCompletionViewProps {
    roundNumber: number;
    onFinish: () => void;
}

export function RoundCompletionView({
    roundNumber,
    onFinish,
}: RoundCompletionViewProps) {
    const isFinal = roundNumber >= 3;

    return (
        <View style={styles.container}>
            <View style={styles.content}>
                <CheckCircle2 size={80} color={Colors.thaiGold} style={styles.icon} />

                <Text style={styles.title}>
                    {isFinal ? 'è¯¾ç¨‹å®Œæˆï¼' : `Round ${roundNumber} å®Œæˆ`}
                </Text>

                <Text style={styles.subtitle}>
                    {isFinal
                        ? 'æ­å–œä½ å®Œæˆäº†æœ¬èŠ‚è¯¾ç¨‹çš„æ‰€æœ‰å­¦ä¹ å†…å®¹ï¼'
                        : 'ä¼‘æ¯ä¸€ä¸‹ï¼Œå‡†å¤‡è¿›å…¥ä¸‹ä¸€è½®å­¦ä¹ \næ¯èŠ‚è¯¾éœ€å®Œæˆ3è½®å­¦ä¹ '}
                </Text>

                <TouchableOpacity
                    style={styles.button}
                    onPress={onFinish}
                    activeOpacity={0.8}
                >
                    <Text style={styles.buttonText}>
                        {isFinal ? 'å®Œæˆè¯¾ç¨‹' : 'è¿”å›é€‰è¯¾'}
                    </Text>
                </TouchableOpacity>
            </View>
        </View>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: Colors.paper,
        justifyContent: 'center',
        padding: 24,
    },
    content: {
        alignItems: 'center',
        backgroundColor: Colors.white,
        padding: 32,
        borderRadius: 24,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.1,
        shadowRadius: 12,
        elevation: 4,
    },
    icon: {
        marginBottom: 24,
    },
    title: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 24,
        color: Colors.ink,
        marginBottom: 12,
        textAlign: 'center',
    },
    subtitle: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 16,
        color: Colors.taupe,
        marginBottom: 32,
        textAlign: 'center',
        lineHeight: 24,
    },
    button: {
        backgroundColor: Colors.ink,
        paddingHorizontal: 48,
        paddingVertical: 16,
        borderRadius: 100,
        width: '100%',
        alignItems: 'center',
    },
    buttonText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.white,
    },
});
</file>

<file path="src/components/learning/alphabet/SessionRecoveryCard.tsx">
// src/components/learning/alphabet/SessionRecoveryCard.tsx

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

interface SessionRecoveryCardProps {
    onContinue: () => void;
    onRestart: () => void;
}

export function SessionRecoveryCard({
    onContinue,
    onRestart,
}: SessionRecoveryCardProps) {
    return (
        <View style={styles.overlay}>
            <View style={styles.card}>
                <Text style={styles.title}>ç»§ç»­ä¸Šæ¬¡å­¦ä¹ ï¼Ÿ</Text>
                <Text style={styles.description}>
                    æ£€æµ‹åˆ°æ‚¨åœ¨è¯¥è¯¾ç¨‹å­˜åœ¨æœªå®Œæˆçš„è½®æ¬¡ï¼Œæ˜¯å¦ç»§ç»­ä¹‹å‰çš„é˜¶æ®µï¼Ÿ
                </Text>

                <View style={styles.buttonRow}>
                    <TouchableOpacity
                        style={[styles.button, styles.restartButton]}
                        onPress={onRestart}
                    >
                        <Text style={styles.restartText}>é‡æ–°å¼€å§‹æœ¬è½®</Text>
                    </TouchableOpacity>

                    <TouchableOpacity
                        style={[styles.button, styles.continueButton]}
                        onPress={onContinue}
                    >
                        <Text style={styles.continueText}>ç»§ç»­å­¦ä¹ </Text>
                    </TouchableOpacity>
                </View>
            </View>
        </View>
    );
}

const styles = StyleSheet.create({
    overlay: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        justifyContent: 'center',
        alignItems: 'center',
        zIndex: 1000,
    },
    card: {
        width: '85%',
        maxWidth: 400,
        backgroundColor: Colors.paper, // slightly off-white like the Phonics card
        borderRadius: 20,
        padding: 24,
        alignItems: 'center',
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.25,
        shadowRadius: 10,
        elevation: 10,
    },
    title: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 20,
        color: Colors.ink,
        marginBottom: 12,
        textAlign: 'center',
    },
    description: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 15,
        color: Colors.taupe,
        textAlign: 'center',
        lineHeight: 22,
        marginBottom: 24,
    },
    buttonRow: {
        flexDirection: 'row',
        width: '100%',
        gap: 12,
        borderTopWidth: 1,
        borderTopColor: '#E0E0E0',
        paddingTop: 16,
    },
    button: {
        flex: 1,
        paddingVertical: 14,
        borderRadius: 12,
        justifyContent: 'center',
        alignItems: 'center',
    },
    restartButton: {
        backgroundColor: '#F5F5F5',
    },
    continueButton: {
        backgroundColor: '#F0F8FF', // Light blueish/interaction hint
    },
    restartText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 15,
        color: '#E63946', // Red destructive color
    },
    continueText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 15,
        color: '#007AFF', // Standard action blue, or we can use another brand color
    },
});
</file>

<file path="src/components/learning/NewWordView.tsx">
import React, { useState } from 'react';
import { useTranslation } from 'react-i18next';
import { View, Text, StyleSheet, Pressable, ScrollView, Dimensions } from 'react-native';
import { Volume2 } from 'lucide-react-native';
import { BlurView } from 'expo-blur';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

// Define types for the word data
export interface WordData {
    id: string;
    thai: string;
    phonetic: string;
    type: string;
    meaning: string;
    definitions: {
        basic: string;
        examples: { thai: string; meaning: string }[];
        usage: {
            grammar: { label: string; content: string; example?: string }[];
            diff: string;
            mistakes: string;
            similar: string;
        };
    };
}

interface NewWordViewProps {
    word: WordData;
    onNext: () => void;
}

type TabType = 'basic' | 'examples' | 'usage';

export const NewWordView: React.FC<NewWordViewProps> = ({ word, onNext }) => {
    const { t } = useTranslation();
    const [isRevealed, setIsRevealed] = useState(false);
    const [activeTab, setActiveTab] = useState<TabType>('basic');

    const handleViewDefinition = () => {
        setIsRevealed(true);
    };

    return (
        <View style={styles.container}>
            <View style={styles.content}>
                {/* Top Section: Word Display */}
                <View style={styles.cardContainer}>
                    <View style={styles.wordCard}>
                        <Text style={styles.thaiWord}>{word.thai}</Text>

                        <View style={styles.phoneticRow}>
                            <Pressable style={styles.audioButton}>
                                <Volume2 size={20} color={Colors.thaiGold} />
                            </Pressable>
                            <Text style={styles.phoneticText}>{word.phonetic}</Text>
                        </View>
                    </View>
                </View>

                {/* Middle Section: Details */}
                <View style={styles.detailsContainer}>
                    {/* Meaning Header */}
                    <View style={styles.meaningHeader}>
                        <Text style={styles.mainMeaning}>{word.meaning}</Text>
                        <View style={styles.typeTag}>
                            <Text style={styles.typeText}>{word.type}</Text>
                        </View>
                    </View>

                    {/* Tabs */}
                    <View style={styles.tabs}>
                        <Pressable
                            style={[styles.tab, activeTab === 'basic' && styles.activeTab]}
                            onPress={() => setActiveTab('basic')}
                        >
                            <Text style={[styles.tabText, activeTab === 'basic' && styles.activeTabText]}>{t('learning.basicDefinition')}</Text>
                        </Pressable>
                        <Pressable
                            style={[styles.tab, activeTab === 'examples' && styles.activeTab]}
                            onPress={() => setActiveTab('examples')}
                        >
                            <Text style={[styles.tabText, activeTab === 'examples' && styles.activeTabText]}>{t('learning.exampleSentences')}</Text>
                        </Pressable>
                        <Pressable
                            style={[styles.tab, activeTab === 'usage' && styles.activeTab]}
                            onPress={() => setActiveTab('usage')}
                        >
                            <Text style={[styles.tabText, activeTab === 'usage' && styles.activeTabText]}>{t('learning.usageDetails')}</Text>
                        </Pressable>
                    </View>

                    {/* Content Area */}
                    <View style={styles.scrollAreaWrapper}>
                        <ScrollView
                            style={styles.scrollArea}
                            contentContainerStyle={styles.scrollContent}
                            showsVerticalScrollIndicator={false}
                        >
                            {activeTab === 'basic' && (
                                <Text style={styles.bodyText}>{word.definitions.basic}</Text>
                            )}

                            {activeTab === 'examples' && (
                                <View style={styles.examplesList}>
                                    {word.definitions.examples.map((ex, index) => (
                                        <View key={index} style={styles.exampleItem}>
                                            <Text style={styles.exampleThai}>{ex.thai}</Text>
                                            <Text style={styles.exampleMeaning}>{ex.meaning}</Text>
                                        </View>
                                    ))}
                                </View>
                            )}

                            {activeTab === 'usage' && (
                                <View style={styles.usageContent}>
                                    <Text style={styles.sectionTitle}>{t('learning.grammarExamples')}</Text>
                                    {word.definitions.usage.grammar.map((g, i) => (
                                        <View key={i} style={styles.grammarItem}>
                                            <Text style={styles.grammarLabel}>{g.label}:</Text>
                                            <Text style={styles.grammarContent}>{g.content}</Text>
                                            {g.example && <Text style={styles.grammarExample}>{g.example}</Text>}
                                        </View>
                                    ))}

                                    <Text style={[styles.sectionTitle, styles.mt4]}>{t('learning.diffWithChinese')}</Text>
                                    <Text style={styles.bodyText}>{word.definitions.usage.diff}</Text>

                                    <Text style={[styles.sectionTitle, styles.mt4]}>{t('learning.commonMistakes')}</Text>
                                    <Text style={styles.bodyText}>{word.definitions.usage.mistakes}</Text>

                                    <Text style={[styles.sectionTitle, styles.mt4]}>{t('learning.similarWordsDiff')}</Text>
                                    <Text style={styles.bodyText}>{word.definitions.usage.similar}</Text>
                                </View>
                            )}
                            <View style={{ height: 100 }} />
                        </ScrollView>

                        {/* Blur Overlay */}
                        {!isRevealed && (
                            <BlurView intensity={20} style={StyleSheet.absoluteFill} tint="light">
                                <View style={styles.blurOverlayContent} />
                            </BlurView>
                        )}
                    </View>
                </View>
            </View>

            {/* Bottom Buttons */}
            <View style={styles.bottomBar}>
                {!isRevealed ? (
                    <Pressable style={styles.mainButton} onPress={handleViewDefinition}>
                        <Text style={styles.mainButtonText}>{t('learning.viewDefinition')}</Text>
                    </Pressable>
                ) : (
                    <Pressable style={styles.mainButton} onPress={onNext}>
                        <Text style={styles.mainButtonText}>{t('learning.nextEnter')}</Text>
                    </Pressable>
                )}
            </View>
        </View>
    );
};

const styles = StyleSheet.create({
    container: {
        flex: 1,
    },
    content: {
        flex: 1,
        paddingHorizontal: 20,
        paddingTop: 10,
    },
    cardContainer: {
        alignItems: 'center',
        marginBottom: 24,
    },
    wordCard: {
        width: '100%',
        backgroundColor: Colors.white,
        borderRadius: 16,
        paddingVertical: 24,
        alignItems: 'center',
        justifyContent: 'center',
        borderWidth: 1,
        borderColor: Colors.sand,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.05,
        shadowRadius: 8,
        elevation: 2,
    },
    thaiWord: {
        fontFamily: Typography.sarabunBold,
        fontSize: 56,
        color: Colors.ink,
        marginBottom: 8,
    },
    phoneticRow: {
        flexDirection: 'row',
        alignItems: 'center',
        gap: 8,
    },
    audioButton: {
        padding: 6,
        backgroundColor: 'rgba(212, 175, 55, 0.1)',
        borderRadius: 20,
    },
    phoneticText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 18,
        color: Colors.taupe,
    },
    detailsContainer: {
        flex: 1,
    },
    meaningHeader: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        marginBottom: 24,
        gap: 12,
    },
    mainMeaning: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 24,
        color: Colors.ink,
    },
    typeTag: {
        backgroundColor: 'rgba(212, 175, 55, 0.1)',
        paddingHorizontal: 8,
        paddingVertical: 4,
        borderRadius: 6,
    },
    typeText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 12,
        color: Colors.thaiGold,
    },
    tabs: {
        flexDirection: 'row',
        backgroundColor: Colors.white,
        borderRadius: 12,
        padding: 4,
        marginBottom: 16,
        borderWidth: 1,
        borderColor: Colors.sand,
    },
    tab: {
        flex: 1,
        paddingVertical: 8,
        alignItems: 'center',
        borderRadius: 8,
    },
    activeTab: {
        backgroundColor: 'rgba(212, 175, 55, 0.15)',
    },
    tabText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 13,
        color: Colors.taupe,
    },
    activeTabText: {
        color: Colors.ink,
        fontWeight: '600',
    },
    scrollAreaWrapper: {
        flex: 1,
        position: 'relative',
        borderRadius: 12,
        overflow: 'hidden',
    },
    scrollArea: {
        flex: 1,
    },
    scrollContent: {
        padding: 4,
    },
    blurOverlayContent: {
        flex: 1,
        backgroundColor: 'rgba(250, 249, 246, 0.6)', // Colors.paper with opacity
    },
    bodyText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 15,
        lineHeight: 24,
        color: Colors.ink,
    },
    examplesList: {
        gap: 16,
    },
    exampleItem: {
        backgroundColor: Colors.white,
        padding: 16,
        borderRadius: 12,
        borderLeftWidth: 3,
        borderLeftColor: Colors.thaiGold,
        borderWidth: 1,
        borderColor: 'rgba(0,0,0,0.03)',
    },
    exampleThai: {
        fontFamily: Typography.sarabunRegular,
        fontSize: 16,
        color: Colors.ink,
        marginBottom: 4,
    },
    exampleMeaning: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.taupe,
    },
    usageContent: {
        gap: 12,
    },
    sectionTitle: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.thaiGold,
        marginBottom: 8,
    },
    grammarItem: {
        marginBottom: 8,
    },
    grammarLabel: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 14,
        color: Colors.ink,
    },
    grammarContent: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.ink,
        marginTop: 2,
    },
    grammarExample: {
        fontFamily: Typography.sarabunRegular,
        fontSize: 14,
        color: Colors.taupe,
        marginTop: 2,
        fontStyle: 'italic',
    },
    mt4: {
        marginTop: 16,
    },
    bottomBar: {
        flexDirection: 'row',
        padding: 20,
        gap: 16,
        backgroundColor: Colors.paper,
        borderTopWidth: 1,
        borderTopColor: Colors.sand,
    },
    mainButton: {
        flex: 1,
        backgroundColor: Colors.ink,
        borderRadius: 12,
        alignItems: 'center',
        justifyContent: 'center',
        paddingVertical: 14,
        shadowColor: Colors.thaiGold,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.2,
        shadowRadius: 8,
        elevation: 4,
    },
    mainButtonText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.white,
    },
});
</file>

<file path="src/components/learning/ReviewWordView.tsx">
import React, { useState } from 'react';
import { useTranslation } from 'react-i18next';
import { View, Text, StyleSheet, Pressable, ScrollView } from 'react-native';
import { Volume2 } from 'lucide-react-native';
import { BlurView } from 'expo-blur';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { WordData } from './NewWordView';

interface ReviewWordViewProps {
    word: WordData;
    onAnswer: (quality: 'know' | 'unsure' | 'forgot') => void;
    onNext: () => void;
}

export const ReviewWordView: React.FC<ReviewWordViewProps> = ({ word, onAnswer, onNext }) => {
    const { t } = useTranslation();
    const [isRevealed, setIsRevealed] = useState(false);

    const handleReveal = (quality: 'know' | 'unsure' | 'forgot') => {
        setIsRevealed(true);
        onAnswer(quality);
    };

    // Extract the first example sentence for the context view
    const exampleSentence = word.definitions.examples[0];

    return (
        <View style={styles.container}>
            <ScrollView style={styles.scrollView} contentContainerStyle={styles.scrollContent}>
                {/* Top Section: Word & Phonetic */}
                <View style={styles.topSection}>
                    <Text style={styles.thaiWord}>{word.thai}</Text>

                    <View style={styles.phoneticRow}>
                        <Pressable style={styles.audioButton}>
                            <Volume2 size={20} color={Colors.thaiGold} />
                        </Pressable>
                        <Text style={styles.phoneticText}>{word.phonetic}</Text>
                    </View>
                </View>

                {/* Context Sentence */}
                {exampleSentence && (
                    <View style={styles.contextContainer}>
                        <Text style={styles.contextThai}>
                            {/* Simple logic to bold the word in the sentence if possible, otherwise just show sentence */}
                            {exampleSentence.thai}
                        </Text>
                        <Text style={styles.contextMeaning}>{exampleSentence.meaning}</Text>
                    </View>
                )}

                {/* Blurred Content Area */}
                <View style={styles.blurredAreaContainer}>
                    <View style={styles.blurredContent}>
                        <View style={styles.meaningHeader}>
                            <Text style={styles.mainMeaning}>{word.meaning}</Text>
                            <View style={styles.typeTag}>
                                <Text style={styles.typeText}>{word.type}</Text>
                            </View>
                        </View>
                        <Text style={styles.definitionText}>{word.definitions.basic}</Text>
                    </View>

                    {!isRevealed && (
                        <BlurView intensity={60} style={StyleSheet.absoluteFill} tint="dark">
                            <View style={styles.blurOverlay} />
                        </BlurView>
                    )}
                </View>
            </ScrollView>

            {/* Bottom Buttons */}
            <View style={styles.bottomBar}>
                {!isRevealed ? (
                    <View style={styles.buttonGrid}>
                        <Pressable
                            style={[styles.actionButton, styles.btnForgot]}
                            onPress={() => handleReveal('forgot')}
                        >
                            <Text style={[styles.btnText, styles.textForgot]}>{t('learning.forgot')}</Text>
                        </Pressable>

                        <Pressable
                            style={[styles.actionButton, styles.btnUnsure]}
                            onPress={() => handleReveal('unsure')}
                        >
                            <Text style={[styles.btnText, styles.textUnsure]}>{t('learning.unsure')}</Text>
                        </Pressable>

                        <Pressable
                            style={[styles.actionButton, styles.btnKnow]}
                            onPress={() => handleReveal('know')}
                        >
                            <Text style={[styles.btnText, styles.textKnow]}>{t('learning.know')}</Text>
                        </Pressable>
                    </View>
                ) : (
                    <Pressable style={styles.nextButton} onPress={onNext}>
                        <Text style={styles.nextButtonText}>{t('learning.next')}</Text>
                    </Pressable>
                )}
            </View>
        </View>
    );
};

const styles = StyleSheet.create({
    container: {
        flex: 1,
    },
    scrollView: {
        flex: 1,
    },
    scrollContent: {
        paddingHorizontal: 24,
        paddingTop: 40,
        paddingBottom: 100,
        alignItems: 'center',
    },
    topSection: {
        alignItems: 'center',
        marginBottom: 32,
    },
    thaiWord: {
        fontFamily: Typography.sarabunBold,
        fontSize: 64,
        color: Colors.ink,
        marginBottom: 12,
    },
    phoneticRow: {
        flexDirection: 'row',
        alignItems: 'center',
        gap: 12,
    },
    audioButton: {
        padding: 8,
        backgroundColor: 'rgba(212, 175, 55, 0.1)',
        borderRadius: 20,
    },
    phoneticText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 20,
        color: Colors.taupe,
    },
    contextContainer: {
        width: '100%',
        backgroundColor: Colors.white,
        padding: 20,
        borderRadius: 16,
        borderWidth: 1,
        borderColor: Colors.sand,
        marginBottom: 32,
    },
    contextThai: {
        fontFamily: Typography.sarabunRegular,
        fontSize: 18,
        color: Colors.ink,
        marginBottom: 8,
        lineHeight: 28,
    },
    contextMeaning: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.taupe,
    },
    blurredAreaContainer: {
        width: '100%',
        minHeight: 200,
        borderRadius: 16,
        overflow: 'hidden',
        position: 'relative',
        backgroundColor: Colors.white,
        borderWidth: 1,
        borderColor: Colors.sand,
    },
    blurredContent: {
        padding: 24,
        alignItems: 'center',
    },
    blurOverlay: {
        flex: 1,
        backgroundColor: 'rgba(26, 26, 26, 0.8)', // Dark overlay for better contrast with white text if needed, or match design
    },
    meaningHeader: {
        flexDirection: 'row',
        alignItems: 'center',
        gap: 12,
        marginBottom: 16,
    },
    mainMeaning: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 24,
        color: Colors.ink,
    },
    typeTag: {
        backgroundColor: 'rgba(212, 175, 55, 0.1)',
        paddingHorizontal: 8,
        paddingVertical: 4,
        borderRadius: 6,
    },
    typeText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 12,
        color: Colors.thaiGold,
    },
    definitionText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 16,
        color: Colors.ink,
        textAlign: 'center',
        lineHeight: 24,
    },
    bottomBar: {
        position: 'absolute',
        bottom: 0,
        left: 0,
        right: 0,
        padding: 24,
        backgroundColor: Colors.paper,
        borderTopWidth: 1,
        borderTopColor: Colors.sand,
    },
    buttonGrid: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        gap: 16,
    },
    actionButton: {
        flex: 1,
        paddingVertical: 16,
        borderRadius: 12,
        alignItems: 'center',
        justifyContent: 'center',
    },
    btnForgot: {
        backgroundColor: '#FEF2F2',
        borderWidth: 1,
        borderColor: '#FCA5A5',
    },
    textForgot: {
        color: '#DC2626',
    },
    btnUnsure: {
        backgroundColor: '#FFFBEB',
        borderWidth: 1,
        borderColor: '#FCD34D',
    },
    textUnsure: {
        color: '#D97706',
    },
    btnKnow: {
        backgroundColor: '#ECFDF5',
        borderWidth: 1,
        borderColor: '#6EE7B7',
    },
    textKnow: {
        color: '#059669',
    },
    btnText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
    },
    nextButton: {
        backgroundColor: Colors.ink,
        paddingVertical: 16,
        borderRadius: 12,
        alignItems: 'center',
    },
    nextButtonText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.white,
    },
});
</file>

<file path="src/config/alphabet/alphabetQuestionTypes.ts">
// src/components/alphabet/alphabetQuestionTypes.ts

export type AlphabetQuestionType =
  | 'soundToLetter'   // å¬éŸ³ â†’ é€‰å­—æ¯
  | 'letterToSound'   // çœ‹å­—æ¯ â†’ é€‰å‘éŸ³
  | 'reading';        // çœ‹éŸ³èŠ‚/è¯ â†’ é€‰è¯»éŸ³ï¼ˆæ‹¼è¯»ï¼‰

export interface AlphabetQuestionOption {
  id: string;
  label: string;        // å±•ç¤ºç»™ç”¨æˆ·çš„æ–‡å­—ï¼ˆå­—æ¯ or å‘éŸ³ï¼‰
  helper?: string;      // å¯é€‰è¾…åŠ©è¯´æ˜ï¼ˆå¦‚ IPA / ä¸­æ–‡æç¤ºï¼‰
}

export interface AlphabetReviewQuestion {
  id: string;
  type: AlphabetQuestionType;
  prompt: string;
  audioUrl?: string;    // å¬éŸ³é¢˜ç”¨
  mainText?: string;    // ä¸»ä½“å±•ç¤ºï¼ˆå­—æ¯/éŸ³èŠ‚/è¯ï¼‰
  options: AlphabetQuestionOption[];
  correctOptionId: string;
  explanation?: string; // å›ç­”åæ˜¾ç¤ºçš„æ‹¼è¯»è§„åˆ™è¯´æ˜
}
</file>

<file path="src/config/alphabet/phonicsRules.config.ts">
// src/config/alphabet/phonicsRules.config.ts

import type { PhonicsRule, PhonicsRuleId } from '@/src/entities/types/phonicsRule.types';

/**
 * 6è¯¾æ‹¼è¯»è§„åˆ™å®Œæ•´é…ç½®
 * 
 * æ¯è¯¾ä¸€ä¸ªæ‹¼è¯»è§„åˆ™,åœ¨Today Learningé¦–æ¬¡è¿›å…¥æ—¶æ˜¾ç¤º
 * 
 * @version 1.0.0
 * @see PhonicsRuleCard.tsx
 */
export const PHONICS_RULES: Record<PhonicsRuleId, PhonicsRule> = {
  /**
   * Lesson 1: åŸºç¡€æ‹¼è¯» - CVç»“æ„
   */
  rule_1_cv_structure: {
    id: 'rule_1_cv_structure',
    lessonId: 'lesson1',
    title: 'æ‹¼è¯»è§„åˆ™ 1: è¾…éŸ³+å…ƒéŸ³',
    content: [
      'âœ… æ³°è¯­éŸ³èŠ‚ = è¾…éŸ³(C) + å…ƒéŸ³(V)',
      'âœ… å…ƒéŸ³å¯åœ¨è¾…éŸ³å‰/å/ä¸Š/ä¸‹',
      'âœ… ä¾‹: à¸ + à¸² = à¸à¸² [ka:] (ä¹Œé¸¦)',
      '',
      'ğŸ¯ è®°å¿†å£è¯€: å…ˆè¯»è¾…éŸ³,å†è¯»å…ƒéŸ³',
    ],
    interactiveExample: {
      consonant: 'à¸',
      vowel: 'à¸²',
      syllable: 'à¸à¸²',
      pronunciation: 'ka:',
      audioUrl: 'https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/word-ka.mp3',
    },
    duration: 30,
    order: 1,
  },

  /**
   * Lesson 2: å‰ç½®å…ƒéŸ³ç³»ç»Ÿ
   */
  rule_2_leading_vowel: {
    id: 'rule_2_leading_vowel',
    lessonId: 'lesson2',
    title: 'æ‹¼è¯»è§„åˆ™ 2: å‰ç½®å…ƒéŸ³',
    content: [
      'âš ï¸ å†™åœ¨è¾…éŸ³å‰,è¯»åœ¨è¾…éŸ³å',
      '',
      'âœ… à¹€à¸ = [ke:] ä¸æ˜¯ [ek]',
      'âœ… à¹à¸¡ = [mÉ›:] ä¸æ˜¯ [É›m]',
      'âœ… à¹‚à¸£ = [ro:] ä¸æ˜¯ [or]',
      '',
      'ğŸ¯ è®°å¿†å£è¯€: çœ‹åˆ° à¹€ à¹ à¹‚,å…ˆè¯»è¾…éŸ³å†è¯»å…ƒéŸ³',
    ],
    interactiveExample: {
      consonant: 'à¸',
      vowel: 'à¹€',
      syllable: 'à¹€à¸',
      pronunciation: 'ke:',
      audioUrl: 'https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/syllable-ke.mp3',
    },
    duration: 30,
    order: 2,
  },

  /**
   * Lesson 3: å£°è°ƒç³»ç»Ÿå…¥é—¨
   */
  rule_3_tone_basics: {
    id: 'rule_3_tone_basics',
    lessonId: 'lesson3',
    title: 'æ‹¼è¯»è§„åˆ™ 3: å£°è°ƒå…¥é—¨',
    content: [
      'ğŸµ æ³°è¯­5ä¸ªå£°è°ƒ:',
      '  1. ä¸­å¹³è°ƒ Â¯ (å¦‚: à¸à¸² [ka:Â¯])',
      '  2. ä½é™è°ƒ ` (å¦‚: à¸à¹ˆà¸² [kÃ :])',
      '  3. é™è°ƒ Ë† (å¦‚: à¸à¹‰à¸² [kÃ¢:])',
      '  4. é«˜è°ƒ Â´ (å¦‚: à¸à¹Šà¸² [kÃ¡:])',
      '  5. å‡è°ƒ Ë‡ (å¦‚: à¸à¹‹à¸² [kÇ:])',
      '',
      'ğŸ“Œ å£°è°ƒç”±4ä¸ªå› ç´ å†³å®š:',
      '  â€¢ è¾…éŸ³ç±»(é«˜/ä¸­/ä½)',
      '  â€¢ å…ƒéŸ³é•¿çŸ­',
      '  â€¢ å£°è°ƒç¬¦å·(à¹ˆ à¹‰ à¹Š à¹‹)',
      '  â€¢ éŸ³èŠ‚ç±»å‹(Live/Dead)',
    ],
    visualChart: {
      columns: ['è¾…éŸ³ç±»', 'é•¿+æ— ', 'çŸ­+æ— ', 'à¹ˆ', 'à¹‰'],
      rows: [
        ['ä¸­è¾…éŸ³', 'Â¯', '`', '`', 'Ë†'],
        ['é«˜è¾…éŸ³', 'Â´', '`', '`', 'Ë†'],
      ],
      interactive: true,
    },
    duration: 45,
    order: 3,
  },

  /**
   * Lesson 4: è¾…éŸ³ç±»ä¸å£°è°ƒè§„åˆ™
   */
  rule_4_consonant_class_tones: {
    id: 'rule_4_consonant_class_tones',
    lessonId: 'lesson4',
    title: 'æ‹¼è¯»è§„åˆ™ 4: è¾…éŸ³ç±»ä¸å£°è°ƒ',
    content: [
      'ğŸ”‘ æ ¸å¿ƒæ¦‚å¿µ: åŒæ ·çš„å…ƒéŸ³+ç¬¦å·,ä¸åŒè¾…éŸ³ç±» â†’ ä¸åŒå£°è°ƒ',
      '',
      'ä¾‹: à¸² + æ— ç¬¦å·',
      '  â€¢ à¸ + à¸² = à¸à¸² [ä¸­å¹³Â¯] (ä¸­è¾…éŸ³)',
      '  â€¢ à¸‚ + à¸² = à¸‚à¸² [å‡è°ƒÂ´] (é«˜è¾…éŸ³)',
      '  â€¢ à¸„ + à¸² = à¸„à¸² [ä¸­å¹³Â¯] (ä½è¾…éŸ³)',
      '',
      'ğŸ¯ å­¦ä¹ ç­–ç•¥:',
      '  1. å…ˆè®°è¾…éŸ³ç±»(é«˜/ä¸­/ä½)',
      '  2. å†æŸ¥å£°è°ƒè¡¨',
      '  3. å¤šå¬å¤šç»ƒ,å½¢æˆç›´è§‰',
    ],
    visualChart: {
      columns: ['è¾…éŸ³ç±»', 'é•¿+æ— ', 'çŸ­+æ— ', 'à¹ˆ', 'à¹‰', 'à¹Š', 'à¹‹'],
      rows: [
        ['ä¸­è¾…éŸ³', 'Â¯', '`', '`', 'Ë†', 'Â´', 'Ë‡'],
        ['é«˜è¾…éŸ³', 'Â´', '`', '`', 'Ë†', '-', '-'],
        ['ä½è¾…éŸ³', 'Â¯', 'Â´', 'Ë†', 'Â´', '-', '-'],
      ],
      interactive: true,
    },
    duration: 45,
    order: 4,
  },

  /**
   * Lesson 5: å¤åˆå…ƒéŸ³æ‹¼è¯»
   */
  rule_5_compound_vowels: {
    id: 'rule_5_compound_vowels',
    lessonId: 'lesson5',
    title: 'æ‹¼è¯»è§„åˆ™ 5: å¤åˆå…ƒéŸ³',
    content: [
      'ğŸ”— å¤åˆå…ƒéŸ³ = 2-3ä¸ªå…ƒéŸ³ç¬¦å·ç»„åˆ',
      '',
      'âœ… à¹€à¸­à¸µà¸¢ [ia]: à¹€ + à¸µ + à¸¢',
      '   ä¾‹: à¹€à¸¡à¸µà¸¢ [mia] (å¦»å­)',
      '',
      'âœ… à¹€à¸­à¸·à¸­ [É¯a]: à¹€ + à¸· + à¸­',
      '   ä¾‹: à¹€à¸¡à¸·à¸­à¸‡ [mÉ¯aÅ‹] (åŸå¸‚)',
      '',
      'âœ… à¸­à¸±à¸§ [ua]: à¸± + à¸§',
      '   ä¾‹: à¸„à¸§à¸²à¸¢ [khwaËy] (æ°´ç‰›)',
      '',
      'ğŸ“Œ æ‹¼è¯»æŠ€å·§: å…ˆè¯»è¾…éŸ³,å†æ»‘è¿‡æ•´ä¸ªå¤åˆå…ƒéŸ³',
    ],
    interactiveExample: {
      consonant: 'à¸¡',
      vowel: 'à¹€à¸­à¸µà¸¢',
      syllable: 'à¹€à¸¡à¸µà¸¢',
      pronunciation: 'mia',
      audioUrl: 'https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/word-mia.mp3',
    },
    duration: 30,
    order: 5,
  },

  /**
   * Lesson 6: ç‰¹æ®Šè§„åˆ™æ±‡æ€»
   */
  rule_6_special_cases: {
    id: 'rule_6_special_cases',
    lessonId: 'lesson6',
    title: 'æ‹¼è¯»è§„åˆ™ 6: ç‰¹æ®Šè§„åˆ™',
    content: [
      'ğŸ”¸ à¸: ä½œå£°æ¯è¯» [y],ä½œå°¾éŸ³è¯» [n]',
      '   ä¾‹: à¸à¸²à¸•à¸´ [yÃ¢Ët] (äº²æˆš), à¸«à¸à¸´à¸‡ [yÇÅ‹] (å¥³äºº)',
      '',
      'ğŸ”¸ à¸¤/à¸¦: æ¢µæ–‡ä¸“ç”¨,ç°ä»£æ³°è¯­å°‘è§',
      '   ä¾‹: à¸¤à¸”à¸¹ [rÉ¯ÌdÃ¹Ë] (å­£èŠ‚)',
      '',
      'ğŸ”¸ à¸« + ä½è¾…éŸ³: å˜é«˜è°ƒè§„åˆ™',
      '   ä¾‹: à¸«à¸™à¸¹ [nÇ”Ë] = à¸«(é™éŸ³) + à¸™à¸¹ (å˜é«˜è°ƒ)',
      '',
      'ğŸ”¸ à¹„/à¹ƒ: åŒéŸ³ä¸åŒå½¢,à¹ƒä»…28ä¸ªè¯',
      '   ä¾‹: à¹ƒà¸à¸¥à¹‰ [klÃ¢y] (è¿‘), à¹„à¸à¸¥ [klay] (è¿œ)',
    ],
    duration: 40,
    order: 6,
  },
};

/**
 * æ ¹æ®è¯¾ç¨‹IDè·å–æ‹¼è¯»è§„åˆ™
 */
export function getPhonicsRuleByLesson(lessonId: string): PhonicsRule | null {
  const ruleId = `rule_${lessonId.replace('lesson', '')}_` as PhonicsRuleId;
  
  const ruleMap: Record<string, PhonicsRuleId> = {
    lesson1: 'rule_1_cv_structure',
    lesson2: 'rule_2_leading_vowel',
    lesson3: 'rule_3_tone_basics',
    lesson4: 'rule_4_consonant_class_tones',
    lesson5: 'rule_5_compound_vowels',
    lesson6: 'rule_6_special_cases',
  };
  
  const actualRuleId = ruleMap[lessonId];
  return actualRuleId ? PHONICS_RULES[actualRuleId] : null;
}

/**
 * è·å–æ‰€æœ‰æ‹¼è¯»è§„åˆ™(æŒ‰é¡ºåº)
 */
export function getAllPhonicsRules(): PhonicsRule[] {
  return Object.values(PHONICS_RULES).sort((a, b) => a.order - b.order);
}
</file>

<file path="src/config/backend.config.ts">
// src/config/backend.config.ts

import { BackendType } from './api.endpoints';

/**
 * åç«¯é…ç½®
 * 
 * ğŸ”§ åˆ‡æ¢åç«¯åªéœ€è¦ä¿®æ”¹ CURRENT_BACKEND
 */

// ==================== ğŸ”§ åˆ‡æ¢åç«¯çš„åœ°æ–¹ ====================
export const CURRENT_BACKEND: BackendType = 
  (process.env.EXPO_PUBLIC_BACKEND as BackendType) || 'cloudbase';

// æç¤ºï¼šåœ¨ .env æ–‡ä»¶ä¸­è®¾ç½® EXPO_PUBLIC_BACKEND=cloudbase æˆ– java

// ==================== åç«¯é…ç½® ====================
export const BACKEND_CONFIG = {
  // CloudBase äº‘å‡½æ•°
  cloudbase: {
    name: 'CloudBase_CloudFunction',
    env: process.env.EXPO_PUBLIC_CLOUDBASE_ENV || 
         'cloud1-1gjcyrdd7ab927c6-1387301748',
    region: process.env.EXPO_PUBLIC_CLOUDBASE_REGION || 'ap-shanghai',
    apiBaseUrl: process.env.EXPO_PUBLIC_API_BASE_URL || 
                'https://cloud1-1gjcyrdd7ab927c6-1387301748.ap-shanghai.app.tcloudbase.com',
  },
  
  // Java Spring Boot
  java: {
    name: 'Java_SpringBoot',
    apiBaseUrl: process.env.EXPO_PUBLIC_JAVA_API_URL || 
                'http://localhost:8080',
    // æœªæ¥ç”Ÿäº§ç¯å¢ƒï¼š'https://api.thailearning.com'
  },
};

// ==================== è·å–å½“å‰åç«¯é…ç½® ====================
export function getCurrentBackendConfig() {
  return BACKEND_CONFIG[CURRENT_BACKEND];
}

// ==================== è·å– API åŸºç¡€åœ°å€ ====================
export function getApiBaseUrl(): string {
  return getCurrentBackendConfig().apiBaseUrl;
}

// ==================== è·å–åç«¯åç§° ====================
export function getBackendName(): string {
  return getCurrentBackendConfig().name;
}

// ==================== åˆ¤æ–­æ˜¯å¦ä¸º CloudBase ====================
export function isCloudBase(): boolean {
  return CURRENT_BACKEND === 'cloudbase';
}

// ==================== åˆ¤æ–­æ˜¯å¦ä¸º Java ====================
export function isJava(): boolean {
  return CURRENT_BACKEND === 'java';
}

// ==================== æ‰“å°å½“å‰é…ç½®ï¼ˆå¼€å‘ç”¨ï¼‰====================
export function logBackendInfo() {
  if (__DEV__) {
    console.log('='.repeat(50));
    console.log('ğŸ”§ å½“å‰åç«¯é…ç½®:');
    console.log('åç«¯ç±»å‹:', CURRENT_BACKEND);
    console.log('åç«¯åç§°:', getBackendName());
    console.log('API åœ°å€:', getApiBaseUrl());
    console.log('='.repeat(50));
  }
}
</file>

<file path="src/constants/typography.ts">
// src/constants/typography.ts
export const Typography = {
    playfairRegular: 'PlayfairDisplay_400Regular',
    playfairBold: 'PlayfairDisplay_700Bold',
    notoSerifRegular: 'NotoSerifSC_400Regular',
    notoSerifBold: 'NotoSerifSC_700Bold',
    sarabunRegular: 'Sarabun_400Regular',
    sarabunBold: 'Sarabun_700Bold',
    // Font sizes
    h1: 32,
    h2: 24,
    h3: 20,
    body: 16,
    caption: 14,
    small: 12,
    // Font weights (as string for fontWeight property)
    regular: '400' as const,
    semibold: '600' as const,
    bold: '700' as const,
  } as const;
</file>

<file path="src/dev/mocks/phonicsRule.mock.ts">
// src/dev/mocks/phonicsRule.mock.ts

import { PhonicsRule, PhonicsRuleId } from "@/src/entities/types/phonicsRule.types";

/**
 * æ‹¼è¯»è§„åˆ™ Mock å·¥å‚
 * åŒ…å«å¤šç§åœºæ™¯çš„æµ‹è¯•æ•°æ®
 */
export const MOCK_PHONICS_RULES: Record<string, PhonicsRule> = {
    // 1. æ ‡å‡†åœºæ™¯
    standard: {
        id: "mock_rule_standard" as PhonicsRuleId,
        lessonId: "mock_lesson_1",
        title: "æ‹¼è¯»è§„åˆ™ 1: è¾…éŸ³+å…ƒéŸ³",
        content: [
            "âœ… æ³°è¯­éŸ³èŠ‚ = è¾…éŸ³(C) + å…ƒéŸ³(V)",
            "âœ… å…ƒéŸ³å¯åœ¨è¾…éŸ³å‰/å/ä¸Š/ä¸‹",
            "âœ… ä¾‹: à¸ + à¸² = à¸à¸² [ka:] (ä¹Œé¸¦)",
            "",
            "ğŸ¯ è®°å¿†å£è¯€: å…ˆè¯»è¾…éŸ³,å†è¯»å…ƒéŸ³"
        ],
        interactiveExample: {
            consonant: "à¸",
            vowel: "à¸²",
            syllable: "à¸à¸²",
            pronunciation: "ka:",
            audioUrl: "https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/word-ka.mp3"
        },
        duration: 30,
        order: 1
    },

    // 2. è¶…é•¿æ–‡æœ¬åœºæ™¯ (æµ‹è¯• ScrollView)
    long_text: {
        id: "mock_rule_long" as PhonicsRuleId,
        lessonId: "mock_lesson_2",
        title: "éå¸¸é•¿çš„è§„åˆ™æ ‡é¢˜æµ‹è¯•éå¸¸é•¿çš„è§„åˆ™æ ‡é¢˜æµ‹è¯•éå¸¸é•¿çš„è§„åˆ™æ ‡é¢˜æµ‹è¯•",
        content: [
            "âœ… ç¬¬ä¸€è¡Œå†…å®¹",
            "âœ… ç¬¬äºŒè¡Œå†…å®¹éå¸¸éå¸¸é•¿ï¼Œç”¨æ¥æµ‹è¯•å½“æ–‡å­—è¶…è¿‡ä¸€è¡Œæ—¶æ˜¯å¦ä¼šè‡ªåŠ¨æ¢è¡Œï¼Œä»¥åŠå¯¹å¸ƒå±€çš„å½±å“ã€‚",
            "âœ… ç¬¬ä¸‰è¡Œå†…å®¹",
            "",
            "âœ… ä»¥ä¸‹æ˜¯é‡å¤å†…å®¹ï¼Œç”¨äºæ’‘å¼€é«˜åº¦æµ‹è¯•æ»šåŠ¨ï¼š",
            ...Array(20).fill("ğŸ“ é‡å¤çš„æµ‹è¯•æ–‡æœ¬è¡Œï¼Œç”¨äºéªŒè¯ ScrollView çš„æ»šåŠ¨èƒ½åŠ›æ˜¯å¦æ­£å¸¸å·¥ä½œã€‚"),
            "",
            "ğŸ¯ ç»“æŸè¡Œ"
        ],
        interactiveExample: {
            consonant: "à¸",
            vowel: "à¸²",
            syllable: "à¸à¸²",
            pronunciation: "ka:",
            audioUrl: "https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/word-ka.mp3"
        },
        duration: 60,
        order: 2
    },

    // 3. æ— äº¤äº’ç¤ºä¾‹åœºæ™¯
    no_interactive: {
        id: "mock_rule_simple" as PhonicsRuleId,
        lessonId: "mock_lesson_3",
        title: "çº¯æ–‡æœ¬è§„åˆ™",
        content: [
            "è¿™æ˜¯ä¸€ä¸ªæ²¡æœ‰ä¸‹æ–¹äº¤äº’æŒ‰é’®çš„è§„åˆ™ã€‚",
            "ä»…åŒ…å«æ–‡æœ¬è¯´æ˜ã€‚",
            "ç”¨æ¥æµ‹è¯•å¸ƒå±€æ”¶ç¼©æ˜¯å¦æ­£å¸¸ã€‚"
        ],
        duration: 15,
        order: 3
    },

    // 4. å¸¦æœ‰å¤æ‚å›¾è¡¨çš„åœºæ™¯
    with_chart: {
        id: "mock_rule_chart" as PhonicsRuleId,
        lessonId: "mock_lesson_4",
        title: "å£°è°ƒå›¾è¡¨è§„åˆ™",
        content: [
            "è¿™ä¹Ÿæ˜¯ä¹‹å‰å¼•èµ· Crash çš„å¤æ‚æƒ…å†µã€‚",
            "è¯·æ£€æŸ¥å›¾è¡¨æ¸²æŸ“ã€‚"
        ],
        visualChart: {
            columns: ["", "å¹³", "äºŒ", "ä¸‰", "å››", "äº”"],
            rows: [
                ["ä¸­è¾…éŸ³", "-", "\\", "^", "/", "v"],
                ["é«˜è¾…éŸ³", "v", "\\", "^", "(N/A)", "(N/A)"]
            ],
            interactive: true
        },
        duration: 45,
        order: 4
    }
};
</file>

<file path="src/dev/registry.ts">
// src/dev/registry.ts

export interface PlaygroundComponent {
    id: string;
    name: string;
    category: string;
    variants: {
        id: string;
        name: string;
        mockId: string; // å¯¹åº” Mock æ•°æ®çš„ key
    }[];
}

export const COMPONENT_REGISTRY: PlaygroundComponent[] = [
    {
        id: 'PhonicsRuleCard',
        name: 'Phonics Rule Card',
        category: 'Learning',
        variants: [
            { id: 'standard', name: 'æ ‡å‡†åœºæ™¯', mockId: 'standard' },
            { id: 'long_text', name: 'è¶…é•¿æ–‡æœ¬æµ‹è¯•', mockId: 'long_text' },
            { id: 'no_interactive', name: 'æ— äº¤äº’ç¤ºä¾‹', mockId: 'no_interactive' },
            { id: 'with_chart', name: 'å¸¦å›¾è¡¨', mockId: 'with_chart' },
        ],
    },
    // å°†æ¥å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ›´å¤šç»„ä»¶ï¼Œå¦‚ RecoveryModal, RoundCompletionView ç­‰
];
</file>

<file path="src/entities/types/alphabetGameTypes.ts">
// src/entities/enum/alphabetGameTypes.ts

/**
 * Alphabet Game Type Enum
 *
 * å®šä¹‰å­—æ¯æ¨¡å—çš„ç»Ÿä¸€é¢˜å‹åè®®
 * æŒ‰ç…§ alphabet-module-spec.md ç¬¬6ç« å’Œ PROJECT_OVERVIEW_SPEC.md 4.3èŠ‚ Phase 2 è¦æ±‚
 *
 * é¢˜å‹åˆ†ä¸ºä¸¤ç±»:
 * - åŸºç¡€é¢˜å‹(LIGHT_GAME_TYPES): ç”¨äºä¸‰æ–°ä¸€å¤(THREE_NEW_ONE_REVIEW)é˜¶æ®µ
 * - è¿›é˜¶é¢˜å‹(ADVANCED_GAME_TYPES): ç”¨äº Final Review é˜¶æ®µ
 */
export enum AlphabetGameType {
  // ===== åŸºç¡€é¢˜å‹ (ç”¨äºä¸‰æ–°ä¸€å¤) =====

  /** å¬éŸ³é€‰å­— - æ’­æ”¾å­—æ¯å‘éŸ³,ç”¨æˆ·ä»é€‰é¡¹ä¸­é€‰æ‹©æ­£ç¡®çš„æ³°æ–‡å­—æ¯ */
  SOUND_TO_LETTER = 'SOUND_TO_LETTER',

  /** çœ‹å­—é€‰éŸ³ - æ˜¾ç¤ºæ³°æ–‡å­—æ¯,ç”¨æˆ·ä»é€‰é¡¹ä¸­é€‰æ‹©æ­£ç¡®çš„å‘éŸ³ */
  LETTER_TO_SOUND = 'LETTER_TO_SOUND',

  // ===== è¿›é˜¶é¢˜å‹ (ç”¨äº Final Review) =====

  /** è¾…éŸ³ç±»åˆ«åˆ¤æ–­ - åˆ¤æ–­å­—æ¯å±äºé«˜/ä¸­/ä½è¾…éŸ³ */
  CONSONANT_CLASS = 'CONSONANT_CLASS',

  /** é¦–è¾…éŸ³åˆ¤æ–­ - åˆ¤æ–­å­—æ¯çš„é¦–è¾…éŸ³å‘éŸ³ */
  INITIAL_SOUND = 'INITIAL_SOUND',

  /** å°¾è¾…éŸ³åˆ¤æ–­ - åˆ¤æ–­å­—æ¯ä½œä¸ºå°¾éŸ³æ—¶çš„å‘éŸ³ */
  FINAL_SOUND = 'FINAL_SOUND',

  /** å£°è°ƒè®¡ç®— - æ ¹æ®è¾…éŸ³ç±»åˆ«+å…ƒéŸ³+å£°è°ƒç¬¦å·è®¡ç®—æœ€ç»ˆå£°è°ƒ (å ä½å®ç°) */
  TONE_CALCULATION = 'TONE_CALCULATION',

  /** æ‹¼è¯»æ•°å­¦ - è¾…éŸ³+å…ƒéŸ³çš„æ‹¼è¯»ç»„åˆç»ƒä¹  (å ä½å®ç°) */
  PHONICS_MATH = 'PHONICS_MATH',
}

/**
 * é¢˜å‹æ˜¾ç¤ºåç§°æ˜ å°„
 */
export const ALPHABET_GAME_TYPE_LABELS: Record<AlphabetGameType, string> = {
  [AlphabetGameType.SOUND_TO_LETTER]: 'å¬éŸ³é€‰å­—',
  [AlphabetGameType.LETTER_TO_SOUND]: 'çœ‹å­—é€‰éŸ³',
  [AlphabetGameType.CONSONANT_CLASS]: 'è¾…éŸ³ç±»åˆ«',
  [AlphabetGameType.INITIAL_SOUND]: 'é¦–éŸ³åˆ¤æ–­',
  [AlphabetGameType.FINAL_SOUND]: 'å°¾éŸ³åˆ¤æ–­',
  [AlphabetGameType.TONE_CALCULATION]: 'å£°è°ƒè®¡ç®—',
  [AlphabetGameType.PHONICS_MATH]: 'æ‹¼è¯»æ•°å­¦',
};

/**
 * é¢˜å‹éš¾åº¦ç­‰çº§ (1-5)
 */
export const ALPHABET_GAME_TYPE_DIFFICULTY: Record<AlphabetGameType, number> = {
  [AlphabetGameType.SOUND_TO_LETTER]: 1,
  [AlphabetGameType.LETTER_TO_SOUND]: 1,
  [AlphabetGameType.CONSONANT_CLASS]: 2,
  [AlphabetGameType.INITIAL_SOUND]: 2,
  [AlphabetGameType.FINAL_SOUND]: 3,
  [AlphabetGameType.TONE_CALCULATION]: 4,
  [AlphabetGameType.PHONICS_MATH]: 4,
};
</file>

<file path="src/entities/types/api.types.ts">
//src/entities/types/api.types.ts
//ç”¨äºAPIæ¥å£çš„ç±»å‹å®šä¹‰ï¼Œä½¿ API å“åº”ç»Ÿä¸€æ ¼å¼

export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  code?: string;
}

// ==================== è®¤è¯ç›¸å…³ ====================

//ç™»å½•è¯·æ±‚
export interface LoginRequest {
  email: string;
  password: string;
}

//æ³¨å†Œè¯·æ±‚
export interface RegisterRequest {
  email: string;
  password: string;
  displayName: string;
}

//ç™»å½•å“åº”
export interface LoginResponse {
  user: {
    userId: string;
    email: string;
    displayName: string;
    role: string;
    registrationDate: string;
    avatar?: string;
  };
  token: string;
  expiresIn: number;  // Token è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰
}

//æ³¨å†Œå“åº”
export interface RegisterResponse extends LoginResponse { }

//æ›´æ–°ç”¨æˆ·ä¿¡æ¯è¯·æ±‚
export interface UpdateProfileRequest {
  displayName?: string;
  avatar?: string;
  // Add other fields if needed
}

export interface ResetPasswordRequest {
  email: string;
}

export interface ResetPasswordResponse {
  message?: string;
}

// ==================== è¯¾ç¨‹ç›¸å…³ ====================

//è·å–è¯¾ç¨‹åˆ—è¡¨å“åº”
export interface GetCoursesResponse {
  courses: Array<{
    courseId: string;
    name: string;
    nameZh: string;
    description: string;
    level: string;
    isActive: boolean;
  }>;
}

//è·å–è¯¾ç¨‹å†…å®¹è¯·æ±‚
export interface GetCourseContentRequest {
  courseId: string;
  contentType: 'alphabet' | 'vocabulary' | 'sentence' | 'article';
}

//è·å–è¯¾ç¨‹å†…å®¹å“åº”
export interface GetCourseContentResponse {
  content: any[];  // æ ¹æ® contentType è¿”å›ä¸åŒç»“æ„
}

// ==================== å­¦ä¹ ç›¸å…³ ====================

//è·å–è¯æ±‡è¯·æ±‚
export interface GetVocabularyRequest {
  courseId: string;
  difficulty?: string;
}

//è·å–è¯æ±‡å“åº”
export interface GetVocabularyResponse {
  vocabulary: Array<{
    vocabId: string;
    thai: string;
    chinese: string;
    pronunciation: string;
    example: string;
    audioUrl?: string;
    difficulty: string;
  }>;
}

//è®°å½•å­¦ä¹ è¯·æ±‚
export interface RecordLearningRequest {
  contentType: 'alphabet' | 'vocabulary' | 'sentence' | 'article';
  contentId: string;
  isCorrect: boolean;
  score?: number;
}

// ==================== è¿›åº¦ç›¸å…³ ====================

//è·å–è¿›åº¦å“åº”
export interface GetProgressResponse {
  progressId: string;
  userId: string;
  courseId: string;
  currentLevel: string;
  completedAlphabets: number;
  completedVocabulary: number;
  completedSentences: number;
  completedArticles: number;
  totalScore: number;
  studyTime: number;
  streakDays: number;
}

// ==================== å‘éŸ³è¯„ä¼° ====================

//å‘éŸ³è¯„ä¼°è¯·æ±‚
export interface AssessPronunciationRequest {
  audioData: string;  // Base64 ç¼–ç çš„éŸ³é¢‘
  targetText: string;
  language: string;  // 'th' for Thai
}

//å‘éŸ³è¯„ä¼°å“åº”
export interface AssessPronunciationResponse {
  overallScore: number;
  toneScore: number;
  phonemeScore: number;
  fluencyScore: number;
  feedback: string;
  pitchData?: number[];
}

// ==================== å¤ä¹ ç›¸å…³ ====================

//è·å–å¾…å¤ä¹ å“åº”
export interface GetDueReviewsResponse {
  reviews: Array<{
    scheduleId: string;
    contentType: string;
    contentId: string;
    nextReviewDate: string;
  }>;
}

//æ›´æ–°å¤ä¹ è¯·æ±‚
export interface UpdateReviewRequest {
  scheduleId: string;
  quality: number;  // 1-5
}
</file>

<file path="src/entities/types/course.ts">
export enum Level {
    BEGINNER_A = 'Beginner A',
    BEGINNER_B = 'Beginner B',
    INTERMEDIATE = 'Intermediate',
    ADVANCED = 'Advanced'
}

export interface Course {
    courseId: string;
    name: string;
    nameZh: string;
    level: Level;
    progress: number;
}
</file>

<file path="src/entities/types/learning.ts">
import { Level } from './course';

export interface ReviewItem {
    id: string;
    char: string;
    phonetic: string;
    type: 'New' | 'Review' | 'Hard';
    dueIn: string;
    meaning?: string;
    category?: string;
}

export interface LearningProgress {
    progressId: string;
    userId: string;
    courseId: string;
    currentLevel: Level;
    completedAlphabets: number;
    completedVocabulary: number;
    completedSentences: number;
    completedArticles: number;
    totalScore: number;
    totalStudyTime: number;
    streakDays: number;
    lastUpdated: Date;
}
</file>

<file path="src/entities/types/phonicsRule.types.ts">
// src/entities/types/phonicsRule.types.ts

/**
 * æ‹¼è¯»è§„åˆ™ç±»å‹å®šä¹‰
 * 
 * ç”¨äºV3.0è¯¾ç¨‹æ–¹æ¡ˆçš„æ‹¼è¯»è§„åˆ™å¡ç‰‡ç³»ç»Ÿ
 * å¯¹åº”PhonicsRuleCardç»„ä»¶
 * 
 * @version 1.0.0
 * @see thai_letter_curriculum_SRS_integrated.md
 */

import type { QuestionType } from '../enums/QuestionType.enum';

/**
 * æ‹¼è¯»è§„åˆ™ID (å¯¹åº”6è¯¾)
 */
export type PhonicsRuleId = 
  | 'rule_1_cv_structure'
  | 'rule_2_leading_vowel'
  | 'rule_3_tone_basics'
  | 'rule_4_consonant_class_tones'
  | 'rule_5_compound_vowels'
  | 'rule_6_special_cases';

/**
 * æ‹¼è¯»è§„åˆ™å®Œæ•´å®šä¹‰
 */
export interface PhonicsRule {
  /** è§„åˆ™ID */
  id: PhonicsRuleId;
  
  /** å¯¹åº”è¯¾ç¨‹ID */
  lessonId: string;
  
  /** è§„åˆ™æ ‡é¢˜ */
  title: string;
  
  /** è§„åˆ™å†…å®¹(æ•°ç»„,æ¯é¡¹ä¸ºä¸€è¡Œæ–‡æœ¬) */
  content: string[];
  
  /** äº¤äº’å¼ç¤ºä¾‹(å¯é€‰) */
  interactiveExample?: {
    /** è¾…éŸ³ */
    consonant: string;
    /** å…ƒéŸ³ */
    vowel: string;
    /** ç»„åˆåçš„éŸ³èŠ‚ */
    syllable: string;
    /** å‘éŸ³ */
    pronunciation: string;
    /** éŸ³é¢‘URL */
    audioUrl: string;
  };
  
  /** å¯è§†åŒ–å›¾è¡¨(å¯é€‰,ç”¨äºå£°è°ƒè§„åˆ™ç­‰) */
  visualChart?: {
    /** è¡¨å¤´ */
    columns: string[];
    /** æ•°æ®è¡Œ */
    rows: string[][];
    /** æ˜¯å¦å¯äº¤äº’(ç‚¹å‡»æ’­æ”¾éŸ³é¢‘) */
    interactive?: boolean;
  };
  
  /** æ˜¾ç¤ºæ—¶é•¿(ç§’) */
  duration: number;
  
  /** æ’åºåºå· */
  order: number;
}

/**
 * è¯¾ç¨‹å…ƒæ•°æ®(å«æ‹¼è¯»è§„åˆ™å…³è”)
 */
export interface LessonMetadata {
  /** è¯¾ç¨‹ID */
  lessonId: string;
  
  /** è¯¾ç¨‹æ ‡é¢˜ */
  title: string;
  
  /** è¯¾ç¨‹æè¿° */
  description: string;
  
  /** è¾…éŸ³åˆ—è¡¨ */
  consonants: string[];
  
  /** å…ƒéŸ³åˆ—è¡¨ */
  vowels: string[];
  
  /** å£°è°ƒç¬¦å·åˆ—è¡¨ */
  tones: string[];
  
  /** å…³è”çš„æ‹¼è¯»è§„åˆ™ID */
  phonicsRuleId: PhonicsRuleId;
  
  /** æ€»å­—æ¯æ•° */
  totalCount: number;
  
  /** æœ€ä½é€šè¿‡ç‡(0-1) */
  minPassRate: number;
  
  /** Mini Reviewè§¦å‘é—´éš”(æ¯Nä¸ªå­—æ¯) */
  miniReviewInterval: number;
  
  /** æ’åºåºå· */
  order: number;
}

/**
 * Mini Review é¢˜ç›®å®šä¹‰
 */
export interface MiniReviewQuestion {
  /** é¢˜ç›®ID */
  id: string;
  
  /** é¢˜å‹ */
  type: QuestionType;
  
  /** é¢˜å¹² */
  question: string;
  
  /** å‰¯æ ‡é¢˜(å¯é€‰) */
  subtitle?: string;
  
  /** é€‰é¡¹ */
  options: Array<{
    /** é€‰é¡¹æ–‡æœ¬ */
    label: string;
    /** é€‰é¡¹å€¼ */
    value: string;
    /** ç¤ºä¾‹(å¯é€‰) */
    example?: string;
  }>;
  
  /** æ­£ç¡®ç­”æ¡ˆ */
  correct: string;
  
  /** è§£é‡Š(ç­”é¢˜åæ˜¾ç¤º) */
  explanation?: string;
  
  /** éŸ³é¢‘URL(å¯é€‰) */
  audioUrl?: string;
  
  /** å£°å­¦æç¤º(ç”¨äºé€æ°”éŸ³å¯¹æ¯”ç­‰) */
  acousticHint?: {
    /** æ˜¯å¦é€æ°” */
    aspirated?: boolean;
    /** æ˜¯å¦æ¸…éŸ³ */
    voiceless?: boolean;
    /** è¾…éŸ³ç±» */
    class?: 'high' | 'mid' | 'low';
  };
  
  /** éŸ³é«˜å¯è§†åŒ–(ç”¨äºå£°è°ƒé¢˜) */
  pitchVisualization?: {
    /** æ˜¯å¦å¯ç”¨ */
    enable: boolean;
    /** ç­”é¢˜åæ˜¾ç¤º */
    showAfterAnswer: boolean;
    /** éŸ³é«˜æ›²çº¿æ•°æ® */
    curve: number[];
  };
}

/**
 * ä¸‰è½®è¯„ä¼°é…ç½®
 */
export interface RoundConfig {
  /** æ€»è½®æ•° */
  totalRounds: 3;
  
  /** é€šè¿‡ç‡è¦æ±‚(0-1) */
  passRate: 0.90;
  
  /** æ¯è½®æœ€å¤šå…è®¸çš„é”™è¯¯æ¬¡æ•° */
  maxErrors: number;
}

/**
 * ä¸‰è½®è¯„ä¼°çŠ¶æ€
 */
export interface RoundEvaluationState {
  /** å½“å‰è½®æ•°(1/2/3) */
  currentRound: 1 | 2 | 3;
  
  /** æ¯è½®çš„ç»Ÿè®¡ */
  rounds: Array<{
    /** è½®æ¬¡ç¼–å· */
    roundNumber: number;
    /** æ€»é¢˜æ•° */
    totalQuestions: number;
    /** æ­£ç¡®æ•° */
    correctCount: number;
    /** å‡†ç¡®ç‡(0-1) */
    accuracy: number;
    /** æ˜¯å¦é€šè¿‡ */
    passed: boolean;
  }>;
  
  /** æ˜¯å¦å®Œæˆæ‰€æœ‰è½®æ¬¡ */
  allRoundsPassed: boolean;
}

/**
 * getTodayMemories è¿”å›çš„æ‰©å±•æ•°æ®
 * (åç«¯éœ€æ–°å¢æ­¤å­—æ®µ)
 */
export interface TodayMemoriesWithMetadata {
  /** å­—æ¯åˆ—è¡¨ */
  items: any[];
  
  /** ç»Ÿè®¡ä¿¡æ¯ */
  summary: {
    total: number;
    newCount: number;
    reviewCount: number;
    entityType: string;
  };
  
  /** æ–°å¢: è¯¾ç¨‹å…ƒæ•°æ® */
  lessonMetadata?: LessonMetadata;
  
  /** æ–°å¢: æ‹¼è¯»è§„åˆ™ */
  phonicsRule?: PhonicsRule;
}

/**
 * æœ€å°å¯¹ç«‹ç»„(Minimal Pair)å®šä¹‰
 * ç”¨äºé€æ°”éŸ³å¯¹æ¯”é¢˜å‹
 */
export interface MinimalPairGroup {
  /** æ ¸å¿ƒå­—æ¯ */
  target: string;
  
  /** å¯¹æ¯”å­—æ¯ç»„ */
  contrasts: Array<{
    /** å­—æ¯ */
    char: string;
    /** å¯¹æ¯”ç»´åº¦ */
    dimension: 'aspiration' | 'class' | 'voicing';
    /** è¯´æ˜ */
    label: string;
  }>;
}

/**
 * å…ƒéŸ³é•¿çŸ­å¯¹(Vowel Length Pair)å®šä¹‰
 */
export interface VowelLengthPair {
  /** çŸ­å…ƒéŸ³ */
  short: {
    char: string;
    duration: number; // ms
    example: string;
  };
  
  /** é•¿å…ƒéŸ³ */
  long: {
    char: string;
    duration: number; // ms
    example: string;
  };
}
</file>

<file path="src/entities/types/storage.types.ts">
// src/entities/types/storage.types.ts

export interface StorageDownloadUrlRequest {
  action: 'getDownloadUrl';
  fileId: string;
  maxAge?: number;
}

export interface StorageBatchDownloadUrlRequest {
  action: 'batchGetDownloadUrls';
  fileIds: string[];
  maxAge?: number;
}

export interface StorageFileInfo {
  fileId: string;
  downloadUrl: string | null;
  status: 'success' | 'failed';
  error?: string | null;
}

export interface StorageDownloadUrlResponse {
  fileId: string;
  downloadUrl: string;
  maxAge: number;
  expiresAt: string;
}

export interface StorageBatchDownloadUrlResponse {
  files: StorageFileInfo[];
  summary: {
    total: number;
    success: number;
    failed: number;
  };
  maxAge: number;
  expiresAt: string;
}
</file>

<file path="src/entities/types/test.types.ts">
// src/entities/types/test.types.ts

export interface TestQuestion {
  questionId: string;
  type: 'multiple_choice' | 'audio_match' | 'sequence';
  content: string;
  options: string[];
  correctAnswer: string;
  explanation: string;
}

export interface AlphabetTest {
  testId: string;
  type: 'skip_test' | 'progress_test';
  difficulty: 'basic' | 'intermediate' | 'advanced';
  questions: TestQuestion[];
  passingScore: number;
  timeLimit: number;
}

export interface TestResult {
  score: number;
  passed: boolean;
  correctCount: number;
  totalQuestions: number;
  results: {
    questionId: string;
    userAnswer: string;
    correctAnswer: string;
    isCorrect: boolean;
    explanation: string;
  }[];
  unlocked: boolean;
  message: string;
}
</file>

<file path="src/entities/types/user.ts">
export interface User {
    userId: string;
    email: string;
    displayName: string;
    role: 'LEARNER' | 'ADMIN';
    registrationDate: string;
    avatar?: string;
}

export interface LoginRequest {
    email: string;
    password: string;
}

export interface RegisterRequest {
    email: string;
    password: string;
    displayName: string;
}

export interface ResetPasswordRequest {
    email: string;
}
</file>

<file path="src/entities/types/vocabulary.types.ts">
// src/entities/types/vocabulary.types.ts

/**
 * å•è¯åŸºç¡€ä¿¡æ¯ï¼ˆåŒ¹é…æ•°æ®åº“å®é™…å­—æ®µï¼‰
 */
export interface Vocabulary {
    _id: string;
    vocabularyId: string;        // å¦‚ "BEGINNER_A_7"
    thaiWord: string;            // æ³°è¯­å•è¯ï¼Œå¦‚ "à¸à¸°"
    pronunciation: string;        // å‘éŸ³ï¼Œå¦‚ "gÃ "
    meaning: string;             // ä¸­æ–‡æ„æ€ï¼Œå¦‚ "ä¼°è®¡"
    partOfSpeech: string;        // è¯æ€§ï¼Œå¦‚ "åŠ¨è¯"
    level: string;               // çº§åˆ«ï¼Œå¦‚ "BEGINNER_A"
    lessonNumber: string;        // è¯¾ç¨‹ç¼–å·
    startingLetter: string;      // èµ·å§‹å­—æ¯
    source: string;              // æ¥æºï¼Œå¦‚ "Thai_1"
    audioPath?: string;          // éŸ³é¢‘è·¯å¾„ï¼Œå¦‚ "7.mp3"

    // ä¾‹å¥ï¼ˆåŒ…å«å¤šä¸ªå®ç”¨åœºæ™¯ï¼‰
    exampleSentences?: {
        [key: string]: {
            æ³°è¯­: string;
            å‘éŸ³: string;
            ä¸­æ–‡: string;
        };
    };

    // å¯¹è¯åœºæ™¯
    dialogue?: {
        åœºæ™¯æè¿°: string;
        å¯¹è¯å†…å®¹: {
            [speaker: string]: {
                æ³°è¯­: string;
                ä¸­æ–‡: string;
            };
        };
    };

    // ç”¨æ³•è¯´æ˜
    usage?: {
        è¯­æ³•ç¤ºä¾‹?: {
            ç»“æ„: string;
            è§£é‡Š: string;
            ä½¿ç”¨æŠ€å·§?: string;
        };
        ä¸ä¸­æ–‡å·®å¼‚?: string;
    };

    // å¸¸è§é”™è¯¯
    mistakes?: {
        å‘éŸ³æ˜“é”™ç‚¹?: string;
        ä½¿ç”¨åœºåˆ?: string;
        ç›¸ä¼¼è¯æ±‡åŒºåˆ«?: string;
    };

    // åŒæ ¹è¯
    cognates?: string[];

    // æ—¶é—´æˆ³
    createdAt?: Date | string;
}

/**
 * å•è¯åˆ†ç±»
 */
export type VocabularyCategory =
    | 'daily'      // æ—¥å¸¸ç”¨è¯­
    | 'food'       // é£Ÿç‰©
    | 'travel'     // æ—…æ¸¸
    | 'business'   // å•†åŠ¡
    | 'family'     // å®¶åº­
    | 'number'     // æ•°å­—
    | 'time';      // æ—¶é—´

/**
 * å•è¯å­¦ä¹ çŠ¶æ€
 */
export interface VocabularyLearningState {
    vocabularyId: string;
    thaiWord: string;
    pronunciation: string;
    meaning: string;
    exampleSentences?: Vocabulary['exampleSentences'];
    audioPath?: string;
    // è®°å¿†å¼•æ“ç›¸å…³
    currentAttempts: number;    // å½“å‰å°è¯•æ¬¡æ•°
    requiredAttempts: number;   // éœ€è¦å°è¯•æ¬¡æ•°
    qualityHistory: number[];   // è´¨é‡å†å²
    isCompleted: boolean;       // æ˜¯å¦å®Œæˆ
    timestamp: string;          // æ—¶é—´æˆ³
}

/**
 * ä»Šæ—¥å•è¯å“åº”
 */
export interface TodayVocabularyResponse {
    items: Array<{
        _id: string;
        entity: Vocabulary;
        memoryState: {
            nextReviewDate: string;
            repetitions: number;
            easeFactor: number;
        };
    }>;
    unlockInfo?: {
        vocabularyProgress: number;
        nextModuleUnlocked: boolean;
    };
}

/**
 * æäº¤ç»“æœè¯·æ±‚
 */
export interface SubmitVocabularyResultRequest {
    userId: string;
    vocabularyId: string;
    quality: number;  // 1-5 çš„è´¨é‡è¯„åˆ†
}

/**
 * å•è¯è¿›åº¦
 */
export interface VocabularyProgress {
    masteredCount: number;
    totalCount: number;
    accuracy: number;
    masteredIds: string[];
}
</file>

<file path="src/hooks/useModuleAccess.ts">
// src/hooks/useModuleAccess.ts

import { useEffect, useState } from 'react';
import { useRouter } from 'expo-router';
import { Alert } from 'react-native';
import { useModuleAccessStore, type ModuleType } from '@/src/stores/moduleAccessStore';
import { useTranslation } from 'react-i18next';

export function useModuleAccess(
  requiredModule: ModuleType
) {
  const router = useRouter();
  const { t } = useTranslation();
  const { checkAccess, userProgress, isLoading } = useModuleAccessStore();
  const [allowed, setAllowed] = useState(false);
  const [checking, setChecking] = useState(true);

  useEffect(() => {
    verifyAccess();
  }, [requiredModule]);

  const verifyAccess = async () => {
    setChecking(true);
    const hasAccess = await checkAccess(requiredModule);
    setAllowed(hasAccess);
    setChecking(false);

    if (!hasAccess && !isLoading) {
      // Optional: Auto-show alert if needed, but usually controlled by UI
      // showAccessDeniedAlert(); 
    }
  };

  const showAccessDeniedAlert = () => {
    if (!userProgress) return;

    const messages: Record<string, string> = {
      word: t('moduleAccess.prerequisite.word'),
      sentence: t('moduleAccess.prerequisite.sentence'),
      article: t('moduleAccess.prerequisite.article'),
    };

    Alert.alert(
      t('moduleAccess.locked'),
      messages[requiredModule] || t('moduleAccess.lockedMessage', { module: requiredModule }),
      [
        {
          text: t('common.cancel'),
          style: 'cancel',
          onPress: () => {
            // Optional: Navigate back
            router.back();
          }
        },
        {
          text: t('moduleAccess.goBack'), // Or "Go to Learning"
          onPress: () => {
            const redirectMap: Record<string, string> = {
              word: '/(tabs)/courses', // Redirect to courses or alphabet
              sentence: '/(tabs)/courses',
              article: '/(tabs)/courses',
            };
            // router.replace(redirectMap[requiredModule] || '/(tabs)/courses');
            router.back();
          },
        },
      ],
      { cancelable: false }
    );
  };

  return {
    allowed,
    loading: checking || isLoading,
    progress: userProgress,
    checkAccess: verifyAccess,
    showAccessDeniedAlert
  };
}
</file>

<file path="src/stores/learningPreferenceStore.ts">
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';
import type { ModuleType } from './moduleAccessStore';

type DailyLimitMap = Partial<Record<ModuleType, number>>;

interface LearningPreferenceStore {
    dailyLimits: DailyLimitMap;
    setDailyLimit: (module: ModuleType, limit: number) => void;
    hasDailyLimit: (module: ModuleType) => boolean;
}

export const useLearningPreferenceStore = create<LearningPreferenceStore>()(
    persist(
        (set, get) => ({
            dailyLimits: {},
            setDailyLimit: (module, limit) =>
                set((state) => ({
                    dailyLimits: {
                        ...state.dailyLimits,
                        [module]: limit,
                    },
                })),
            hasDailyLimit: (module) => get().dailyLimits[module] !== undefined,
        }),
        {
            name: 'learning-preferences',
            storage: createJSONStorage(() => AsyncStorage),
        }
    )
);
</file>

<file path="src/stores/moduleAccessStore.ts.backup">
// src/stores/moduleAccessStore.ts

/**
 * æ¨¡å—è®¿é—®æ§åˆ¶ Store
 * 
 * åŠŸèƒ½ï¼š
 * 1. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æŸä¸ªæ¨¡å—
 * 2. ç¼“å­˜è®¿é—®æƒé™ç»“æœ
 * 3. æä¾›å…¨å±€è¿›åº¦æ•°æ®
 */

import { create } from 'zustand';
import { callCloudFunction } from '@/src/utils/apiClient';
import { API_ENDPOINTS } from '@/src/config/api.endpoints';
import { useUserStore } from './userStore';
import { LESSON_METADATA } from '@/src/config/alphabet/lessonMetadata.config';
import AsyncStorage from '@react-native-async-storage/async-storage';


const getCompletedLessonsStorageKey = (userId: string): string =>
    `@alphabet_completed_lessons_${userId}`;



// ==================== ç±»å‹å®šä¹‰ ====================

/**
 * æ¨¡å—ç±»å‹
 * 
 * æ³¨æ„ï¼š
 * - ä¸åç«¯ memory-engine.checkModuleAccess ä¿æŒä¸€è‡´ï¼Œå­—æ¯æ¨¡å—ä½¿ç”¨ 'letter'
 */
export type ModuleType = 'letter' | 'word' | 'sentence' | 'article';

/**
 * ç”¨æˆ·è¿›åº¦æ•°æ®
 */
export interface UserProgress {
    // å­—æ¯å­¦ä¹ è¿›åº¦
    letterProgress: number;           // 0-1 (åç«¯å­˜å‚¨ä¸ºæ¯”ä¾‹å€¼)
    letterCompleted: boolean;         // Added: Whether letter learning is completed
    letterMasteredCount: number;      // å·²æŒæ¡å­—æ¯æ•°
    letterTotalCount: number;         // æ€»å­—æ¯æ•°

    // å•è¯å­¦ä¹ è¿›åº¦
    wordProgress: number;             // 0-100
    wordMasteredCount: number;        // å·²æŒæ¡å•è¯æ•°
    wordTotalCount: number;           // æ€»å•è¯æ•°

    // å¥å­å­¦ä¹ è¿›åº¦
    sentenceProgress: number;         // 0-100
    sentenceMasteredCount: number;    // å·²æŒæ¡å¥å­æ•°
    sentenceTotalCount: number;       // æ€»å¥å­æ•°

    // æ–‡ç« å­¦ä¹ è¿›åº¦
    articleProgress: number;          // 0-100
    articleMasteredCount: number;     // å·²æŒæ¡æ–‡ç« æ•°
    articleTotalCount: number;        // æ€»æ–‡ç« æ•°

    // è§£é”çŠ¶æ€
    wordUnlocked: boolean;            // å•è¯æ¨¡å—æ˜¯å¦è§£é”
    sentenceUnlocked: boolean;        // å¥å­æ¨¡å—æ˜¯å¦è§£é”
    articleUnlocked: boolean;         // æ–‡ç« æ¨¡å—æ˜¯å¦è§£é”

    /**
     * å­—æ¯è¯¾ç¨‹å®Œæˆæƒ…å†µï¼ˆä»…å‰ç«¯ä½¿ç”¨ï¼‰
     * ä¾‹å¦‚: ['lesson1','lesson2',...]
     */
    completedAlphabetLessons?: string[];

    // è®¾ç½®
    dailyLimit?: number;              // æ¯æ—¥å­¦ä¹ æ•°é‡è®¾ç½®
}

/**
 * è®¿é—®æ£€æŸ¥å“åº”
 */
interface CheckAccessResponse {
    allowed: boolean;
    reason?: string;
    requiredProgress?: number;
    currentProgress?: number;
}

/**
 * ç”¨æˆ·è¿›åº¦å“åº”
 */
interface UserProgressResponse {
    progress: UserProgress;
}

// ==================== Store å®šä¹‰ ====================

interface ModuleAccessStore {
    // ===== çŠ¶æ€ =====
    userProgress: UserProgress | null;
    accessCache: Map<ModuleType, boolean>;
    isLoading: boolean;
    error: string | null;

    // ===== æ–¹æ³• =====
    checkAccess: (moduleType: ModuleType) => Promise<boolean>;
    checkAccessLocally: (moduleType: ModuleType) => boolean;
    getUserProgress: () => Promise<void>;
    clearCache: () => void;
    setError: (error: string | null) => void;
    setDailyLimit: (moduleType: ModuleType, limit: number) => void;
    /**
     * æ ‡è®°æŸä¸ªå­—æ¯è¯¾ç¨‹å·²å®Œæˆï¼ˆä»…ç”¨äºå­—æ¯æ¨¡å—è§£é”é“¾è·¯ï¼‰
     */
    markAlphabetLessonCompleted: (lessonId: string) => void;
}

// ==================== é»˜è®¤è¿›åº¦æ•°æ® ====================

const defaultProgress: UserProgress = {
    letterProgress: 0,
    letterCompleted: false,
    letterMasteredCount: 0,
    letterTotalCount: 44,
    wordProgress: 0,
    wordMasteredCount: 0,
    wordTotalCount: 0,
    sentenceProgress: 0,
    sentenceMasteredCount: 0,
    sentenceTotalCount: 0,
    articleProgress: 0,
    articleMasteredCount: 0,
    articleTotalCount: 0,
    wordUnlocked: false,
    sentenceUnlocked: false,
    articleUnlocked: false,
};

// ==================== Store å®ç° ====================

export const useModuleAccessStore = create<ModuleAccessStore>()((set, get) => ({
    // ===== åˆå§‹çŠ¶æ€ =====
    userProgress: null,
    accessCache: new Map<ModuleType, boolean>(),
    isLoading: false,
    error: null,

    // ===== æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™ =====
    /**
     * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æŸä¸ªæ¨¡å—
     * 
     * @param moduleType æ¨¡å—ç±»å‹
     * @returns æ˜¯å¦æœ‰æƒé™è®¿é—®
     */
    checkAccess: async (moduleType: ModuleType): Promise<boolean> => {
        const { accessCache } = get();
        const userId = useUserStore.getState().currentUser?.userId;

        if (!userId) {
            console.warn('âš ï¸ ç”¨æˆ·æœªç™»å½•ï¼Œæ— æ³•æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™');
            return false;
        }

        // 1. æ£€æŸ¥ç¼“å­˜
        if (accessCache.has(moduleType)) {
            const cachedResult = accessCache.get(moduleType);
            console.log(`âœ… ä»ç¼“å­˜è·å– ${moduleType} è®¿é—®æƒé™:`, cachedResult);
            return cachedResult!;
        }

        try {
            set({ isLoading: true, error: null });

            // 2. è°ƒç”¨äº‘å‡½æ•°æ£€æŸ¥æƒé™
            const result = await callCloudFunction<CheckAccessResponse>(
                'checkModuleAccess',
                {
                    userId,
                    moduleType,
                },
                {
                    endpoint: API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase,
                }
            );

            if (result.success && result.data) {
                const allowed = result.data.allowed;

                // 3. ç¼“å­˜ç»“æœ
                const newCache = new Map(accessCache);
                newCache.set(moduleType, allowed);
                set({ accessCache: newCache, isLoading: false });

                console.log(`âœ… ${moduleType} è®¿é—®æƒé™æ£€æŸ¥å®Œæˆ:`, allowed);

                // å¦‚æœä¸å…è®¸ï¼Œè®°å½•åŸå› 
                if (!allowed && result.data.reason) {
                    console.log(`ğŸ“Œ æ‹’ç»åŸå› : ${result.data.reason}`);
                }

                return allowed;
            } else {
                // è¯·æ±‚å¤±è´¥ï¼Œé™çº§å¤„ç†
                console.warn('âš ï¸ äº‘å‡½æ•°è°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°é€»è¾‘åˆ¤æ–­');
                const localAllowed = get().checkAccessLocally(moduleType);

                // ç¼“å­˜æœ¬åœ°åˆ¤æ–­ç»“æœ
                const newCache = new Map(accessCache);
                newCache.set(moduleType, localAllowed);
                set({ accessCache: newCache, isLoading: false });

                return localAllowed;
            }
        } catch (error: any) {
            console.error('âŒ checkAccess error:', error);
            set({ error: error.message || 'æ£€æŸ¥æƒé™å¤±è´¥', isLoading: false });

            // é™çº§åˆ°æœ¬åœ°é€»è¾‘
            const localAllowed = get().checkAccessLocally(moduleType);

            // ç¼“å­˜æœ¬åœ°åˆ¤æ–­ç»“æœ
            const newCache = new Map(get().accessCache);
            newCache.set(moduleType, localAllowed);
            set({ accessCache: newCache });

            return localAllowed;
        }
    },

    // ===== æœ¬åœ°æƒé™æ£€æŸ¥é€»è¾‘ï¼ˆé™çº§æ–¹æ¡ˆï¼‰=====
    /**
     * æœ¬åœ°æƒé™æ£€æŸ¥é€»è¾‘ï¼ˆé™çº§æ–¹æ¡ˆï¼‰
     * 
     * @param moduleType æ¨¡å—ç±»å‹
     * @returns æ˜¯å¦æœ‰æƒé™è®¿é—®
     */
    checkAccessLocally: (moduleType: ModuleType): boolean => {
        const { userProgress } = get();

        if (!userProgress) {
            // å¦‚æœæ²¡æœ‰è¿›åº¦æ•°æ®ï¼Œå…è®¸è®¿é—®å­—æ¯æ¨¡å—ï¼Œå…¶ä»–æ¨¡å—ä¸å…è®¸
            return moduleType === 'letter';
        }

        // ä¸åç«¯ memory-engine.checkModuleAccess çš„æ„å›¾ä¿æŒä¸€è‡´ï¼š
        // - å­—æ¯æ¨¡å—å§‹ç»ˆå¯è®¿é—®
        // - åªè¦ letterCompleted ä¸º trueï¼Œæˆ– letterProgress â‰¥ 0.8ï¼Œæ‰€æœ‰éå­—æ¯æ¨¡å—ç»Ÿä¸€è§£é”
        if (moduleType === 'letter') {
            return true;
        }

        const finishedByTest = !!userProgress.letterCompleted;
        const finishedByProgress = (userProgress.letterProgress ?? 0) >= 0.8;

        return finishedByTest || finishedByProgress;
    },

    // ===== è·å–ç”¨æˆ·è¿›åº¦ =====
    // ===== è·å–ç”¨æˆ·è¿›åº¦ =====
    /**
     * ä»åç«¯è·å–ç”¨æˆ·è¿›åº¦æ•°æ®
     */
    getUserProgress: async (): Promise<void> => {
        const userId = useUserStore.getState().currentUser?.userId;

        if (!userId) {
            console.warn('âš ï¸ ç”¨æˆ·æœªç™»å½•ï¼Œæ— æ³•è·å–è¿›åº¦æ•°æ®');
            set({ userProgress: defaultProgress });
            return;
        }

        try {
            const oldKey = '@alphabet_completed_lessons';
            const oldData = await AsyncStorage.getItem(oldKey);
            if (oldData) {
                await AsyncStorage.removeItem(oldKey);
                console.log('Old key has been delete.');
            }
        } catch (e) {
            console.warn('åˆ é™¤æ—§keyå¤±è´¥ï¼š', e)
        }

        set({ isLoading: true, error: null });

        // Helper to try fetch
        const fetchProgress = async (endpoint: string) => {
            return await callCloudFunction<UserProgressResponse>(
                'getUserProgress',
                { userId, entityType: 'letter' },  // ğŸ”¥ æ·»åŠ  entityType å‚æ•°
                { endpoint }
            );
        };

        try {
            // 1. Try Primary Endpoint (memory-engine)
            let result = await fetchProgress(API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase);

            // 2. Fallback to Legacy Endpoint (learn-vocab) if failed
            if (!result.success) {
                console.warn(`âš ï¸ Primary endpoint failed (${result.error}), trying fallback...`);
                result = await fetchProgress(API_ENDPOINTS.MODULE.CHECK_ACCESS.cloudbase);
            }

            if (result.success && result.data) {
                // ğŸ”¥ Merge with local persisted completed lessons
                let completedAlphabetLessons: string[] = [];
                try {
                    const storageKey = getCompletedLessonsStorageKey(userId)
                    const stored = await AsyncStorage.getItem(storageKey);
                    if (stored) {
                        completedAlphabetLessons = JSON.parse(stored);
                    }
                } catch (e) {
                    console.warn('âš ï¸ Failed to load local completed lessons:', e);
                }

                // If remote has it (unlikely), merge distinct? Or trust local?
                // Rule: Local is the source of truth for this frontend-only field.
                // But if backend sends it, we might want to union. 
                // For now, assume backend sends undefined/empty.
                const remoteCompleted = result.data.progress.completedAlphabetLessons || [];
                const mergedCompleted = Array.from(new Set([...completedAlphabetLessons, ...remoteCompleted]));

                // If local had nothing but remote did (e.g. cloud sync feature added later), we should update local storage too?
                // Yes, harmless to sync back.
                if (mergedCompleted.length > completedAlphabetLessons.length) {
                    const storageKey = getCompletedLessonsStorageKey(userId);
                    void AsyncStorage.setItem(storageKey, JSON.stringify(mergedCompleted));
                }

                set({
                    userProgress: {
                        ...result.data.progress,
                        completedAlphabetLessons: mergedCompleted
                    },
                    isLoading: false,
                });
                console.log('âœ… ç”¨æˆ·è¿›åº¦æ•°æ®å·²æ›´æ–° (Merged):', {
                    ...result.data.progress,
                    completedAlphabetLessons: mergedCompleted
                });
            } else {
                console.warn('âš ï¸ è·å–ç”¨æˆ·è¿›åº¦å¤±è´¥ (Primary & Fallback)ï¼Œä½¿ç”¨é»˜è®¤æ•°æ®');
                // Don't overwrite with default if we have stale data? 
                // Actually, for safety, maybe we should? Or keep stale?
                // Requirements mainly imply getting fresh data. 
                // If failed, we likely shouldn't nuke existing state if it exists, but here we usually start from null/default.
                set({
                    userProgress: defaultProgress,
                    isLoading: false,
                    error: result.error || 'Failed to fetch progress'
                });
            }
        } catch (error: any) {
            console.error('âŒ getUserProgress error:', error);
            set({
                error: error.message || 'è·å–è¿›åº¦å¤±è´¥',
                userProgress: defaultProgress,
                isLoading: false,
            });
        }
    },

    // ===== æ¸…é™¤ç¼“å­˜ =====
    /**
     * æ¸…é™¤è®¿é—®æƒé™ç¼“å­˜
     * ç”¨äºï¼šç”¨æˆ·å®Œæˆå­¦ä¹ åéœ€è¦é‡æ–°æ£€æŸ¥æƒé™
     */
    clearCache: (): void => {
        set({ accessCache: new Map<ModuleType, boolean>() });
        console.log('ğŸ—‘ï¸ è®¿é—®æƒé™ç¼“å­˜å·²æ¸…é™¤');
    },

    // ===== è®¾ç½®é”™è¯¯ =====
    setError: (error: string | null): void => {
        set({ error });
    },

    // ===== æ›´æ–°æ¯æ—¥å­¦ä¹ é‡ï¼ˆå‰ç«¯ç¼“å­˜ï¼‰=====
    setDailyLimit: (moduleType: ModuleType, limit: number) => {
        set((state) => ({
            userProgress: {
                ...(state.userProgress || { ...defaultProgress }),
                dailyLimit: limit,
            },
        }));

        console.log(`ğŸ“Œ å·²æ›´æ–° ${moduleType} dailyLimit ä¸º ${limit}`);
    },

    // ===== æ ‡è®°å­—æ¯è¯¾ç¨‹å®Œæˆï¼ˆå‰ç«¯æœ¬åœ°ï¼‰=====
    markAlphabetLessonCompleted: (lessonId: string) => {
        const totalLessons = Object.keys(LESSON_METADATA).length;
        const coreLessons = 6; // å®Œæˆå‰ 6 è¯¾è§†ä¸ºâ€œæ ¸å¿ƒå­—æ¯å·²å­¦å®Œâ€

        set((state) => {
            const prev = state.userProgress || { ...defaultProgress };

            const prevCompleted = new Set(prev.completedAlphabetLessons ?? []);
            prevCompleted.add(lessonId);
            const completedAlphabetLessons = Array.from(prevCompleted);

            const completedCount = completedAlphabetLessons.length;
            const allLessonsDone = completedCount >= totalLessons;

            // è¿›åº¦ï¼š
            // - å®Œæˆ lesson1-4 è§†ä¸º 0.8
            // - å®Œæˆ lesson1-6 è§†ä¸º 0.9ï¼ˆæ ¸å¿ƒå­—æ¯å…¨éƒ¨å®Œæˆï¼‰
            // - å®Œæˆå…¨éƒ¨ 7 è¯¾è§†ä¸º 1.0ï¼ˆå«ç½•ç”¨/å¤ä½“å­—æ¯ï¼‰
            let nextLetterProgress = prev.letterProgress;
            if (completedCount >= 4 && nextLetterProgress < 0.8) {
                nextLetterProgress = 0.8;
            }
            if (completedCount >= coreLessons && nextLetterProgress < 0.9) {
                nextLetterProgress = 0.9;
            }
            if (completedCount >= totalLessons && nextLetterProgress < 1) {
                nextLetterProgress = 1;
            }

            // å®Œæˆå‰ 6 è¯¾å³è§†ä¸ºæ ¸å¿ƒå­—æ¯å­¦ä¹ å®Œæˆï¼Œ
            // lesson7 ä½œä¸ºè¡¥å……è¯¾ç¨‹ä¸å½±å“å…¶ä»–æ¨¡å—è§£é”
            const coreLessonsDone = completedCount >= coreLessons;
            const nextLetterCompleted =
                prev.letterCompleted || coreLessonsDone;

            const updated: UserProgress = {
                ...prev,
                completedAlphabetLessons,
                letterCompleted: nextLetterCompleted,
                letterProgress: nextLetterProgress,
            };

            // ğŸ”¥ Persist to AsyncStorage (Fire and forget)
            const storageKey = getCompletedLessonsStorageKey(userId);
            AsyncStorage.setItem(storageKey, JSON.stringify(completedAlphabetLessons)).catch(err => {
                console.error('âŒ Failed to persist completed alphabet lessons:', err);
            });

            return {
                userProgress: updated,
                accessCache: allLessonsDone
                    ? new Map<ModuleType, boolean>()
                    : state.accessCache,
            };
        });

        console.log(`âœ… å­—æ¯è¯¾ç¨‹å·²å®Œæˆ: ${lessonId}`);
    },
}));
</file>

<file path="src/stores/storageStore.ts">
// src/stores/storageStore.ts

import { create } from 'zustand';
import { callCloudFunction } from '@/src/utils/apiClient';
import { API_ENDPOINTS } from '@/src/config/api.endpoints';
import type {
  StorageDownloadUrlResponse,
  StorageBatchDownloadUrlResponse,
} from '@/src/entities/types/storage.types';

interface StorageStoreState {
  isLoading: boolean;
  error: string | null;

  getDownloadUrl: (fileId: string, maxAge?: number) => Promise<string | null>;
  batchGetDownloadUrls: (
    fileIds: string[],
    maxAge?: number,
  ) => Promise<StorageBatchDownloadUrlResponse | null>;
  clearError: () => void;
}

export const useStorageStore = create<StorageStoreState>((set, get) => ({
  isLoading: false,
  error: null,

  getDownloadUrl: async (fileId: string, maxAge: number = 7200) => {
    set({ isLoading: true, error: null });
    try {
      const res = await callCloudFunction<StorageDownloadUrlResponse>(
        'getDownloadUrl',
        {
          action: 'getDownloadUrl',
          fileId,
          maxAge,
        },
        {
          endpoint: API_ENDPOINTS.STORAGE.GET_DOWNLOAD_URL.cloudbase,
        },
      );

      if (!res.success || !res.data) {
        throw new Error(res.error ?? 'è·å–ä¸‹è½½é“¾æ¥å¤±è´¥');
      }

      set({ isLoading: false });
      return res.data.downloadUrl;
    } catch (e: any) {
      console.error('[storageStore.getDownloadUrl] error:', e);
      set({ isLoading: false, error: e?.message ?? 'è·å–ä¸‹è½½é“¾æ¥å¤±è´¥' });
      return null;
    }
  },

  batchGetDownloadUrls: async (
    fileIds: string[],
    maxAge: number = 7200,
  ) => {
    set({ isLoading: true, error: null });

    if (fileIds.length > 50) {
      set({
        isLoading: false,
        error: 'å•æ¬¡æœ€å¤šæ”¯æŒ 50 ä¸ªæ–‡ä»¶',
      });
      return null;
    }

    try {
      const res = await callCloudFunction<StorageBatchDownloadUrlResponse>(
        'batchGetDownloadUrls',
        {
          action: 'batchGetDownloadUrls',
          fileIds,
          maxAge,
        },
        {
          endpoint: API_ENDPOINTS.STORAGE.BATCH_GET_DOWNLOAD_URLS.cloudbase,
        },
      );

      if (!res.success || !res.data) {
        throw new Error(res.error ?? 'æ‰¹é‡è·å–ä¸‹è½½é“¾æ¥å¤±è´¥');
      }

      set({ isLoading: false });
      return res.data;
    } catch (e: any) {
      console.error('[storageStore.batchGetDownloadUrls] error:', e);
      set({ isLoading: false, error: e?.message ?? 'æ‰¹é‡è·å–ä¸‹è½½é“¾æ¥å¤±è´¥' });
      return null;
    }
  },

  clearError: () => set({ error: null }),
}));
</file>

<file path="src/utils/lettersDistractorEngine.ts">
// src/utils/alphabet/distractorEngine.ts

import type { Letter } from '@/src/entities/types/letter.types';

export interface DistractorOptions {
  count: number;      // å¹²æ‰°é¡¹æ•°é‡
  pool: Letter[];     // å¯ç”¨å­—æ¯æ± ï¼ˆä» store æˆ–çˆ¶ç»„ä»¶ä¼ å…¥ï¼‰
  correct: Letter;    // æ­£ç¡®å­—æ¯
}

/**
 * æŒ‰ä¼˜å…ˆçº§ç”Ÿæˆå¹²æ‰°é¡¹ï¼š
 * 1. ä¸æ­£ç¡®å­—æ¯ class ç›¸åŒï¼ˆé«˜/ä¸­/ä½è¾…éŸ³ï¼‰
 * 2. ä¸æ­£ç¡®å­—æ¯ initialSound ç›¸åŒ
 * 3. å…¶ä½™å­—æ¯
 */
export function generateLetterDistractors(opts: DistractorOptions): Letter[] {
  const { pool, correct, count } = opts;

  if (!pool || pool.length === 0) return [];

  const sameClass = pool.filter(
    (l) => l.class === correct.class && l._id !== correct._id,
  );

  const sameSound = pool.filter(
    (l) => l.initialSound === correct.initialSound && l._id !== correct._id,
  );

  const others = pool.filter((l) => l._id !== correct._id);

  const merged: Letter[] = [...sameClass, ...sameSound, ...others];

  // å»é‡
  const uniqueMap = new Map<string, Letter>();
  merged.forEach((l) => uniqueMap.set(l._id, l));

  const unique = Array.from(uniqueMap.values());

  return unique.slice(0, count);
}
</file>

<file path="src/utils/validation.ts">
// src/utils/validation.ts
/**
 * Frontend Validation Utilities
 * 
 * Purpose: Centralized validation logic for forms
 * Used by: All form components (Login, Register, etc.)
 * 
 * Philosophy: 
 * - Frontend validation for UX (instant feedback)
 * - Backend validation for security (trust nothing from client)
 */

export interface ValidationResult {
  isValid: boolean;
  error?: string;
}

/**
 * Validate email format
 */
export function validateEmail(email: string): ValidationResult {
  if (!email) {
    return {
      isValid: false,
      error: 'Email is required',
    };
  }

  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    return {
      isValid: false,
      error: 'Please enter a valid email address',
    };
  }

  return { isValid: true };
}

/**
 * Validate password strength
 */
export function validatePassword(password: string): ValidationResult {
  if (!password) {
    return {
      isValid: false,
      error: 'Password is required',
    };
  }

  if (password.length < 6) {
    return {
      isValid: false,
      error: 'Password must be at least 6 characters',
    };
  }

  // Optional: Check for password strength
  // const hasNumber = /\d/.test(password);
  // const hasLetter = /[a-zA-Z]/.test(password);
  // if (!hasNumber || !hasLetter) {
  //   return {
  //     isValid: false,
  //     error: 'Password must contain letters and numbers',
  //   };
  // }

  return { isValid: true };
}

/**
 * Validate display name
 */
export function validateDisplayName(name: string): ValidationResult {
  if (!name) {
    return {
      isValid: false,
      error: 'Display name is required',
    };
  }

  if (name.length < 2) {
    return {
      isValid: false,
      error: 'Display name must be at least 2 characters',
    };
  }

  if (name.length > 50) {
    return {
      isValid: false,
      error: 'Display name must be less than 50 characters',
    };
  }

  return { isValid: true };
}

/**
 * Validate password confirmation
 */
export function validatePasswordMatch(
  password: string,
  confirmPassword: string
): ValidationResult {
  if (password !== confirmPassword) {
    return {
      isValid: false,
      error: 'Passwords do not match',
    };
  }

  return { isValid: true };
}

/**
 * Validate registration form
 */
export function validateRegistrationForm(data: {
  email: string;
  password: string;
  confirmPassword: string;
  displayName: string;
}): ValidationResult {
  // Validate display name
  const nameResult = validateDisplayName(data.displayName);
  if (!nameResult.isValid) return nameResult;

  // Validate email
  const emailResult = validateEmail(data.email);
  if (!emailResult.isValid) return emailResult;

  // Validate password
  const passwordResult = validatePassword(data.password);
  if (!passwordResult.isValid) return passwordResult;

  // Validate password match
  const matchResult = validatePasswordMatch(data.password, data.confirmPassword);
  if (!matchResult.isValid) return matchResult;

  return { isValid: true };
}

/**
 * Validate login form
 */
export function validateLoginForm(data: {
  email: string;
  password: string;
}): ValidationResult {
  // Validate email
  const emailResult = validateEmail(data.email);
  if (!emailResult.isValid) return emailResult;

  // Validate password exists
  if (!data.password) {
    return {
      isValid: false,
      error: 'Password is required',
    };
  }

  return { isValid: true };
}

/**
 * Real-time validation helpers for form inputs
 * Use these with onChange handlers for instant feedback
 */
export const realtimeValidators = {
  email: (email: string): string | undefined => {
    if (!email) return undefined; // Don't show error for empty field
    const result = validateEmail(email);
    return result.isValid ? undefined : result.error;
  },

  password: (password: string): string | undefined => {
    if (!password) return undefined;
    const result = validatePassword(password);
    return result.isValid ? undefined : result.error;
  },

  displayName: (name: string): string | undefined => {
    if (!name) return undefined;
    const result = validateDisplayName(name);
    return result.isValid ? undefined : result.error;
  },

  confirmPassword: (password: string, confirmPassword: string): string | undefined => {
    if (!confirmPassword) return undefined;
    const result = validatePasswordMatch(password, confirmPassword);
    return result.isValid ? undefined : result.error;
  },
};
</file>

<file path=".skip-template">
2026-01-04T11:03:56.683Z
</file>

<file path="CLAUDE.md">
# Project Development Rules (Mandatory)

This is an existing, production-oriented project with frozen specifications.
You are NOT working on a greenfield project.

Your primary responsibility is to maintain consistency and prevent structural entropy.

---
## Language Rule (Mandatory)

- All responses MUST be written in **Simplified Chinese**.
- This includes:
  - Explanations
  - Code comments
  - Commit-style summaries
  - Error analysis
- Do NOT switch languages unless explicitly requested.

## 1. Absolute Rules

- Always read and follow all Project Freeze Documents before making any change.
- Treat the current running behavior of the codebase as the source of truth.
- Do NOT design or implement features that are not explicitly requested.

---

## 2. Single Source of Truth

- Every concept must have exactly ONE authoritative definition.
- If multiple definitions exist:
  - Identify which one is currently effective
  - Mark others as deprecated
  - Do NOT create parallel systems

---

## 3. File Creation Rules

Do NOT create new files, enums, configs, or abstractions if:
- A similar concept already exists
- The task can be completed by extending an existing file

File placement rules:
- Constants â†’ src/config/constants.ts
- API endpoints â†’ src/config/api.endpoints.ts
- Enums â†’ src/entities/enums/
- Types / Interfaces â†’ src/entities/types/
- Business logic / generators â†’ src/utils/

---

## 4. Forbidden Behaviors

- Inventing new enums when one already exists
- Duplicating configs between frontend and backend without stating authority
- Implementing future phases not active in the current release
- Refactoring by addition instead of alignment

---

## 5. Documentation Synchronization

Any change that affects:
- behavior
- data flow
- source of truth

MUST be reflected in the Project Freeze Document,
or explicitly noted as a known deviation.

---

## 6. Development Philosophy

Your goal is NOT to make the code perfect.
Your goal is to make it predictable, traceable, and consistent.

When in doubt, do less, not more.

## Mandatory Self-Check

Before writing code, you must silently verify:
- The change complies with all rules above
- No new parallel abstractions are introduced
- The change aligns with the current frozen behavior

If any rule would be violated, you must refuse and explain why.
</file>

<file path="cloudbaserc.json">
{
  "envId": "{{env.ENV_ID}}",
  "functionRoot": "./functions",
  "functions": [],
  "ai": {
    "defaultAgent": "{{env.AI_DEFAULT_AGENT}}",
    "agents": {
      "codex": {
        "type": "custom",
        "baseUrl": "{{env.AI_CODEX_BASE_URL}}",
        "apiKey": "{{env.AI_CODEX_API_KEY}}",
        "model": "{{env.AI_CODEX_MODEL}}"
      }
    }
  }
}
</file>

<file path="convert-json-to-jsonl-but-keep-json.js">
const fs = require('fs');

// âœ… ä½ çš„åŸå§‹é¢˜åº“æ–‡ä»¶ï¼ˆæ•°ç»„æ ¼å¼ï¼‰
const inputFile = './.json';

// âœ… è¯»å–å¹¶è§£æ
const raw = fs.readFileSync(inputFile, 'utf-8');
const data = JSON.parse(raw);

// âœ… è½¬æ¢ä¸º JSON Linesï¼Œä½†ä»ç„¶è¾“å‡ºä¸º .json åç¼€
const output = data.map(item => JSON.stringify(item)).join('\n');

// âœ… è¦†ç›–å†™å›åŸæ–‡ä»¶ï¼ˆåç¼€ä¸å˜ï¼ï¼‰
fs.writeFileSync(inputFile, output, 'utf-8');

console.log('âœ… å·²è½¬æ¢ä¸º JSON Lines æ ¼å¼ï¼ˆåç¼€ä»ä¸º .jsonï¼‰');
console.log('âœ… ç°åœ¨å¯ä»¥ç›´æ¥ä¸Šä¼ åˆ° CloudBase å¯¼å…¥');
</file>

<file path="global.css">
/* global.css */
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="tailwind.config.js">
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
    content: [
      "./app/**/*.{js,jsx,ts,tsx}",
      "./src/components/**/*.{js,jsx,ts,tsx}"
    ],
    presets: [require("nativewind/preset")],
    theme: {
      extend: {
        colors: {
          paper: '#FAF9F6',
          ink: '#1A1A1A',
          sand: '#E5E2DB',
          taupe: '#8E8B82',
          thaiGold: '#D4AF37',
          accent: '#B8956A',
        },
      },
    },
    plugins: [],
  }
</file>

<file path="app/(auth)/forgot-password.tsx">
// app/(auth)/forgot-password.tsx
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { useTranslation } from 'react-i18next';
import Animated, { FadeInDown } from 'react-native-reanimated';
import { Ionicons } from '@expo/vector-icons';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { LanguageSwitcher } from '@/src/components/common/LanguageSwitcher';
import { useUserStore } from '@/src/stores/userStore';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

export default function ForgotPasswordScreen() {
  const { t } = useTranslation();
  const router = useRouter();
  const { requestPasswordReset, isLoading, error, clearError } = useUserStore();

  const [email, setEmail] = useState('');
  const [isEmailSent, setIsEmailSent] = useState(false);

  // Clear error when component unmounts
  useEffect(() => {
    return () => {
      clearError();
    };
  }, []);

  // Show error alert if error changes
  useEffect(() => {
    if (error) {
      Alert.alert(t('common.error'), error);
    }
  }, [error]);

  const handleResetPassword = async () => {
    // Validate email
    if (!email) {
      Alert.alert(t('common.error'), 'Please enter your email address');
      return;
    }

    // Email format validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      Alert.alert(t('common.error'), 'Please enter a valid email address');
      return;
    }

    // Call password reset action
    const success = await requestPasswordReset({ email: email.toLowerCase().trim() });

    if (success) {
      setIsEmailSent(true);
    }
  };

  const handleBackToLogin = () => {
    router.back();
  };

  // If email sent successfully, show success screen
  if (isEmailSent) {
    return (
      <SafeAreaView style={styles.container}>
        <ThaiPatternBackground opacity={0.08} />

        <View style={styles.languageSwitcherContainer}>
          <LanguageSwitcher />
        </View>

        <View style={styles.content}>
          <Animated.View
            entering={FadeInDown.delay(100).duration(500)}
            style={styles.successSection}
          >
            <View style={styles.iconContainer}>
              <Ionicons name="mail-outline" size={64} color={Colors.thaiGold} />
            </View>

            <Text style={styles.successTitle}>Check Your Email</Text>
            <Text style={styles.successMessage}>
              If an account exists for {email}, you will receive password reset instructions shortly.
            </Text>

            <Text style={styles.infoText}>
              Didn't receive the email? Check your spam folder or try again.
            </Text>

            <Pressable style={styles.backButton} onPress={handleBackToLogin}>
              <Text style={styles.backButtonText}>Back to Login</Text>
            </Pressable>

            <Pressable
              style={styles.resendButton}
              onPress={() => {
                setIsEmailSent(false);
                setEmail('');
              }}
            >
              <Text style={styles.resendButtonText}>Try Another Email</Text>
            </Pressable>
          </Animated.View>
        </View>
      </SafeAreaView>
    );
  }

  // Default screen - email input
  return (
    <SafeAreaView style={styles.container}>
      <ThaiPatternBackground opacity={0.08} />

      <View style={styles.languageSwitcherContainer}>
        <LanguageSwitcher />
      </View>

      {/* Back Button */}
      <Pressable style={styles.headerBackButton} onPress={handleBackToLogin}>
        <Ionicons name="arrow-back" size={24} color={Colors.ink} />
      </Pressable>

      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <View style={styles.content}>
          {/* Header */}
          <Animated.View
            entering={FadeInDown.delay(100).duration(500)}
            style={styles.headerSection}
          >
            <View style={styles.iconContainer}>
              <Ionicons name="lock-closed-outline" size={64} color={Colors.thaiGold} />
            </View>
            <Text style={styles.title}>Forgot Password?</Text>
            <Text style={styles.subtitle}>
              Enter your email address and we'll send you instructions to reset your password.
            </Text>
          </Animated.View>

          {/* Form */}
          <Animated.View
            entering={FadeInDown.delay(200).duration(500)}
            style={styles.formSection}
          >
            <View style={styles.inputContainer}>
              <Text style={styles.label}>{t('auth.email')}</Text>
              <TextInput
                style={styles.input}
                placeholder={t('auth.emailPlaceholder')}
                placeholderTextColor={Colors.taupe}
                value={email}
                onChangeText={setEmail}
                keyboardType="email-address"
                autoCapitalize="none"
                autoCorrect={false}
                editable={!isLoading}
              />
            </View>

            <Pressable
              style={[styles.resetButton, isLoading && styles.resetButtonDisabled]}
              onPress={handleResetPassword}
              disabled={isLoading}
            >
              <Text style={styles.resetButtonText}>
                {isLoading ? t('common.loading') : 'Send Reset Link'}
              </Text>
            </Pressable>

            <Pressable
              style={styles.backTextButton}
              onPress={handleBackToLogin}
              disabled={isLoading}
            >
              <Ionicons name="arrow-back" size={16} color={Colors.thaiGold} />
              <Text style={styles.backTextButtonText}>Back to Login</Text>
            </Pressable>
          </Animated.View>
        </View>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.paper,
  },
  languageSwitcherContainer: {
    position: 'absolute',
    top: 60,
    right: 24,
    zIndex: 10,
  },
  headerBackButton: {
    position: 'absolute',
    top: 60,
    left: 24,
    zIndex: 10,
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: Colors.white,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  keyboardView: {
    flex: 1,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    paddingHorizontal: 32,
  },
  headerSection: {
    alignItems: 'center',
    marginBottom: 48,
  },
  iconContainer: {
    width: 120,
    height: 120,
    borderRadius: 60,
    backgroundColor: Colors.white,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  title: {
    fontFamily: Typography.playfairBold,
    fontSize: 28,
    color: Colors.ink,
    marginBottom: 12,
    textAlign: 'center',
  },
  subtitle: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.taupe,
    textAlign: 'center',
    lineHeight: 24,
    paddingHorizontal: 20,
  },
  formSection: {
    width: '100%',
  },
  inputContainer: {
    marginBottom: 24,
  },
  label: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.ink,
    marginBottom: 8,
  },
  input: {
    fontFamily: Typography.notoSerifRegular,
    height: 56,
    backgroundColor: Colors.white,
    borderWidth: 1,
    borderColor: Colors.sand,
    borderRadius: 16,
    paddingHorizontal: 20,
    fontSize: 16,
    color: Colors.ink,
  },
  resetButton: {
    height: 56,
    backgroundColor: Colors.ink,
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  resetButtonDisabled: {
    opacity: 0.6,
  },
  resetButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
    fontWeight: '600',
  },
  backTextButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 24,
    gap: 8,
  },
  backTextButtonText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.thaiGold,
  },
  // Success screen styles
  successSection: {
    alignItems: 'center',
  },
  successTitle: {
    fontFamily: Typography.playfairBold,
    fontSize: 28,
    color: Colors.ink,
    marginBottom: 16,
    textAlign: 'center',
  },
  successMessage: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.ink,
    textAlign: 'center',
    lineHeight: 24,
    marginBottom: 24,
    paddingHorizontal: 20,
  },
  infoText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
    textAlign: 'center',
    lineHeight: 20,
    marginBottom: 32,
    paddingHorizontal: 20,
  },
  backButton: {
    width: '100%',
    height: 56,
    backgroundColor: Colors.ink,
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  backButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
    fontWeight: '600',
  },
  resendButton: {
    width: '100%',
    height: 56,
    backgroundColor: Colors.white,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: Colors.sand,
    alignItems: 'center',
    justifyContent: 'center',
  },
  resendButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.ink,
    fontWeight: '600',
  },
});
</file>

<file path="app/(auth)/register.tsx">
// app/(auth)/register.tsx
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { useTranslation } from 'react-i18next';
import Animated, { FadeInDown } from 'react-native-reanimated';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { LanguageSwitcher } from '@/src/components/common/LanguageSwitcher';
import { useUserStore } from '@/src/stores/userStore';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { validateRegistrationForm } from '@/src/utils/validation';


export default function RegisterScreen() {
  const { t } = useTranslation();
  const router = useRouter();
  const { register, isLoading, error, clearError } = useUserStore();
  const [displayName, setDisplayName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPwd, setConfirmPwd] = useState('');

  // æ¸…ç†é”™è¯¯
  useEffect(() => {
    return () => clearError();
  }, []);

  // æ˜¾ç¤ºé”™è¯¯æç¤º
  useEffect(() => {
    if (error) {
      Alert.alert(t('common.error'), error);
    }
  }, [error]);

  const handleRegister = async () => {

    const validation = validateRegistrationForm({
      email,
      password,
      confirmPassword: confirmPwd,
      displayName
    });
    // éªŒè¯æ ¼å¼æ˜¯å¦æ­£ç¡®
    if (!validation.isValid) {
      Alert.alert('Error', validation.error);
      return; // é˜»æ­¢å‘é€è¯·æ±‚
    }

    const success = await register({
      displayName: displayName.trim(),
      email: email.toLowerCase().trim(),
      password,
    })

     if (success) {
      Alert.alert(
        t('auth.registerSuccess'),
        'Your account has been created successfully!',
        [
          {
            text: 'OK',
            onPress: () => router.replace('/(auth)/login'),
          },
        ]
      );
    }


  };

  return (
    <SafeAreaView style={styles.container}>

      {/* èƒŒæ™¯ */}
      <ThaiPatternBackground opacity={0.08} />

      {/* è¯­è¨€é€‰æ‹©å™¨ */}
      <View style={styles.languageSwitcherContainer}>
        <LanguageSwitcher />
      </View>

      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <View style={styles.content}>
          {/* Logo & Title */}
          <Animated.View
            entering={FadeInDown.delay(100).duration(500)}
            style={styles.headerSection}
          >
            <Text style={styles.logo}>à¸Šà¸²</Text>
            <Text style={styles.title}>{t('auth.title')}</Text>
            <Text style={styles.subtitle}>{t('auth.register')}</Text>
          </Animated.View>

          {/* Register Form */}
          <Animated.View
            entering={FadeInDown.delay(200).duration(500)}
            style={styles.formSection}
          >
            <View style={styles.inputContainer}>
              <Text style={styles.label}>{t('auth.displayName') || 'Display Name'}</Text>
              <TextInput
                style={styles.input}
                placeholder={t('auth.displayNamePlaceholder') || 'Enter your name'}
                placeholderTextColor={Colors.taupe}
                value={displayName}
                onChangeText={setDisplayName}
              />
            </View>

            <View style={styles.inputContainer}>
              <Text style={styles.label}>{t('auth.email')}</Text>
              <TextInput
                style={styles.input}
                placeholder={t('auth.emailPlaceholder')}
                placeholderTextColor={Colors.taupe}
                value={email}
                onChangeText={setEmail}
                keyboardType="email-address"
                autoCapitalize="none"
                autoCorrect={false}
              />
            </View>

            <View style={styles.inputContainer}>
              <Text style={styles.label}>{t('auth.password')}</Text>
              <TextInput
                style={styles.input}
                placeholder={t('auth.passwordPlaceholder')}
                placeholderTextColor={Colors.taupe}
                value={password}
                onChangeText={setPassword}
                secureTextEntry
                autoCapitalize="none"
              />
            </View>

            <View style={styles.inputContainer}>
              <Text style={styles.label}>{t('auth.confirmPassword') || 'Confirm Password'}</Text>
              <TextInput
                style={styles.input}
                placeholder={t('auth.confirmPasswordPlaceholder') || 'Re-enter your password'}
                placeholderTextColor={Colors.taupe}
                value={confirmPwd}
                onChangeText={setConfirmPwd}
                secureTextEntry
                autoCapitalize="none"
              />
            </View>

            <Pressable
              style={[styles.loginButton, isLoading && styles.loginButtonDisabled]}
              onPress={handleRegister}
              disabled={isLoading}
            >
              <Text style={styles.loginButtonText}>
                {isLoading ? t('common.loading') : t('auth.register')}
              </Text>
            </Pressable>

            <View style={styles.registerSection}>
              <Text style={styles.registerText}>{t('auth.alreadyHaveAccount') || 'Already have an account?'}</Text>
              <Pressable onPress={() => router.replace('/(auth)/login')}>
                <Text style={styles.registerLink}>{t('auth.login')}</Text>
              </Pressable>
            </View>
          </Animated.View>
        </View>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.paper,
  },
  languageSwitcherContainer: {
    position: 'absolute',
    top: 60,
    right: 24,
    zIndex: 10,
  },
  keyboardView: {
    flex: 1,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    paddingHorizontal: 32,
  },
  headerSection: {
    alignItems: 'center',
    marginBottom: 48,
  },
  logo: {
    fontFamily: Typography.sarabunBold,
    fontSize: 72,
    color: Colors.thaiGold,
    marginBottom: 8,
  },
  title: {
    fontFamily: Typography.playfairBold,
    fontSize: 28,
    color: Colors.ink,
    marginBottom: 4,
  },
  subtitle: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.taupe,
  },
  formSection: {
    width: '100%',
  },
  inputContainer: {
    marginBottom: 20,
  },
  label: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.ink,
    marginBottom: 8,
  },
  input: {
    fontFamily: Typography.notoSerifRegular,
    height: 56,
    backgroundColor: Colors.white,
    borderWidth: 1,
    borderColor: Colors.sand,
    borderRadius: 16,
    paddingHorizontal: 20,
    fontSize: 16,
    color: Colors.ink,
  },
  loginButton: {
    height: 56,
    backgroundColor: Colors.ink,
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  loginButtonDisabled: {
    opacity: 0.6,
  },
  loginButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
    fontWeight: '600',
  },
  registerSection: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 24,
    gap: 8,
  },
  registerText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  registerLink: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    color: Colors.thaiGold,
    fontWeight: '600',
  },
});
</file>

<file path="app/learning/setup.tsx">
import React, { useMemo, useState } from 'react';
import { View, Text, StyleSheet, Pressable } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter, useLocalSearchParams } from 'expo-router';
import Slider from '@react-native-community/slider';
import { useTranslation } from 'react-i18next';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { useLearningPreferenceStore } from '@/src/stores/learningPreferenceStore';
import { useModuleAccessStore, type ModuleType } from '@/src/stores/moduleAccessStore';
import { useVocabularyStore } from '@/src/stores/vocabularyStore';

export default function DailyLimitSetupScreen() {
    const { t } = useTranslation();
    const router = useRouter();
    const params = useLocalSearchParams();
    const moduleParam = typeof params.module === 'string' ? params.module : 'word';
    const moduleType: ModuleType = moduleParam === 'letter' ? 'letter' : 'word';
    const courseSource = typeof params.source === 'string' ? params.source : undefined;

    const { dailyLimits, setDailyLimit } = useLearningPreferenceStore();
    const { setDailyLimit: setProgressDailyLimit } = useModuleAccessStore();
    const { startCourse } = useVocabularyStore();

    const initialLimit = useMemo(() => dailyLimits[moduleType] || 20, [dailyLimits, moduleType]);
    const [limit, setLimit] = useState(initialLimit);

    const handleConfirm = async () => {
        setDailyLimit(moduleType, limit);
        setProgressDailyLimit(moduleType, limit);

        if (courseSource) {
            await startCourse(courseSource);
        }

        router.replace({
            pathname: '/learning',
            params: {
                module: moduleType,
                source: courseSource,
            },
        });
    };

    return (
        <SafeAreaView style={styles.container}>
            <ThaiPatternBackground opacity={0.1} />
            <View style={styles.header}>
                <Text style={styles.title}>{t('learning.setupTitle', 'ä»Šæ—¥å­¦ä¹ è®¡åˆ’')}</Text>
                <Text style={styles.subtitle}>
                    {moduleType === 'letter'
                        ? t('learning.setupSubtitle', 'é€‰æ‹©ä»Šå¤©è¦å­¦ä¹ /å¤ä¹ çš„å­—æ¯æ•°é‡')
                        : t('learning.setupSubtitleWords', 'é€‰æ‹©ä»Šå¤©è¦å­¦ä¹ /å¤ä¹ çš„å•è¯æ•°é‡')}
                </Text>
            </View>

            <View style={styles.card}>
                <Text style={styles.limitValue}>{limit}</Text>
                <Slider
                    style={styles.slider}
                    minimumValue={5}
                    maximumValue={500}
                    step={5}
                    value={limit}
                    onValueChange={(value) => setLimit(Math.round(value))}
                    minimumTrackTintColor={Colors.thaiGold}
                    maximumTrackTintColor={Colors.sand}
                    thumbTintColor={Colors.ink}
                />
                <View style={styles.limitLabels}>
                    <Text style={styles.limitLabel}>5</Text>
                    <Text style={styles.limitLabel}>500</Text>
                </View>

                <Pressable style={styles.startButton} onPress={handleConfirm}>
                    <Text style={styles.startButtonText}>{t('learning.start', 'å¼€å§‹å­¦ä¹ ')}</Text>
                </Pressable>
            </View>
        </SafeAreaView>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: Colors.paper,
        paddingHorizontal: 24,
        paddingTop: 24,
    },
    header: {
        marginBottom: 24,
        gap: 8,
    },
    title: {
        fontFamily: Typography.playfairBold,
        fontSize: 26,
        color: Colors.ink,
    },
    subtitle: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.taupe,
        lineHeight: 20,
    },
    card: {
        backgroundColor: Colors.white,
        borderRadius: 20,
        padding: 24,
        borderWidth: 1,
        borderColor: Colors.sand,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.05,
        shadowRadius: 10,
        elevation: 4,
    },
    limitValue: {
        fontFamily: Typography.playfairBold,
        fontSize: 42,
        color: Colors.ink,
        textAlign: 'center',
        marginBottom: 12,
    },
    slider: {
        width: '100%',
        height: 40,
    },
    limitLabels: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        marginTop: -8,
        marginBottom: 24,
    },
    limitLabel: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 12,
        color: Colors.taupe,
    },
    startButton: {
        backgroundColor: Colors.ink,
        paddingVertical: 14,
        borderRadius: 14,
        alignItems: 'center',
    },
    startButtonText: {
        color: Colors.white,
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
    },
});
</file>

<file path="cloudbase/functions/alphabet/handlers/passLetterTest.js">
const { createResponse } = require('../utils/response');
/**
 * æ ‡è®°å­—æ¯æµ‹è¯•é€šè¿‡
 * @param {Object} db - æ•°æ®åº“å®ä¾‹
 * @param {Object} data - è¯·æ±‚æ•°æ® { userId }
 */
// âœ… è®°å½•å­—æ¯æµ‹è¯•é€šè¿‡çŠ¶æ€
async function passLetterTest(db, data) {
    const { userId } = data || {};

    if (!userId) {
        return createResponse(false, null, 'userId å‚æ•°ç¼ºå¤±', 'INVALID_PARAMS');
    }

    const now = new Date().toISOString();

    try {
        const updateResult = await db.collection('user_progress')
            .where({ userId })
            .update({
                data: {
                    letterCompleted: true,
                    letterProgress: 1,
                    updatedAt: now
                }
            });
        // 2. å¦‚æœ update è¿”å› 0ï¼ˆè®°å½•ä¸å­˜åœ¨ï¼‰ï¼Œåˆ™ add
        if (updateResult.stats.updated === 0) {
            console.log(`[passLetterTest] è®°å½•ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ›å»º...`);
            await db.collection('user_progress').add({
                data: {
                    userId,
                    letterCompleted: true,
                    letterProgress: 1,
                    letterMasteredCount: 0,
                    letterTotalCount: 44,
                    wordProgress: 0,
                    wordMasteredCount: 0,
                    wordTotalCount: 0,
                    sentenceProgress: 0,
                    sentenceMasteredCount: 0,
                    sentenceTotalCount: 0,
                    articleProgress: 0,
                    articleMasteredCount: 0,
                    articleTotalCount: 0,
                    wordUnlocked: false,
                    sentenceUnlocked: false,
                    articleUnlocked: false,
                    createdAt: now,
                    updatedAt: now
                }
            });
        }

        return createResponse(true, {
            letterCompleted: true,
            letterProgress: 1,
        }, 'å­—æ¯æµ‹è¯•é€šè¿‡ï¼Œæ‰€æœ‰æ¨¡å—å·²è§£é”')
    } catch (error) {
        console.error('[passLetterTest] å†™å…¥è¿›åº¦å¤±è´¥ï¼š', error);
        return createResponse(false, null, 'å†™å…¥è¿›åº¦å¤±è´¥', 'DB_ERROR');
    }
}

module.exports = passLetterTest;
</file>

<file path="cloudbase/functions/alphabet/utils/memoryEngine.js">
/**
 * alphabet/utils/memoryEngine.js
 *
 * è¯´æ˜ï¼š
 *  - æ—©æœŸ alphabet æ¨¡å—å†…å¤åˆ¶äº†ä¸€ä»½è®°å¿†å¼•æ“å®ç°ï¼Œå’Œ memory-engine ä¸‹çš„ utils/memoryEngine åŸºæœ¬é‡å¤ã€‚
 *  - ä¸ºé¿å…é€»è¾‘åˆ†å‰ï¼Œè¿™é‡Œæ”¹ä¸ºç›´æ¥å¤ç”¨ç»Ÿä¸€è®°å¿†å¼•æ“çš„å®ç°ã€‚
 */

module.exports = require('../memory-engine/utils/memoryEngine');
</file>

<file path="cloudbase/functions/alphabet/utils/response.js">
/**
 * å“åº”æ ¼å¼åŒ–æ¨¡å—
 * 
 * ç»Ÿä¸€ API å“åº”æ ¼å¼
 * ä¸å‰ç«¯ ApiResponse<T> ç±»å‹å®šä¹‰ä¿æŒä¸€è‡´
 */

'use strict';

const { ErrorCodes, ERROR_MESSAGES } = require('./constants');

/**
 * åˆ›å»ºæ ‡å‡†åŒ– API å“åº”
 * 
 * å¯¹åº”å‰ç«¯ç±»å‹:
 * interface ApiResponse<T> {
 *   success: boolean;
 *   data?: T;
 *   message?: string;
 *   errorCode?: string;
 *   timestamp: string;
 * }
 * 
 * @param {boolean} success - æ˜¯å¦æˆåŠŸ
 * @param {Object} data - è¿”å›æ•°æ®
 * @param {string} message - æç¤ºæ¶ˆæ¯
 * @param {string} errorCode - é”™è¯¯ç 
 * @returns {Object} æ ‡å‡†åŒ–å“åº”å¯¹è±¡
 */
function createResponse(success, data = null, message = '', errorCode = null) {
  return {
    success,
    data,
    message,
    errorCode,
    timestamp: new Date().toISOString(),
  };
}

/**
 * åˆ›å»ºæˆåŠŸå“åº”
 * 
 * @param {Object} data - è¿”å›æ•°æ®
 * @param {string} message - æˆåŠŸæ¶ˆæ¯
 * @returns {Object} æˆåŠŸå“åº”å¯¹è±¡
 */
function successResponse(data, message = 'æ“ä½œæˆåŠŸ') {
  return createResponse(true, data, message, null);
}

/**
 * åˆ›å»ºé”™è¯¯å“åº”
 * 
 * @param {string} errorCode - é”™è¯¯ç  (æ¥è‡ª ErrorCodes)
 * @param {string} customMessage - è‡ªå®šä¹‰æ¶ˆæ¯ (å¯é€‰)
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function errorResponse(errorCode, customMessage = null) {
  const message = customMessage || ERROR_MESSAGES[errorCode] || 'æœªçŸ¥é”™è¯¯';
  return createResponse(false, null, message, errorCode);
}

/**
 * åˆ›å»ºå‚æ•°é”™è¯¯å“åº”
 * 
 * @param {string} detail - é”™è¯¯è¯¦æƒ…
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function invalidParamsResponse(detail) {
  return errorResponse(ErrorCodes.INVALID_PARAMS, detail);
}

/**
 * åˆ›å»ºç”¨æˆ·ä¸å­˜åœ¨å“åº”
 * 
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function userNotFoundResponse() {
  return errorResponse(ErrorCodes.USER_NOT_FOUND);
}

/**
 * åˆ›å»ºè¯æ±‡ä¸å­˜åœ¨å“åº”
 * 
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function vocabularyNotFoundResponse() {
  return errorResponse(ErrorCodes.VOCABULARY_NOT_FOUND);
}

/**
 * åˆ›å»ºæœåŠ¡å™¨é”™è¯¯å“åº”
 * 
 * @param {Error} error - é”™è¯¯å¯¹è±¡
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function serverErrorResponse(error) {
  // ç”Ÿäº§ç¯å¢ƒä¸æš´éœ²é”™è¯¯è¯¦æƒ…
  const message = process.env.NODE_ENV === 'development' 
    ? `æœåŠ¡å™¨é”™è¯¯: ${error.message}`
    : ERROR_MESSAGES.SERVER_ERROR;
  
  return errorResponse(ErrorCodes.SERVER_ERROR, message);
}

module.exports = {
  createResponse,
  successResponse,
  errorResponse,
  invalidParamsResponse,
  userNotFoundResponse,
  vocabularyNotFoundResponse,
  serverErrorResponse,
};
</file>

<file path="cloudbase/functions/shared/package.json">
{
  "name": "@thai-app/shared",
  "version": "1.0.0",
  "description": "Shared utilities for CloudBase cloud functions",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "cloudbase",
    "shared",
    "utilities"
  ],
  "author": "Liang JianYu",
  "license": "MIT",
  "dependencies": {
    "wx-server-sdk": "~2.6.3"
  }
}
</file>

<file path="cloudbase/functions/user-login/index.js">
// functions/user-login/index.js
const cloud = require('wx-server-sdk');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';
const JWT_EXPIRES_IN = '7d';

exports.main = async (event, context) => {
  try {
    // Parse request body if coming from HTTP trigger
    let requestData = event;
    if (typeof event.body === 'string') {
      try {
        requestData = JSON.parse(event.body);
      } catch (e) {
        return {
          success: false,
          error: 'Invalid JSON in request body',
          code: 'INVALID_JSON'
        };
      }
    } else if (event.body && typeof event.body === 'object') {
      requestData = event.body;
    }

    const { email, password } = requestData;

    // ===== Validation =====
    if (!email || !password) {
      return {
        success: false,
        error: 'Email and password are required',
        code: 'INVALID_INPUT'
      };
    }

    // ===== Find user by email =====
    const userResult = await db.collection('users')
      .where({
        email: email.toLowerCase()
      })
      .get();

    if (userResult.data.length === 0) {
      return {
        success: false,
        error: 'Invalid email or password',
        code: 'INVALID_CREDENTIALS'
      };
    }

    const user = userResult.data[0];

    // ===== Verify password =====
    const isPasswordValid = await bcrypt.compare(password, user.passwordHash);

    if (!isPasswordValid) {
      return {
        success: false,
        error: 'Invalid email or password',
        code: 'INVALID_CREDENTIALS'
      };
    }

    // ===== Check if account is active =====
    if (!user.isActive) {
      return {
        success: false,
        error: 'Account is deactivated',
        code: 'ACCOUNT_DEACTIVATED'
      };
    }

    // ===== Update last login =====
    await db.collection('users')
      .doc(user._id)
      .update({
        data: {
          lastLogin: new Date().toISOString()
        }
      });

    // ===== Generate JWT token =====
    const token = jwt.sign(
      {
        userId: user.userId,
        email: user.email,
        role: user.role
      },
      JWT_SECRET,
      { expiresIn: JWT_EXPIRES_IN }
    );

    // ===== Return user data (exclude password hash and _id) =====
    const { passwordHash, _id, ...userResponse } = user;

    return {
      success: true,
      data: {
        user: userResponse,
        token,
        expiresIn: 604800
      }
    };

  } catch (error) {
    console.error('Login error:', error);
    return {
      success: false,
      error: 'Login failed',
      code: 'SERVER_ERROR'
    };
  }
};
</file>

<file path="cloudbase/functions/user-login/package.json">
{
  "name": "user-login",
  "version": "1.0.0",
  "description": "User login cloud function",
  "main": "index.js",
  "dependencies": {
    "wx-server-sdk": "~2.6.3",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2"
  }
}
</file>

<file path="cloudbase/functions/user-reset-password/index.js">
// functions/user-reset-password/index.js
const cloud = require('wx-server-sdk');
const crypto = require('crypto');

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();

exports.main = async (event, context) => {
  try {
    // Parse request body if coming from HTTP trigger
    let requestData = event;
    if (typeof event.body === 'string') {
      try {
        requestData = JSON.parse(event.body);
      } catch (e) {
        return {
          success: false,
          error: 'Invalid JSON in request body',
          code: 'INVALID_JSON'
        };
      }
    } else if (event.body && typeof event.body === 'object') {
      requestData = event.body;
    }

    const { email } = requestData;

    // ===== Validation =====
    if (!email) {
      return {
        success: false,
        error: 'Email is required',
        code: 'INVALID_INPUT'
      };
    }

    // ===== Find user =====
    const userResult = await db.collection('users')
      .where({
        email: email.toLowerCase()
      })
      .get();

    // For security, always return success even if user not found
    if (userResult.data.length === 0) {
      return {
        success: true,
        data: {
          message: 'If this email is registered, you will receive password reset instructions.'
        }
      };
    }

    const user = userResult.data[0];

    // ===== Generate reset token =====
    const resetToken = crypto.randomBytes(32).toString('hex');
    const resetTokenHash = crypto
      .createHash('sha256')
      .update(resetToken)
      .digest('hex');

    const resetTokenExpiry = new Date(Date.now() + 3600000); // 1 hour from now

    // ===== Save reset token =====
    await db.collection('users')
      .doc(user._id)
      .update({
        data: {
          resetToken: resetTokenHash,
          resetTokenExpiry: resetTokenExpiry.toISOString()
        }
      });

    // ===== Send email (pseudo-code) =====
    // In production, integrate with email service like SendGrid, AWS SES, etc.
    const resetLink = `https://your-app.com/reset-password?token=${resetToken}`;
    
    // TODO: Implement actual email sending
    console.log(`Password reset link for ${email}: ${resetLink}`);
    
    // Placeholder for email service integration:
    // await sendEmail({
    //   to: email,
    //   subject: 'Password Reset Request',
    //   body: `Click this link to reset your password: ${resetLink}`
    // });

    return {
      success: true,
      data: {
        message: 'If this email is registered, you will receive password reset instructions.'
      }
    };

  } catch (error) {
    console.error('Password reset error:', error);
    return {
      success: false,
      error: 'Password reset request failed',
      code: 'SERVER_ERROR'
    };
  }
};
</file>

<file path="cloudbase/functions/user-update-profile/index.js">
// functions/user-update-profile/index.js
const cloud = require('wx-server-sdk');

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();

// Middleware to verify JWT token (simplified)
function verifyToken(event) {
  // In production, verify the JWT token from Authorization header
  // For now, we'll trust the userId from the request
  return event.userId;
}

exports.main = async (event, context) => {
  try {
    // Parse request body if coming from HTTP trigger
    let requestData = event;
    if (typeof event.body === 'string') {
      try {
        requestData = JSON.parse(event.body);
      } catch (e) {
        return {
          success: false,
          error: 'Invalid JSON in request body',
          code: 'INVALID_JSON'
        };
      }
    } else if (event.body && typeof event.body === 'object') {
      requestData = event.body;
    }

    // ===== Verify authentication =====
    const userId = verifyToken(requestData);
    if (!userId) {
      return {
        success: false,
        error: 'Unauthorized',
        code: 'UNAUTHORIZED'
      };
    }

    const { displayName, avatar, preferences } = requestData;

    // ===== Build update object =====
    const updateData = {};
    
    // ===== Validate display name =====
    if (displayName !== undefined) {
      if (displayName.length < 2 || displayName.length > 10) {
        return {
          success: false,
          error: 'Display name must be 2-10 characters',
          code: 'INVALID_DISPLAY_NAME'
        };
      }
      updateData.displayName = displayName;
    }

    // ===== Validate avatar =====
    if (avatar !== undefined) {
      updateData.avatar = avatar;
    }

    // ===== Validate preferences =====
    if (preferences !== undefined) {
      updateData.preferences = preferences;
    }

    if (Object.keys(updateData).length === 0) {
      return {
        success: false,
        error: 'No fields to update',
        code: 'INVALID_INPUT'
      };
    }

    updateData.updatedAt = new Date().toISOString();

    // ===== Update user =====
    const result = await db.collection('users')
      .where({
        userId: userId
      })
      .update({
        data: updateData
      });

    if (result.stats.updated === 0) {
      return {
        success: false,
        error: 'User not found',
        code: 'USER_NOT_FOUND'
      };
    }

    // ===== Get updated user =====
    const userResult = await db.collection('users')
      .where({
        userId: userId
      })
      .get();

    const { passwordHash, _id, ...userResponse } = userResult.data[0];

    return {
      success: true,
      data: userResponse
    };

  } catch (error) {
    console.error('Profile update error:', error);
    return {
      success: false,
      error: 'Profile update failed',
      code: 'SERVER_ERROR'
    };
  }
};
</file>

<file path="cloudbase/test-comprehensive.sh">
#!/bin/bash

echo "======================================"
echo "å®Œæ•´ä¿®å¤: Node.js ç‰ˆæœ¬ + ç¬¦å·é“¾æ¥"
echo "======================================"
echo ""

cd ~/LearnOnThailand/ThaiLearningApp/cloudbase/functions

# 1. ä¿®å¤ shared çš„ Node.js ç‰ˆæœ¬
echo "1ï¸âƒ£ ä¿®å¤ shared æ¨¡å—..."
cd shared
node -e "
const fs = require('fs');
const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
pkg.engines = { node: '>=16.0.0' };
if (!pkg.dependencies) pkg.dependencies = {};
pkg.dependencies['wx-server-sdk'] = '~2.6.3';
fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
console.log('âœ… shared/package.json å·²æ›´æ–°');
"
npm install --production
cd ..

# 2. ä¿®å¤æ¯ä¸ªäº‘å‡½æ•°
for func in alphabet learn-vocab memory-engine; do
  echo ""
  echo "2ï¸âƒ£ å¤„ç† $func..."
  
  cd $func
  
  # æ›´æ–° package.json
  node -e "
  const fs = require('fs');
  const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
  pkg.engines = { node: '18.20.0' };
  fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
  console.log('  âœ… package.json å·²æ›´æ–°');
  "
  
  # åˆ é™¤ç¬¦å·é“¾æ¥,å¤åˆ¶çœŸå®æ–‡ä»¶
  rm -rf node_modules/@thai-app
  mkdir -p node_modules/@thai-app/shared
  cp -r ../shared/*.js node_modules/@thai-app/shared/
  cp ../shared/package.json node_modules/@thai-app/shared/
  cp -r ../shared/node_modules node_modules/@thai-app/shared/ 2>/dev/null || true
  
  echo "  âœ… shared å·²å¤åˆ¶ä¸ºçœŸå®æ–‡ä»¶"
  
  cd ..
done

echo ""
echo "======================================"
echo "3ï¸âƒ£ éªŒè¯é…ç½®..."
echo "======================================"
cd memory-engine
node -e "
try {
  console.log('Node ç‰ˆæœ¬:', process.version);
  const shared = require('@thai-app/shared');
  console.log('âœ… shared æ¨¡å—åŠ è½½æˆåŠŸ');
  console.log('å¯¼å‡º:', Object.keys(shared));
} catch(err) {
  console.error('âŒ', err.message);
  process.exit(1);
}
"
cd ..

echo ""
echo "======================================"
echo "âœ… ä¿®å¤å®Œæˆ! ç°åœ¨é‡æ–°éƒ¨ç½²:"
echo "======================================"
echo "tcb fn deploy memory-engine --runtime Nodejs18.20"
echo "tcb fn deploy alphabet --runtime Nodejs18.20"
echo "tcb fn deploy learn-vocab --runtime Nodejs18.20"
</file>

<file path="docs/project-freeze/backend-memory-engine-spec.md">
# åç«¯ç»Ÿä¸€è®°å¿†å¼•æ“ä¸æ¨¡å—è§£é”è§„æ ¼è¯´æ˜ï¼ˆBackend Memory Engine Spec, Freeze V2.0.1ï¼‰

> ç›®å½•ï¼š`docs/project-freeze/backend-memory-engine-spec.md`  
> èŒƒå›´ï¼š`cloudbase/functions/memory-engine`ã€`cloudbase/functions/learn-vocab` ä¸­ä¸è®°å¿†/è¿›åº¦ç›¸å…³çš„å…¨éƒ¨é€»è¾‘ + æ•°æ®åº“æ ¸å¿ƒé›†åˆã€‚  
> ç›®æ ‡ï¼šç»Ÿä¸€æè¿°åç«¯å¦‚ä½•è°ƒåº¦å¤ä¹ é˜Ÿåˆ—ï¼ˆSMâ€‘2ï¼‰ã€å¦‚ä½•æ§åˆ¶æ¨¡å—è§£é”ï¼Œå¹¶ä¸å‰ç«¯çš„ Alphabet / Vocabulary æ¨¡å—è§„æ ¼å¯¹é½ï¼Œé¿å…å‰åç«¯è¯­ä¹‰ä¸ä¸€è‡´ã€‚

---

## 1. äº‘å‡½æ•°ä¸æ¨¡å—æ€»è§ˆ

### 1.1 memory-engine äº‘å‡½æ•°

**è·¯å¾„**ï¼š`cloudbase/functions/memory-engine`  
**å…¥å£**ï¼š`index.js`  
**è§¦å‘æ–¹å¼**ï¼šHTTP è§¦å‘å™¨ï¼Œç»Ÿä¸€è·¯ç”±å­—æ®µï¼š

```js
// è¯·æ±‚ä½“
{
  action: 'getTodayMemories' | 'submitMemoryResult' | 'submitRoundEvaluation'
        | 'checkModuleAccess' | 'getUserProgress' | 'getAlphabetLessons',
  data: { ... }
}
```

**ä¸»è¦ Actionï¼ˆç°æœ‰ + è§„åˆ’ä¸­çš„æœ€å°é›†åˆï¼‰ï¼š**

- `getTodayMemories`ï¼šç»Ÿä¸€è·å–â€œä»Šæ—¥å­¦ä¹ å†…å®¹â€ï¼ˆå­—æ¯/å•è¯/å¥å­ï¼‰ã€‚  
- `submitMemoryResult`ï¼šç»Ÿä¸€æäº¤å­¦ä¹ ç»“æœï¼Œ**æ”¯æŒå•æ¡å’Œæ‰¹é‡**ã€‚  
- `submitRoundEvaluation`ï¼šå­—æ¯æ¨¡å—ä¸“ç”¨ä¸‰è½®è¯„ä¼°å†™å…¥ `user_alphabet_progress`ã€‚  
- `checkModuleAccess`ï¼šæ£€æŸ¥æ¨¡å—è®¿é—®æƒé™ï¼ˆå­—æ¯å§‹ç»ˆæ”¾è¡Œï¼›å…¶ä»–æ¨¡å—éœ€å®Œæˆä¸€å®šå­—æ¯è¿›åº¦ï¼‰ã€‚  
- `getUserProgress`ï¼šè¿”å› `user_progress` ä¸­çš„å…¨å±€è¿›åº¦ã€‚  
- `getAlphabetLessons`ï¼šè¿”å›å­—æ¯è¯¾ç¨‹é…ç½®ã€‚  
- `registerStudySession`ï¼ˆ**å»ºè®®æ–°å¢ï¼Œæ”¯æŒå‰ç«¯è®°å½•å­¦ä¹ æ—¶é•¿ä¸æ‰“å¡**ï¼‰ï¼š  
  - ç”±å‰ç«¯å­¦ä¹ æ¨¡å—æˆ–å£³å±‚åœ¨ä¸€æ¬¡å­¦ä¹ ç»“æŸæ—¶è°ƒç”¨ï¼›  
  - ç”¨äºæ›´æ–° `user_progress.totalStudyDays / streakDays / lastStudyDate` ä»¥åŠ `LearningStore` éœ€è¦çš„æ€»å­¦ä¹ åˆ†é’Ÿæ•°ï¼ˆå¯æ–°å¢ `totalStudyMinutes` å­—æ®µï¼‰ã€‚

### 1.2 learn-vocab äº‘å‡½æ•°

**è·¯å¾„**ï¼š`cloudbase/functions/learn-vocab`  
**ä½œç”¨**ï¼šæ‰¿è½½**è¯æ±‡ä¸“ç”¨ API**ï¼ˆä¼ ç»Ÿè¯æ±‡æ¨¡å—ï¼‰ï¼ŒåŒ…æ‹¬ï¼š

- `getTodayWords` / `updateMastery` / `toggleSkipWord` / `getVocabularyDetail`  
- `getReviewStatistics` / `getVocabularyList` / `getSkippedWords`

> æ³¨æ„ï¼š`getTodayMemories` / `submitMemoryResult` ç­‰**å·²ç»è¿ç§»è‡³ `memory-engine`**ã€‚learn-vocab æ–‡æ¡£ä»ç„¶æœ‰æ•ˆï¼Œä½†åœ¨é¡¹ç›®å†»ç»“ä¸­ï¼Œè¯æ±‡æ¨¡å—ä¼˜å…ˆä½¿ç”¨ `memory-engine + vocabulary` ç»„åˆï¼ˆè¯¦è§ `vocabulary-module-spec.md`ï¼‰ã€‚

### 1.3 æ ¸å¿ƒæ•°æ®åº“é›†åˆ

é‡è¦é›†åˆè§ `docs/database_schema.md`ï¼Œä¸ memory-engine ç›´æ¥ç›¸å…³çš„æœ‰ï¼š

- `memory_status`ï¼šç»Ÿä¸€è®°å¿†çŠ¶æ€ï¼ˆå­—æ¯/å•è¯/å¥å­ï¼‰ï¼›  
- `user_progress`ï¼šæ•´ä½“æ¨¡å—è§£é”çŠ¶æ€ï¼›  
- `user_alphabet_progress`ï¼šå­—æ¯æ¨¡å—è¯¾ç¨‹çº§è¿›åº¦ï¼ˆå«ä¸‰è½®è¯„ä¼°ï¼‰ï¼›  
- `letters` / `vocabulary` / `sentences`ï¼šå®ä½“å†…å®¹è¡¨ã€‚

---

## 2. ç»Ÿä¸€è®°å¿†å¼•æ“æ ¸å¿ƒé€»è¾‘ï¼ˆmemoryEngine.js + sm2.jsï¼‰

### 2.1 createMemoryRecord / getOrCreateMemory

æ–‡ä»¶ï¼š`cloudbase/functions/memory-engine/utils/memoryEngine.js`

- `createMemoryRecord(db, userId, entityType, entityId, isLocked = false)`ï¼š
  - åœ¨ `memory_status` ä¸­æ’å…¥ä¸€æ¡æ–°çš„è®°å½•ï¼š
    - `masteryLevel: 0.0`  
    - `reviewStage: 0`  
    - `easinessFactor: 2.5`  
    - `intervalDays: 1`  
    - `nextReviewAt`: 1 å¤©åï¼ˆè‹¥ `isLocked === false`ï¼‰ã€‚  
- è‹¥æ’å…¥å› å”¯ä¸€ç´¢å¼•å¤±è´¥ï¼ˆé‡å¤ keyï¼‰ï¼Œä¼šé€€å›åˆ° `where({ userId, entityType, entityId }).get()` å¹¶è¿”å›å·²æœ‰è®°å½•ã€‚

- `getOrCreateMemory(db, userId, entityType, entityId, isLocked = false)`ï¼š
  - å…ˆ `where` æŸ¥è¯¢ï¼Œå¦‚æœå­˜åœ¨åˆ™è¿”å›ç¬¬ä¸€æ¡ï¼›  
  - å¦åˆ™è°ƒç”¨ `createMemoryRecord`ã€‚

### 2.2 updateMemoryAfterReviewï¼ˆSMâ€‘2 æ›´æ–°ï¼‰

`updateMemoryAfterReview(db, userId, entityType, entityId, quality)`ï¼š

- å…¥å‚ `quality` ä¸ºä¸­æ–‡å­—ç¬¦ä¸²ï¼š`'é™Œç”Ÿ' | 'æ¨¡ç³Š' | 'è®°å¾—'`ã€‚  
- æ­¥éª¤ï¼š
  1. é€šè¿‡ `getOrCreateMemory` å–å¾— `memory_status` è®°å½•ã€‚  
  2. ä½¿ç”¨ `calculateSM2Optimized(mastery, memory.intervalDays, memory.easinessFactor, memory.reviewStage)` è®¡ç®—ï¼š  
     - `interval`ï¼ˆä¸‹æ¬¡é—´éš”å¤©æ•°ï¼‰ï¼›  
     - `easinessFactor`ï¼ˆæ–°çš„ EFï¼‰ï¼›  
     - `repetitions`ï¼ˆæ–°çš„ reviewStageï¼‰ã€‚  
  3. æ ¹æ®è´¨é‡è°ƒæ•´ `masteryLevel`ï¼š
     - `è®°å¾—`ï¼š`+0.15`ï¼Œä¸Šé™ `1.0`ï¼›  
     - `æ¨¡ç³Š`ï¼š`+0.05`ï¼Œä¸‹é™ `0.0`ï¼›  
     - `é™Œç”Ÿ`ï¼š`-0.2`ï¼Œä¸‹é™ `0.0`ã€‚  
  4. æ›´æ–°è®¡æ•°ï¼š
     - `streakCorrect`ï¼šè®°å¾—åˆ™ `+1`ï¼Œå¦åˆ™ `0`ï¼›  
     - `correctCount` / `wrongCount`ï¼šåˆ†åˆ«åœ¨è®°å¾— / é™Œç”Ÿæ—¶è‡ªå¢ã€‚  
  5. è®¡ç®— `nextReviewAt = now + intervalDays`ã€‚  
  6. ç”¨ `update({ data: updateData })` å†™å› `memory_status`ã€‚

è¿”å›ç»™è°ƒç”¨æ–¹çš„ç»“æ„ï¼ˆè¢« `submitMemoryResult` åŒ…è£…ï¼‰ï¼š

```js
{
  entityType,
  entityId,
  quality,        // 'é™Œç”Ÿ'/'æ¨¡ç³Š'/'è®°å¾—'
  memoryState: {  // æ›´æ–°åçš„å…³é”®å­—æ®µ
    masteryLevel,
    reviewStage,
    easinessFactor,
    intervalDays,
    nextReviewAt,
    correctCount,
    wrongCount,
    streakCorrect,
  }
}
```

### 2.3 SMâ€‘2 ä¼˜åŒ–ç®—æ³•ï¼ˆsm2.jsï¼‰

`calculateSM2Optimized(mastery, currentInterval, easinessFactor, reviewCount)`ï¼š

- `mastery` åŒæ ·ä½¿ç”¨ `'é™Œç”Ÿ'/'æ¨¡ç³Š'/'è®°å¾—'`ï¼›å†…éƒ¨å…ˆæ˜ å°„åˆ° **Quality**ï¼ˆ1/3/5ï¼‰ã€‚  
- ç®—æ³•è¦ç‚¹ï¼š

1. **é™Œç”Ÿï¼ˆquality < 3ï¼‰**  
   - è§†ä¸ºâ€œå®Œå…¨å¿˜è®°â€ï¼š  
     - `interval = 1`ï¼›  
     - `easinessFactor -= 0.2`ï¼ˆä¸ä½äº `1.3`ï¼‰ï¼›  
     - æ ‡è®° `shouldResetCount = true`ã€‚

2. **æ¨¡ç³Šï¼ˆquality === 3ï¼‰**  
   - ç¼©çŸ­é—´éš”ï¼ŒåŠ å¼ºå¤ä¹ ï¼š  
     - `interval = currentInterval * FUZZY_MULTIPLIERï¼ˆâ‰ˆ0.8ï¼‰`ï¼Œè‡³å°‘ 1 å¤©ï¼›  
     - `easinessFactor -= 0.1`ï¼Œä¸ä½äº `1.3`ã€‚

3. **è®°å¾—ï¼ˆquality > 3ï¼‰**  
   - è‹¥ `reviewCount < EARLY_INTERVALS.length`ï¼Œä½¿ç”¨æ—©æœŸå›ºå®šé—´éš”ï¼š`[1,2,4,7,14]`ï¼›  
   - å¦åˆ™ `interval = round(currentInterval * EF)`ã€‚  
   - æŒ‰æ ‡å‡† SMâ€‘2 å…¬å¼æ›´æ–° EFï¼Œå¹¶é™åˆ¶åœ¨åˆç†åŒºé—´ã€‚

è¿”å›ï¼š

```js
{
  interval,           // ç”¨äº memory_status.intervalDays
  easinessFactor,     // ç”¨äº memory_status.easinessFactor
  repetitions,        // ç”¨äº memory_status.reviewStage
  nextInterval, nextEasinessFactor, nextReviewDate, shouldResetCount
}
```

### 2.4 ä»Šæ—¥å¾…å¤ä¹ å®ä½“ï¼ˆgetTodayReviewEntitiesï¼‰

`getTodayReviewEntities(db, userId, entityType, limit)`ï¼š

- æŸ¥è¯¢æ¡ä»¶ï¼š

```js
where({
  userId,
  entityType,
  isLocked: false,
  nextReviewAt: db.command.lte(new Date())
})
.orderBy('nextReviewAt', 'asc')
.limit(limit)
```

- è¿”å› `memory_status` æ–‡æ¡£æ•°ç»„ï¼Œåç»­ç”± `getTodayMemories` æ‹¼ä¸Šå®ä½“è¯¦æƒ…ã€‚

---

## 3. getTodayMemories è¡Œä¸ºï¼ˆè¯¾ç¨‹æ¨¡å¼ + SRS æ¨¡å¼ï¼‰

æ–‡ä»¶ï¼š`cloudbase/functions/memory-engine/handlers/getTodayMemories.js`

### 3.1 å…¥å£å‚æ•°

```ts
{
  userId: string;
  entityType: 'letter' | 'word' | 'sentence';
  limit?: number;          // é»˜è®¤ 30
  includeNew?: boolean;    // é»˜è®¤ true
  lessonId?: string;       // å­—æ¯è¯¾ç¨‹æ¨¡å¼ä¸‹ä½¿ç”¨
}
```

### 3.2 æ­¥éª¤æ¦‚è§ˆ

1. **æ‡’åˆå§‹åŒ–**ï¼š
   - `entityType === 'letter'` â†’ `ensureUserAlphabetProgress`ï¼ˆæ’å…¥ `user_alphabet_progress` å ä½è®°å½•ï¼‰ï¼›  
   - `entityType === 'word'` â†’ `ensureUserVocabularyProgress`ï¼ˆæ’å…¥ `user_vocabulary_progress` å ä½è®°å½•ï¼‰ã€‚  

2. **æ¨¡å—è®¿é—®æ£€æŸ¥**ï¼š`checkModuleAccess(db, userId, entityType)`ï¼š
   - å­—æ¯æ¨¡å—ï¼šæ°¸è¿œå…è®¸è®¿é—®ï¼›å¿…è¦æ—¶è‡ªåŠ¨è°ƒç”¨ `initUserProgress` åˆ›å»º `user_progress`ã€‚  
   - å…¶ä»–æ¨¡å—ï¼šè¦æ±‚ `letterCompleted === true` æˆ– `letterProgress >= 0.8`ï¼Œå¦åˆ™è¿”å› `MODULE_LOCKED`ã€‚  
   - æ”¯æŒ `FORCE_UNLOCK` ç¯å¢ƒå˜é‡å¼ºåˆ¶æ”¾è¡Œï¼›`userId === 'test-user'` ç›´æ¥æ”¾è¡Œã€‚

3. **æ¯æ—¥å­¦ä¹ é‡ï¼ˆlimitï¼‰å¤„ç†**ï¼š
   - è‹¥åç«¯ `user_progress.dailyLimit` å­˜åœ¨ï¼Œåˆ™è¦†ç›–å‰ç«¯ä¼ å…¥çš„ `limit`ï¼›  
   - `entityType === 'letter'` æ—¶ï¼Œå§‹ç»ˆä»¥æœåŠ¡å™¨é…ç½®ä¸ºå‡†ï¼ˆå¿½ç•¥å‰ç«¯åŠ¨æ€è°ƒæ•´ï¼‰ã€‚  
   - å¯¹å…¶ä»–å®ä½“ï¼Œè‹¥å‰ç«¯ä¼ å…¥ limit ä¸å­˜é‡ä¸åŒï¼Œä¼šåŒæ—¶æ›´æ–° `user_progress.dailyLimit`ã€‚

4. **è·å–ä»Šæ—¥å¤ä¹ å®ä½“ï¼ˆæ—§ + æ–°ï¼‰**ï¼š
   - æ—§å®ä½“ï¼š`getTodayReviewEntities(db, userId, entityType, effectiveLimit)`ï¼›  
   - æ–°å®ä½“ï¼ˆ`includeNew === true` ä¸”å¤ä¹ ä¸è¶³ `effectiveLimit`ï¼‰ï¼š
     - `letter + lessonId`ï¼šä» `letters` ä¸­æŒ‰ `curriculumLessonIds: db.command.in([lessonId])` å–å‡ºè¯¾ç¨‹ä¸­å‰©ä½™æ‰€æœ‰å­—æ¯ï¼ˆé™ 200ï¼‰ï¼Œ**ä¸å†æŒ‰ limit æˆªæ–­**ï¼›  
     - å…¶ä»–æƒ…å†µï¼šä»å¯¹åº”é›†åˆï¼ˆ`vocabulary` ç­‰ï¼‰æŒ‰ `lessonNumber` ä¸ `_id` æ’åºï¼Œå– `remainingSlots` æ¡ã€‚
   - å¯¹æ¯ä¸ªæ–°å®ä½“è°ƒç”¨ `getOrCreateMemory(..., isLocked = false)` ç”Ÿæˆ `memory_status` è®°å½•ã€‚

5. **æ•´åˆé˜Ÿåˆ—ï¼ˆ3 æ–° 1 å¤ä¹ ï¼‰**ï¼š
   - å†å²å¤ä¹ ï¼š`allMemories = [...reviewMemories]`ï¼›  
   - æ–°å†…å®¹ï¼š

```js
for i in 0..newMemories.length-1:
  allMemories.push(newMemories[i]);
  if ((i + 1) % 3 === 0) {
    allMemories.push(newMemories[i - 2]); // å¤ä¹ æœ¬ç»„ä¸‰å­—ä¸­çš„ç¬¬1ä¸ª
  }
```

> è¿™æ˜¯ä¸€ç§â€œä¼šè¯å†…å°å¤ä¹ â€å®ç°ï¼Œå‰ç«¯å¯ä»¥é€‰æ‹©æ˜¯å¦æŒ‰è¯¥é˜Ÿåˆ—ç›´æ¥å‡ºé¢˜ï¼Œæˆ–åœ¨è‡ªå·±çš„ Flow ä¸­ç”¨ä½œå‚è€ƒã€‚

6. **æ‹¼æ¥å®ä½“è¯¦æƒ…**ï¼š
   - æ”¶é›† `entityIds`ï¼Œä»å¯¹åº”é›†åˆï¼ˆ`letters`/`vocabulary` ç­‰ï¼‰æŸ¥è¯¢ï¼›  
   - ä¸ºæ¯ä¸ª memory è®°å½•è¡¥ä¸Š `entity` å­—æ®µä¸ `memoryState`ï¼š

```js
memoryState: {
  masteryLevel,
  reviewStage,
  correctCount,
  wrongCount,
  streakCorrect,
  nextReviewAt,
  isNew: memory.reviewStage === 0
}
```

7. **å­—æ¯è¯¾ç¨‹å…ƒæ•°æ®**ï¼ˆä»… `entityType === 'letter'`ï¼‰ï¼š
   - è‡ªåŠ¨æ¨å¯¼ `resolvedLessonId`ï¼ˆä¼˜å…ˆ `params.lessonId`ï¼Œé€€åŒ–ä¸ºå®ä½“ä¸Šçš„ `curriculumLessonIds[0] / lessonId / lessonNumber`ï¼‰ï¼›  
   - é€šè¿‡ `getLessonMetadataFromDb` ä¸ `getPhonicsRuleByLessonFromDb` è¿”å› `lessonMetadata` ä¸ `phonicsRule`ã€‚

8. **å“åº”ç»“æ„ï¼š**

```ts
{
  items: Array<Letter | Vocabulary & { memoryState }>,
  summary: {
    total: number;
    reviewCount: number;
    newCount: number;
    entityType: 'letter' | 'word' | 'sentence';
  },
  lessonMetadata?: LessonMetadata;   // ä»…å­—æ¯
  phonicsRule?: PhonicsRule | null; // ä»…å­—æ¯
}
```

### 3.3 è¯¾ç¨‹æ¨¡å¼ vs çº¯ SRS æ¨¡å¼

- **å­—æ¯æ¨¡å—ï¼ˆè¯¾ç¨‹æ¨¡å¼ï¼‰**ï¼š
  - æ¨èå‰ç«¯åœ¨è°ƒç”¨ `getTodayMemories` æ—¶å§‹ç»ˆæºå¸¦ `lessonId`ï¼›  
  - åç«¯å¯¹æ–°å­—æ¯â€œä¸å†æŒ‰ limit æˆªæ–­â€ï¼Œè€Œæ˜¯ä¸€æ¬¡æ€§æˆæƒæ•´è¯¾å­—æ¯ï¼›  
  - `reviewMemories` ä»ç”± SMâ€‘2 å†³å®šæ˜¯å¦æœ‰â€œè·¨å¤©å¤ä¹ â€ï¼Œä½†åœ¨é¡¹ç›®å†»ç»“è®¾è®¡ä¸­ï¼Œå‰ç«¯å¯ä»¥é€‰æ‹©**å¿½ç•¥**è¿™éƒ¨åˆ†ï¼Œåªç”¨ `memoryState` åšéš¾åº¦å‚è€ƒï¼Œå°†çœŸæ­£çš„è¯¾ç¨‹é˜Ÿåˆ—é€»è¾‘æ”¾åˆ°å‰ç«¯ï¼ˆè¯¦è§ `alphabet-module-spec.md` ç¬¬ 11 ç« ï¼‰ã€‚

- **è¯æ±‡æ¨¡å—ï¼ˆçº¯ SRS æ¨¡å¼ï¼‰**ï¼š
  - å‰ç«¯ä¸ä¼  `lessonId`ï¼Œåªä¼  `entityType: 'word'`ï¼Œç”± `getTodayReviewEntities` + æ–°è¯é€»è¾‘å…±åŒå†³å®šä»Šæ—¥é˜Ÿåˆ—ï¼›  
  - è¯æ±‡æ¨¡å—çš„è¯¦ç»†è¡Œä¸ºç”± `learn-vocab` çš„ `getTodayWords` / `updateMastery` + `vocabulary-module-spec.md` å®šä¹‰ã€‚

---

## 4. submitMemoryResult è¡Œä¸ºï¼ˆå•æ¡ + æ‰¹é‡ï¼‰

æ–‡ä»¶ï¼š`cloudbase/functions/memory-engine/handlers/submitMemoryResult.js`

### 4.1 æ¥å£å½¢æ€

æ”¯æŒä¸¤ç§ç”¨æ³•ï¼š

1. **å•æ¡æäº¤ï¼ˆæ—§ç‰ˆå…¼å®¹ï¼‰**

```json
{
  "action": "submitMemoryResult",
  "data": {
    "userId": "u_xxx",
    "entityType": "letter",
    "entityId": "TH_C_01",
    "quality": "è®°å¾—"
  }
}
```

2. **æ‰¹é‡æäº¤ï¼ˆæ¨èï¼‰**

```json
{
  "action": "submitMemoryResult",
  "data": {
    "userId": "u_xxx",
    "results": [
      { "entityType": "letter", "entityId": "TH_C_01", "quality": "è®°å¾—" },
      { "entityType": "letter", "entityId": "TH_C_02", "quality": "æ¨¡ç³Š" }
    ]
  }
}
```

### 4.2 è¡Œä¸º

- ç»Ÿä¸€æŠŠå‚æ•°è½¬æ¢ä¸º `items[]` æ•°ç»„ï¼›  
- é€æ¡è°ƒç”¨ `updateMemoryAfterReview(db, userId, entityType, entityId, quality)`ï¼›  
- èšåˆç»“æœåä½¿ç”¨ `createResponse(true, { updatedMemories }, 'æäº¤å­¦ä¹ ç»“æœæˆåŠŸ')` è¿”å›ã€‚

> ä¸å‰ç«¯ Spec å¯¹é½ï¼š  
> - **Alphabet æ¨¡å—**ï¼šæ¨èåœ¨æ¯ä¸ª Round ç»“æŸåï¼Œå°†â€œæœ¬è½®å‡ºç°è¿‡çš„å­—æ¯ + è®¡ç®—å¥½çš„ `quality`â€æ‰“åŒ…æˆ `results[]` ä¸€æ¬¡æäº¤ã€‚  
> - **Vocabulary æ¨¡å—**ï¼šæ¨èåœ¨ä¸€æ¬¡ä¼šè¯ç»“æŸåï¼Œå¯¹ä»Šæ—¥å‡ºç°è¿‡çš„æ‰€æœ‰å•è¯èšåˆä¸º `results[]` ä¸€æ¬¡æäº¤ï¼Œæˆ–ä½¿ç”¨ learn-vocab çš„ `updateMastery`ï¼ˆäºŒé€‰ä¸€ï¼Œä¿æŒä¸€è‡´å³å¯ï¼‰ã€‚

---

## 5. å­¦ä¹ ä¼šè¯ç™»è®°ï¼ˆregisterStudySessionï¼Œè§„åˆ’ä¸­ï¼‰

> ä¸ºäº†è®©å‰ç«¯ `LearningStore` æ‹¥æœ‰å¯é çš„æ•°æ®æ¥æºï¼ŒåŒæ—¶ä¸åœ¨å„æ¨¡å—ä¸­é‡å¤è®¡ç®—â€œæ‰“å¡å¤©æ•° / æ€»å­¦ä¹ æ—¶é•¿â€ï¼Œå»ºè®®åœ¨ `memory-engine` ä¸­æ–°å¢ `registerStudySession` Actionã€‚  
> è¯¥ Action çš„é€»è¾‘è¶³å¤Ÿç®€å•ï¼Œä¸æ¶‰åŠ SRSï¼Œåªæ›´æ–° `user_progress` ä¸­çš„ç»Ÿè®¡å­—æ®µã€‚

### 5.1 Action è®¾è®¡

è¯·æ±‚ï¼š

```ts
// action: 'registerStudySession'
interface RegisterStudySessionRequest {
  userId: string;
  module: 'letter' | 'word' | 'sentence' | 'article';
  minutes: number;              // æœ¬æ¬¡å­¦ä¹ æ—¶é•¿ï¼ˆå‘ä¸‹å–æ•´çš„åˆ†é’Ÿæ•°ï¼‰
  finishedLessonId?: string;    // è‹¥æœ¬æ¬¡å®Œæˆäº†æŸè¯¾ï¼Œå¯é€‰ä¼ å…¥ lessonId
  date?: string;                // å¯é€‰ï¼ŒISO æ—¥æœŸï¼›ç¼ºçœåˆ™ä½¿ç”¨æœåŠ¡å™¨å½“å¤©
}
```

è¡Œä¸ºï¼š

- æŒ‰ `userId` æŸ¥æ‰¾ `user_progress`ï¼›è‹¥ä¸å­˜åœ¨åˆ™å…ˆèµ° `initUserProgress`ï¼›  
- è®¡ç®—å½“å¤©æ˜¯å¦é¦–æ¬¡å­¦ä¹ ï¼š
  - è‹¥ `lastStudyDate` ä¸º null æˆ–æ—©äºå½“æ—¥ï¼Œåˆ™ `totalStudyDays += 1`ï¼Œ`streakDays` æŒ‰å¤©æ•°æ˜¯å¦è¿ç»­é€’å¢æˆ–é‡ç½®ï¼›  
  - æ›´æ–° `lastStudyDate = today`ã€‚  
- å¢åŠ æ–°çš„å­—æ®µï¼ˆå»ºè®®ï¼‰ï¼š

```ts
user_progress.totalStudyMinutes += minutes;
```

- è‹¥ `finishedLessonId` å­˜åœ¨ï¼Œå¯é€‰æ›´æ–°å¯¹åº”æ¨¡å—è¿›åº¦ï¼ˆä¾‹å¦‚å­—æ¯è¯¾å®Œæˆæ•°ï¼‰ï¼Œå…·ä½“ç»†èŠ‚ç”±å„æ¨¡å—åœ¨å‰ç«¯å¤„ç†ã€‚

å“åº”ï¼š

```ts
interface RegisterStudySessionResponse {
  userId: string;
  totalStudyDays: number;
  streakDays: number;
  lastStudyDate: string;
  totalStudyMinutes?: number;
}
```

å‰ç«¯ä½¿ç”¨æ–¹å¼ï¼š

- å„å­¦ä¹ æ¨¡å—åœ¨ä¸€æ¬¡â€œæ­£å¼å­¦ä¹ ç»“æŸâ€æ—¶è°ƒç”¨ï¼š

```ts
await callCloudFunction('memory-engine', {
  action: 'registerStudySession',
  data: {
    userId,
    module: 'letter',        // æˆ– 'word' ...
    minutes: sessionMinutes,
    finishedLessonId,
  },
});
```

- `LearningStore.registerStudySession` å¯åœ¨å†…éƒ¨è°ƒç”¨æ­¤ Actionï¼Œå¹¶åŒæ­¥æ›´æ–°æœ¬åœ°ä»ªè¡¨ç›˜ç»Ÿè®¡ã€‚

---

## 6. æ¨¡å—è§£é”é€»è¾‘ï¼ˆcheckModuleAccessï¼‰

æ–‡ä»¶ï¼š`cloudbase/functions/memory-engine/utils/memoryEngine.js` ä¸­çš„ `checkModuleAccess`

### 5.1 ç‰¹æ®Šæ”¾è¡Œä¸åˆå§‹åŒ–

- `userId === 'test-user'`ï¼šç›´æ¥æ”¾è¡Œä»»æ„æ¨¡å—ï¼Œè¿”å›ä¸€ä»½æœ€å°è¿›åº¦å¯¹è±¡ï¼Œåªç”¨äºæœ¬åœ°å¼€å‘ã€‚  
- æœªæ‰¾åˆ° `user_progress`ï¼š
  - è‹¥ `FORCE_UNLOCK === 'true'`ï¼šæ”¾è¡Œæ‰€æœ‰æ¨¡å—ï¼›  
  - è‹¥ `moduleType === 'letter'`ï¼šè‡ªåŠ¨è°ƒç”¨ `initUserProgress`ï¼Œåˆå§‹åŒ–ä¸ºï¼š

```js
{
  letterCompleted: false,
  letterProgress: 0,
  wordUnlocked: false,
  wordProgress: 0,
  sentenceUnlocked: false,
  sentenceProgress: 0,
  articleUnlocked: false,
  currentStage: 'letter',
  ...
}
```

  - å…¶ä»–æ¨¡å—ï¼šè¿”å› `USER_PROGRESS_NOT_FOUND`ã€‚

### 5.2 æ­£å¸¸åˆ¤æ–­

- è‹¥è®¾ç½®äº† `FORCE_UNLOCK`ï¼šç›´æ¥æ”¾è¡Œæ‰€æœ‰æ¨¡å—ï¼Œå¹¶å°†å¯¹åº” `*Unlocked` å­—æ®µè§†ä¸º trueã€‚  
- å­—æ¯æ¨¡å—ï¼šæ°¸è¿œå…è®¸è®¿é—®ï¼ˆç”¨äºè¡¥è¯¾æˆ–å›é¡¾ï¼‰ã€‚  
- å…¶ä»–æ¨¡å—ï¼ˆè¯æ±‡/å¥å­/æ–‡ç« ï¼‰ï¼šä½¿ç”¨ç»Ÿä¸€è§„åˆ™ï¼š
  - è‹¥ `letterCompleted === true` â†’ æ”¾è¡Œï¼›  
  - å¦åˆ™è‹¥ `letterProgress >= 0.8` â†’ æ”¾è¡Œï¼›  
  - å¦åˆ™è¿”å› `MODULE_LOCKED`ï¼Œé™„å¸¦å½“å‰ `letterProgress` ç™¾åˆ†æ¯”ã€‚

> ä¸å‰ç«¯å¯¹é½ï¼š  
> - Courses é¡µåœ¨å±•ç¤ºè¯æ±‡è¯¾ç¨‹æ—¶ï¼Œå¯ä»¥æ ¹æ® `getUserProgress` / `moduleAccessStore` åˆ¤æ–­æ˜¯å¦å±•ç¤ºé”å›¾æ ‡ã€‚  
> - ç”¨æˆ·å³ä½¿å®Œæˆäº†å­—æ¯è¯¾ç¨‹ï¼Œä»å¯éšæ—¶è¿”å›å­—æ¯æ¨¡å—ç»§ç»­ç»ƒä¹ ï¼›åç«¯ä¸ä¼šç¦æ­¢ã€‚

---

## 6. å¤šæ¨¡å—åˆ‡æ¢ä¸æ··åˆå¤ä¹ çš„çº¦å®š

> ç›®å‰åç«¯çš„è®¾è®¡**æ²¡æœ‰ç›´æ¥æ”¯æŒâ€œæ··åˆå­—æ¯ + å•è¯â€çš„ getTodayMemories é˜Ÿåˆ—**ï¼Œæ‰€æœ‰è°ƒç”¨éƒ½ä»¥ `entityType` ä¸ºç²’åº¦ã€‚  
> å¦‚æœæœªæ¥éœ€è¦â€œç»¼åˆå¤ä¹ â€é¡µé¢ï¼Œå¯ä»¥åœ¨å‰ç«¯æŒ‰ä»¥ä¸‹çº¦å®šç»„åˆè°ƒç”¨ã€‚

### 6.1 ç°çŠ¶ï¼šæŒ‰å®ä½“ç±»å‹ç‹¬ç«‹è°ƒåº¦

- `getTodayMemories` æ¯æ¬¡åªæ¥å—ä¸€ä¸ª `entityType`ï¼š`letter` æˆ– `word`ã€‚  
- Alphabet æ¨¡å—ï¼šå»ºè®®å§‹ç»ˆåœ¨è¯¾ç¨‹å†…éƒ¨ä½¿ç”¨æœ¬åœ°é˜Ÿåˆ— + `submitMemoryResult`ï¼›  
- Vocabulary æ¨¡å—ï¼šå¯ä»¥é€‰æ‹©ä½¿ç”¨ `memory-engine`ï¼ˆ`entityType: 'word'`ï¼‰ï¼Œæˆ–æ²¿ç”¨ `learn-vocab` çš„ `getTodayWords`ã€‚

### 6.2 ç”¨æˆ·åœ¨æ¨¡å—é—´åå¤åˆ‡æ¢æ—¶çš„è¡Œä¸º

1. ç”¨æˆ·å®Œæˆ Alphabet æŸä¸€è¯¾çš„ä¸‰è½®å­¦ä¹  â†’ å‰ç«¯èšåˆè´¨é‡åè°ƒç”¨ `submitMemoryResult`ï¼ˆletterï¼‰ï¼Œå¹¶åœ¨ `user_alphabet_progress` ä¸­è®°å½• Round3 é€šè¿‡ç»“æœ â†’ åç«¯ `user_progress.letterCompleted` æˆ– `letterProgress` è¢«æ›´æ–°ï¼ˆç”±åç»­ä»»åŠ¡å®ç°ï¼‰ã€‚  
2. å½“ `checkModuleAccess('word')` è¿”å› allowed æ—¶ï¼Œç”¨æˆ·å¯ä»¥è¿›å…¥è¯æ±‡æ¨¡å—å­¦ä¹ ã€‚  
3. è‹¥ç”¨æˆ·å†æ¬¡è¿”å›å­—æ¯æ¨¡å—ï¼š
   - `checkModuleAccess('letter')` æ°¸è¿œå…è®¸ï¼›  
   - è‹¥å‰ç«¯ä»è°ƒç”¨ `getTodayMemories(letter, { includeNew:true })`ï¼Œåç«¯ä¼šæŒ‰ SMâ€‘2 æ—¶é—´è°ƒåº¦åˆ°æœŸçš„å­—æ¯ + å‘ç°æ–°å­—æ¯æ—¶åˆ›å»ºæ–° `memory_status`ï¼›  
   - é¡¹ç›®å†»ç»“æ–¹æ¡ˆä¸­ï¼Œæ¨èï¼š**å­—æ¯è¯¾ç¨‹å†…ä¸å†ä¾èµ– `getTodayMemories` çš„é˜Ÿåˆ—ï¼Œè€Œæ˜¯ä»¥ lessonId + æœ¬åœ° session ä¸ºä¸»ï¼Œ`memory_status` åªå­˜å‚¨è´¨é‡ç»“æœ**ã€‚

### 6.3 æœªæ¥çš„â€œæ··åˆå¤ä¹ â€é¡µé¢ï¼ˆå»ºè®®ï¼‰

è‹¥æœªæ¥è¦å®ç°â€œæ¯æ—¥ç»¼åˆå¤ä¹ é¡µé¢ï¼ˆå­—æ¯ + å•è¯ï¼‰â€ï¼Œå¯ä»¥å‰ç«¯æŒ‰ä»¥ä¸‹æ–¹å¼å®ç°ï¼Œè€Œæ— éœ€æ”¹åŠ¨åç«¯ï¼š

1. åˆ†åˆ«è°ƒç”¨ï¼š

```ts
const letters = await getTodayMemories({ userId, entityType: 'letter', limit: L, includeNew: false });
const words   = await getTodayMemories({ userId, entityType: 'word',   limit: W, includeNew: false });
```

2. åœ¨å‰ç«¯æ ¹æ®éœ€è¦äº¤é”™ `letters.items` ä¸ `words.items`ï¼Œç”Ÿæˆç»¼åˆé˜Ÿåˆ—ï¼›  
3. æ¯é“é¢˜ç»“æŸåå°†ç»“æœè®°å…¥æœ¬åœ° `perLetterStats` / `perWordStats`ï¼›  
4. åœ¨ä¼šè¯ç»“æŸæ—¶ï¼Œå°†ä¸¤ç±»å®ä½“åˆ†åˆ«æ‰“åŒ…ä¸ºï¼š

```ts
submitMemoryResult({
  userId,
  results: [
    { entityType: 'letter', entityId, quality },
    { entityType: 'word',   entityId, quality },
    ...
  ]
});
```

åç«¯æ— éœ€å…³å¿ƒé¢˜ç›®æ˜¯åœ¨å“ªä¸ªé¡µé¢å®Œæˆçš„ï¼Œåªè¦ `entityType` ä¸ `entityId` ä¸€è‡´å³å¯ã€‚

---

## 7. ä¸å‰ç«¯ Spec çš„ä¸€è‡´æ€§è¯´æ˜

### 7.1 å­—æ¯æ¨¡å—

- å‰ç«¯ Specï¼ˆ`alphabet-module-spec.md` ç¬¬ 11 ç« ï¼‰ä¸­å®šä¹‰çš„ï¼š
  - â€œæŒ‰å­—æ¯ Ã— è½®æ¬¡èšåˆè´¨é‡ï¼ˆFORGET/FUZZY/KNOWï¼‰â€ï¼›  
  - â€œåœ¨ Round ç»“æŸæ—¶ç»Ÿä¸€è°ƒç”¨ `submitMemoryResult`ï¼ˆæ‰¹é‡ï¼‰â€ï¼›  
  - â€œå­—æ¯è¯¾ç¨‹å†…çš„é˜Ÿåˆ—ç”±å‰ç«¯è´Ÿè´£ï¼Œ`getTodayMemories` åªä½œä¸ºè¯¾ç¨‹åˆå§‹åŒ–è¾…åŠ©â€ï¼›  
 è¿™äº›è¡Œä¸ºä¸åç«¯ç°æœ‰æ¥å£å®Œå…¨å…¼å®¹ï¼Œå¹¶å»ºè®®ä½¿ç”¨ **æ‰¹é‡ results[] æäº¤**ã€‚

### 7.2 è¯æ±‡æ¨¡å—

- è¯æ±‡æ¨¡å—å¯ä»¥é€‰æ‹©ä¸¤æ¡è·¯ï¼š
  1. ç»§ç»­ä½¿ç”¨ `learn-vocab.getTodayWords + updateMastery`ï¼ˆå®Œå…¨ç‹¬ç«‹äº memory-engineï¼‰ï¼›  
  2. é€æ­¥è¿ç§»åˆ° `memory-engine.getTodayMemories(entityType:'word') + submitMemoryResult`ã€‚  

- é¡¹ç›®å†»ç»“ä¸­ï¼Œ`vocabulary-module-spec.md` é‡‡ç”¨çš„è®¾è®¡æ˜¯ï¼š
  - ä½¿ç”¨ `learn-vocab.getTodayWords` è·å–å½“æ—¥å•è¯åˆ—è¡¨ï¼ˆå› ä¸ºå·²æœ‰å®Œå–„å­—æ®µä¸ UI éœ€æ±‚ï¼‰ï¼›  
  - ä½†åœ¨å‰ç«¯å†…éƒ¨ä¹Ÿå¯ä»¥ä½¿ç”¨ memory-engine çš„ `submitMemoryResult` è¿›è¡Œç»Ÿä¸€ SMâ€‘2 è°ƒåº¦â€”â€”åªè¦å°† `mastery` æ˜ å°„ä¸º `'é™Œç”Ÿ'/'æ¨¡ç³Š'/'è®°å¾—'` å³å¯ã€‚

> å…³é”®è¦æ±‚ï¼š  
> - ä¸è®ºé‡‡ç”¨å“ªæ¡è·¯ï¼Œ**åŒä¸€ä¸ªå•è¯çš„é•¿æœŸå¤ä¹ çŠ¶æ€åªèƒ½ç”±ä¸€å¥—è¡¨å†³å®š**ï¼ˆ`user_vocabulary_progress` æˆ– `memory_status`ï¼‰ï¼Œé¿å…åŒæºç«äº‰ï¼›  
> - è‹¥æœªæ¥å®Œå…¨è¿ç§»åˆ° `memory_status`ï¼Œåˆ™ `user_vocabulary_progress` å¯ä»¥é€æ­¥é€€åŒ–ä¸ºç»Ÿè®¡è¡¨ã€‚

---

æœ¬è§„æ ¼æ–‡æ¡£å†»ç»“äº†åç«¯ç»Ÿä¸€è®°å¿†å¼•æ“ä¸æ¨¡å—è§£é”çš„**çœŸå®è¡Œä¸º**ï¼Œå¹¶æ˜ç¡®äº†ä¸å‰ç«¯ Alphabet / Vocabulary æ¨¡å—çš„å¥‘çº¦ä¸æ‰©å±•æ–¹å¼ã€‚  
åç»­å¦‚éœ€ä¿®æ”¹ memory-engine / learn-vocab çš„é€»è¾‘ï¼Œå¿…é¡»åŒæ­¥æ›´æ–°æœ¬æ–‡ä»¶åŠç›¸åº”å‰ç«¯ Specï¼Œä¿æŒâ€œå‰åç«¯å•ä¸€çœŸç›¸â€ã€‚***
</file>

<file path="docs/project-freeze/database_schema.md">
# æ•°æ®åº“ç»“æ„è¯´æ˜æ–‡æ¡£ï¼ˆV2.1.0ï¼‰

æœ¬æ–‡æ¡£åŸºäº `assets/data/Final_DB_Data` ä¸­ç”± `local_cleaner_v3.py` è„šæœ¬æ¸…æ´—åçš„å®é™…æ•°æ®ç»“æ„æ•´ç†ã€‚  
å¦‚æ— ç‰¹åˆ«è¯´æ˜ï¼Œæ‰€æœ‰æ—¶é—´å­—æ®µå‡ä¸º ISO å­—ç¬¦ä¸²æˆ– CloudBase å†…éƒ¨çš„ `Date` å¯¹è±¡ã€‚

**æ ¸å¿ƒå˜æ›´ï¼ˆç›¸å¯¹ V2.0.1ï¼‰ï¼š**

- ä¸»é”®ç­–ç•¥ï¼š`_id` ä¸ `vocabularyId` é‡‡ç”¨ `{source}_{OriginalID}` ç»„åˆï¼ˆå¦‚ `BaseThai_1_7`ï¼‰ï¼Œå½»åº•è§£å†³ä¸åŒæ•™æé—´ ID å†²çªé—®é¢˜ã€‚  
- éŸ³é¢‘é€»è¾‘ï¼š`audioPath` ä»…å­˜å‚¨æ–‡ä»¶åï¼ˆå¦‚ `7.mp3`ï¼‰ï¼Œå‰ç«¯éœ€ç»“åˆ `source` å­—æ®µæ‹¼æ¥äº‘å­˜å‚¨è·¯å¾„ã€‚  
- å¯Œåª’ä½“ç»“æ„ï¼šä¾‹å¥ã€å¯¹è¯ã€åŒæºè¯ç­‰å­—æ®µå†…éƒ¨å·²æ³¨å…¥å¯¹åº”çš„ `audioPath`ï¼Œå‰ç«¯å¯ç›´æ¥ä½¿ç”¨ã€‚

---

## 1. æ ¸å¿ƒé›†åˆ (Collections)

> ä»¥ä¸‹å­—æ®µä¸ºå½“å‰ä»£ç ä¸­**å®é™…ä½¿ç”¨å’Œå†™å…¥**çš„å­—æ®µï¼Œè‹¥æœªæ¥éœ€è¦æ–°å¢å­—æ®µï¼Œè¯·åŒæ­¥æ›´æ–°æœ¬è¡¨ã€‚

### 1.1 Users (ç”¨æˆ·è¡¨)
**é›†åˆå**: `users`
**ç”¨é€”**: å­˜å‚¨ç”¨æˆ·åŸºæœ¬ä¿¡æ¯ã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | è®°å½•ID | è‡ªåŠ¨ç”Ÿæˆ |
| `userId` | String | ç”¨æˆ·å”¯ä¸€æ ‡è¯† | æ ¸å¿ƒç´¢å¼•å­—æ®µ |
| `nickname` | String | æ˜µç§° | |
| `avatarUrl` | String | å¤´åƒåœ°å€ | |
| `createdAt` | Date | åˆ›å»ºæ—¶é—´ | |

### 1.2 Vocabulary (è¯æ±‡è¡¨)
**é›†åˆå**: `vocabulary`  
**ç”¨é€”**: å­˜å‚¨ã€ŠåŸºç¡€æ³°è¯­ã€‹ç³»åˆ—æ•™æå•è¯ï¼ŒåŒ…å«è¯¦ç»†çš„å¯Œæ–‡æœ¬åŠéŸ³é¢‘ä¿¡æ¯ã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | å…¨å±€å”¯ä¸€ä¸»é”® | æ ¼å¼ï¼š`{source}_{OriginalID}`ï¼Œä¾‹ï¼š`"BaseThai_1_7"` |
| `vocabularyId` | String | ä¸šåŠ¡ ID | ä¸ `_id` ä¿æŒä¸€è‡´ï¼Œç”¨äºå‰ç«¯é€»è¾‘ |
| `source` | String | ä¹¦å/æ¥æº | å¯¹åº”äº‘å­˜å‚¨æ–‡ä»¶å¤¹åï¼Œå¦‚ `"BaseThai_1"`ã€`"BaseThai_2"` |
| `level` | String | éš¾åº¦ç­‰çº§ | ä¾‹å¦‚ `"A1"`, `"A2"`, `"B1"` |
| `lessonNumber` | String | è¯¾ç¨‹ç¼–å· | ä¾‹å¦‚ `"1"`, `"15.3"`ï¼ˆå­—ç¬¦ä¸²ï¼‰ |
| `thaiWord` | String | æ³°è¯­å•è¯ | ä¾‹å¦‚ `"à¸à¸°"` |
| `meaning` | String | ä¸­æ–‡å«ä¹‰ | ä¾‹å¦‚ `"ä¼°è®¡"` |
| `startingLetter` | String | æ³°è¯­é¦–å­—æ¯ | ä¾‹å¦‚ `"à¸"` |
| `pronunciation` | String | å‘éŸ³/éŸ³æ ‡ | ä¾‹å¦‚ `"gÃ "` |
| `partOfSpeech` | String | è¯æ€§ | ä¾‹å¦‚ `"åè¯"` |
| `audioPath` | String | å•è¯ä¸»éŸ³é¢‘æ–‡ä»¶å | ä¾‹å¦‚ `"7.mp3"`ã€‚æ‰€æœ‰è¯æ±‡éŸ³é¢‘ç»Ÿä¸€å­˜æ”¾åœ¨ COS æ ¹ç›®å½• `BaseThai_Audio/` ä¸‹ï¼Œä»¥ä¹¦å `source` ä½œä¸ºå­ç›®å½•å‰ç¼€ï¼š`BaseThai_Audio/{source}_Audio/{audioPath}`ï¼Œå…¶ä¸­ `source` å¦‚ `"BaseThai_1"`ã€`"BaseThai_2"` ç­‰ã€‚ |
| `exampleSentences` | Object | ä¾‹å¥é›†åˆ | Map ç»“æ„ï¼Œè¯¦è§ä¸‹æ–‡ |
| `dialogue` | Object | å¯¹è¯åœºæ™¯ | åŒ…å«åœºæ™¯æè¿°åŠå¯¹è¯å†…å®¹ï¼Œè¯¦è§ä¸‹æ–‡ |
| `cognates` | Array\<Object\> | åŒæºè¯/ç›¸å…³è¯ | ç»“æ„è§ä¸‹æ–‡ |
| `mistakes` | Object | å¸¸è§é”™è¯¯/æ˜“é”™ç‚¹ | åŒ…å«å‘éŸ³æ˜“é”™ç‚¹ã€ç›¸ä¼¼è¯åŒºåˆ«ã€ä½¿ç”¨åœºåˆç­‰ |
| `usage` | Object | ç”¨æ³•è¯´æ˜ | åŒ…å«è¯­æ³•ç¤ºä¾‹ã€ä¸ä¸­æ–‡å·®å¼‚ç­‰ |
| `analysis` | Object | åŸå§‹åˆ†ææ•°æ® | ä¿ç•™åŸå§‹æ¸…æ´—è„šæœ¬è¾“å‡ºï¼Œç”¨äº debug/å¤‡ä»½ |
| `createdAt` | Date\|String | åˆ›å»ºæ—¶é—´ | |

#### 1.2.1 `exampleSentences` å­—æ®µç»“æ„

- ç±»å‹ï¼š`Record<string, { æ³°è¯­: string; ä¸­æ–‡: string; å‘éŸ³: string; audioPath: string }>`  
- Keyï¼šåœºæ™¯åï¼ˆä¾‹å¦‚ `"å®ç”¨åœºæ™¯1"`ã€`"å®ç”¨åœºæ™¯2"`ï¼‰ã€‚  
- Value ç¤ºä¾‹ï¼š

```json
{
  "å®ç”¨åœºæ™¯1": {
    "æ³°è¯­": "à¸‰à¸±à¸™à¸à¸´à¸™à¸™à¹‰à¸³à¸¡à¸°à¸¥à¸°à¸à¸­à¸—à¸¸à¸à¸§à¸±à¸™",
    "ä¸­æ–‡": "æˆ‘æ¯å¤©å–æœ¨ç“œæ±",
    "å‘éŸ³": "chÇn gin nÃ¡am mÃ¡-lÃ -kÉ”ÌŒÉ” tÃ»u-kÃºu-wan",
    "audioPath": "207_sen_å®ç”¨åœºæ™¯1.mp3"
  }
}
```

> å‰ç«¯æ’­æ”¾ä¾‹å¥éŸ³é¢‘æ—¶åº”ç›´æ¥ä½¿ç”¨ `exampleSentences[key].audioPath`ï¼Œå¹¶æŒ‰ `BaseThai_Audio/{source}_Audio/{audioPath}` æ‹¼æ¥å®Œæ•´è·¯å¾„ã€‚å…¶ä¸­ï¼š
> - `source` ä¸ `vocabulary.source` ä¸€è‡´ï¼ˆå¦‚ `"BaseThai_1"`ï¼‰ï¼›  
> - `audioPath` ä¸ºè¯¥ä¾‹å¥åœ¨å¯¹åº” `{source}_Audio` ç›®å½•ä¸­çš„æ–‡ä»¶åæˆ–ç›¸å¯¹è·¯å¾„ã€‚

#### 1.2.2 `dialogue` å­—æ®µç»“æ„

- ç±»å‹ï¼š

```ts
{
  "åœºæ™¯æè¿°": string;
  "å¯¹è¯å†…å®¹": {
    [role: string]: {
      æ³°è¯­: string;
      ä¸­æ–‡?: string;
      audioPath: string;
    };
  };
}
```

- ç¤ºä¾‹ï¼š

```json
{
  "åœºæ™¯æè¿°": "åœ¨æ°´æœæ‘Šå‰é¡¾å®¢ä¸æ‘Šä¸»è®¨è®ºè´­ä¹°æœ¨ç“œ",
  "å¯¹è¯å†…å®¹": {
    "A": {
      "æ³°è¯­": "à¸à¸µà¹ˆà¸„à¸£à¸±à¸š à¸¡à¸°à¸¥à¸°à¸à¸­à¸­à¸±à¸™à¸™à¸µà¹‰à¸ªà¸¸à¸à¸¢à¸±à¸‡à¸„à¸£à¸±à¸š?",
      "ä¸­æ–‡": "å¤§å“¥ï¼Œè¿™ä¸ªæœ¨ç“œç†Ÿäº†å—ï¼Ÿ",
      "audioPath": "207_dia_A.mp3"
    },
    "B": {
      "æ³°è¯­": "à¸¢à¸±à¸‡à¸„à¸£à¸±à¸š à¹à¸•à¹ˆà¸–à¹‰à¸²à¸­à¸¢à¸²à¸à¸à¸´à¸™à¹€à¸›à¸£à¸µà¹‰à¸¢à¸§à¹† à¹ƒà¸Šà¹‰à¹„à¸”à¹‰à¹€à¸¥à¸¢",
      "ä¸­æ–‡": "è¿˜æ²¡ç†Ÿé€ï¼Œä½†å¦‚æœä½ æƒ³åƒé…¸ä¸€ç‚¹çš„ï¼Œè¿™ä¸ªæ­£åˆé€‚",
      "audioPath": "207_dia_B.mp3"
    }
  }
}
```

#### 1.2.3 `cognates` å­—æ®µç»“æ„

- ç±»å‹ï¼š`Array<{ text: string; audioPath: string }>`  
- ç¤ºä¾‹ï¼š

```json
[
  {
    "text": "à¸™à¹‰à¸³à¸¡à¸°à¸¥à¸°à¸à¸­ (nÃ¡am mÃ¡-lÃ -kÉ”ÌŒÉ”) - æœ¨ç“œæ±",
    "audioPath": "207_cog_1.mp3"
  },
  {
    "text": "à¸ªà¹‰à¸¡à¸•à¸³à¸¡à¸°à¸¥à¸°à¸à¸­ (sÃ´m dtÃ m mÃ¡-lÃ -kÉ”ÌŒÉ”) - æœ¨ç“œæ²™æ‹‰",
    "audioPath": "207_cog_2.mp3"
  }
]
```

#### 1.2.4 `analysis` å­—æ®µç»“æ„ï¼ˆä¿ç•™ç”¨ï¼‰

- è¯¥å­—æ®µå®Œæ•´ä¿ç•™ local_cleaner è„šæœ¬ç”Ÿæˆçš„åŸå§‹åˆ†æï¼š

```ts
interface Analysis {
  pronunciation: string;
  part_of_speech: string;
  letter_pron_analysis?: string;
  phonetic_association?: {
    æ‹†åˆ†?: string;
    è®°å¿†å¥?: string;
  };
  cognates?: string[];
  example_sentences?: Record<string, { æ³°è¯­: string; ä¸­æ–‡: string; å‘éŸ³: string }>;
  example_dialogue?: {
    åœºæ™¯æè¿°: string;
    å¯¹è¯å†…å®¹: Record<string, { æ³°è¯­: string; ä¸­æ–‡: string }>;
  };
  common_mistakes?: Record<string, string>;
  usage_details?: {
    è¯­æ³•ç¤ºä¾‹?: { ç»“æ„: string; è§£é‡Š: string; ä½¿ç”¨æŠ€å·§?: string };
    ä¸ä¸­æ–‡å·®å¼‚?: string;
  };
  mistakes?: Record<string, string>;
  usage?: {
    è¯­æ³•ç¤ºä¾‹?: { ç»“æ„: string; è§£é‡Š: string; ä½¿ç”¨æŠ€å·§?: string };
    ä¸ä¸­æ–‡å·®å¼‚?: string;
  };
}
```

> å‰ç«¯ä¸šåŠ¡åº”ä¼˜å…ˆä½¿ç”¨é¡¶å±‚çš„ `exampleSentences` / `dialogue` / `mistakes` / `usage` å­—æ®µï¼›`analysis` ä¸»è¦ç”¨äºè°ƒè¯•ä¸ä»¥åç”Ÿæˆ AI å†…å®¹ã€‚

### 1.3 User Vocabulary Progress (ç”¨æˆ·å•è¯è¿›åº¦è¡¨)

**é›†åˆå**: `user_vocabulary_progress`  
**ç”¨é€”**: è®°å½•ç”¨æˆ·å¯¹æ¯ä¸ªå•è¯çš„å­¦ä¹ çŠ¶æ€ï¼ˆæ—§ç‰ˆè¯æ±‡ SRS å¼•æ“ï¼‰ã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | è®°å½•ID | è‡ªåŠ¨ç”Ÿæˆ |
| `userId` | String | ç”¨æˆ·ID | ç´¢å¼• |
| `vocabularyId` | String | å•è¯ID | å…³è” `vocabulary._id`ï¼Œä¾‹å¦‚ `BaseThai_1_7` |
| `mastery` | String\|null | æŒæ¡ç¨‹åº¦ | `'UNFAMILIAR'`, `'FUZZY'`, `'REMEMBERED'` æˆ– `null` |
| `nextReviewDate` | Date\|null | ä¸‹æ¬¡å¤ä¹ æ—¶é—´ | `getTodayWords` ç”¨äºç­›é€‰ä»Šæ—¥å¤ä¹  |
| `intervalDays` | Number | é—´éš”å¤©æ•° | |
| `easinessFactor` | Number | æ˜“è®°ç³»æ•° | é»˜è®¤ 2.5 |
| `reviewCount` | Number | å¤ä¹ æ¬¡æ•° | |
| `createdAt` | Date | åˆ›å»ºæ—¶é—´ | |
| `updatedAt` | Date | æ›´æ–°æ—¶é—´ | |

### 1.4 Letters (å­—æ¯è¡¨)
**é›†åˆå**: `letters`  
**ç”¨é€”**: å­˜å‚¨æ³°è¯­å­—æ¯ã€å…ƒéŸ³ã€å£°è°ƒç¬¦å·åŠå…¶éŸ³é¢‘ä¸è¯¾ç¨‹ä¿¡æ¯ã€‚

> è¯¦ç»†å­—æ®µå®šä¹‰è¯·å‚è€ƒ `src/entities/types/letter.types.ts` ä¸ `assets/courses/letters_final.enriched.json`ã€‚  
> æ­¤å¤„ä¿æŒç®€è¦è¯´æ˜ï¼ˆä¸»è¦ç”¨äºç†è§£ä¸å…¶ä»–é›†åˆçš„å…³ç³»ï¼‰ã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | å­—æ¯ID | å¦‚ `TH_C_01` |
| `type` | String | ç±»å‹ | `'consonant' \| 'vowel' \| 'tone'` |
| `thaiChar` | String | æ³°æ–‡å­—æ¯/å…ƒéŸ³/å£°è°ƒå­—ç¬¦ | å¦‚ `"à¸"` |
| `nameThai` | String | æ³°æ–‡åç§° | å¦‚ `"à¹„à¸à¹ˆ"` |
| `nameEnglish` | String | è‹±æ–‡åç§° | å¦‚ `"ko kai"` |
| `initialSound` | String | é¦–è¾…éŸ³è¯»éŸ³ | å¦‚ `"k"`ï¼ˆå¯ä¸ºç©ºï¼Œå¯¹å…ƒéŸ³/å£°è°ƒï¼‰ |
| `finalSound` | String | æ”¶å°¾è¾…éŸ³è¯»éŸ³ | å¦‚ `"k"` |
| `class` | String\|null | è¾…éŸ³ç±» | `'mid'`, `'high'`, `'low'`ï¼Œå…ƒéŸ³/å£°è°ƒä¸º `null` |
| `audioPath` | String | æ—§ç‰ˆéŸ³é¢‘è·¯å¾„ | æ–°ç‰ˆä¼˜å…ˆä½¿ç”¨ `*SoundUrl` |
| `exampleWord` | String | ç¤ºä¾‹å•è¯ | å¦‚ `"à¹„à¸à¹ˆ"` |
| `exampleMeaning` | String | ç¤ºä¾‹å«ä¹‰ | å¦‚ `"é¸¡"` |
| `strokeCount` | Number | ç¬”ç”»æ•° | é¢„ç•™ |
| `learningLevel` | String | å­¦ä¹ çº§åˆ« | `'BEGINNER' \| 'INTERMEDIATE' \| 'ADVANCED'` |
| `lessonNumber` | Number | æ—§è¯¾ç¨‹ç¼–å· | ä¸æ–°ç‰ˆ `lessonId` å¹¶å­˜ |
| `category` | String | åˆ†ç±» | å¦‚ `'mid_consonant'`, `'vowel'`, `'tone'` |
| `subCategory` | String | å­ç±»åˆ« | å¦‚ `'lesson1_mid'` |
| `keyboardKey` | String\|undefined | é”®ç›˜å¯¹åº”æŒ‰é”® | ç”¨äºè¾“å…¥ç»ƒä¹  |
| `fullSound` | String\|undefined | å®Œæ•´å‘éŸ³ key | å¦‚ `"consonant-ko-kai"` |
| `fullSoundUrl` | String\|undefined | å®Œæ•´å‘éŸ³éŸ³é¢‘ key | æ˜ å°„åˆ° COS `/alphabet/{key}.mp3` |
| `syllableSoundName` | String\|undefined | éŸ³èŠ‚æ ¸å¿ƒå‘éŸ³åç§° | å¦‚ `"k"` |
| `syllableSound` | String\|undefined | éŸ³èŠ‚å‘éŸ³ key | å¦‚ `"sound-k"` |
| `syllableSoundUrl` | String\|undefined | éŸ³èŠ‚éŸ³é¢‘ key | |
| `endSyllableSoundName` | String\|undefined | å°¾éŸ³èŠ‚åç§° | |
| `endSyllableSound` | String\|undefined | å°¾éŸ³èŠ‚å‘éŸ³ key | |
| `endSyllableSoundUrl` | String\|undefined | å°¾éŸ³èŠ‚éŸ³é¢‘ key | |
| `letterNamePronunciation` | String\|undefined | å­—æ¯åç§°å‘éŸ³æ–‡æœ¬ | å¦‚ `"kayá¿¯"` |
| `letterPronunciationUrl` | String\|undefined | å­—æ¯åç§°å‘éŸ³éŸ³é¢‘ key | å¦‚ `"word-kay"` |
| `letterImageUrl` | String\|undefined | å­—æ¯æ’å›¾ URL | é¢„ç•™ |
| `description` | String\|undefined | è¯´æ˜ | |
| `curriculumLessonIds` | String[]\|undefined | æ‰€å±è¯¾ç¨‹ ID åˆ—è¡¨ | å¦‚ `["lesson1"]` |
| `curriculumLessonOrders` | Number[]\|undefined | å„è¯¾ç¨‹ä¸­çš„æ’åº | |
| `primaryCurriculumLessonId` | String\|undefined | ä¸»è¯¾ç¨‹ ID | å¦‚ `"lesson1"` |
| `primaryCurriculumLessonOrder` | Number\|undefined | ä¸»è¯¾ç¨‹ä¸­çš„æ’åº | |
| `createdAt` | String | åˆ›å»ºæ—¶é—´ | |


### 1.5 Sentences (å¥å­è¡¨)
**é›†åˆå**: `sentences` (æ¨æµ‹)
**ç”¨é€”**: å­˜å‚¨ä¾‹å¥æ•°æ®ã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | å¥å­ID | |
| `thai` | String | æ³°è¯­å¥å­ | |
| `chinese` | String | ä¸­æ–‡ç¿»è¯‘ | |

### 1.6 Letter Test Bank (å­—æ¯é¢˜åº“)
**é›†åˆå**: `letter_test_bank`
**ç”¨é€”**: å­˜å‚¨å­—æ¯æµ‹è¯•é¢˜ç›®ã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | é¢˜ç›®ID | |
| `question` | String | é¢˜ç›®å†…å®¹ | |
| `options` | Array | é€‰é¡¹åˆ—è¡¨ | |
| `answer` | String | æ­£ç¡®ç­”æ¡ˆ | |

### 1.7 memory_status (ç»Ÿä¸€è®°å¿†çŠ¶æ€è¡¨)
**é›†åˆå**: `memory_status`  
**ç”¨é€”**: ç»Ÿä¸€ SRS å¼•æ“æ ¸å¿ƒè¡¨ï¼Œè®°å½•ç”¨æˆ·å¯¹ä»»æ„å®ä½“ï¼ˆå­—æ¯/å•è¯/å¥å­ç­‰ï¼‰çš„è®°å¿†çŠ¶æ€ã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | è®°å½•ID | è‡ªåŠ¨ç”Ÿæˆ |
| `userId` | String | ç”¨æˆ·ID | ç´¢å¼• |
| `entityType` | String | å®ä½“ç±»å‹ | `'letter'`ã€`'word'` ç­‰ |
| `entityId` | String | å®ä½“ID | å…³è” `letters._id` / `vocabulary._id` ç­‰ï¼Œä¾‹å¦‚ `BaseThai_1_7` |
| `masteryLevel` | Number | æŒæ¡åº¦ | 0.0â€“1.0 |
| `reviewStage` | Number | å¤ä¹ é˜¶æ®µ | ç­‰ä»·äº SMâ€‘2 repetitions |
| `easinessFactor` | Number | æ˜“è®°ç³»æ•° | åˆå§‹ 2.5 |
| `intervalDays` | Number | é—´éš”å¤©æ•° | ä¸‹ä¸€æ¬¡å¤ä¹ é—´éš”ï¼ˆå¤©ï¼‰ |
| `lastReviewAt` | String\|null | ä¸Šæ¬¡å¤ä¹ æ—¶é—´ | ISO å­—ç¬¦ä¸² |
| `nextReviewAt` | String\|null | ä¸‹æ¬¡å¤ä¹ æ—¶é—´ | ç”¨äºç­›é€‰ä»Šæ—¥å¤ä¹ é˜Ÿåˆ— |
| `correctCount` | Number | ç´¯è®¡ç­”å¯¹æ¬¡æ•° | |
| `wrongCount` | Number | ç´¯è®¡ç­”é”™æ¬¡æ•° | |
| `streakCorrect` | Number | è¿ç»­ç­”å¯¹æ¬¡æ•° | |
| `isLocked` | Boolean | æ˜¯å¦é”å®š | é”å®šæ—¶ä¸å®‰æ’å¤ä¹  |
| `createdAt` | String | åˆ›å»ºæ—¶é—´ | |
| `updatedAt` | String | æœ€è¿‘æ›´æ–°æ—¶é—´ | |

### 1.8 user_progress (ç”¨æˆ·æ€»è¿›åº¦è¡¨)
**é›†åˆå**: `user_progress`  
**ç”¨é€”**: è®°å½•ç”¨æˆ·åœ¨å„æ¨¡å—ï¼ˆå­—æ¯/å•è¯/å¥å­/æ–‡ç« ï¼‰çš„æ•´ä½“å®Œæˆåº¦ä¸è§£é”çŠ¶æ€ã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | è®°å½•ID | |
| `userId` | String | ç”¨æˆ·ID | å”¯ä¸€ç´¢å¼• |
| `letterCompleted` | Boolean | æ˜¯å¦å®Œæˆå­—æ¯æ¨¡å— | è§£é”åç»­æ¨¡å—çš„ç¡¬æ¡ä»¶ |
| `letterProgress` | Number | å­—æ¯æ¨¡å—æ•´ä½“è¿›åº¦ | 0.0â€“1.0 |
| `wordUnlocked` | Boolean | å•è¯æ¨¡å—æ˜¯å¦è§£é” | |
| `wordProgress` | Number | å•è¯æ¨¡å—æ•´ä½“è¿›åº¦ | 0.0â€“1.0 |
| `sentenceUnlocked` | Boolean | å¥å­æ¨¡å—æ˜¯å¦è§£é” | |
| `sentenceProgress` | Number | å¥å­æ¨¡å—æ•´ä½“è¿›åº¦ | |
| `articleUnlocked` | Boolean | æ–‡ç« æ¨¡å—æ˜¯å¦è§£é” | |
| `articleProgress` | Number\|undefined | æ–‡ç« æ¨¡å—æ•´ä½“è¿›åº¦ | æ—§è®°å½•å¯èƒ½æ— æ­¤å­—æ®µ |
| `currentStage` | String | å½“å‰å­¦ä¹ é˜¶æ®µ | `'letter' \| 'word' \| 'sentence' \| 'article'` |
| `totalStudyDays` | Number | æ€»å­¦ä¹ å¤©æ•° | |
| `streakDays` | Number | è¿ç»­å­¦ä¹ å¤©æ•° | |
| `lastStudyDate` | String\|null | æœ€è¿‘å­¦ä¹ æ—¥æœŸ | |
| `createdAt` | Date | åˆ›å»ºæ—¶é—´ | |
| `updatedAt` | Date | æœ€è¿‘æ›´æ–°æ—¶é—´ | |

### 1.9 user_alphabet_progress (ç”¨æˆ·å­—æ¯æ¨¡å—è¿›åº¦è¡¨)
**é›†åˆå**: `user_alphabet_progress`  
**ç”¨é€”**: è®°å½•ç”¨æˆ·åœ¨ **å­—æ¯è¯¾ç¨‹æ¨¡å—** çš„æ•´ä½“è¿›åº¦ä¸ä¸‰è½®è¯„ä¼°ç»“æœã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | è®°å½•ID | |
| `userId` | String | ç”¨æˆ·ID | å”¯ä¸€ç´¢å¼• |
| `letterProgress` | Number | å­—æ¯è¯¾ç¨‹æ•´ä½“è¿›åº¦ | 0.0â€“1.0ï¼Œè¯¾ç¨‹/è½®æ¬¡å®Œæˆåæ›´æ–° |
| `letterCompleted` | Boolean | æ˜¯å¦å®Œæˆå…¨éƒ¨å­—æ¯è¯¾ç¨‹ | å®Œæˆåå¯è§£é”å…¨éƒ¨æ¨¡å— |
| `completedLessons` | String[] | å·²å®Œæˆè¯¾ç¨‹IDåˆ—è¡¨ | å¦‚ `["lesson1","lesson2"]` |
| `masteredLetterCount` | Number | å·²æŒæ¡å­—æ¯æ•°é‡ | |
| `totalLetterCount` | Number | å­—æ¯æ€»æ•° | å½“å‰çº¦ 80 |
| `currentRound` | Number | æœ€è¿‘ä¸€è½®è¯„ä¼°è½®æ¬¡ | 1ã€2 æˆ– 3 |
| `roundHistory` | Array\<Object\> | å„è½®è¯„ä¼°è®°å½• | è§ä¸‹è¡¨ |
| `createdAt` | String | åˆ›å»ºæ—¶é—´ | |
| `updatedAt` | String | æœ€è¿‘æ›´æ–°æ—¶é—´ | |

`roundHistory` å­ç»“æ„ï¼š

| å­—æ®µå | ç±»å‹ | æè¿° |
| :--- | :--- | :--- |
| `lessonId` | String | å¯¹åº”è¯¾ç¨‹ IDï¼Œå¦‚ `lesson1` |
| `roundNumber` | Number | è½®æ¬¡ï¼ˆ1/2/3ï¼‰ |
| `totalQuestions` | Number | æœ¬è½®æ€»é¢˜æ•° |
| `correctCount` | Number | ç­”å¯¹é¢˜æ•° |
| `accuracy` | Number | æ­£ç¡®ç‡ï¼ˆ0.0â€“1.0ï¼‰ |
| `passed` | Boolean | æ˜¯å¦é€šè¿‡ï¼ˆâ‰¥ 0.9ï¼‰ |
| `updatedAt` | String | æäº¤æ—¶é—´ |

---

## 2. å…³è”å…³ç³»

- **ç”¨æˆ· -> å•è¯è¿›åº¦**  
  `users.userId` â†’ `user_vocabulary_progress.userId`
- **å•è¯è¿›åº¦ -> å•è¯**  
  `user_vocabulary_progress.vocabularyId` â†’ `vocabulary._id`
- **ç”¨æˆ· -> ç»Ÿä¸€è®°å¿†çŠ¶æ€**  
  `users.userId` â†’ `memory_status.userId`
- **è®°å¿†çŠ¶æ€ -> å®ä½“**  
  `memory_status.entityId` â†’ `letters._id` / `vocabulary._id` / å…¶ä»–å®ä½“é›†åˆ `_id`
- **ç”¨æˆ· -> æ€»è¿›åº¦**  
  `users.userId` â†’ `user_progress.userId`
- **ç”¨æˆ· -> å­—æ¯æ¨¡å—è¿›åº¦**  
  `users.userId` â†’ `user_alphabet_progress.userId`

---

## 3. ç´¢å¼•é…ç½® (Index Configuration)

> ä»¥ä¸‹ç´¢å¼•éœ€è¦åœ¨ CloudBase æ§åˆ¶å°ä¸­ä¸º `vocabulary` é›†åˆæ‰‹åŠ¨åˆ›å»ºï¼Œåç§°ä»…ä½œå‚è€ƒã€‚

| ç´¢å¼•åç§° | å­—æ®µå®šä¹‰ | å”¯ä¸€æ€§ | ç”¨é€” |
| :--- | :--- | :--- | :--- |
| `unique_id` | `{ "vocabularyId": 1 }` | âœ… | ç¡®ä¿å•è¯ ID å”¯ä¸€ï¼Œé˜²æ­¢é‡å¤å¯¼å…¥ |
| `book_lesson` | `{ "source": 1, "lessonNumber": 1, "_id": 1 }` | âŒ | æ ¸å¿ƒæŸ¥è¯¢ï¼šæŒ‰æ•™æå’Œè¯¾æ¬¡åŠ è½½å•è¯åˆ—è¡¨ |
| `search_thai` | `{ "thaiWord": 1 }` | âŒ | æŒ‰æ³°è¯­å•è¯æœç´¢ |
| `search_meaning` | `{ "meaning": 1 }` | âŒ | æŒ‰ä¸­æ–‡å«ä¹‰æœç´¢ |
| `level_filter` | `{ "level": 1 }` | âŒ | æŒ‰éš¾åº¦ç­‰çº§è·¨ä¹¦ç­›é€‰ |

---

## 4. å‰ç«¯èµ„æºè·¯å¾„æ‹¼æ¥æŒ‡å—

> éŸ³é¢‘æ–‡ä»¶æŒ‰æ•™æå­˜æ”¾åœ¨äº‘å­˜å‚¨ `/audio/{source}/` ç›®å½•ä¸‹ï¼Œæ•°æ®åº“ä»…è®°å½•æ–‡ä»¶åéƒ¨åˆ†ã€‚

æ‹¼æ¥å…¬å¼ç¤ºä¾‹ï¼š

```ts
const CLOUD_ROOT = 'cloud://<env-id>.tcloudbaseapp.com'; // äº‘ç¯å¢ƒæ ¹è·¯å¾„
const fullPath = `${CLOUD_ROOT}/audio/${word.source}/${word.audioPath}`;
```

- `word.source`ï¼šå¦‚ `"BaseThai_1"`ï¼›  
- `word.audioPath`ï¼šå¦‚ `"207.mp3"`ã€`"207_sen_å®ç”¨åœºæ™¯1.mp3"` ç­‰ï¼›  
- ä¾‹å¥ã€å¯¹è¯ã€åŒæºè¯ä¸­çš„ `audioPath` åŒæ ·éµå¾ª `{source}/{audioPath}` è§„åˆ™ã€‚

> æ³¨æ„ï¼šè¯·ç¡®ä¿äº‘å­˜å‚¨ä¸­çš„æ–‡ä»¶å¤¹åç§°ä¸ `source` å­—æ®µå®Œå…¨ä¸€è‡´ï¼ˆå¤§å°å†™æ•æ„Ÿï¼‰ï¼Œå¦åˆ™ä¼šå¯¼è‡´éŸ³é¢‘æ— æ³•æ­£ç¡®åŠ è½½ã€‚

---

## 3. è¡¥å……è¯´æ˜

- å®é™…ç´¢å¼•é…ç½®å¯åœ¨ CloudBase æ§åˆ¶å°ä¸­æŸ¥çœ‹å’Œç®¡ç†ï¼›  
- è‹¥æ–°å¢å­—æ®µæˆ–é›†åˆï¼Œè¯·åŒæ­¥æ›´æ–°æœ¬æ–‡ä»¶ï¼Œä»¥é¿å…å‰åç«¯è®¤çŸ¥ä¸ä¸€è‡´ã€‚
</file>

<file path="docs/project-freeze/vocabulary-module-spec.md">
# è¯æ±‡æ¨¡å—æœ€ç»ˆè§„æ ¼è¯´æ˜ï¼ˆVocabulary Module Spec, Freeze Draftï¼‰

> ç›®å½•ï¼š`docs/project-freeze/vocabulary-module-spec.md`  
> é€‚ç”¨èŒƒå›´ï¼š**è¯æ±‡å­¦ä¹ å‰ç«¯ + `vocabulary` äº‘å‡½æ•° + ç»Ÿä¸€è®°å¿†é€»è¾‘ï¼ˆSMâ€‘2ï¼‰**  
> ç›®æ ‡ï¼šå†»ç»“è¯æ±‡æ¨¡å—çš„èŒè´£è¾¹ç•Œã€æµç¨‹ã€é¢˜å‹ä¸è®°å¿†ç­–ç•¥ï¼Œè®©åç»­å¼€å‘åªéœ€æŒ‰æœ¬æ–‡æ¡£å®ç°å³å¯ã€‚

---

## 1. æ¨¡å—å®šä½ä¸è¾¹ç•Œ

### 1.1 æ¨¡å—èŒè´£

è¯æ±‡æ¨¡å—è´Ÿè´£ï¼š

- æä¾›åŸºäºè¯¾ç¨‹çš„**æ³°è¯­å•è¯ç²¾è®² + å¤ä¹ å­¦ä¹ ä½“éªŒ**ï¼›  
- ä½¿ç”¨ `vocabulary` äº‘å‡½æ•°ä¸­çš„ SMâ€‘2 è®°å¿†å¼•æ“ç®¡ç†**é•¿æœŸå¤ä¹ è®¡åˆ’**ï¼›  
- åœ¨å‰ç«¯å®ç°**å½“æ—¥å­¦ä¹ è„šæœ¬ + é”™é¢˜ç»Ÿè®¡ + è´¨é‡èšåˆ**ï¼Œé¿å…é«˜é¢‘ç½‘ç»œè¯·æ±‚ï¼›  
- ä¸ Courses æ¨¡å— & LearningStore ååŒï¼Œè®°å½•ç”¨æˆ·å½“å‰å•è¯è¯¾ç¨‹ã€å­¦ä¹ æ—¶é•¿ä¸æ‰“å¡ä¿¡æ¯ã€‚

### 1.2 ä¸å…¶ä»–æ¨¡å—çš„å…³ç³»

- ä¸ **Courses æ¨¡å—**ï¼š
  - Courses é¡µè´Ÿè´£å±•ç¤ºâ€œåŸºç¡€æ³°è¯­ 1/2/3 â€¦â€ç­‰å•è¯è¯¾ç¨‹ï¼›
  - ç‚¹å‡»æŸä¸ªå•è¯è¯¾ç¨‹å¡ç‰‡åï¼Œå¯¼èˆªåˆ° `app/learning/index.tsx?module=word&source=COURSE_ID`ï¼›
  - Courses ä¸å…³å¿ƒå…·ä½“é¢˜å‹å’Œè®°å¿†é€»è¾‘ã€‚

- ä¸ **LearningStoreï¼ˆå…¨å±€å­¦ä¹ çŠ¶æ€ï¼‰**ï¼š
  - è®°å½• `currentCourseId`ã€`streakDays`ã€`totalStudyMinutes` ç­‰å…¨å±€ä¿¡æ¯ï¼›
  - è¯æ±‡æ¨¡å—åœ¨ä¼šè¯å¼€å§‹/ç»“æŸæ—¶è°ƒç”¨ `learningStore.registerStudySession` è®°å½•ä¸€æ¡å­¦ä¹ ä¼šè¯ã€‚

- ä¸ **Alphabet æ¨¡å— / memory-engine**ï¼š
  - Alphabet æ¨¡å—è´Ÿè´£â€œå­—æ¯è¯¾ç¨‹çº§è®­ç»ƒâ€ï¼Œå†…ç½®ä¸‰è½®æœºåˆ¶ï¼›  
  - è¯æ±‡æ¨¡å—è´Ÿè´£â€œé•¿æœŸè¯æ±‡ SRSâ€ï¼Œä½¿ç”¨ `vocabulary` äº‘å‡½æ•°ç»´æŠ¤ `learningStatus`ï¼›  
  - è¯¾ç¨‹çº§è§£é”ï¼ˆä¾‹å¦‚â€œå¿…é¡»å®Œæˆå­—æ¯è¯¾ç¨‹åæ‰èƒ½å­¦ä¹ è¯æ±‡â€ï¼‰ç”± `moduleAccessStore` æ§åˆ¶ã€‚

---

## 2. ç›¸å…³ä»£ç æ–‡ä»¶ä¸è°ƒç”¨æ ˆ

### 2.1 å‰ç«¯è·¯ç”±ä¸é¡µé¢

- `app/(tabs)/courses.tsx`
  - å±•ç¤ºå…¨éƒ¨è¯¾ç¨‹åˆ—è¡¨ï¼›
  - å¯¹ `category === 'vocabulary'` çš„è¯¾ç¨‹ä½¿ç”¨ `CourseCard` æ¸²æŸ“ï¼›
  - ç‚¹å‡»åï¼š`router.push('/learning?module=word&source=' + course.source)`ï¼›
  - åŒæ—¶è°ƒç”¨ `learningStore.setCurrentCourse(course.source)`ã€‚

- `app/learning/index.tsx`
  - ç»Ÿä¸€å­¦ä¹ å…¥å£ï¼›é€šè¿‡ query å‚æ•° `module` å†³å®šæ˜¯å­—æ¯æ¨¡å—è¿˜æ˜¯è¯æ±‡æ¨¡å—ï¼š
    - `module=word` â†’ è¯æ±‡å­¦ä¹ ä¼šè¯ï¼ˆWordSessionï¼‰ï¼›
    - `module=letter` â†’ å­—æ¯å­¦ä¹ ä¼šè¯ï¼ˆAlphabetSessionï¼‰ã€‚  
  - å½“å‰å®ç°ä»æœ‰å¤§é‡ mock æ•°æ®ï¼Œæœ¬è§„èŒƒå®šä¹‰çš„ä¸º**ç›®æ ‡è¡Œä¸º**ã€‚

### 2.2 ç»„ä»¶å±‚

- `src/components/learning/NewWordView.tsx`
  - å±•ç¤ºå•è¯çš„â€œç²¾è®²å¡ç‰‡â€ï¼ŒåŒ…å«ï¼š
    - æ³°è¯­è¯å½¢ + å‘éŸ³ + è¯æ€§ï¼›
    - åŸºç¡€é‡Šä¹‰ã€è”æƒ³æ‹†åˆ†ã€è®°å¿†æç¤ºï¼›
    - ä¾‹å¥ã€å¯¹è¯ç¤ºä¾‹ã€ç”¨æ³•è¯¦è§£ã€å¸¸è§é”™è¯¯ã€ç›¸ä¼¼è¯å¯¹æ¯”ç­‰ Tabã€‚
  - ç”±è¯æ±‡å­¦ä¹ å¼•æ“åœ¨â€œæ–°è¯è®²è§£é˜¶æ®µâ€ä½¿ç”¨ã€‚

- `src/components/learning/ReviewWordView.tsx`
  - ç°æœ‰ç‰ˆæœ¬ä¸»è¦å±•ç¤ºâ€œå¡ç‰‡ + ä¸‰ä¸ªè´¨é‡æŒ‰é’®ï¼ˆå¿˜è®°/æ¨¡ç³Š/è®°å¾—ï¼‰â€ï¼›  
  - å†»ç»“ç‰ˆç›®æ ‡ï¼š
    - é‡æ„ä¸ºâ€œé¢˜å‹å®¹å™¨â€ï¼Œæ”¯æŒ 4 ç§é€‰æ‹©é¢˜ + 2 ç§æ‹¼å†™é¢˜ï¼ˆè§ 4.1ï¼‰ï¼›  
    - æ¯é“é¢˜åªè´Ÿè´£ï¼š
      - æ¸²æŸ“é¢˜å¹² + é€‰é¡¹/è¾“å…¥æ¡†ï¼›  
      - å°† `isCorrect` / `questionType` å›è°ƒç»™ä¸Šå±‚ã€‚

### 2.3 Store ä¸ Hook

- `src/stores/vocabularyStore.ts`
  - ç›®å‰ï¼šæ··åˆäº†æ—§ç‰ˆ `memory-engine` æ€è·¯ä¸æœ¬åœ°è¿›åº¦é€»è¾‘ã€‚  
  - å†»ç»“ç›®æ ‡ï¼šå°†å…¶é‡æ„ä¸º**è¯æ±‡ä¼šè¯æ€»æ§ Store**ï¼š
    - ç»´æŠ¤ `VocabularySessionState`ï¼ˆè§ 3.3ï¼‰ï¼›  
    - æš´éœ²ï¼š
      - `initializeSession(userId, source)`ï¼šåˆå§‹åŒ– / æ¢å¤ä¼šè¯ï¼›  
      - `answerQuestion(vocabularyId, isCorrect, questionType)`ï¼šè®°å½•ä¸€æ¬¡ç­”é¢˜ï¼›  
      - `revealHint(vocabularyId)`ï¼šç”¨æˆ·æŸ¥çœ‹æç¤º/ç­”æ¡ˆï¼›  
      - `finishSession()`ï¼šç»“æŸä»Šæ—¥å­¦ä¹ å¹¶æäº¤åˆ†æ•°ï¼›  
      - `skipReviewAndLearnNew()`ï¼šè·³è¿‡â€œä»Šæ—¥å¤ä¹ ï¼Œç›´æ¥å­¦æ–°è¯â€ï¼›  
      - `resetCourseProgress(source)`ï¼šæ¸…ç©ºæŸè¯¾ç¨‹çš„æœ¬åœ°/è¿œç«¯è¿›åº¦ã€‚

- `src/stores/learningPreferenceStore.ts`
  - æä¾›ç”¨æˆ·è®¾å®šçš„æ¯æ—¥å•è¯å­¦ä¹ ä¸Šé™ï¼š`dailyLimits.word`ï¼›  
  - è¯æ±‡æ¨¡å—é€šè¿‡å®ƒå†³å®šå½“æ—¥æœ€å¤šå­¦ä¹ /å¤ä¹ å¤šå°‘ä¸ªå•è¯ã€‚

- `src/stores/learningStore.ts`ï¼ˆè§„åˆ’ä¸­ï¼‰
  - è®°å½•å½“å‰è¯¾ç¨‹ã€å­¦ä¹ æ—¶é•¿ã€æ‰“å¡å¤©æ•°ç­‰å…¨å±€ä¿¡æ¯ï¼›  
  - è¯æ±‡ä¼šè¯å¼€å§‹/ç»“æŸæ—¶è°ƒç”¨ï¼š
    - `registerStudySession({ module: 'word', courseSource, durationMinutes })`ã€‚

### 2.4 äº‘å‡½æ•°ä¸åç«¯

- `cloudbase/functions/vocabulary/index.js`
  - å¤š Action äº‘å‡½æ•°ï¼Œè‡³å°‘åŒ…å«ï¼š
    - `getTodayWords`ï¼šè¿”å›ä»Šæ—¥éœ€è¦å­¦ä¹ /å¤ä¹ çš„å•è¯åˆ—è¡¨ï¼›  
    - `updateMastery`ï¼šæ ¹æ®æŒæ¡ç¨‹åº¦æ›´æ–° SMâ€‘2 è®°å¿†çŠ¶æ€ï¼›  
    - `getVocabularyDetail`ï¼šè·å–å•è¯ç²¾è®²å¡ç‰‡å†…å®¹ï¼›  
    - `getReviewStatistics`ï¼šè¿”å›æ•´ä½“è¿›åº¦ç»Ÿè®¡ã€‚  
  - å‚ç…§ `docs/08-Vocabulary-API-Documentation.md`ã€‚

---

## 3. ä¼šè¯å±‚è®¾è®¡ï¼šä»Šæ—¥å­¦ä¹  / å¤ä¹ æµç¨‹

### 3.1 åŸºæœ¬åŸåˆ™

- **ç»Ÿä¸€å…¥å£**ï¼šæ¯æ¬¡è¿›å…¥ `/learning?module=word&source=XXX` éƒ½å¯åŠ¨ä¸€æ¬¡â€œè¯æ±‡å­¦ä¹ ä¼šè¯â€ï¼›  
- **å…ˆå¤ä¹ åæ–°å­¦**ï¼šä¼˜å…ˆå¤„ç† `getTodayWords` è¿”å›çš„å¤ä¹ é¡¹ï¼Œå†åˆ†é…æ–°è¯ï¼›  
- **ä¼šè¯å†…å¤šé¢˜å‹**ï¼šåŒä¸€ä¸ªå•è¯åœ¨ä¸€æ¬¡ä¼šè¯ä¸­å¯ä»¥å‡ºç°å¤šé“é¢˜ï¼Œä½†æœ€ç»ˆåªäº§ç”Ÿä¸€æ¬¡è´¨é‡å€¼ï¼›  
- **å¤±è´¥è¡¥æ•‘**ï¼šæ¯ä¸ªå•è¯è‡³å°‘å‡ºç°ä¸€æ¬¡ç­”å¯¹è®°å½•æ‰ç®—â€œæœ¬æ¬¡ä¼šè¯é€šè¿‡â€ï¼›å¦åˆ™è®°ä¸º `é™Œç”Ÿ`ã€‚

### 3.2 å½“æ—¥ç›®æ ‡ä¸é˜Ÿåˆ—æ„å»º

1. è¯»å–ç”¨æˆ·è®¾å®šï¼š`dailyLimit = learningPreferenceStore.dailyLimits.word`ï¼ˆé»˜è®¤ 20ï¼‰ã€‚  
2. è°ƒç”¨äº‘å‡½æ•°ï¼š

```ts
callCloudFunction<GetTodayWordsResponse>('vocabulary', {
  action: 'getTodayWords',
  data: {
    userId,
    limit: dailyLimit,
    level: courseLevel,        // å¯é€‰ï¼šç”± courseSource å†³å®š
  },
});
```

3. äº‘å‡½æ•°è¿”å›ï¼š

```ts
{
  words: TodayWordItem[];
  summary: {
    reviewCount: number;
    newCount: number;
  };
}
```

4. å‰ç«¯é˜Ÿåˆ—åˆ’åˆ†ï¼š

- `reviewWords` = `words.filter(w => w.learningStatus?.isReview)`ï¼›  
- `newWords`    = `words.filter(w => w.learningStatus?.isNew)`ï¼›  
- å¯ä»¥æ ¹æ® `dailyLimit` åšå†æ¬¡è£å‰ªï¼ˆä¾‹å¦‚â€œè‡³å°‘ä¸€åŠæ˜¯å¤ä¹ è¯â€ï¼‰ã€‚

### 3.3 VocabularySessionStateï¼ˆå»ºè®®ï¼‰

```ts
export type VocabularyQuestionType =
  | 'THAI_TO_CN_4CHOICE'      // çœ‹æ³°è¯­é€‰ä¸­æ–‡
  | 'CN_TO_THAI_4CHOICE'      // çœ‹ä¸­æ–‡é€‰æ³°è¯­
  | 'AUDIO_TO_THAI_4CHOICE'   // å¬éŸ³é€‰æ³°è¯­
  | 'AUDIO_TO_CN_4CHOICE'     // å¬éŸ³é€‰ä¸­æ–‡
  | 'SPELL_THAI_FROM_CN'      // çœ‹ä¸­æ–‡æ‹¼å†™æ³°è¯­
  | 'SPELL_THAI_FROM_AUDIO';  // å¬éŸ³æ‹¼å†™æ³°è¯­

export interface VocabularyQuestionRecord {
  vocabularyId: string;
  questionType: VocabularyQuestionType;
  isCorrect: boolean;
  usedHint: boolean;
}

export interface VocabularyPerWordStats {
  attempts: number;
  wrongCount: number;
  usedHint: boolean;
  questionTypes: VocabularyQuestionType[];
}

export interface VocabularySessionState {
  userId: string;
  courseSource: string;           // ä¾‹å¦‚ 'BASIC_THAI_1'
  dateKey: string;                // 'YYYY-MM-DD'

  reviewQueue: string[];          // vocabularyId[]
  newQueue: string[];             // vocabularyId[]
  currentIndex: number;
  mode: 'REVIEW' | 'LEARN_NEW';

  perWordStats: Record<string, VocabularyPerWordStats>;

   // ç®€å•æœ¬åœ°é”™é¢˜æœ¬ï¼ˆä¾›ä¼šè¯å†…å¤ä¹ ä¸ AI ä½¿ç”¨ï¼‰
   wrongWordIds: string[];        // å½“æ—¥æ›¾ç»ç­”é”™è¿‡çš„å•è¯ IDï¼ˆæŒ‰é¦–æ¬¡å‡ºé”™é¡ºåºå»é‡ï¼‰
   wrongRecords: VocabularyQuestionRecord[]; // è¯¦ç»†é”™é¢˜è®°å½•ï¼Œå¯é€‰ä¼ ç»™ AI

  // æ˜¯å¦å·²æäº¤åˆ°åç«¯
  submitted: boolean;
}
```

æŒä¹…åŒ–ï¼š

- ä½¿ç”¨ `persist` + AsyncStorageï¼Œkey å»ºè®®ä¸ºï¼š`vocabulary-session:${userId}:${courseSource}:${dateKey}`ã€‚  
- è‹¥ç”¨æˆ·ä¸­é€”é€€å‡ºï¼Œå†æ¬¡è¿›å…¥åŒä¸€è¯¾ç¨‹ã€åŒä¸€å¤©æ—¶ï¼Œä¼˜å…ˆæ¢å¤è¯¥ Sessionã€‚

---

## 4. é¢˜å‹ä¸å®‰æ’ç­–ç•¥

### 4.1 å¯å®ç°çš„ 6 ç§é¢˜å‹

1. `THAI_TO_CN_4CHOICE`ï¼š**çœ‹æ³°è¯­é€‰ä¸­æ–‡**ï¼ˆ4 é€‰ 1ï¼‰ã€‚  
2. `CN_TO_THAI_4CHOICE`ï¼š**çœ‹ä¸­æ–‡é€‰æ³°è¯­**ï¼ˆ4 é€‰ 1ï¼‰ã€‚  
3. `AUDIO_TO_THAI_4CHOICE`ï¼š**å¬éŸ³é€‰æ³°è¯­**ï¼ˆ4 é€‰ 1ï¼‰ã€‚  
4. `AUDIO_TO_CN_4CHOICE`ï¼š**å¬éŸ³é€‰ä¸­æ–‡**ï¼ˆ4 é€‰ 1ï¼‰ã€‚  
5. `SPELL_THAI_FROM_CN`ï¼šçœ‹ä¸­æ–‡ï¼Œç”¨æˆ·ä½¿ç”¨ç³»ç»Ÿé”®ç›˜**è¾“å…¥æ³°è¯­æ‹¼å†™**ã€‚  
6. `SPELL_THAI_FROM_AUDIO`ï¼šå¬éŸ³ï¼Œç”¨æˆ·è¾“å…¥æ³°è¯­æ‹¼å†™ã€‚

> è¿‘ä¼¼è¯å¹²æ‰°é¢˜æš‚ä¸åœ¨æœ¬ç‰ˆæœ¬å®ç°ï¼›å¹²æ‰°é¡¹ä¼˜å…ˆä»**åŒè¯¾ç¨‹ã€åŒè¯æ€§**å•è¯ä¸­éšæœºæŠ½å–ã€‚

### 4.2 ä¼šè¯ä¸­çš„é¢˜å‹é¡ºåºï¼ˆMVPï¼‰

ç›®æ ‡ç‰ˆæœ¬ï¼ˆ2 ä¸ªæœˆå†…å¯å®Œæˆï¼‰é‡‡ç”¨**è½»é‡ä¼˜å…ˆ**ç­–ç•¥ï¼š

- å¯¹äº**å¤ä¹ è¯**ï¼š
  - é»˜è®¤å®‰æ’ 1â€“2 é“é¢˜ï¼š
    - ç¬¬ä¸€é“ï¼š`THAI_TO_CN_4CHOICE` æˆ– `CN_TO_THAI_4CHOICE`ï¼›  
    - ç¬¬äºŒé“ï¼ˆå¯é€‰ï¼Œé«˜æŒæ¡åº¦æ—¶ï¼‰ï¼š`AUDIO_TO_THAI_4CHOICE` æˆ– `AUDIO_TO_CN_4CHOICE`ã€‚  
- å¯¹äº**æ–°è¯**ï¼š
  - å…ˆå±•ç¤º `NewWordView` è®²è§£å¡ï¼›  
  - ç´§è·Ÿä¸€é¢˜ï¼š`CN_TO_THAI_4CHOICE`ï¼ˆå·©å›ºå½¢ä¹‰å¯¹åº”ï¼‰ï¼›  
  - å½“è¯¥è¯åœ¨æœªæ¥å¤ä¹ é˜¶æ®µæŒæ¡åº¦è¾ƒé«˜æ—¶ï¼Œæ‰å¼•å…¥æ‹¼å†™é¢˜ã€‚

æ‹¼å†™é¢˜ï¼ˆ5/6ï¼‰æš‚è§„åˆ’ä¸º**åç»­è¿­ä»£**ï¼Œå½“å‰è§„æ ¼åªè¦æ±‚é¢„ç•™ç±»å‹ä¸æ•°æ®ç»“æ„ã€‚

### 4.3 é¢˜å‹ä¸è´¨é‡è¯„åˆ†å…³ç³»

- æ¯é“é¢˜ç»“æŸåï¼ŒStore åªè®°å½•ï¼š

```ts
answerQuestion(vocabularyId, isCorrect, questionType, { usedHint });
```

- ä¼šè¯ç»“æŸæ—¶ï¼Œå¯¹æ¯ä¸ªå•è¯èšåˆï¼š

```ts
type MasteryLevel = 'é™Œç”Ÿ' | 'æ¨¡ç³Š' | 'è®°å¾—';

function computeMasteryFromStats(stats: VocabularyPerWordStats): MasteryLevel {
  if (stats.wrongCount === 0 && !stats.usedHint) return 'è®°å¾—';
  if (stats.wrongCount <= 1) return 'æ¨¡ç³Š';
  return 'é™Œç”Ÿ';
}
```

### 4.4 æœ¬åœ°é”™é¢˜æœ¬ä¸ AI ååŒï¼ˆMVPï¼‰

> ç›®æ ‡ï¼šåœ¨ä¸å¢åŠ é¢å¤–æ•°æ®åº“é›†åˆçš„å‰æä¸‹ï¼Œä¸º AI æ¨¡å—æä¾›â€œä»Šæ—¥é”™è¯åˆ—è¡¨â€ï¼Œç”¨äºç”Ÿæˆé¢å¤–ç»ƒä¹ æˆ–å¾®é˜…è¯»å†…å®¹ã€‚

- åœ¨ `VocabularySessionState` ä¸­ï¼Œä½¿ç”¨ `wrongWordIds` å’Œ `wrongRecords` ä¿å­˜**å½“æ—¥ä¼šè¯å†…çš„é”™é¢˜**ï¼š
  - æ¯å½“ `answerQuestion` æ”¶åˆ° `isCorrect === false` æ—¶ï¼š

    ```ts
    if (!state.wrongWordIds.includes(vocabularyId)) {
      state.wrongWordIds.push(vocabularyId);
    }
    state.wrongRecords.push({ vocabularyId, questionType, isCorrect: false, usedHint });
    ```

  - è¿™äº›æ•°æ®ä»…ä¿å­˜åœ¨å‰ç«¯ Store / AsyncStorage ä¸­ï¼Œç”¨äºï¼š
    - ä¼šè¯å†…éƒ¨çš„â€œé”™é¢˜å†ç»ƒâ€ç¯èŠ‚ï¼›  
    - åœ¨ç”¨æˆ·ä¸»åŠ¨ç‚¹å‡»â€œAI å¼ºåŒ–ç»ƒä¹ â€æ—¶ï¼Œä½œä¸ºå‚æ•°ä¼ ç»™ `ai-engine`ã€‚

- ä¸ AI æ¨¡å—çš„ååŒè°ƒç”¨ç¤ºä¾‹ï¼š

  ```ts
  const { wrongWordIds, courseSource } = useVocabularyStore.getState().session;

  await callCloudFunction('ai-engine', {
    action: 'generateWeaknessVocabulary',
    data: {
      userId,
      topN: 5,
      // å¯é€‰ï¼šå°†æœ¬åœ°é”™é¢˜åˆ—è¡¨ä¼ å…¥ï¼ŒAI ä¼˜å…ˆä½¿ç”¨è¿™äº› ID ç”Ÿæˆå†…å®¹
      focusVocabularyIds: wrongWordIds,
      source: courseSource,
    },
  });
  ```

- è®¾è®¡çº¦æŸï¼š
  - ä¸åœ¨åç«¯æ–°å¢â€œé”™é¢˜æœ¬é›†åˆâ€ï¼Œé•¿æœŸå¼±é¡¹ç”± `memory_status` / `user_vocabulary_progress` ç®¡ç†ï¼›  
  - æœ¬åœ°é”™é¢˜æœ¬åªè´Ÿè´£**å½“æ—¥ä¸´æ—¶é”™è¯¯**ï¼Œç”¨äº AI ç”Ÿæˆæ›´å¤šä¾‹å¥ / å¾®é˜…è¯»æˆ–é¢å¤–é€‰æ‹©é¢˜ç´ æã€‚

---

## 5. ä¸ `vocabulary` äº‘å‡½æ•°çš„äº’åŠ¨

> âš ï¸ å­—æ®µå¯¹é½è¯´æ˜ï¼š  
> - åç«¯ `vocabulary` é›†åˆå·²æ›´æ–°ä¸º**å¯Œç»“æ„å­—æ®µ**ï¼ˆè§ `docs/database_schema.md` 1.2 ä¸ `src/entities/types/vocabulary.types.ts`ï¼‰ï¼›  
> - `getTodayWords`ã€`getVocabularyDetail` ç­‰æ¥å£è¿”å›çš„å­—æ®µå¿…é¡»è‡³å°‘è¦†ç›–ï¼š
>   `_id / vocabularyId / thaiWord / meaning / pronunciation / partOfSpeech / level / lessonNumber / startingLetter / source / audioPath`  
>   ä»¥åŠ `exampleSentences / dialogue / usage / mistakes / cognates` ä¸­ç”¨åˆ°çš„å­å­—æ®µï¼›  
> - è‹¥å®é™…é›†åˆå­—æ®µå‘ç”Ÿå˜åŒ–ï¼Œå¿…é¡»**å…ˆæ›´æ–° `vocabulary.types.ts` å’Œ `database_schema.md`ï¼Œå†åŒæ­¥ä¿®æ”¹æœ¬ Spec å’Œ 08-Vocabulary-API æ–‡æ¡£**ã€‚

### 5.1 è·å–ä»Šæ—¥å•è¯ï¼šgetTodayWords

åœ¨ `initializeSession` ä¸­ï¼š

```ts
const response = await callCloudFunction<ApiResponse<GetTodayWordsResponse>>(
  'vocabulary',
  {
    action: 'getTodayWords',
    data: {
      userId,
      limit: dailyLimit,
      level: courseLevel,
    },
  },
);
```

- è‹¥å‘ç°å­˜åœ¨æœªæäº¤çš„æœ¬åœ° Sessionï¼ˆç›¸åŒ userId + courseSource + dateKey ä¸” `submitted === false`ï¼‰ï¼Œä¼˜å…ˆæ¢å¤æœ¬åœ°çŠ¶æ€ï¼Œ**ä¸é‡å¤è¯·æ±‚**ï¼›  
- æ–°çš„ä¸€å¤©æˆ–é¦–æ¬¡è¿›å…¥æ—¶æ‰è°ƒç”¨ `getTodayWords`ã€‚

### 5.2 æäº¤æŒæ¡ç¨‹åº¦ï¼šupdateMasteryï¼ˆèšåˆæäº¤ï¼‰

åœ¨ `finishSession()` ä¸­ï¼š

```ts
async function finishSession() {
  const { userId, courseSource, perWordStats } = getState().session;

  const entries = Object.entries(perWordStats);

  for (const [vocabularyId, stats] of entries) {
    const mastery = computeMasteryFromStats(stats); // é™Œç”Ÿ/æ¨¡ç³Š/è®°å¾—

    await callCloudFunction('vocabulary', {
      action: 'updateMastery',
      data: {
        userId,
        vocabularyId,
        mastery,
      },
    });
  }

  // æ ‡è®° submittedï¼Œé¿å…é‡å¤æäº¤
  setState((prev) => ({
    ...prev,
    session: { ...prev.session, submitted: true },
  }));
}
```

æ³¨æ„ï¼š

- æ¯ä¸ªå•è¯åœ¨ä¸€æ¬¡ä¼šè¯å†…**ä»…æäº¤ä¸€æ¬¡ mastery**ï¼›  
- å†æ¬¡è¿›å…¥æ—¶ï¼Œå¦‚ä»åœ¨åŒä¸€å¤©ä¸” Session å·²æäº¤ï¼Œåˆ™ä½¿ç”¨æ–°çš„ `getTodayWords` ç»“æœå¼€å§‹ä¸‹ä¸€è½®ï¼ˆé€šå¸¸ä¸ä¼šå‘ç”Ÿï¼‰ã€‚

---

## 6. å…¸å‹ç”¨ä¾‹ä¸ç«¯åˆ°ç«¯æ—¶åº

### 6.1 ä» Courses è¿›å…¥è¯æ±‡å­¦ä¹ 

```text
ç”¨æˆ·
  â”‚ ç‚¹å‡»â€œåŸºç¡€æ³°è¯­ 1â€è¯¾ç¨‹å¡ç‰‡
  â–¼
app/(tabs)/courses.tsx
  â”‚ è°ƒç”¨ learningStore.setCurrentCourse('BASIC_THAI_1')
  â”‚ router.push('/learning?module=word&source=BASIC_THAI_1')
  â–¼
app/learning/index.tsxï¼ˆWordSessionï¼‰
  â”‚ è¯»å– query.module='word', source='BASIC_THAI_1'
  â”‚ è°ƒç”¨ vocabularyStore.initializeSession(userId, source)
  â–¼
vocabularyStore.initializeSession
  â”‚ æ£€æŸ¥æœ¬åœ°æ˜¯å¦å­˜åœ¨æœªæäº¤ Sessionï¼ˆåŒ userId+source+dateï¼‰
  â”œâ”€ æœ‰ â†’ ç›´æ¥æ¢å¤ VocabularySessionStateï¼ˆä¸è°ƒåç«¯ï¼‰
  â””â”€ æ—  â†’ è°ƒç”¨ vocabulary.getTodayWords â†’ æ„å»º reviewQueue/newQueue
  â–¼
WordSession
  â”‚ æ ¹æ®å½“å‰é˜Ÿåˆ—æ¸²æŸ“ï¼š
  â”œâ”€ review item â†’ ReviewWordView + é€‰æ‹©é¢˜
  â””â”€ new item    â†’ NewWordViewï¼ˆè®²è§£ï¼‰â†’ ReviewWordViewï¼ˆè½»é‡é€‰æ‹©é¢˜ï¼‰
```

### 6.2 åšé¢˜ã€è®°å½•ä¸æäº¤

```text
ReviewWordView / æ‹¼å†™ç»„ä»¶
  â”‚ ç”¨æˆ·ç­”é¢˜ â†’ onResult({ isCorrect, questionType, usedHint })
  â–¼
WordSession
  â”‚ è°ƒç”¨ vocabularyStore.answerQuestion(vocabularyId, isCorrect, questionType, usedHint)
  â–¼
vocabularyStore.answerQuestion
  â”‚ æ›´æ–° session.perWordStats[vocabularyId]
  â”‚ æŒ‰é˜Ÿåˆ—è§„åˆ™é€‰æ‹©ä¸‹ä¸€ä¸ªå•è¯
  â–¼
WordSession
  â”‚ é˜Ÿåˆ—å…¨éƒ¨å®Œæˆ â†’ æ˜¾ç¤ºâ€œæœ¬æ¬¡å­¦ä¹ å®Œæˆâ€é¡µ
  â”‚ ç”¨æˆ·ç‚¹å‡»â€œç»“æŸä»Šå¤©å­¦ä¹ â€
  â–¼
vocabularyStore.finishSession
  â”‚ å¯¹æ‰€æœ‰ perWordStats è®¡ç®— masteryï¼ˆé™Œç”Ÿ/æ¨¡ç³Š/è®°å¾—ï¼‰
  â”‚ ä¸ºæ¯ä¸ªå•è¯è°ƒç”¨ vocabulary.updateMasteryï¼ˆä¸€æ¬¡ä¼šè¯åªæäº¤ä¸€æ¬¡ï¼‰
  â”‚ æ ‡è®° session.submitted = true
  â–¼
å­¦ä¹ ç»“æŸ
  â”‚ è°ƒç”¨ learningStore.registerStudySession({ module:'word', courseSource, durationMinutes })
  â”‚ è·³è½¬å›é¦–é¡µæˆ– Courses é¡µ
```

---

## 7. ä»»åŠ¡åˆ—è¡¨ä¸é‡Œç¨‹ç¢‘ï¼ˆè¯æ±‡æ¨¡å—ï¼‰

> ç›®æ ‡ï¼šåœ¨å‰©ä½™çº¦ 2 ä¸ªæœˆçš„å‘¨æœŸå†…ï¼Œå®Œæˆä¸€ä¸ª**å¯ä¸Šçº¿çš„æœ€å°å¯ç”¨è¯æ±‡æ¨¡å—**ã€‚

### 7.1 P0ï¼šæ¥å…¥ `vocabulary` äº‘å‡½æ•°åŸºç¡€èƒ½åŠ›ï¼ˆçº¦ 1 å‘¨ï¼‰

- [ ] å°† `vocabularyStore.initSession` ä»æ—§çš„ memory-engine é€»è¾‘åˆ‡æ¢ä¸º `vocabulary.getTodayWords`ã€‚  
- [ ] å¢åŠ  `vocabularyStore.finishSession`ï¼Œè°ƒç”¨ `updateMastery` æäº¤ç»“æœã€‚  
- [ ] åœ¨ `app/learning/index.tsx` ä¸­ç§»é™¤ mock æ•°æ®ï¼Œæ”¹ä¸ºä½¿ç”¨ `vocabularyStore` æä¾›çš„å½“å‰å•è¯ã€‚

### 7.2 P1ï¼šå®ç° VocabularySessionState ä¸ä¼šè¯æ¢å¤ï¼ˆçº¦ 1â€“2 å‘¨ï¼‰

- [ ] å®šä¹‰å¹¶å®ç° `VocabularySessionState`ã€`perWordStats` ä¸æŒä¹…åŒ–é€»è¾‘ã€‚  
- [ ] å®ç° `answerQuestion` / `skipReviewAndLearnNew` / `resetCourseProgress` ç­‰æ ¸å¿ƒ APIã€‚  
- [ ] æ‰‹å·¥æµ‹è¯•ï¼šåœ¨å¤ä¹ é˜¶æ®µã€æ–°è¯è®²è§£é˜¶æ®µã€é”™é¢˜é˜¶æ®µä¸­é€”é€€å‡ºï¼Œé‡æ–°è¿›å…¥åèƒ½å¤Ÿæ¢å¤ã€‚

### 7.3 P2ï¼šé¢˜å‹å®¹å™¨ä¸ 4 ç§é€‰æ‹©é¢˜ï¼ˆçº¦ 2 å‘¨ï¼‰

- [ ] é‡æ„ `ReviewWordView`ï¼Œæ‹†æˆï¼šé¢˜ç›®å®¹å™¨ + å…·ä½“é¢˜å‹ rendererã€‚  
- [ ] å®ç° 4 ç§é€‰æ‹©é¢˜ï¼ˆä¸å«æ‹¼å†™é¢˜ï¼‰ï¼Œæ”¯æŒä¼ å…¥å¹²æ‰°é¡¹ã€‚  
- [ ] å®ç°ç®€å•å¹²æ‰°é¡¹ç”Ÿæˆå™¨ï¼šä»åŒè¯¾ç¨‹ + åŒè¯æ€§ä¸­éšæœºé€‰ 3 ä¸ªã€‚  
- [ ] å°† `WordSession` æ”¹ä¸ºæ ¹æ® `learningStatus` ä¸ `perWordStats` é€‰æ‹©é¢˜å‹ã€‚

### 7.4 P3ï¼šæ‹¼å†™é¢˜ï¼ˆå¯é€‰ï¼Œçº¦ 2 å‘¨ï¼‰

- [ ] å®ç° `SPELL_THAI_FROM_CN` ä¸ `SPELL_THAI_FROM_AUDIO` é¢˜å‹ç»„ä»¶ã€‚  
- [ ] ä½¿ç”¨ç³»ç»Ÿé”®ç›˜è¾“å…¥æ³°è¯­ï¼Œä¸åšæ¨¡ç³ŠåŒ¹é…ï¼Œåªæ¥å—**å®Œå…¨ä¸€è‡´**çš„è¯å½¢ã€‚  
- [ ] å°†æ‹¼å†™é¢˜ä»…ç”¨äºé«˜æŒæ¡åº¦å•è¯ï¼Œä»¥å‡å°‘ç”¨æˆ·è´Ÿæ‹…ã€‚

### 7.5 P4ï¼šç»Ÿè®¡ä¸ä¼˜åŒ–ï¼ˆçº¦ 1 å‘¨ï¼‰

- [ ] é›†æˆ `getReviewStatistics`ï¼Œåœ¨ Courses æˆ–ä¸ªäººä¸­å¿ƒå±•ç¤ºæ•´ä½“æŒæ¡ç‡ã€‚  
- [ ] ä¸º `vocabulary` äº‘å‡½æ•°å¢åŠ å¿…è¦æ—¥å¿—ï¼ˆuserIdã€vocabularyIdã€masteryã€sourceï¼‰ã€‚  
- [ ] åœ¨ `docs/project-freeze/README.md` ä¸­æ ‡è®°è¯æ±‡æ¨¡å—ä¸ºâ€œå·²å†»ç»“æ¶æ„â€ã€‚

---

æœ¬è§„æ ¼æ–‡æ¡£å®šä¹‰äº†è¯æ±‡æ¨¡å—ä»è·¯ç”±ã€ç»„ä»¶ã€Storeã€äº‘å‡½æ•°åˆ°è®°å¿†ç®—æ³•çš„å®Œæ•´é“¾è·¯ï¼Œå¹¶ç»™å‡ºäº†**æŒ‰å•è¯èšåˆè´¨é‡ + æ‰¹é‡æäº¤**çš„æœ€ç»ˆæ–¹æ¡ˆã€‚  
åç»­æ‰€æœ‰å…³äºè¯æ±‡çš„ UI/é¢˜å‹/AI æ‹“å±•ï¼ˆä¾‹å¦‚ AI ä¾‹å¥ç”Ÿæˆã€å¼±é¡¹å¼ºåŒ–ï¼‰éƒ½å¿…é¡»å»ºç«‹åœ¨æœ¬è§„æ ¼ä¹‹ä¸Šï¼Œä¸å¾—å†å¼•å…¥ç¬¬äºŒå¥—è®°å¿† / é˜Ÿåˆ—ç³»ç»Ÿã€‚***
</file>

<file path="src/components/common/Button.tsx">
// src/components/common/Button.tsx
import React from 'react';
import { 
  TouchableOpacity,   // å¯ç‚¹å‡»ç»„ä»¶
  Text,               // æ–‡æœ¬ç»„ä»¶
  StyleSheet,         // æ ·å¼è¡¨
  ActivityIndicator,  // åŠ è½½åŠ¨ç”»
  ViewStyle,          // æ ·å¼ç±»å‹
  TextStyle           // æ–‡æœ¬æ ·å¼ç±»å‹
} from 'react-native';

// ã€æ¥å£ã€‘å®šä¹‰ç»„ä»¶æ¥æ”¶çš„å±æ€§
interface ButtonProps {
  title: string;                              // æŒ‰é’®æ–‡å­—
  onPress: () => void;                        // ç‚¹å‡»äº‹ä»¶
  loading?: boolean;                          // æ˜¯å¦åŠ è½½ä¸­(å¯é€‰)
  disabled?: boolean;                         // æ˜¯å¦ç¦ç”¨(å¯é€‰)
  variant?: 'primary' | 'secondary';          // æ ·å¼å˜ä½“(å¯é€‰)
  style?: ViewStyle;                          // è‡ªå®šä¹‰æ ·å¼(å¯é€‰)
}

// ã€ç»„ä»¶ã€‘Button
export default function Button({ 
  title, 
  onPress, 
  loading = false,      // é»˜è®¤å€¼
  disabled = false, 
  variant = 'primary',
  style
}: ButtonProps) {
  return (
    <TouchableOpacity 
      style={[  // ã€æ•°ç»„æ ·å¼ã€‘åé¢çš„ä¼šè¦†ç›–å‰é¢çš„
        styles.button,                                  // åŸºç¡€æ ·å¼
        variant === 'secondary' && styles.buttonSecondary,  // æ¬¡è¦æŒ‰é’®æ ·å¼
        disabled && styles.buttonDisabled,              // ç¦ç”¨æ ·å¼
        style  // è‡ªå®šä¹‰æ ·å¼(æœ€é«˜ä¼˜å…ˆçº§)
      ]}
      onPress={onPress}
      disabled={disabled || loading}  // åŠ è½½æ—¶ä¹Ÿç¦ç”¨
      activeOpacity={0.7}  // ç‚¹å‡»æ—¶é€æ˜åº¦
    >
      {loading ? (
        <ActivityIndicator color={variant === 'primary' ? '#fff' : '#4A90E2'} />
      ) : (
        <Text style={[
          styles.buttonText,
          variant === 'secondary' && styles.buttonTextSecondary
        ]}>
          {title}
        </Text>
      )}
    </TouchableOpacity>
  );
}

// ã€æ ·å¼è¡¨ã€‘
const styles = StyleSheet.create({
  button: {
    backgroundColor: '#4A90E2',  // è“è‰²èƒŒæ™¯
    paddingVertical: 15,         // ä¸Šä¸‹å†…è¾¹è·
    borderRadius: 8,             // åœ†è§’
    alignItems: 'center',        // æ°´å¹³å±…ä¸­
  },
  buttonSecondary: {
    backgroundColor: '#fff',     // ç™½è‰²èƒŒæ™¯
    borderWidth: 1,              // è¾¹æ¡†å®½åº¦
    borderColor: '#4A90E2',      // è¾¹æ¡†é¢œè‰²
  },
  buttonDisabled: {
    opacity: 0.5,                // åŠé€æ˜
  },
  buttonText: {
    color: '#fff',               // ç™½è‰²æ–‡å­—
    fontSize: 16,
    fontWeight: '600',           // åŠ ç²—
  },
  buttonTextSecondary: {
    color: '#4A90E2',            // è“è‰²æ–‡å­—
  },
});
</file>

<file path="src/components/common/GlassCard.tsx">
// src/components/common/GlassCard.tsx
import React from 'react';
import { View, StyleSheet, ViewStyle } from 'react-native';

interface GlassCardProps {
  children: React.ReactNode;
  style?: ViewStyle | ViewStyle[];
}

export const GlassCard: React.FC<GlassCardProps> = ({ children, style }) => {
  return (
    <View style={[styles.card, style]}>
      {children}
    </View>
  );
};

const styles = StyleSheet.create({
  card: {
    backgroundColor: 'rgba(255, 255, 255, 0.85)',
    borderRadius: 16,
    padding: 20,
    borderWidth: 1,
    borderColor: 'rgba(229, 226, 219, 0.8)',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 12,
    elevation: 5,
  },
});
</file>

<file path="src/components/courses/CourseCard.tsx">
import React from 'react';
import { View, Text, StyleSheet, Pressable, Image, ImageSourcePropType } from 'react-native';
import { useTranslation } from 'react-i18next';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

export interface CourseCardData {
    id: string;
    source: string;
    title: string;
    description: string;
    level: string;
    imageSource: ImageSourcePropType;
    category: string;
    lessons: number;
}

interface CourseCardProps {
    course: CourseCardData;
    isCurrent: boolean;
    onStart: () => void;
    onCardPress?: () => void;
    progress?: {
        completed: number;
        total: number;
    };
    isLocked?: boolean; // Added: Locked state prop
}

export function CourseCard({
    course,
    isCurrent,
    onStart,
    onCardPress,
    progress,
    isLocked = false, // Default to unlocked
}: CourseCardProps) {
    const { t } = useTranslation();

    const progressPercent = progress && progress.total > 0
        ? Math.min(100, Math.round((progress.completed / progress.total) * 100))
        : null;

    return (
        <Pressable
            key={course.id}
            style={[
                styles.card,
                (isCurrent && !isLocked) && styles.activeCard,
                // Removed: isLocked && styles.lockedCard (User requested normal look)
            ]}
            onPress={isLocked ? undefined : (onCardPress || onStart)} // Still disable press if locked
            disabled={isLocked}
        >
            <Image
                source={course.imageSource}
                style={styles.image} // Removed: isLocked && styles.lockedImage
            />
            <View style={styles.info}>
                <View style={styles.header}>
                    <Text style={styles.title} numberOfLines={1}>
                        {course.title}
                    </Text>
                    {!isLocked && (
                        <View style={styles.levelBadge}>
                            <Text style={styles.levelText}>{course.level}</Text>
                        </View>
                    )}
                </View>

                <Text style={styles.description} numberOfLines={2}>
                    {course.description}
                </Text>

                <View style={styles.footer}>
                    {/* Meta Info (Hidden or dimmed when locked) */}
                    <View style={styles.metaColumn}>
                        {!isLocked && (
                            progressPercent !== null ? (
                                <>
                                    <View style={styles.progressBar}>
                                        <View style={[styles.progressFill, { width: `${progressPercent}%` }]} />
                                    </View>
                                    <Text style={styles.metaText}>
                                        {progress?.completed}/{progress?.total} ({progressPercent}%)
                                    </Text>
                                </>
                            ) : (
                                <Text style={styles.metaText}>{course.lessons} è¯¾æ—¶</Text>
                            )
                        )}
                    </View>

                    <Pressable
                        style={[
                            styles.startBtn,
                            isCurrent && styles.activeStartBtn,
                            isLocked && styles.lockedBtn // Locked button style
                        ]}
                        onPress={(e) => {
                            if (isLocked) return;
                            e.stopPropagation();
                            onStart();
                        }}
                        disabled={isLocked}
                    >
                        <Text style={[
                            styles.startBtnText,
                            isCurrent && styles.activeStartBtnText,
                            isLocked && styles.lockedBtnText // Locked text style
                        ]}>
                            {isLocked
                                ? t('courses.locked', 'æœªè§£é”')
                                : (isCurrent ? t('courses.continue', 'ç»§ç»­å­¦ä¹ ') : t('courses.startBtnText', 'å¼€å§‹å­¦ä¹ '))
                            }
                        </Text>
                    </Pressable>
                </View>
            </View>
        </Pressable>
    );
}

const styles = StyleSheet.create({
    card: {
        flexDirection: 'row',
        backgroundColor: Colors.white,
        borderRadius: 16,
        overflow: 'hidden',
        borderWidth: 1,
        borderColor: Colors.sand,
        height: 136,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.05,
        shadowRadius: 8,
        elevation: 3,
    },
    activeCard: {
        borderColor: Colors.thaiGold,
        borderWidth: 2,
        backgroundColor: '#FFFCF5',
    },
    lockedCard: {
        backgroundColor: '#F5F5F5',
        borderColor: '#E0E0E0',
        elevation: 0,
        shadowOpacity: 0,
    },
    image: {
        width: 110,
        height: '100%',
        resizeMode: 'cover',
    },
    lockedImage: {
        opacity: 0.5,
        tintColor: 'gray', // Grayscale effect
    },
    info: {
        flex: 1,
        padding: 12,
        justifyContent: 'space-between',
        gap: 8,
    },
    header: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'flex-start',
        gap: 8,
    },
    title: {
        flex: 1,
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.ink,
    },
    lockedText: {
        color: '#A0A0A0',
    },
    levelBadge: {
        paddingHorizontal: 6,
        paddingVertical: 2,
        backgroundColor: 'rgba(212, 175, 55, 0.1)',
        borderRadius: 4,
        borderWidth: 1,
        borderColor: 'rgba(212, 175, 55, 0.3)',
    },
    levelText: {
        fontSize: 10,
        color: Colors.thaiGold,
        fontFamily: Typography.notoSerifRegular,
    },
    description: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 12,
        color: Colors.taupe,
        lineHeight: 16,
    },
    footer: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        gap: 12,
    },
    metaColumn: {
        flex: 1,
        gap: 6,
    },
    metaText: {
        fontSize: 11,
        color: Colors.taupe,
        fontFamily: Typography.notoSerifRegular,
    },
    progressBar: {
        height: 6,
        backgroundColor: '#F0F0F0',
        borderRadius: 3,
        overflow: 'hidden',
    },
    progressFill: {
        height: '100%',
        backgroundColor: Colors.thaiGold,
        borderRadius: 3,
    },
    startBtn: {
        paddingHorizontal: 14,
        paddingVertical: 10,
        backgroundColor: Colors.ink,
        borderRadius: 12,
    },
    activeStartBtn: {
        backgroundColor: Colors.thaiGold,
    },
    lockedBtn: {
        backgroundColor: '#E0E0E0',
    },
    startBtnText: {
        fontSize: 12,
        color: Colors.white,
        fontFamily: Typography.notoSerifRegular,
    },
    activeStartBtnText: {
        color: Colors.white,
        fontWeight: '600',
    },
    lockedBtnText: {
        color: '#9E9E9E',
    },
});
</file>

<file path="src/components/courses/CourseSelectionModal.tsx">
import React from 'react';
import { View, Text, StyleSheet, Modal, Pressable } from 'react-native';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { useTranslation } from 'react-i18next';

interface CourseSelectionModalProps {
    visible: boolean;
    courseTitle: string;
    onConfirm: () => void;
    onCancel: () => void;
}

export function CourseSelectionModal({
    visible,
    courseTitle,
    onConfirm,
    onCancel,
}: CourseSelectionModalProps) {
    const { t } = useTranslation();

    return (
        <Modal
            visible={visible}
            transparent
            animationType="fade"
            onRequestClose={onCancel}
        >
            <View style={styles.overlay}>
                <View style={styles.modalContainer}>
                    <Text style={styles.title}>{t('courses.switchCourseTitle', 'Switch Course?')}</Text>
                    <Text style={styles.message}>
                        {t('courses.switchCourseMessage', 'åˆ‡æ¢åˆ° {{course}} ä¼šå…ˆä¿å­˜å½“å‰è¯¾ç¨‹çš„è¿›åº¦ï¼Œå†å¼€å§‹æ–°çš„è¯¾ç¨‹ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ', { course: courseTitle })}
                    </Text>

                    <View style={styles.buttonContainer}>
                        <Pressable style={[styles.button, styles.cancelButton]} onPress={onCancel}>
                            <Text style={styles.cancelButtonText}>{t('common.cancel', 'Cancel')}</Text>
                        </Pressable>
                        <Pressable style={[styles.button, styles.confirmButton]} onPress={onConfirm}>
                            <Text style={styles.confirmButtonText}>{t('common.confirm', 'Confirm')}</Text>
                        </Pressable>
                    </View>
                </View>
            </View>
        </Modal>
    );
}

const styles = StyleSheet.create({
    overlay: {
        flex: 1,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        justifyContent: 'center',
        alignItems: 'center',
        padding: 24,
    },
    modalContainer: {
        backgroundColor: Colors.white,
        borderRadius: 20,
        padding: 24,
        width: '100%',
        maxWidth: 340,
        alignItems: 'center',
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.1,
        shadowRadius: 12,
        elevation: 5,
    },
    title: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 20,
        color: Colors.ink,
        marginBottom: 12,
        textAlign: 'center',
    },
    message: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.taupe,
        textAlign: 'center',
        marginBottom: 24,
        lineHeight: 20,
    },
    buttonContainer: {
        flexDirection: 'row',
        gap: 12,
        width: '100%',
    },
    button: {
        flex: 1,
        height: 44,
        borderRadius: 12,
        justifyContent: 'center',
        alignItems: 'center',
    },
    cancelButton: {
        backgroundColor: Colors.paper,
        borderWidth: 1,
        borderColor: Colors.sand,
    },
    confirmButton: {
        backgroundColor: Colors.thaiGold,
    },
    cancelButtonText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 14,
        color: Colors.taupe,
    },
    confirmButtonText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 14,
        color: Colors.white,
    },
});
</file>

<file path="src/components/learning/alphabet/PhonicsRuleCard.tsx">
// src/components/learning/alphabet/PhonicsRuleCard.tsx

import React, { useState, useEffect, useCallback, useRef } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  ScrollView,
  Pressable,
  ActivityIndicator,
} from 'react-native';
import { Audio } from 'expo-av';
import { X } from 'lucide-react-native';

import type { PhonicsRule } from '@/src/entities/types/phonicsRule.types';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

// ==================== Props æ¥å£ ====================

interface PhonicsRuleCardProps {
  /** æ‹¼è¯»è§„åˆ™æ•°æ® */
  rule: PhonicsRule;

  /** å®Œæˆå›è°ƒ(å€’è®¡æ—¶ç»“æŸæˆ–ç”¨æˆ·ç‚¹å‡»ç»§ç»­) */
  onComplete: () => void;

  /** æ˜¯å¦æ˜¾ç¤ºå…³é—­æŒ‰é’®(å¯é€‰,é»˜è®¤false) */
  showCloseButton?: boolean;

  /** å…³é—­å›è°ƒ(å¯é€‰) */
  onClose?: () => void;
}

// ==================== ä¸»ç»„ä»¶ ====================

export function PhonicsRuleCard({ rule, onComplete, showCloseButton = false, onClose, }: PhonicsRuleCardProps) {
  const [timeLeft, setTimeLeft] = useState(rule.duration);
  const [isPlaying, setIsPlaying] = useState(false);
  const soundRef = useRef<Audio.Sound | null>(null);

  // ===== å€’è®¡æ—¶é€»è¾‘ =====
  useEffect(() => {
    if (timeLeft <= 0) {
      onComplete();
      return;
    }

    const timer = setInterval(() => {
      setTimeLeft((prev) => prev - 1);
    }, 1000);

    return () => clearInterval(timer);
  }, [timeLeft, onComplete]);

  // ===== éŸ³é¢‘æ’­æ”¾ =====
  const handlePlayExample = useCallback(async () => {
    console.log('ğŸ‘† [PhonicsRuleCard] Interactive Example Clicked');
    console.log('ğŸ“Š [PhonicsRuleCard] Data:', rule.interactiveExample);
    console.log('ğŸ”— [PhonicsRuleCard] Source Rule:', { id: rule.id, title: rule.title, lessonId: rule.lessonId });

    if (!rule.interactiveExample?.audioUrl) {
      console.warn('âš ï¸ [PhonicsRuleCard] No audioUrl found in interactiveExample');
      return;
    }

    try {
      setIsPlaying(true);

      // å¦‚æœå·²æœ‰éŸ³é¢‘å®ä¾‹,ç›´æ¥é‡æ’­
      if (soundRef.current) {
        await soundRef.current.replayAsync();
        setIsPlaying(false);
        return;
      }

      // åˆ›å»ºæ–°éŸ³é¢‘å®ä¾‹
      const { sound } = await Audio.Sound.createAsync(
        { uri: rule.interactiveExample.audioUrl },
        { shouldPlay: true }
      );

      soundRef.current = sound;

      // ç›‘å¬æ’­æ”¾å®Œæˆ
      sound.setOnPlaybackStatusUpdate((status) => {
        if (status.isLoaded && status.didJustFinish) {
          setIsPlaying(false);
        }
      });
    } catch (error) {
      console.warn('[PhonicsRuleCard] æ’­æ”¾éŸ³é¢‘å¤±è´¥:', error);
      setIsPlaying(false);
    }
  }, [rule.interactiveExample]);

  // ===== æ¸…ç†éŸ³é¢‘èµ„æº =====
  useEffect(() => {
    return () => {
      if (soundRef.current) {
        soundRef.current.unloadAsync().catch(() => { });
        soundRef.current = null;
      }
    };
  }, []);

  // ===== æ¸²æŸ“å¯è§†åŒ–å›¾è¡¨ =====
  const renderVisualChart = () => {
    if (!rule.visualChart) return null;

    return (
      <View style={styles.chartContainer}>
        <Text style={styles.chartTitle}>å£°è°ƒè§„åˆ™è¡¨</Text>

        {/* è¡¨å¤´ */}
        <View style={styles.chartRow}>
          {rule.visualChart.columns.map((col, index) => (
            <View
              key={index}
              style={[
                styles.chartCell,
                styles.chartHeaderCell,
                index === 0 && styles.chartFirstColumn,
              ]}
            >
              <Text style={styles.chartHeaderText}>{col}</Text>
            </View>
          ))}
        </View>

        {/* æ•°æ®è¡Œ */}
        {rule.visualChart.rows.map((row, rowIndex) => (
          <View key={rowIndex} style={styles.chartRow}>
            {row.map((cell, cellIndex) => {
              const isFirstColumn = cellIndex === 0;
              const isInteractive = rule.visualChart?.interactive && !isFirstColumn;

              return (
                <Pressable
                  key={cellIndex}
                  style={[
                    styles.chartCell,
                    isFirstColumn && styles.chartFirstColumn,
                    isInteractive && styles.chartInteractiveCell,
                  ]}
                  disabled={!isInteractive}
                  onPress={() => {
                    if (isInteractive) {
                      // æœªæ¥å¯æ‰©å±•:ç‚¹å‡»å•å…ƒæ ¼æ’­æ”¾å¯¹åº”å£°è°ƒç¤ºä¾‹
                      console.log('Play tone example:', row[0], cell);
                    }
                  }}
                >
                  <Text
                    style={[
                      styles.chartCellText,
                      isFirstColumn && styles.chartFirstColumnText,
                      !isFirstColumn && styles.chartToneText,
                    ]}
                  >
                    {cell}
                  </Text>
                </Pressable>
              );
            })}
          </View>
        ))}
      </View>
    );
  };

  return (
    <View style={styles.overlay}>
      <View style={styles.card}>
        {/* å…³é—­æŒ‰é’® */}
        {showCloseButton && (
          <TouchableOpacity
            style={styles.closeButton}
            onPress={onClose}
            accessibilityRole="button"
            accessibilityLabel="å…³é—­è§„åˆ™å¡ç‰‡"
          >
            <X size={24} color={Colors.taupe} />
          </TouchableOpacity>
        )}

        {/* å€’è®¡æ—¶æ˜¾ç¤º */}
        <View style={styles.timerContainer}>
          <Text style={styles.timerText}>{timeLeft}ç§’</Text>
        </View>

        <ScrollView
          style={styles.scrollView}
          contentContainerStyle={styles.scrollContent}
          showsVerticalScrollIndicator={true}
        >
          {/* æ ‡é¢˜ */}
          <Text style={styles.title}>{rule.title}</Text>

          {/* è§„åˆ™å†…å®¹ */}
          <View style={styles.contentContainer}>
            {rule.content.map((line, index) => (
              <Text
                key={index}
                style={[
                  styles.contentLine,
                  line === '' && styles.emptyLine,
                ]}
              >
                {line}
              </Text>
            ))}
          </View>

          {/* äº¤äº’å¼ç¤ºä¾‹ */}
          {rule.interactiveExample && (
            <View style={styles.exampleContainer}>
              <Text style={styles.exampleLabel}>ğŸ“Œ äº¤äº’ç¤ºä¾‹</Text>
              <Pressable
                style={styles.exampleButton}
                onPress={handlePlayExample}
                disabled={isPlaying}
                accessibilityRole="button"
                accessibilityLabel={`æ’­æ”¾ç¤ºä¾‹: ${rule.interactiveExample.syllable}`}
              >
                {isPlaying ? (
                  <ActivityIndicator size="small" color={Colors.white} />
                ) : (
                  <>
                    <View style={styles.exampleParts}>
                      <Text style={styles.exampleConsonant}>
                        {rule.interactiveExample.consonant}
                      </Text>
                      <Text style={styles.examplePlus}>+</Text>
                      <Text style={styles.exampleVowel}>
                        {rule.interactiveExample.vowel}
                      </Text>
                      <Text style={styles.exampleEquals}>=</Text>
                      <Text style={styles.exampleSyllable}>
                        {rule.interactiveExample.syllable}
                      </Text>
                    </View>
                    <Text style={styles.examplePronunciation}>
                      [{rule.interactiveExample.pronunciation}]
                    </Text>
                  </>
                )}
              </Pressable>
            </View>
          )}

          {/* å¯è§†åŒ–å›¾è¡¨ */}
          {renderVisualChart()}
        </ScrollView>

        {/* ç»§ç»­æŒ‰é’® */}
        <TouchableOpacity
          style={styles.continueButton}
          onPress={onComplete}
          accessibilityRole="button"
          accessibilityLabel="æ˜ç™½äº†,ç»§ç»­å­¦ä¹ "
        >
          <Text style={styles.continueText}>æ˜ç™½äº†,ç»§ç»­å­¦ä¹  â†’</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}

// ==================== æ ·å¼ ====================

const styles = StyleSheet.create({
  overlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 1000,
  },
  card: {
    width: '90%',
    maxWidth: 500,
    maxHeight: '85%',
    backgroundColor: Colors.white,
    borderRadius: 16,
    padding: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 12,
    elevation: 10,
  },
  closeButton: {
    position: 'absolute',
    top: 16,
    right: 16,
    zIndex: 10,
    padding: 8,
  },
  timerContainer: {
    alignItems: 'flex-end',
    marginBottom: 12,
  },
  timerText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  scrollView: {
    flexGrow: 0,
  },
  scrollContent: {
    paddingBottom: 16,
  },
  title: {
    fontFamily: Typography.playfairBold,
    fontSize: 22,
    color: Colors.thaiGold,
    marginBottom: 20,
    textAlign: 'center',
  },
  contentContainer: {
    marginBottom: 20,
  },
  contentLine: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    lineHeight: 24,
    color: Colors.ink,
    marginBottom: 4,
  },
  emptyLine: {
    height: 8,
  },
  exampleContainer: {
    backgroundColor: '#F5F5F5',
    borderRadius: 12,
    padding: 16,
    marginBottom: 20,
  },
  exampleLabel: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
    marginBottom: 12,
  },
  exampleButton: {
    backgroundColor: Colors.thaiGold,
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    minHeight: 60,
    justifyContent: 'center',
  },
  exampleParts: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  exampleConsonant: {
    fontFamily: Typography.playfairBold,
    fontSize: 32,
    color: Colors.white,
  },
  examplePlus: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 24,
    color: 'rgba(255, 255, 255, 0.7)',
    marginHorizontal: 8,
  },
  exampleVowel: {
    fontFamily: Typography.playfairBold,
    fontSize: 32,
    color: Colors.white,
  },
  exampleEquals: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 24,
    color: 'rgba(255, 255, 255, 0.7)',
    marginHorizontal: 8,
  },
  exampleSyllable: {
    fontFamily: Typography.playfairBold,
    fontSize: 36,
    color: Colors.white,
  },
  examplePronunciation: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.9)',
  },
  chartContainer: {
    marginBottom: 20,
    borderWidth: 1,
    borderColor: Colors.sand,
    borderRadius: 8,
    overflow: 'hidden',
  },
  chartTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.ink,
    padding: 12,
    backgroundColor: '#F5F5F5',
    textAlign: 'center',
  },
  chartRow: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: Colors.sand,
  },
  chartCell: {
    flex: 1,
    padding: 12,
    justifyContent: 'center',
    alignItems: 'center',
    minHeight: 48,
  },
  chartHeaderCell: {
    backgroundColor: '#FFF9E6',
  },
  chartFirstColumn: {
    backgroundColor: '#F5F5F5',
    flex: 1.2,
  },
  chartInteractiveCell: {
    backgroundColor: '#F0F8FF',
  },
  chartHeaderText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    color: Colors.ink,
    textAlign: 'center',
  },
  chartCellText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.ink,
    textAlign: 'center',
  },
  chartFirstColumnText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    color: Colors.thaiGold,
  },
  chartToneText: {
    fontFamily: Typography.playfairBold,
    fontSize: 24,
    color: Colors.ink,
  },
  continueButton: {
    backgroundColor: Colors.thaiGold,
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    marginTop: 16,
  },
  continueText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
  },
});
</file>

<file path="src/components/learning/ModuleLockedScreen.tsx">
// src/components/learning/ModuleLockedScreen.tsx

/**
 * æ¨¡å—é”å®šç•Œé¢
 * 
 * åŠŸèƒ½ï¼š
 * 1. æ˜¾ç¤ºæ¨¡å—è¢«é”å®šçš„æç¤º
 * 2. æ˜¾ç¤ºå½“å‰è¿›åº¦å’Œè§£é”è¦æ±‚
 * 3. æä¾›è¿”å›æŒ‰é’®
 */

import React from 'react';
import { View, Text, StyleSheet, Pressable } from 'react-native';
import { useTranslation } from 'react-i18next';
import { useRouter } from 'expo-router';
import { Lock, ArrowLeft } from 'lucide-react-native';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { useModuleAccessStore, type ModuleType } from '@/src/stores/moduleAccessStore';

// ==================== ç±»å‹å®šä¹‰ ====================

interface ModuleLockedScreenProps {
    moduleType: ModuleType;
}

// ==================== è¾…åŠ©å‡½æ•° ====================

/**
 * è·å–æ¨¡å—çš„æ˜¾ç¤ºåç§°
 */
const getModuleName = (moduleType: ModuleType, t: any): string => {
    const moduleNames: Record<ModuleType, string> = {
        letter: t('modules.alphabet'),
        word: t('modules.word'),
        sentence: t('modules.sentence'),
        article: t('modules.article'),
    };
    return moduleNames[moduleType];
};

/**
 * è·å–é”å®šåŸå› å’Œè§£é”è¦æ±‚
 */
const getUnlockRequirement = (
    moduleType: ModuleType,
    userProgress: any,
    t: any
): { prerequisite: string; currentProgress: number; requiredProgress: number } => {
    if (!userProgress) {
        return {
            prerequisite: t('moduleAccess.noProgress'),
            currentProgress: 0,
            requiredProgress: 95,
        };
    }

    switch (moduleType) {
        case 'word':
            return {
                prerequisite: t('moduleAccess.prerequisite.word'),
                // åç«¯ letterProgress ä¸º 0-1ï¼Œå±•ç¤ºæ—¶è½¬ä¸º 0-100
                currentProgress: (userProgress.letterProgress || 0) * 100,
                requiredProgress: 80,
            };
        case 'sentence':
            return {
                prerequisite: t('moduleAccess.prerequisite.sentence'),
                currentProgress: userProgress.wordProgress || 0,
                requiredProgress: 80,
            };
        case 'article':
            return {
                prerequisite: t('moduleAccess.prerequisite.article'),
                currentProgress: userProgress.sentenceProgress || 0,
                requiredProgress: 80,
            };
        default:
            return {
                prerequisite: t('moduleAccess.unknownModule'),
                currentProgress: 0,
                requiredProgress: 100,
            };
    }
};

// ==================== ç»„ä»¶ ====================

export default function ModuleLockedScreen({ moduleType }: ModuleLockedScreenProps) {
    const { t } = useTranslation();
    const router = useRouter();
    const { userProgress } = useModuleAccessStore();

    const moduleName = getModuleName(moduleType, t);
    const { prerequisite, currentProgress, requiredProgress } = getUnlockRequirement(
        moduleType,
        userProgress,
        t
    );

    const progressPercentage = Math.min(currentProgress, requiredProgress);

    const handleBack = () => {
        router.back();
    };

    return (
        <View style={styles.container}>
            {/* é”å®šå›¾æ ‡ */}
            <View style={styles.iconContainer}>
                <View style={styles.iconCircle}>
                    <Lock size={64} color={Colors.taupe} strokeWidth={1.5} />
                </View>
            </View>

            {/* æ ‡é¢˜ */}
            <Text style={styles.title}>{t('moduleAccess.locked')}</Text>

            {/* æç¤ºæ–‡å­— */}
            <Text style={styles.message}>
                {t('moduleAccess.lockedMessage', { module: moduleName })}
            </Text>

            {/* å‰ç½®è¦æ±‚ */}
            <View style={styles.requirementCard}>
                <Text style={styles.requirementTitle}>{t('moduleAccess.requirement')}</Text>
                <Text style={styles.requirementText}>{prerequisite}</Text>
            </View>

            {/* è¿›åº¦æ¡ */}
            <View style={styles.progressContainer}>
                <View style={styles.progressHeader}>
                    <Text style={styles.progressLabel}>{t('moduleAccess.currentProgress')}</Text>
                    <Text style={styles.progressValue}>
                        {currentProgress}% / {requiredProgress}%
                    </Text>
                </View>

                <View style={styles.progressBarContainer}>
                    <View style={styles.progressBarBackground}>
                        <View
                            style={[
                                styles.progressBarFill,
                                {
                                    width: `${(progressPercentage / requiredProgress) * 100}%`,
                                },
                            ]}
                        />
                    </View>
                </View>

                {/* è¿›åº¦æç¤º */}
                {currentProgress < requiredProgress ? (
                    <Text style={styles.progressHint}>
                        {t('moduleAccess.remainingProgress', {
                            remaining: requiredProgress - currentProgress,
                        })}
                    </Text>
                ) : (
                    <Text style={styles.progressComplete}>
                        {t('moduleAccess.progressComplete')}
                    </Text>
                )}
            </View>

            {/* è¿”å›æŒ‰é’® */}
            <Pressable style={styles.backButton} onPress={handleBack}>
                <ArrowLeft size={20} color={Colors.white} />
                <Text style={styles.backButtonText}>{t('moduleAccess.goBack')}</Text>
            </Pressable>
        </View>
    );
}

// ==================== æ ·å¼ ====================

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: Colors.paper,
        paddingHorizontal: 24,
        paddingTop: 80,
        paddingBottom: 40,
        alignItems: 'center',
    },
    iconContainer: {
        marginBottom: 32,
    },
    iconCircle: {
        width: 120,
        height: 120,
        borderRadius: 60,
        backgroundColor: Colors.sand,
        alignItems: 'center',
        justifyContent: 'center',
        borderWidth: 2,
        borderColor: Colors.taupe,
        opacity: 0.8,
    },
    title: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 28,
        color: Colors.ink,
        marginBottom: 12,
        textAlign: 'center',
    },
    message: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 16,
        color: Colors.taupe,
        textAlign: 'center',
        marginBottom: 32,
        lineHeight: 24,
    },
    requirementCard: {
        width: '100%',
        backgroundColor: Colors.white,
        borderRadius: 16,
        padding: 20,
        marginBottom: 32,
        borderWidth: 1,
        borderColor: Colors.sand,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.05,
        shadowRadius: 8,
        elevation: 2,
    },
    requirementTitle: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 14,
        color: Colors.thaiGold,
        marginBottom: 8,
        textTransform: 'uppercase',
        letterSpacing: 0.5,
    },
    requirementText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 16,
        color: Colors.ink,
        lineHeight: 24,
    },
    progressContainer: {
        width: '100%',
        marginBottom: 40,
    },
    progressHeader: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: 12,
    },
    progressLabel: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.taupe,
    },
    progressValue: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 14,
        color: Colors.ink,
    },
    progressBarContainer: {
        marginBottom: 8,
    },
    progressBarBackground: {
        width: '100%',
        height: 12,
        backgroundColor: Colors.sand,
        borderRadius: 6,
        overflow: 'hidden',
    },
    progressBarFill: {
        height: '100%',
        backgroundColor: Colors.thaiGold,
        borderRadius: 6,
    },
    progressHint: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 13,
        color: Colors.taupe,
        fontStyle: 'italic',
    },
    progressComplete: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 13,
        color: Colors.thaiGold,
    },
    backButton: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: Colors.ink,
        paddingHorizontal: 32,
        paddingVertical: 16,
        borderRadius: 12,
        gap: 8,
        shadowColor: Colors.thaiGold,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.2,
        shadowRadius: 8,
        elevation: 4,
    },
    backButtonText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.white,
    },
});
</file>

<file path="src/config/alphabet/alphabetQuestionGenerator.ts">
// src/components/alphabet/alphabetQuestionGenerator.ts

import { AlphabetLearningState } from '@/src/stores/alphabetStore';
import {
  AlphabetQuestionType,
  AlphabetReviewQuestion,
  AlphabetQuestionOption,
} from '@/src/config/alphabet/alphabetQuestionTypes';

// å¯é€‰ï¼šè®©å¤–å±‚æ§åˆ¶é¢˜å‹æ¯”ä¾‹
export interface QuestionGenerationOptions {
  preferredType?: AlphabetQuestionType;
  // é¢˜ç›® ID å‰ç¼€ï¼Œæ–¹ä¾¿è°ƒè¯• / æ—¥å¿—
  idPrefix?: string;
  // é€‰é¡¹æ•°é‡ï¼ˆ3~6 æ¯”è¾ƒåˆç†ï¼‰
  optionCount?: number;
}

export interface QuestionGenerationContext {
  current: AlphabetLearningState;          // å½“å‰è¦å¤ä¹ çš„å­—æ¯
  pool: AlphabetLearningState[];          // ä»Šæ—¥ session çš„æ‰€æœ‰å­—æ¯
  options?: QuestionGenerationOptions;
}

// å·¥å…·å‡½æ•°ï¼šä»æ•°ç»„ä¸­å–éšæœºè‹¥å¹²ä¸ªä¸åŒå…ƒç´ 
function pickRandomDistinct<T>(items: T[], count: number, exclude?: T): T[] {
  const pool = exclude ? items.filter((i) => i !== exclude) : [...items];
  const result: T[] = [];
  const max = Math.min(count, pool.length);

  while (result.length < max && pool.length > 0) {
    const index = Math.floor(Math.random() * pool.length);
    const [picked] = pool.splice(index, 1);
    result.push(picked);
  }

  return result;
}

// å†³å®šé¢˜å‹ï¼šå¦‚æœå¤–å±‚ä¸ä¼ ï¼Œå°±åšä¸€ä¸ªç®€å•è½®ç›˜ï¼ˆä¸åšå¤æ‚ stage é€»è¾‘ï¼‰
function decideQuestionType(
  preferredType?: AlphabetQuestionType,
): AlphabetQuestionType {
  if (preferredType) return preferredType;

  const r = Math.random();
  if (r < 0.33) return 'soundToLetter';
  if (r < 0.66) return 'letterToSound';
  return 'reading';
}

// æ„é€ é€‰é¡¹ï¼šå­—æ¯â†’é€‰é¡¹å¯¹è±¡
function buildLetterOptions(
  correct: AlphabetLearningState,
  distractors: AlphabetLearningState[],
): AlphabetQuestionOption[] {
  const all = [correct, ...distractors];
  return all.map((letter, idx) => ({
    id: letter._id ?? letter.thaiChar ?? String(idx),
    label: letter.thaiChar,
  }));
}

// æ„é€ é€‰é¡¹ï¼šå‘éŸ³â†’é€‰é¡¹å¯¹è±¡ï¼ˆä½¿ç”¨ syllableSoundName / initialSound / pronunciationï¼‰
function buildSoundOptions(
  correct: AlphabetLearningState,
  distractors: AlphabetLearningState[],
): AlphabetQuestionOption[] {
  const getSoundLabel = (item: AlphabetLearningState): string => {
    return (
      item.syllableSoundName ||
      item.initialSound ||
      item.pronunciation ||
      item.thaiChar
    );
  };

  const all = [correct, ...distractors];
  return all.map((item, idx) => ({
    id: item._id ?? `${getSoundLabel(item)}-${idx}`,
    label: getSoundLabel(item),
  }));
}

// è½»é‡è§£é‡Šæ–‡æ¡ˆï¼ˆä¸å®ç°å®Œæ•´è§„åˆ™ï¼Œåªåšå‹å¥½æç¤ºï¼‰
function buildPhonicsExplanation(
  questionType: AlphabetQuestionType,
  current: AlphabetLearningState,
): string | undefined {
  const baseChar = current.thaiChar;
  const example = current.example;

  if (questionType === 'soundToLetter') {
    return example
      ? `ä½ å¬åˆ°çš„å‘éŸ³æ¥è‡ªå­—æ¯ã€Œ${baseChar}ã€åŠå…¶åœ¨å•è¯ã€Œ${example}ã€ä¸­çš„è¯»æ³•ã€‚`
      : `ä½ å¬åˆ°çš„å‘éŸ³æ¥è‡ªå­—æ¯ã€Œ${baseChar}ã€çš„è¯»éŸ³ã€‚`;
  }

  if (questionType === 'letterToSound') {
    return `æ³¨æ„å­—æ¯ã€Œ${baseChar}ã€çš„èµ·å§‹éŸ³ï¼ˆinitial soundï¼‰ï¼Œåœ¨ä¸åŒå…ƒéŸ³ç»„åˆä¸­ä¼šä¿æŒç›¸åŒçš„è¾…éŸ³éŸ³å€¼ã€‚`;
  }

  if (questionType === 'reading') {
    return example
      ? `å°è¯•å°†å•è¯æ‹†æˆã€Œè¾…éŸ³ + å…ƒéŸ³ã€å†åˆæˆå‘éŸ³ï¼Œä¾‹å¦‚ï¼š${example}ã€‚`
      : `å°è¯•åœ¨è„‘ä¸­å…ˆè¯»å‡ºè¾…éŸ³ï¼Œå†åŠ ä¸Šå…ƒéŸ³ï¼Œæœ€ååˆæˆä¸€ä¸ªæ•´ä½“éŸ³èŠ‚ã€‚`;
  }

  return undefined;
}

// ğŸ‘‡ æ ¸å¿ƒå¯¼å‡ºå‡½æ•°ï¼šæ ¹æ®å½“å‰å­—æ¯ + ä»Šæ—¥å­—æ¯æ± ç”Ÿæˆä¸€é“é¢˜
export function generateAlphabetQuestion(
  ctx: QuestionGenerationContext,
): AlphabetReviewQuestion {
  const { current, pool, options } = ctx;
  const {
    preferredType,
    idPrefix = 'qa',
    optionCount = 4,
  } = options || {};
  const type = decideQuestionType(preferredType);

  // ä¸ºäº†é¿å…æ‹¿ä¸åˆ°å­—æ®µæ—¶å´©æ‰ï¼Œåšä¸€äº›å…œåº•
  const mainChar = current.thaiChar ?? '';
  const example = current.example ?? '';
  // ç»Ÿä¸€ä¼˜å…ˆä½¿ç”¨ AlphabetLearningState ä¸­å·²ç»è§£æå¥½çš„ audioUrl
  const audioUrl =
    current.audioUrl ||
    current.syllableSoundUrl ||
    current.letterPronunciationUrl ||
    current.audioPath;

  const distractorCount = Math.max(optionCount - 1, 1);
  const otherLetters = pool.filter((l) => l !== current);

  let question: AlphabetReviewQuestion;

  if (type === 'soundToLetter') {
    // å¬éŸ³ â†’ é€‰å­—æ¯
    const distractors = pickRandomDistinct(otherLetters, distractorCount);
    const optionsArr = buildLetterOptions(current, distractors);

    question = {
      id: `${idPrefix}-sound-${current._id ?? mainChar}`,
      type: 'soundToLetter',
      prompt: 'å¬å‘éŸ³ï¼Œé€‰æ‹©å¯¹åº”çš„æ³°æ–‡å­—æ¯ã€‚',
      audioUrl: audioUrl,
      options: optionsArr,
      correctOptionId: optionsArr[0].id, // ç¬¬ä¸€ä¸ªæ˜¯æ­£ç¡®é¡¹ï¼ˆbuildLetterOptions ä¿è¯ï¼‰
      explanation: buildPhonicsExplanation('soundToLetter', current),
    };
  } else if (type === 'letterToSound') {
    // çœ‹å­—æ¯ â†’ é€‰å‘éŸ³
    const distractors = pickRandomDistinct(otherLetters, distractorCount);
    const optionsArr = buildSoundOptions(current, distractors);

    question = {
      id: `${idPrefix}-letter-${current._id ?? mainChar}`,
      type: 'letterToSound',
      prompt: 'è§‚å¯Ÿè¿™ä¸ªå­—æ¯ï¼Œé€‰æ‹©å®ƒçš„è¯»éŸ³ã€‚',
      mainText: mainChar,
      options: optionsArr,
      correctOptionId: optionsArr[0].id,
      explanation: buildPhonicsExplanation('letterToSound', current),
    };
  } else {
    // readingï¼šæ‹¼è¯»é¢˜ï¼ˆå°½é‡ä½¿ç”¨ä¾‹è¯ï¼Œä¸ç”Ÿæˆæ–°éŸ³èŠ‚ï¼‰
    const distractors = pickRandomDistinct(otherLetters, distractorCount);
    const optionsArr = buildSoundOptions(current, distractors);

    question = {
      id: `${idPrefix}-reading-${current._id ?? mainChar}`,
      type: 'reading',
      prompt: example
        ? 'å°è¯•è¯»å‡ºè¿™ä¸ªè¯çš„å‘éŸ³ã€‚'
        : 'å°è¯•è¯»å‡ºè¿™ä¸ªéŸ³èŠ‚/å­—æ¯çš„å‘éŸ³ã€‚',
      mainText: example || mainChar,
      audioUrl: audioUrl,
      options: optionsArr,
      correctOptionId: optionsArr[0].id,
      explanation: buildPhonicsExplanation('reading', current),
    };
  }

  // æ‰“ä¹±é€‰é¡¹é¡ºåºï¼ˆé¿å…æ­£ç¡®é¡¹ä¸€ç›´åœ¨ç¬¬ä¸€ä½ï¼‰
  const shuffledOptions = [...question.options];
  for (let i = shuffledOptions.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffledOptions[i], shuffledOptions[j]] = [
      shuffledOptions[j],
      shuffledOptions[i],
    ];
  }

  // æ‰¾åˆ°æ‰“ä¹±åæ­£ç¡®é€‰é¡¹çš„ id
  const correct = question.options[0];
  const correctInShuffled = shuffledOptions.find(
    (opt) => opt.id === correct.id,
  )!;
  question.options = shuffledOptions;
  question.correctOptionId = correctInShuffled.id;

  return question;
}
</file>

<file path="src/config/alphabet/lettersSequence.ts">
// LetterSequence.ts
// æ··åˆå¼æœ€ä¼˜æ³°è¯­å­—æ¯å­¦ä¹ åºåˆ—ï¼ˆè¾…éŸ³ + å…ƒéŸ³ + å£°è°ƒï¼‰
// âœ… è¦†ç›–ï¼š44 ä¸ªè¾…éŸ³ + 32 ä¸ªå…ƒéŸ³ + 4 ä¸ªå£°è°ƒï¼ˆå…± 80 ä¸ªï¼‰
// âœ… å·²å¯¹ç…§ letters_final.jsonï¼Œç¡®è®¤æ— é—æ¼ã€æ— å¤šä½™ã€æ— é‡å¤

/**
 * å­—æ¯å­¦ä¹ æœ€ä¼˜é¡ºåºï¼ˆä»…åŒ…å«æ•°æ®åº“å®é™…å­˜åœ¨çš„ thaiCharï¼‰
 * ä¿®å¤ç‚¹ï¼š
 * - åˆ é™¤ tone marksï¼ˆà¹ˆà¹‰à¹Šà¹‹ï¼‰
 * - åˆ é™¤æ•°æ®åº“ä¸å­˜åœ¨çš„å¤åˆå…ƒéŸ³ï¼ˆà¹€à¸­à¸° à¹à¸­à¸° à¹‚à¸­à¸° ç­‰ï¼‰
 * - åˆ é™¤ à¸¤ à¸¤à¹… à¸¦ à¸¦à¹… à¸ƒ à¸…ï¼ˆæ•°æ®åº“ä¸­ä¸å­˜åœ¨ï¼‰
 * - ä¿ç•™è¾…éŸ³ + åŸºç¡€å…ƒéŸ³
 */

export const LETTER_SEQUENCE: readonly string[] = [
  // ------------------------------------------
  // Stage 1 â€” åŸºç¡€æ‹¼è¯»èƒ½åŠ›ï¼ˆè¾…éŸ³ + åŸºç¡€å…ƒéŸ³ï¼‰
  // ------------------------------------------
  "à¸", "à¸™", "à¸¡", "à¸›", "à¸•", "à¸š", "à¸„", "à¸‡", "à¸­",
  "à¸°", "à¸²", "à¸´", "à¸µ", "à¸¸", "à¸¹",

  // ------------------------------------------
  // Stage 2 â€” æ‰©å±•æ‹¼è¯»ï¼ˆå‰ç½®å…ƒéŸ³ + é«˜é¢‘è¾…éŸ³ï¼‰
  // ------------------------------------------
  "à¸”", "à¸—", "à¸", "à¸Ÿ", "à¸¢", "à¸§", "à¸¥", "à¸£",
  "à¹€", "à¹", "à¹‚", "à¹„", "à¹ƒ",

  // ------------------------------------------
  // Stage 3 â€” é€æ°”å¯¹æ¯” + ç‰¹æ®Šè¯»éŸ³
  // ------------------------------------------
  "à¸‚", "à¸Š", "à¸‹", "à¸ˆ", "à¸‰", "à¸œ", "à¸", "à¸®",
  "à¸·", // é•¿å…ƒéŸ³æ‰©å±•

  // ------------------------------------------
  // Stage 4 â€” é«˜é¢‘è¾…éŸ³æ‰©å±•
  // ------------------------------------------
  "à¸–", "à¸˜", "à¸ ", "à¸¨", "à¸©", "à¸ª", "à¸«", "à¸", "à¸", "à¸",

  // ------------------------------------------
  // Stage 5 â€” å¤æ‚è¾…éŸ³ä¸å°‘é‡ç‰¹æ®Šç»„åˆï¼ˆä»…ä¿ç•™æ•°æ®åº“å­˜åœ¨ï¼‰
  // ------------------------------------------
  "à¸‘", "à¸’", "à¸†", "à¸", "à¸Œ", "à¸“", "à¸¬",
];

/**
 * é¢„ç”Ÿæˆå­—ç¬¦ â†’ æ’åºåºå·æ˜ å°„
 */
export const LETTER_INDEX_MAP = new Map<string, number>(
  LETTER_SEQUENCE.map((char, index) => [char, index]),
);

/**
 * æŒ‰æœ€ä¼˜é¡ºåºæ’åºï¼ˆitems å¿…é¡»æœ‰ thaiChar å­—æ®µï¼‰
 */
export function sortByLetterSequence<T extends { thaiChar: string }>(
  items: T[],
): T[] {
  return [...items].sort((a, b) => {
    const ia = LETTER_INDEX_MAP.get(a.thaiChar) ?? Number.MAX_SAFE_INTEGER;
    const ib = LETTER_INDEX_MAP.get(b.thaiChar) ?? Number.MAX_SAFE_INTEGER;
    return ia - ib;
  });
}

/**
 * å°† sequence æŒ‰ Lesson åˆ†ç»„ï¼ˆ5 è¯¾ï¼‰
 * ä¾› AlphabetCoursesScreen ä¸ Lesson orchestrator ä½¿ç”¨
 */
export const SEQUENCE_LESSONS = {
  lesson1: LETTER_SEQUENCE.slice(0, 15),
  lesson2: LETTER_SEQUENCE.slice(15, 15 + 12),
  lesson3: LETTER_SEQUENCE.slice(27, 27 + 9),
  lesson4: LETTER_SEQUENCE.slice(36, 36 + 9),
  lesson5: LETTER_SEQUENCE.slice(45),
};
</file>

<file path="src/constants/colors.ts">
// src/constants/colors.ts
export const Colors = {
    paper: '#FAF9F6',
    ink: '#1A1A1A',
    sand: '#E5E2DB',
    taupe: '#8E8B82',
    thaiGold: '#D4AF37',
    accent: '#B8956A',
    white: '#FFFFFF',
    glassWhite: 'rgba(255, 255, 255, 0.85)',
    error: '#DC2626',
    red: {
      50: '#FEF2F2',
      600: '#DC2626',
    },
     success: '#2A9D8F',
  } as const;
</file>

<file path="src/entities/enums/QualityScore.enum.ts">
// src/entities/enums/QualityScore.enum.ts

export enum QualityButton {
  KNOW = 'è®°å¾—',
  FUZZY = 'æ¨¡ç³Š',
  FORGET = 'é™Œç”Ÿ',
}

export const QUALITY_SCORE_MAP: Record<QualityButton, number> = {
  [QualityButton.KNOW]: 5,
  [QualityButton.FUZZY]: 3,
  [QualityButton.FORGET]: 1,
};

export const ATTEMPTS_INCREMENT_MAP: Record<QualityButton, number> = {
  [QualityButton.KNOW]: 3,
  [QualityButton.FUZZY]: 1,
  [QualityButton.FORGET]: 2,
};
</file>

<file path="src/entities/enums/QuestionType.enum.ts">
// src/entities/enums/QuestionType.enum.ts

/**
 * å­—æ¯å¤ä¹ é¢˜å‹æšä¸¾
 * 
 * åŸºäºæ³°è¯­è¯­éŸ³å­¦ä¼˜åŒ–çš„12ç§é¢˜å‹ç³»ç»Ÿ
 * åŒ…å«é€æ°”éŸ³å¯¹æ¯”ã€å…ƒéŸ³é•¿çŸ­å¯¹æ¯”ã€å£°è°ƒå¬è¾¨ç­‰æ ¸å¿ƒè®­ç»ƒ
 * 
 * @version 3.0.0
 * @see lettersQuestionGenerator.ts
 */
export enum QuestionType {
    // ===== åŸºç¡€é¢˜å‹(Lesson 1-2) =====
    /** å¬éŸ³é€‰å­—æ¯ */
    SOUND_TO_LETTER = 'sound-to-letter',
    /** çœ‹å­—æ¯é€‰å‘éŸ³ */
    LETTER_TO_SOUND = 'letter-to-sound',

    // ===== æ‹¼è¯»é¢˜å‹(Lesson 2-3) =====
    /** æ‹¼è¯»ç»„åˆ: è¾…éŸ³+å…ƒéŸ³ */
    SYLLABLE = 'syllable',
    /** éŸ³ç´ åˆ†ç¦»: å‘éŸ³â†’è¾…éŸ³ */
    REVERSE_SYLLABLE = 'reverse-syllable',
    /** ç¼ºå­—å¡«ç©º */
    MISSING_LETTER = 'missing-letter',

    // ===== ğŸ”´ æ ¸å¿ƒå¯¹æ¯”é¢˜å‹(Lesson 2-4) =====
    /** é€æ°”éŸ³å¯¹æ¯”(æœ€å°å¯¹ç«‹ç»„è®­ç»ƒ) - à¸/à¸‚/à¸„ */
    ASPIRATED_CONTRAST = 'aspirated-contrast',
    /** å…ƒéŸ³é•¿çŸ­å¯¹æ¯” - à¸²/à¸° */
    VOWEL_LENGTH_CONTRAST = 'vowel-length-contrast',

    // ===== è¿›é˜¶é¢˜å‹(Lesson 3-5) =====
    /** å°¾è¾…éŸ³è§„åˆ™ */
    FINAL_CONSONANT = 'final-consonant',
    /** å£°è°ƒå¬è¾¨(å«éŸ³é«˜å¯è§†åŒ–) */
    TONE_PERCEPTION = 'tone-perception',

    // ===== é«˜çº§é¢˜å‹(Lesson 4-6) =====
    /** è¾…éŸ³åˆ†ç±»(é«˜/ä¸­/ä½) */
    CLASS_CHOICE = 'class-choice',
    /** å­—æ¯åç§°è¯†åˆ« */
    LETTER_NAME = 'letter-name',
    /** é¦–éŸ³åˆ¤æ–­ */
    INITIAL_SOUND = 'initial-sound',
}

/**
 * é¢˜å‹æ˜¾ç¤ºåç§°æ˜ å°„
 */
export const QUESTION_TYPE_LABELS: Record<QuestionType, string> = {
    [QuestionType.SOUND_TO_LETTER]: 'å¬éŸ³é€‰å­—æ¯',
    [QuestionType.LETTER_TO_SOUND]: 'çœ‹å­—æ¯é€‰å‘éŸ³',
    [QuestionType.SYLLABLE]: 'æ‹¼è¯»ç»„åˆ',
    [QuestionType.REVERSE_SYLLABLE]: 'éŸ³ç´ åˆ†ç¦»',
    [QuestionType.MISSING_LETTER]: 'ç¼ºå­—å¡«ç©º',
    [QuestionType.ASPIRATED_CONTRAST]: 'é€æ°”éŸ³å¯¹æ¯”',
    [QuestionType.VOWEL_LENGTH_CONTRAST]: 'å…ƒéŸ³é•¿çŸ­å¯¹æ¯”',
    [QuestionType.FINAL_CONSONANT]: 'å°¾éŸ³è§„åˆ™',
    [QuestionType.TONE_PERCEPTION]: 'å£°è°ƒå¬è¾¨',
    [QuestionType.CLASS_CHOICE]: 'è¾…éŸ³åˆ†ç±»',
    [QuestionType.LETTER_NAME]: 'å­—æ¯åç§°',
    [QuestionType.INITIAL_SOUND]: 'é¦–éŸ³åˆ¤æ–­',
};

/**
 * é¢˜å‹éš¾åº¦ç­‰çº§(1-5)
 */
export const QUESTION_TYPE_DIFFICULTY: Record<QuestionType, 1 | 2 | 3 | 4 | 5> = {
    [QuestionType.SOUND_TO_LETTER]: 1,
    [QuestionType.LETTER_TO_SOUND]: 1,
    [QuestionType.SYLLABLE]: 2,
    [QuestionType.REVERSE_SYLLABLE]: 3,
    [QuestionType.MISSING_LETTER]: 2,
    [QuestionType.ASPIRATED_CONTRAST]: 3,
    [QuestionType.VOWEL_LENGTH_CONTRAST]: 2,
    [QuestionType.FINAL_CONSONANT]: 4,
    [QuestionType.TONE_PERCEPTION]: 4,
    [QuestionType.CLASS_CHOICE]: 3,
    [QuestionType.LETTER_NAME]: 2,
    [QuestionType.INITIAL_SOUND]: 2,
};

/**
 * éŸ³é¢‘éœ€æ±‚ç±»å‹å®šä¹‰
 */
export type AudioRequirementType =
    | 'letter'        // å•å­—æ¯å‘éŸ³
    | 'syllable'      // éŸ³èŠ‚å‘éŸ³
    | 'minimal-pair'  // æœ€å°å¯¹ç«‹ç»„(éœ€åŠ¨æ€ç”Ÿæˆ)
    | 'tone-set';     // 5ä¸ªå£°è°ƒå˜ä½“(éœ€TTSç”Ÿæˆ)

/**
 * é¢˜å‹æ‰€éœ€çš„éŸ³é¢‘ç±»å‹
 */
export const QUESTION_TYPE_AUDIO_REQUIREMENTS: Record<
    QuestionType,
    AudioRequirementType
> = {
    [QuestionType.SOUND_TO_LETTER]: 'letter',
    [QuestionType.LETTER_TO_SOUND]: 'letter',
    [QuestionType.SYLLABLE]: 'syllable',
    [QuestionType.REVERSE_SYLLABLE]: 'syllable',
    [QuestionType.MISSING_LETTER]: 'syllable',
    [QuestionType.ASPIRATED_CONTRAST]: 'minimal-pair',
    [QuestionType.VOWEL_LENGTH_CONTRAST]: 'minimal-pair',
    [QuestionType.FINAL_CONSONANT]: 'syllable',
    [QuestionType.TONE_PERCEPTION]: 'tone-set',
    [QuestionType.CLASS_CHOICE]: 'letter',
    [QuestionType.LETTER_NAME]: 'letter',
    [QuestionType.INITIAL_SOUND]: 'letter',
};

/**
 * æ ¹æ®è¯¾ç¨‹é˜¶æ®µè·å–æ¨èé¢˜å‹æƒé‡
 * 
 * @param lessonId - è¯¾ç¨‹ID (lesson1-lesson6)
 * @returns é¢˜å‹æƒé‡æ˜ å°„ (æƒé‡æ€»å’Œä¸º1)
 */
export function getQuestionTypeWeights(
    lessonId: string
): Partial<Record<QuestionType, number>> {
    switch (lessonId) {
        case 'lesson1':
            // åŸºç¡€å¬è¾¨+æ‹¼è¯»
            return {
                [QuestionType.SOUND_TO_LETTER]: 0.4,
                [QuestionType.LETTER_TO_SOUND]: 0.4,
                [QuestionType.SYLLABLE]: 0.2,
            };

        case 'lesson2':
            // å¼•å…¥å…ƒéŸ³é•¿çŸ­å¯¹æ¯”
            return {
                [QuestionType.SOUND_TO_LETTER]: 0.25,
                [QuestionType.SYLLABLE]: 0.3,
                [QuestionType.VOWEL_LENGTH_CONTRAST]: 0.25,
                [QuestionType.REVERSE_SYLLABLE]: 0.2,
            };

        case 'lesson3':
            // ğŸ”´ é‡ç‚¹:é€æ°”éŸ³å¯¹æ¯”è®­ç»ƒ
            return {
                [QuestionType.ASPIRATED_CONTRAST]: 0.35,
                [QuestionType.SYLLABLE]: 0.25,
                [QuestionType.MISSING_LETTER]: 0.2,
                [QuestionType.VOWEL_LENGTH_CONTRAST]: 0.2,
            };

        case 'lesson4':
            // ğŸ”´ é‡ç‚¹:å£°è°ƒç³»ç»Ÿè®­ç»ƒ
            return {
                [QuestionType.TONE_PERCEPTION]: 0.4,
                [QuestionType.CLASS_CHOICE]: 0.25,
                [QuestionType.ASPIRATED_CONTRAST]: 0.2,
                [QuestionType.FINAL_CONSONANT]: 0.15,
            };

        case 'lesson5':
            // ç»¼åˆå¤ä¹ ,å£°è°ƒä¸ºä¸»
            return {
                [QuestionType.TONE_PERCEPTION]: 0.3,
                [QuestionType.CLASS_CHOICE]: 0.2,
                [QuestionType.REVERSE_SYLLABLE]: 0.25,
                [QuestionType.LETTER_NAME]: 0.15,
                [QuestionType.ASPIRATED_CONTRAST]: 0.1,
            };

        case 'lesson6':
            // å…¨é¢˜å‹ç»¼åˆæµ‹è¯•
            return {
                [QuestionType.SOUND_TO_LETTER]: 0.1,
                [QuestionType.ASPIRATED_CONTRAST]: 0.15,
                [QuestionType.VOWEL_LENGTH_CONTRAST]: 0.15,
                [QuestionType.SYLLABLE]: 0.15,
                [QuestionType.TONE_PERCEPTION]: 0.25,
                [QuestionType.CLASS_CHOICE]: 0.1,
                [QuestionType.LETTER_NAME]: 0.1,
            };

        default:
            // é»˜è®¤å‡åŒ€åˆ†å¸ƒ(åŸºç¡€é¢˜)
            return {
                [QuestionType.SOUND_TO_LETTER]: 0.33,
                [QuestionType.LETTER_TO_SOUND]: 0.33,
                [QuestionType.SYLLABLE]: 0.34,
            };
    }
}

/**
 * æ ¹æ®æƒé‡éšæœºé€‰æ‹©é¢˜å‹
 * 
 * @param weights - é¢˜å‹æƒé‡æ˜ å°„
 * @returns é€‰ä¸­çš„é¢˜å‹
 */
export function selectQuestionTypeByWeight(
    weights: Partial<Record<QuestionType, number>>
): QuestionType {
    const types = Object.keys(weights) as QuestionType[];
    const weightValues = types.map(t => weights[t] || 0);

    // è®¡ç®—ç´¯ç§¯æƒé‡
    const cumulativeWeights: number[] = [];
    let sum = 0;
    for (const weight of weightValues) {
        sum += weight;
        cumulativeWeights.push(sum);
    }

    // éšæœºé€‰æ‹©
    const random = Math.random() * sum;
    const index = cumulativeWeights.findIndex(w => random <= w);

    return types[index] || types[0];
}

/**
 * è·å–é¢˜å‹å›¾æ ‡(ç”¨äºUIæ˜¾ç¤º)
 */
export const QUESTION_TYPE_ICONS: Record<QuestionType, string> = {
    [QuestionType.SOUND_TO_LETTER]: 'ğŸ”Š',
    [QuestionType.LETTER_TO_SOUND]: 'ğŸ‘ï¸',
    [QuestionType.SYLLABLE]: 'ğŸ”¤',
    [QuestionType.REVERSE_SYLLABLE]: 'ğŸ”„',
    [QuestionType.MISSING_LETTER]: 'â“',
    [QuestionType.ASPIRATED_CONTRAST]: 'ğŸ’¨',
    [QuestionType.VOWEL_LENGTH_CONTRAST]: 'â±ï¸',
    [QuestionType.FINAL_CONSONANT]: 'ğŸ”š',
    [QuestionType.TONE_PERCEPTION]: 'ğŸµ',
    [QuestionType.CLASS_CHOICE]: 'ğŸ“Š',
    [QuestionType.LETTER_NAME]: 'ğŸ“',
    [QuestionType.INITIAL_SOUND]: 'ğŸ‘‚',
};
</file>

<file path="src/entities/types/entities.ts">
export * from './user';
export * from './course';
export * from './learning';
</file>

<file path="src/entities/types/memory.types.ts">
// src/entities/types/memory.types.ts

export interface MemoryStatus {
  userId: string;
  entityType: 'letter' | 'word' | 'sentence';
  entityId: string;
  masteryLevel: number;
  reviewStage: number;
  easinessFactor: number;
  intervalDays: number;
  nextReviewAt: string;
  correctCount: number;
  wrongCount: number;
  streakCorrect: number;
  isLocked: boolean;
}

export interface UnlockInfo {
  unlocked: boolean;
  stage?: 'word' | 'sentence' | 'article';
  message: string;
  letterProgress: number; // 0-1 æ¯”ä¾‹å€¼
}
</file>

<file path="src/stores/languageStore.ts">
// src/stores/languageStore.ts
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';
import i18n from '@/src/i18n';

export type Language = 'zh' | 'en';

interface LanguageState {
  currentLanguage: Language;
  changeLanguage: (lang: Language) => Promise<void>;
}

export const useLanguageStore = create<LanguageState>()(
  persist(
    (set) => ({
      currentLanguage: 'zh',
      changeLanguage: async (lang: Language) => {
        try {
          await i18n.changeLanguage(lang);
          set({ currentLanguage: lang });
        } catch (error) {
          console.error('Failed to change language:', error);
        }
      },
    }),
    {
      name: 'language-storage',
      storage: createJSONStorage(() => AsyncStorage),
    }
  )
);
</file>

<file path="src/stores/learningStore.ts">
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Course, LearningProgress, Level } from '../entities/types/entities';

interface LearningState {
  currentCourse: Course | null;
  progress: LearningProgress | null;
  completedContent: string[];
  
  setCourse: (course: Course) => void;
  updateProgress: (contentType: string, score: number) => void;
  getCompletionRate: () => number;
  resetLearning: () => void;
}

export const useLearningStore = create<LearningState>()(
  persist(
    (set, get) => ({
      currentCourse: null,
      progress: null,
      completedContent: [],

      setCourse: (course: Course) => {
        set({ currentCourse: course });
        
        if (!get().progress) {
          const newProgress: LearningProgress = {
            progressId: 'progress_' + Date.now(),
            userId: 'user_1',
            courseId: course.courseId,
            currentLevel: Level.BEGINNER_A,
            completedAlphabets: 30,
            completedVocabulary: 150,
            completedSentences: 20,
            completedArticles: 5,
            totalScore: 0,
            totalStudyTime: 1200,
            streakDays: 7,
            lastUpdated: new Date(),
          };
          set({ progress: newProgress });
        }
      },

      updateProgress: (contentType: string, score: number) => {
        const progress = get().progress;
        if (!progress) return;

        const updatedProgress = { ...progress };
        
        switch (contentType) {
          case 'alphabet':
            updatedProgress.completedAlphabets += 1;
            break;
          case 'vocabulary':
            updatedProgress.completedVocabulary += 1;
            break;
          case 'sentence':
            updatedProgress.completedSentences += 1;
            break;
          case 'article':
            updatedProgress.completedArticles += 1;
            break;
        }
        
        updatedProgress.totalScore += score;
        updatedProgress.lastUpdated = new Date();
        
        set({ progress: updatedProgress });
      },

      getCompletionRate: () => {
        const progress = get().progress;
        if (!progress) return 0;
        
        const total = 76 + 500 + 100 + 20;
        const completed = 
          progress.completedAlphabets +
          progress.completedVocabulary +
          progress.completedSentences +
          progress.completedArticles;
        
        return (completed / total) * 100;
      },

      resetLearning: () => {
        set({
          currentCourse: null,
          progress: null,
          completedContent: [],
        });
      },
    }),
    {
      name: 'learning-storage',
      storage: createJSONStorage(() => AsyncStorage),
    }
  )
);
</file>

<file path="src/utils/alphabet/buildAlphabetQueue.ts">
// å‰ç«¯æƒå¨é˜Ÿåˆ—æ„å»ºå™¨ï¼ˆé¦–å‘å†»ç»“ç‰ˆï¼‰
// ä»…æŒ‰è¯¾ç¨‹å†…ä¸‰æ–°ä¸€å¤ + mini-review + final-review ç”Ÿæˆ deterministic é˜Ÿåˆ—

import type {
  AlphabetLearningMode,
  AlphabetLearningState,
  AlphabetQueueItem,
  AlphabetQueueSource,
} from '@/src/stores/alphabetStore';

interface BuildAlphabetQueueParams {
  lessonLetters: AlphabetLearningState[];
  round: number;
  mode: AlphabetLearningMode;
  previousRoundLetters?: AlphabetLearningState[];
}

const MINI_REVIEW_CHUNK = 3;

export function buildAlphabetQueue(
  params: BuildAlphabetQueueParams
): AlphabetQueueItem[] {
  const { lessonLetters, round, mode, previousRoundLetters = [] } = params;
  const queue: AlphabetQueueItem[] = [];

  const pushWithSource = (item: AlphabetLearningState, source: AlphabetQueueSource) => {
    queue.push({
      ...item,
      source,
      round,
    });
  };

  const previousLetters = mode === 'learning' ? previousRoundLetters : [];

  // Phase 1: ä¸Šä¸€è½®å¤ä¹ 
  // ğŸ”¥ TODO-03: ç»Ÿä¸€ä½¿ç”¨ 'previous-review' è€Œä¸æ˜¯ 'previous-round-review'
  previousLetters.forEach((letter) => pushWithSource(letter, 'previous-review'));

  // Phase 2: ä»Šæ—¥å­¦ä¹  + mini-review (ä¸‰æ–°ä¸€å¤)
  for (let i = 0; i < lessonLetters.length; i += 1) {
    const letter = lessonLetters[i];
    // ğŸ”¥ TODO-03: ç»Ÿä¸€ä½¿ç”¨ 'new-learning' è€Œä¸æ˜¯ 'new'
    pushWithSource(letter, 'new-learning');

    const hasCompletedChunk = (i + 1) % MINI_REVIEW_CHUNK === 0;
    if (hasCompletedChunk) {
      const chunkStart = i + 1 - MINI_REVIEW_CHUNK;
      const chunk = lessonLetters.slice(chunkStart, i + 1);
      chunk.forEach((l) => pushWithSource(l, 'mini-review'));
    }
  }

  // Phase 3: æ€»å¤ä¹ ï¼ˆæœ¬è½®å…¨éƒ¨å­—æ¯ï¼‰
  lessonLetters.forEach((letter) => pushWithSource(letter, 'final-review'));

  return queue;
}
</file>

<file path="src/utils/alphabetQuestionTypeAssigner.ts">
// src/utils/alphabetQuestionTypeAssigner.ts

/**
 * Alphabet Question Type Assigner
 *
 * é¢˜å‹åˆ†é…å™¨ - æ ¹æ®å­¦ä¹ é˜¶æ®µ(Phase)åˆ†é…åˆé€‚çš„é¢˜å‹
 * æŒ‰ç…§ alphabet-module-spec.md ç¬¬6ç« è¦æ±‚å®ç°
 *
 * æ ¸å¿ƒç­–ç•¥:
 * - ä¸‰æ–°ä¸€å¤é˜¶æ®µ: ä½¿ç”¨è½»é‡é¢˜å‹(å¬éŸ³é€‰å­—ã€çœ‹å­—é€‰éŸ³)
 * - Final Review é˜¶æ®µ: ä½¿ç”¨æ•´åˆé¢˜å‹(è¾…éŸ³ç±»åˆ«ã€é¦–éŸ³ã€å°¾éŸ³ã€å£°è°ƒã€æ‹¼è¯»)
 */

import { AlphabetGameType } from '@/src/entities/types/alphabetGameTypes';

/**
 * ä¸‰æ–°ä¸€å¤é˜¶æ®µä½¿ç”¨çš„è½»é‡é¢˜å‹
 *
 * è¿™äº›é¢˜å‹ä¸“æ³¨äºåŸºç¡€çš„å­—æ¯è¯†åˆ«,ä¸æ¶‰åŠå¤æ‚çš„è¯­éŸ³å­¦è§„åˆ™
 */
export const LIGHT_GAME_TYPES: AlphabetGameType[] = [
  AlphabetGameType.SOUND_TO_LETTER,
  AlphabetGameType.LETTER_TO_SOUND,
];

/**
 * Final Review é˜¶æ®µä½¿ç”¨çš„æ•´åˆé¢˜å‹
 *
 * è¿™äº›é¢˜å‹è¦æ±‚å­¦ç”Ÿç»¼åˆè¿ç”¨è¾…éŸ³ç±»åˆ«ã€å‘éŸ³è§„åˆ™ç­‰çŸ¥è¯†
 */
export const ADVANCED_GAME_TYPES: AlphabetGameType[] = [
  AlphabetGameType.CONSONANT_CLASS,
  AlphabetGameType.INITIAL_SOUND,
  AlphabetGameType.FINAL_SOUND,
  AlphabetGameType.TONE_CALCULATION,
  AlphabetGameType.PHONICS_MATH,
];

/**
 * å­¦ä¹ é˜¶æ®µç±»å‹
 */
export type LearningPhase = 'THREE_NEW_ONE_REVIEW' | 'FINAL_REVIEW';

/**
 * æ ¹æ®å­¦ä¹ é˜¶æ®µåˆ†é…é¢˜å‹
 *
 * @param phase - å­¦ä¹ é˜¶æ®µ ('THREE_NEW_ONE_REVIEW' æˆ– 'FINAL_REVIEW')
 * @returns éšæœºé€‰æ‹©çš„é¢˜å‹
 *
 * @example
 * // ä¸‰æ–°ä¸€å¤é˜¶æ®µ
 * const gameType = assignGameTypeForPhase('THREE_NEW_ONE_REVIEW');
 * // è¿”å› SOUND_TO_LETTER æˆ– LETTER_TO_SOUND
 *
 * @example
 * // Final Review é˜¶æ®µ
 * const gameType = assignGameTypeForPhase('FINAL_REVIEW');
 * // è¿”å› CONSONANT_CLASS, INITIAL_SOUND, FINAL_SOUND, TONE_CALCULATION, æˆ– PHONICS_MATH
 */
export function assignGameTypeForPhase(
  phase: LearningPhase
): AlphabetGameType {
  const pool =
    phase === 'THREE_NEW_ONE_REVIEW' ? LIGHT_GAME_TYPES : ADVANCED_GAME_TYPES;

  // ä»é¢˜å‹æ± ä¸­éšæœºé€‰æ‹©
  return pool[Math.floor(Math.random() * pool.length)];
}

/**
 * æ ¹æ®å­¦ä¹ é˜¶æ®µå’Œæƒé‡åˆ†é…é¢˜å‹
 *
 * @param phase - å­¦ä¹ é˜¶æ®µ
 * @param weights - å¯é€‰çš„é¢˜å‹æƒé‡æ˜ å°„,ç”¨äºå¾®è°ƒé¢˜å‹åˆ†å¸ƒ
 * @returns æ ¹æ®æƒé‡éšæœºé€‰æ‹©çš„é¢˜å‹
 *
 * @example
 * // æŒ‡å®šæƒé‡: 70% SOUND_TO_LETTER, 30% LETTER_TO_SOUND
 * const gameType = assignGameTypeWithWeights('THREE_NEW_ONE_REVIEW', {
 *   [AlphabetGameType.SOUND_TO_LETTER]: 0.7,
 *   [AlphabetGameType.LETTER_TO_SOUND]: 0.3,
 * });
 */
export function assignGameTypeWithWeights(
  phase: LearningPhase,
  weights?: Partial<Record<AlphabetGameType, number>>
): AlphabetGameType {
  // å¦‚æœæ²¡æœ‰æä¾›æƒé‡,ä½¿ç”¨é»˜è®¤å‡åŒ€åˆ†å¸ƒ
  if (!weights || Object.keys(weights).length === 0) {
    return assignGameTypeForPhase(phase);
  }

  const pool =
    phase === 'THREE_NEW_ONE_REVIEW' ? LIGHT_GAME_TYPES : ADVANCED_GAME_TYPES;

  // åªä¿ç•™å±äºå½“å‰é˜¶æ®µé¢˜å‹æ± çš„æƒé‡
  const filteredWeights: Record<AlphabetGameType, number> = {} as any;
  let totalWeight = 0;

  for (const gameType of pool) {
    const weight = weights[gameType] ?? 1; // é»˜è®¤æƒé‡ä¸º 1
    filteredWeights[gameType] = weight;
    totalWeight += weight;
  }

  // å½’ä¸€åŒ–æƒé‡å¹¶æ ¹æ®éšæœºæ•°é€‰æ‹©
  const random = Math.random() * totalWeight;
  let cumulativeWeight = 0;

  for (const gameType of pool) {
    cumulativeWeight += filteredWeights[gameType];
    if (random <= cumulativeWeight) {
      return gameType;
    }
  }

  // å…œåº•: è¿”å›æ± ä¸­ç¬¬ä¸€ä¸ªé¢˜å‹
  return pool[0];
}
</file>

<file path="src/utils/ModuleGuard.tsx">
// src/utils/ModuleGuard.tsx

/**
 * æ¨¡å—è®¿é—®å®ˆå«ç»„ä»¶
 * 
 * åŠŸèƒ½ï¼š
 * 1. åœ¨è¿›å…¥å­¦ä¹ é¡µé¢å‰æ£€æŸ¥æƒé™
 * 2. æ˜¾ç¤ºåŠ è½½çŠ¶æ€
 * 3. æƒé™ä¸è¶³æ—¶æ˜¾ç¤ºé”å®šé¡µé¢
 */

import React, { useEffect, useState } from 'react';
import { View, ActivityIndicator, StyleSheet } from 'react-native';
import { useModuleAccessStore, type ModuleType } from '@/src/stores/moduleAccessStore';
import ModuleLockedScreen from '@/src/components/learning/ModuleLockedScreen';

// ==================== ç±»å‹å®šä¹‰ ====================

interface ModuleGuardProps {
    moduleType: ModuleType;
    children: React.ReactNode;
}

// ==================== ç»„ä»¶ ====================

/**
 * æ¨¡å—è®¿é—®å®ˆå«
 * 
 * @param moduleType æ¨¡å—ç±»å‹
 * @param children å­ç»„ä»¶ï¼ˆå­¦ä¹ é¡µé¢ï¼‰
 */
export default function ModuleGuard({ moduleType, children }: ModuleGuardProps) {
    const { checkAccess, getUserProgress } = useModuleAccessStore();
    const [hasAccess, setHasAccess] = useState<boolean | null>(null);
    const [isChecking, setIsChecking] = useState(true);

    useEffect(() => {
        const checkModuleAccess = async () => {
            try {
                setIsChecking(true);

                // å…ˆè·å–ç”¨æˆ·è¿›åº¦æ•°æ®
                await getUserProgress();

                // æ£€æŸ¥è®¿é—®æƒé™
                const allowed = await checkAccess(moduleType);
                setHasAccess(allowed);
            } catch (error) {
                console.error('âŒ ModuleGuard: æƒé™æ£€æŸ¥å¤±è´¥', error);
                // å¦‚æœæ£€æŸ¥å¤±è´¥ï¼Œé»˜è®¤ä¸å…è®¸è®¿é—®ï¼ˆé™¤äº†å­—æ¯æ¨¡å—ï¼‰
                setHasAccess(moduleType === 'letter');
            } finally {
                setIsChecking(false);
            }
        };

        checkModuleAccess();
    }, [moduleType]);

    // ===== åŠ è½½çŠ¶æ€ =====
    if (isChecking || hasAccess === null) {
        return (
            <View style={styles.loadingContainer}>
                <ActivityIndicator size="large" color="#4A90E2" />
            </View>
        );
    }

    // ===== æƒé™ä¸è¶³ =====
    if (!hasAccess) {
        return <ModuleLockedScreen moduleType={moduleType} />;
    }

    // ===== æƒé™é€šè¿‡ï¼Œæ¸²æŸ“å­ç»„ä»¶ =====
    return <>{children}</>;
}

// ==================== æ ·å¼ ====================

const styles = StyleSheet.create({
    loadingContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: '#F5F9FF',
    },
});
</file>

<file path=".nvmrc">
20.19.4
</file>

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(cat:*)",
      "Bash(npx tsc:*)",
      "Bash(grep:*)"
    ],
    "deny": [],
    "ask": []
  }
}
</file>

<file path="app/(auth)/_layout.tsx">
// app/(auth)/_layout.tsx
import { Stack } from 'expo-router';
import { useEffect } from 'react';
import { useRouter } from 'expo-router';
import { useUserStore } from '@/src/stores/userStore';

export default function AuthLayout() {
  const router = useRouter();
  const { isAuthenticated } = useUserStore();

  useEffect(() => {
    if (isAuthenticated) {
      router.replace('/(tabs)');
    }
  }, [isAuthenticated]);

  return (
    <Stack screenOptions={{ headerShown: false }}>
      <Stack.Screen name="login" />
      <Stack.Screen name="register" />
    </Stack>
  );
}
</file>

<file path="cloudbase/functions/alphabet/handlers/getLetterTest.js">
// âœ… è·å–å›ºå®šå­—æ¯æµ‹è¯•é¢˜
const { createResponse } = require('../utils/response');

async function getLetterTest(db) {
    const res = await db.collection('letter_test_bank')
        .limit(20) // ä½ è¯´æ˜¯å›ºå®šé¢˜ï¼Œä¸éœ€è¦éšæœº
        .get();

    return createResponse(true, {
        total: res.data.length,
        questions: res.data
    }, 'è·å–å­—æ¯æµ‹è¯•é¢˜æˆåŠŸ');
}

module.exports = getLetterTest;
</file>

<file path="cloudbase/functions/alphabet/utils/constants.js">
/**
 * å¸¸é‡å®šä¹‰æ¨¡å—
 * 
 * ä¸å‰ç«¯ src/config/constants.ts ä¿æŒä¸€è‡´çš„è®¾è®¡é£æ ¼
 * é›†ä¸­ç®¡ç†æ‰€æœ‰äº‘å‡½æ•°å¸¸é‡
 */

'use strict';

// ==================== æ•°æ®åº“é›†åˆåç§° ====================
// ä¸å‰ç«¯ COLLECTIONS ä¿æŒä¸€è‡´
const COLLECTIONS = {
  USERS: 'users',
  VOCABULARY: 'vocabulary',
  USER_VOCABULARY_PROGRESS: 'user_vocabulary_progress',
  LETTERS: 'letters',
  USER_ALPHABET_PROGRESS: 'user_alphabet_progress',
  LETTER_TEST_BANK: 'letter_test_bank',
  COURSES: 'courses',
  LESSONS: 'lessons',
  PROGRESS: 'progress',
};

// ==================== æŒæ¡ç¨‹åº¦ ====================
// ä½¿ç”¨ä¸­æ–‡å€¼ï¼Œä¾¿äºå‰ç«¯ç›´æ¥æ˜¾ç¤º
const MasteryLevel = Object.freeze({
  UNFAMILIAR: 'é™Œç”Ÿ',
  FUZZY: 'æ¨¡ç³Š',
  REMEMBERED: 'è®°å¾—',
});

// ==================== å­¦ä¹ ç­‰çº§ ====================
// ä¸å‰ç«¯ LEVELS ä¿æŒä¸€è‡´
const LEVELS = Object.freeze({
  BEGINNER_A: 'BEGINNER_A',
  BEGINNER_B: 'BEGINNER_B',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED',
});

// ==================== SM-2 ç®—æ³•å‚æ•° ====================
// ä¼˜åŒ–ç‰ˆå‚æ•°ï¼ŒåŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿
const SM2_PARAMS = Object.freeze({
  INITIAL_EASINESS_FACTOR: 2.5,   // åˆå§‹ç®€æ˜“åº¦
  MIN_EASINESS_FACTOR: 1.3,       // æœ€å°ç®€æ˜“åº¦
  MAX_INTERVAL_DAYS: 180,         // æœ€å¤§é—´éš”ï¼ˆå¤©ï¼‰
  FUZZY_MULTIPLIER: 0.8,          // "æ¨¡ç³Š"æ—¶é—´éš”ç¼©çŸ­æ¯”ä¾‹
});

// ==================== æ—©æœŸå¤ä¹ é—´éš”åºåˆ— ====================
// åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–: 1â†’2â†’4â†’7â†’14 å¤©
const EARLY_INTERVALS = Object.freeze([1, 2, 4, 7, 14]);

// ==================== æ¯æ—¥å­¦ä¹ é…ç½® ====================
const DAILY_LEARNING_CONFIG = Object.freeze({
  MAX_NEW_WORDS: 10,              // æ¯æ—¥æ–°è¯ä¸Šé™
  MAX_REVIEW_WORDS: 20,           // æ¯æ—¥å¤ä¹ ä¸Šé™
  TOTAL_WORDS_LIMIT: 30,          // æ¯æ—¥æ€»è¯æ•°ä¸Šé™
});

// ==================== é”™è¯¯ç  ====================
// ç»Ÿä¸€é”™è¯¯ç å®šä¹‰
const ErrorCodes = Object.freeze({
  SUCCESS: 'SUCCESS',
  USER_NOT_FOUND: 'USER_NOT_FOUND',
  VOCABULARY_NOT_FOUND: 'VOCABULARY_NOT_FOUND',
  INVALID_PARAMS: 'INVALID_PARAMS',
  INVALID_MASTERY: 'INVALID_MASTERY',
  UNKNOWN_ACTION: 'UNKNOWN_ACTION',
  SERVER_ERROR: 'SERVER_ERROR',
});

// ==================== é”™è¯¯æ¶ˆæ¯ ====================
// ä¸å‰ç«¯ ERROR_MESSAGES é£æ ¼ä¸€è‡´
const ERROR_MESSAGES = Object.freeze({
  USER_NOT_FOUND: 'ç”¨æˆ·ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥ç”¨æˆ·IDæˆ–é‡æ–°ç™»å½•',
  VOCABULARY_NOT_FOUND: 'è¯æ±‡ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥è¯æ±‡ID',
  INVALID_PARAMS: 'å‚æ•°æ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥è¾“å…¥',
  INVALID_MASTERY: 'æ— æ•ˆçš„æŒæ¡ç¨‹åº¦ï¼Œå…è®¸å€¼: é™Œç”Ÿ/æ¨¡ç³Š/è®°å¾—',
  UNKNOWN_ACTION: 'æœªçŸ¥æ“ä½œç±»å‹',
  SERVER_ERROR: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•',
});

// ==================== æ”¯æŒçš„ Actions ====================
const SUPPORTED_ACTIONS = Object.freeze([
  'getTodayWords',
  'updateMastery',
  'toggleSkipWord',
  'getVocabularyDetail',
  'getReviewStatistics',
  'getVocabularyList',
  'getSkippedWords',
  'getLetterTest',
  'submitLetterTest',
  'passLetterTest',
  'getTodayMemories',
  'submitMemoryResult',
  'checkModuleAccess',
  'getUserProgress'
]);

module.exports = {
  // é›†åˆ
  COLLECTIONS,

  // æšä¸¾
  MasteryLevel,
  LEVELS,
  ErrorCodes,

  // ç®—æ³•å‚æ•°
  SM2_PARAMS,
  EARLY_INTERVALS,

  // é…ç½®
  DAILY_LEARNING_CONFIG,

  // æ¶ˆæ¯
  ERROR_MESSAGES,
  SUPPORTED_ACTIONS,
};
</file>

<file path="cloudbase/functions/alphabet/package.json">
{
  "name": "alphabet",
  "version": "1.0.0",
  "description": "Alphabet learning function",
  "main": "index.js",
  "dependencies": {
    "wx-server-sdk": "latest"
  },
  "engines": {
    "node": "18.20.0"
  }
}
</file>

<file path="cloudbase/functions/learn-vocab/utils/constants.js">
/**
 * å¸¸é‡å®šä¹‰æ¨¡å—
 * 
 * ä¸å‰ç«¯ src/config/constants.ts ä¿æŒä¸€è‡´çš„è®¾è®¡é£æ ¼
 * é›†ä¸­ç®¡ç†æ‰€æœ‰äº‘å‡½æ•°å¸¸é‡
 */

'use strict';

// ==================== æ•°æ®åº“é›†åˆåç§° ====================
// ä¸å‰ç«¯ COLLECTIONS ä¿æŒä¸€è‡´
const COLLECTIONS = {
  USERS: 'users',
  VOCABULARY: 'vocabulary',
  USER_VOCABULARY_PROGRESS: 'user_vocabulary_progress',
  LETTERS: 'letters',
  USER_ALPHABET_PROGRESS: 'user_alphabet_progress',
  LETTER_TEST_BANK: 'letter_test_bank',
  COURSES: 'courses',
  LESSONS: 'lessons',
  PROGRESS: 'progress',
};

// ==================== æŒæ¡ç¨‹åº¦ ====================
// ä½¿ç”¨ä¸­æ–‡å€¼ï¼Œä¾¿äºå‰ç«¯ç›´æ¥æ˜¾ç¤º
const MasteryLevel = Object.freeze({
  UNFAMILIAR: 'é™Œç”Ÿ',
  FUZZY: 'æ¨¡ç³Š',
  REMEMBERED: 'è®°å¾—',
});

// ==================== å­¦ä¹ ç­‰çº§ ====================
// ä¸å‰ç«¯ LEVELS ä¿æŒä¸€è‡´
const LEVELS = Object.freeze({
  BEGINNER_A: 'BEGINNER_A',
  BEGINNER_B: 'BEGINNER_B',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED',
});

// ==================== SM-2 ç®—æ³•å‚æ•° ====================
// ä¼˜åŒ–ç‰ˆå‚æ•°ï¼ŒåŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿
const SM2_PARAMS = Object.freeze({
  INITIAL_EASINESS_FACTOR: 2.5,   // åˆå§‹ç®€æ˜“åº¦
  MIN_EASINESS_FACTOR: 1.3,       // æœ€å°ç®€æ˜“åº¦
  MAX_INTERVAL_DAYS: 180,         // æœ€å¤§é—´éš”ï¼ˆå¤©ï¼‰
  FUZZY_MULTIPLIER: 0.8,          // "æ¨¡ç³Š"æ—¶é—´éš”ç¼©çŸ­æ¯”ä¾‹
});

// ==================== æ—©æœŸå¤ä¹ é—´éš”åºåˆ— ====================
// åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–: 1â†’2â†’4â†’7â†’14 å¤©
const EARLY_INTERVALS = Object.freeze([1, 2, 4, 7, 14]);

// ==================== æ¯æ—¥å­¦ä¹ é…ç½® ====================
const DAILY_LEARNING_CONFIG = Object.freeze({
  MAX_NEW_WORDS: 10,              // æ¯æ—¥æ–°è¯ä¸Šé™
  MAX_REVIEW_WORDS: 20,           // æ¯æ—¥å¤ä¹ ä¸Šé™
  TOTAL_WORDS_LIMIT: 30,          // æ¯æ—¥æ€»è¯æ•°ä¸Šé™
});

// ==================== é”™è¯¯ç  ====================
// ç»Ÿä¸€é”™è¯¯ç å®šä¹‰
const ErrorCodes = Object.freeze({
  SUCCESS: 'SUCCESS',
  USER_NOT_FOUND: 'USER_NOT_FOUND',
  VOCABULARY_NOT_FOUND: 'VOCABULARY_NOT_FOUND',
  INVALID_PARAMS: 'INVALID_PARAMS',
  INVALID_MASTERY: 'INVALID_MASTERY',
  UNKNOWN_ACTION: 'UNKNOWN_ACTION',
  SERVER_ERROR: 'SERVER_ERROR',
});

// ==================== é”™è¯¯æ¶ˆæ¯ ====================
// ä¸å‰ç«¯ ERROR_MESSAGES é£æ ¼ä¸€è‡´
const ERROR_MESSAGES = Object.freeze({
  USER_NOT_FOUND: 'ç”¨æˆ·ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥ç”¨æˆ·IDæˆ–é‡æ–°ç™»å½•',
  VOCABULARY_NOT_FOUND: 'è¯æ±‡ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥è¯æ±‡ID',
  INVALID_PARAMS: 'å‚æ•°æ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥è¾“å…¥',
  INVALID_MASTERY: 'æ— æ•ˆçš„æŒæ¡ç¨‹åº¦ï¼Œå…è®¸å€¼: é™Œç”Ÿ/æ¨¡ç³Š/è®°å¾—',
  UNKNOWN_ACTION: 'æœªçŸ¥æ“ä½œç±»å‹',
  SERVER_ERROR: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•',
});

// ==================== æ”¯æŒçš„ Actions ====================
const SUPPORTED_ACTIONS = Object.freeze([
  'getTodayWords',
  'updateMastery',
  'toggleSkipWord',
  'getVocabularyDetail',
  'getReviewStatistics',
  'getVocabularyList',
  'getSkippedWords',
  'getLetterTest',
  'submitLetterTest',
  'passLetterTest',
  'getTodayMemories',
  'submitMemoryResult',
  'checkModuleAccess',
  'getUserProgress'
]);

module.exports = {
  // é›†åˆ
  COLLECTIONS,

  // æšä¸¾
  MasteryLevel,
  LEVELS,
  ErrorCodes,

  // ç®—æ³•å‚æ•°
  SM2_PARAMS,
  EARLY_INTERVALS,

  // é…ç½®
  DAILY_LEARNING_CONFIG,

  // æ¶ˆæ¯
  ERROR_MESSAGES,
  SUPPORTED_ACTIONS,
};
</file>

<file path="cloudbase/functions/learn-vocab/utils/database.js">
const cloud = require('wx-server-sdk');

cloud.init({
    env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();
const _ = db.command;

const collections = {
    users: db.collection('users'),
    vocabulary: db.collection('vocabulary'),
    letters: db.collection('letters'),
    sentences: db.collection('sentences'),
    memory_status: db.collection('memory_status'),
    user_progress: db.collection('user_progress'),
    user_vocabulary_progress: db.collection('user_vocabulary_progress')
};

module.exports = {
    db,
    _,
    userCollection: collections.users,
    vocabularyCollection: collections.vocabulary,
    letterCollection: collections.letters,
    sentenceCollection: collections.sentences,
    memoryStatusCollection: collections.memory_status,
    userProgressCollection: collections.user_progress,
    progressCollection: collections.user_vocabulary_progress,
    collections
};
</file>

<file path="cloudbase/functions/learn-vocab/utils/response.js">
/**
 * å“åº”æ ¼å¼åŒ–æ¨¡å—
 * 
 * ç»Ÿä¸€ API å“åº”æ ¼å¼
 * ä¸å‰ç«¯ ApiResponse<T> ç±»å‹å®šä¹‰ä¿æŒä¸€è‡´
 */

'use strict';

const { ErrorCodes, ERROR_MESSAGES } = require('./constants');

/**
 * åˆ›å»ºæ ‡å‡†åŒ– API å“åº”
 * 
 * å¯¹åº”å‰ç«¯ç±»å‹:
 * interface ApiResponse<T> {
 *   success: boolean;
 *   data?: T;
 *   message?: string;
 *   errorCode?: string;
 *   timestamp: string;
 * }
 * 
 * @param {boolean} success - æ˜¯å¦æˆåŠŸ
 * @param {Object} data - è¿”å›æ•°æ®
 * @param {string} message - æç¤ºæ¶ˆæ¯
 * @param {string} errorCode - é”™è¯¯ç 
 * @returns {Object} æ ‡å‡†åŒ–å“åº”å¯¹è±¡
 */
function createResponse(success, data = null, message = '', errorCode = null) {
  return {
    success,
    data,
    message,
    errorCode,
    timestamp: new Date().toISOString(),
  };
}

/**
 * åˆ›å»ºæˆåŠŸå“åº”
 * 
 * @param {Object} data - è¿”å›æ•°æ®
 * @param {string} message - æˆåŠŸæ¶ˆæ¯
 * @returns {Object} æˆåŠŸå“åº”å¯¹è±¡
 */
function successResponse(data, message = 'æ“ä½œæˆåŠŸ') {
  return createResponse(true, data, message, null);
}

/**
 * åˆ›å»ºé”™è¯¯å“åº”
 * 
 * @param {string} errorCode - é”™è¯¯ç  (æ¥è‡ª ErrorCodes)
 * @param {string} customMessage - è‡ªå®šä¹‰æ¶ˆæ¯ (å¯é€‰)
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function errorResponse(errorCode, customMessage = null) {
  const message = customMessage || ERROR_MESSAGES[errorCode] || 'æœªçŸ¥é”™è¯¯';
  return createResponse(false, null, message, errorCode);
}

/**
 * åˆ›å»ºå‚æ•°é”™è¯¯å“åº”
 * 
 * @param {string} detail - é”™è¯¯è¯¦æƒ…
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function invalidParamsResponse(detail) {
  return errorResponse(ErrorCodes.INVALID_PARAMS, detail);
}

/**
 * åˆ›å»ºç”¨æˆ·ä¸å­˜åœ¨å“åº”
 * 
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function userNotFoundResponse() {
  return errorResponse(ErrorCodes.USER_NOT_FOUND);
}

/**
 * åˆ›å»ºè¯æ±‡ä¸å­˜åœ¨å“åº”
 * 
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function vocabularyNotFoundResponse() {
  return errorResponse(ErrorCodes.VOCABULARY_NOT_FOUND);
}

/**
 * åˆ›å»ºæœåŠ¡å™¨é”™è¯¯å“åº”
 * 
 * @param {Error} error - é”™è¯¯å¯¹è±¡
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function serverErrorResponse(error) {
  // ç”Ÿäº§ç¯å¢ƒä¸æš´éœ²é”™è¯¯è¯¦æƒ…
  const message = process.env.NODE_ENV === 'development' 
    ? `æœåŠ¡å™¨é”™è¯¯: ${error.message}`
    : ERROR_MESSAGES.SERVER_ERROR;
  
  return errorResponse(ErrorCodes.SERVER_ERROR, message);
}

module.exports = {
  createResponse,
  successResponse,
  errorResponse,
  invalidParamsResponse,
  userNotFoundResponse,
  vocabularyNotFoundResponse,
  serverErrorResponse,
};
</file>

<file path="cloudbase/functions/learn-vocab/package.json">
{
  "name": "learn-vocab",
  "version": "1.2.0",
  "description": "Thai Learning App - è¯æ±‡å­¦ä¹ äº‘å‡½æ•° (æ¨¡å—åŒ–ç‰ˆæœ¬)",
  "main": "index.js",
  "scripts": {
    "deploy": "tcb fn deploy learn-vocab",
    "logs": "tcb fn log learn-vocab",
    "test": "tcb fn invoke learn-vocab --data '{\"action\":\"getVocabularyList\",\"data\":{\"limit\":3}}'",
    "test:today": "tcb fn invoke learn-vocab --data '{\"action\":\"getTodayWords\",\"data\":{\"userId\":\"test\",\"limit\":5}}'",
    "test:stats": "tcb fn invoke learn-vocab --data '{\"action\":\"getReviewStatistics\",\"data\":{\"userId\":\"test\"}}'"
  },
  "dependencies": {
    "wx-server-sdk": "~2.6.3"
  },
  "author": "Liang JianYu",
  "license": "MIT",
  "keywords": [
    "thai",
    "language-learning",
    "vocabulary",
    "cloudbase",
    "sm2-algorithm",
    "spaced-repetition",
    "modular"
  ],
  "engines": {
    "node": "18.20.0"
  }
}
</file>

<file path="cloudbase/functions/memory-engine/handlers/submitRoundEvaluation.js">
'use strict';

/**
 * æäº¤å­—æ¯æ¨¡å—çš„ä¸‰è½®è¯„ä¼°ç»“æœï¼ˆæ¯è½®ä¸€ä¸ªæ€»åˆ†ï¼‰
 *
 * è®¾è®¡ç›®æ ‡ï¼š
 * - å­—æ¯ç”¨æˆ·å‰ç«¯åªæœ‰â€œå¯¹/é”™â€æŒ‰é’®ï¼Œä¸é€‰æ‹© AGAIN/HARD/GOOD/EASYï¼›
 * - æ¯è½®ç»“æŸæ—¶å‰ç«¯è®¡ç®—æ•´ä½“æ­£ç¡®ç‡ accuracyï¼Œå¹¶ä¸Šä¼ åˆ°æ­¤ handlerï¼Œ
 *   ä»…ç”¨äºè®°å½•åˆ° user_alphabet_progress.roundHistoryï¼Œä¸æ”¹å˜ SM-2 è®°å¿†ç®—æ³•ï¼›
 * - è¿™æ ·å¯ä»¥åœ¨ä¸ä¿®æ”¹ updateMemoryAfterReview çš„å‰æä¸‹ï¼Œä¿ç•™è½®æ¬¡çº§åˆ«çš„ç»Ÿè®¡æ•°æ®ã€‚
 */

const { createResponse } = require('../utils/response');

/**
 * @param {Object} db     - cloud.database()
 * @param {Object} params - { userId, entityType, lessonId, roundNumber, totalQuestions, correctCount, accuracy }
 */
async function submitRoundEvaluation(db, params) {
  const {
    userId,
    entityType,
    lessonId,
    roundNumber,
    totalQuestions,
    correctCount,
    accuracy,
  } = params || {};

  if (!userId || !entityType || !lessonId || !roundNumber) {
    return createResponse(
      false,
      null,
      'ç¼ºå°‘å¿…å¡«å‚æ•°: userId, entityType, lessonId, roundNumber',
      'INVALID_PARAMS',
    );
  }

  if (entityType !== 'letter') {
    return createResponse(
      false,
      null,
      'submitRoundEvaluation ç›®å‰ä»…æ”¯æŒ entityType = letter',
      'INVALID_ENTITY_TYPE',
    );
  }

  const total = typeof totalQuestions === 'number' ? totalQuestions : 0;
  const correct = typeof correctCount === 'number' ? correctCount : 0;
  const acc = typeof accuracy === 'number' && !Number.isNaN(accuracy)
    ? accuracy
    : total > 0
      ? correct / total
      : 0;

  const passed = acc >= 0.9;
  const now = new Date().toISOString();

  const col = db.collection('user_alphabet_progress');

  try {
    const existing = await col.where({ userId }).limit(1).get();

    const roundEntry = {
      lessonId,
      roundNumber,
      totalQuestions: total,
      correctCount: correct,
      accuracy: acc,
      passed,
      updatedAt: now,
    };

    if (!existing.data || existing.data.length === 0) {
      // ğŸ”¥ ä¿®æ­£ï¼šé¦–æ¬¡åˆ›å»ºæ—¶çš„ nextRound è®¡ç®—ï¼ˆé˜²æ­¢è·¨è¯¾æ±¡æŸ“ï¼‰
      const nextRound = passed
        ? (roundNumber < 3 ? roundNumber + 1 : 1)
        : 1;

      // ğŸ”¥ P0-B: é¦–æ¬¡åˆ›å»ºæ—¶ä¹Ÿè¦åˆ¤å®š completedLessons
      const initialCompletedLessons = (passed && roundNumber === 3 && lessonId)
        ? [lessonId]
        : [];

      console.log(`ğŸ” [P0-B-init] roundNumber: ${roundNumber}, passed: ${passed}, lessonId: ${lessonId || 'N/A'}, initialCompleted: [${initialCompletedLessons.join(',')}], nextRound: ${nextRound}`);

      // æ²¡æœ‰è¿›åº¦è®°å½•æ—¶ï¼Œæ’å…¥ä¸€æ¡å¸¦æœ‰ roundHistory çš„é»˜è®¤è®°å½•
      await col.add({
        data: {
          userId,
          letterProgress: 0.0,
          letterCompleted: false,
          completedLessons: initialCompletedLessons, // ğŸ”¥ P0-B: åˆå§‹å€¼
          masteredLetterCount: 0,
          totalLetterCount: 80,
          currentRound: nextRound, // ğŸ”¥ ä½¿ç”¨ä¿®æ­£åçš„ nextRound
          roundHistory: [roundEntry],
          createdAt: now,
          updatedAt: now,
        },
      });
    } else {
      const doc = existing.data[0];
      const docId = doc._id;
      const history = Array.isArray(doc.roundHistory) ? doc.roundHistory : [];

      // æ›¿æ¢åŒä¸€ lessonId + roundNumber çš„æ—§è®°å½•
      const filtered = history.filter(
        (r) => !(r.lessonId === lessonId && r.roundNumber === roundNumber),
      );
      filtered.push(roundEntry);

      // ğŸ”¥ P0-B: Round3 passed æ—¶å†™å…¥ completedLessons
      let updatedCompletedLessons = Array.isArray(doc.completedLessons)
        ? [...doc.completedLessons]
        : [];

      const completedLessonsBefore = [...updatedCompletedLessons];

      if (passed && roundNumber === 3 && lessonId) {
        if (!updatedCompletedLessons.includes(lessonId)) {
          updatedCompletedLessons.push(lessonId);
        }
      }

      console.log(`ğŸ” [P0-B] roundNumber: ${roundNumber}, passed: ${passed}, lessonId: ${lessonId || 'N/A'}, completedBefore: [${completedLessonsBefore.join(',')}], completedAfter: [${updatedCompletedLessons.join(',')}]`);

      // ğŸ”¥ ä¿®æ­£ï¼šnextRound é‡ç½®é˜²æ­¢è·¨è¯¾æ±¡æŸ“
      const nextRound = passed
        ? (roundNumber < 3 ? roundNumber + 1 : 1)
        : 1;

      await col.doc(docId).update({
        data: {
          currentRound: nextRound,
          roundHistory: filtered,
          completedLessons: updatedCompletedLessons, // ğŸ”¥ P0-B: å†™å…¥ completedLessons
          updatedAt: now,
        },
      });
    }

    return createResponse(true, { round: roundEntry }, 'æäº¤è½®æ¬¡è¯„ä¼°æˆåŠŸ');
  } catch (err) {
    console.error('[submitRoundEvaluation] error:', err);
    return createResponse(
      false,
      null,
      err.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      'SERVER_ERROR',
    );
  }
}

module.exports = submitRoundEvaluation;
</file>

<file path="cloudbase/functions/memory-engine/utils/constants.js">
/**
 * å¸¸é‡å®šä¹‰æ¨¡å—
 * 
 * ä¸å‰ç«¯ src/config/constants.ts ä¿æŒä¸€è‡´çš„è®¾è®¡é£æ ¼
 * é›†ä¸­ç®¡ç†æ‰€æœ‰äº‘å‡½æ•°å¸¸é‡
 */

'use strict';

// ==================== æ•°æ®åº“é›†åˆåç§° ====================
// ä¸å‰ç«¯ COLLECTIONS ä¿æŒä¸€è‡´
const COLLECTIONS = {
  USERS: 'users',
  VOCABULARY: 'vocabulary',
  USER_VOCABULARY_PROGRESS: 'user_vocabulary_progress',
  LETTERS: 'letters',
  USER_ALPHABET_PROGRESS: 'user_alphabet_progress',
  LETTER_TEST_BANK: 'letter_test_bank',
  COURSES: 'courses',
  LESSONS: 'lessons',
  PROGRESS: 'progress',
};

// ==================== æŒæ¡ç¨‹åº¦ ====================
// ä½¿ç”¨ä¸­æ–‡å€¼ï¼Œä¾¿äºå‰ç«¯ç›´æ¥æ˜¾ç¤º
const MasteryLevel = Object.freeze({
  UNFAMILIAR: 'é™Œç”Ÿ',
  FUZZY: 'æ¨¡ç³Š',
  REMEMBERED: 'è®°å¾—',
});

// ==================== å­¦ä¹ ç­‰çº§ ====================
// ä¸å‰ç«¯ LEVELS ä¿æŒä¸€è‡´
const LEVELS = Object.freeze({
  BEGINNER_A: 'BEGINNER_A',
  BEGINNER_B: 'BEGINNER_B',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED',
});

// ==================== SM-2 ç®—æ³•å‚æ•° ====================
// ä¼˜åŒ–ç‰ˆå‚æ•°ï¼ŒåŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿
const SM2_PARAMS = Object.freeze({
  INITIAL_EASINESS_FACTOR: 2.5,   // åˆå§‹ç®€æ˜“åº¦
  MIN_EASINESS_FACTOR: 1.3,       // æœ€å°ç®€æ˜“åº¦
  MAX_INTERVAL_DAYS: 180,         // æœ€å¤§é—´éš”ï¼ˆå¤©ï¼‰
  FUZZY_MULTIPLIER: 0.8,          // "æ¨¡ç³Š"æ—¶é—´éš”ç¼©çŸ­æ¯”ä¾‹
});

// ==================== æ—©æœŸå¤ä¹ é—´éš”åºåˆ— ====================
// åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–: 1â†’2â†’4â†’7â†’14 å¤©
const EARLY_INTERVALS = Object.freeze([1, 2, 4, 7, 14]);

// ==================== æ¯æ—¥å­¦ä¹ é…ç½® ====================
const DAILY_LEARNING_CONFIG = Object.freeze({
  MAX_NEW_WORDS: 10,              // æ¯æ—¥æ–°è¯ä¸Šé™
  MAX_REVIEW_WORDS: 20,           // æ¯æ—¥å¤ä¹ ä¸Šé™
  TOTAL_WORDS_LIMIT: 30,          // æ¯æ—¥æ€»è¯æ•°ä¸Šé™
});

// ==================== é”™è¯¯ç  ====================
// ç»Ÿä¸€é”™è¯¯ç å®šä¹‰
const ErrorCodes = Object.freeze({
  SUCCESS: 'SUCCESS',
  USER_NOT_FOUND: 'USER_NOT_FOUND',
  VOCABULARY_NOT_FOUND: 'VOCABULARY_NOT_FOUND',
  INVALID_PARAMS: 'INVALID_PARAMS',
  INVALID_MASTERY: 'INVALID_MASTERY',
  UNKNOWN_ACTION: 'UNKNOWN_ACTION',
  SERVER_ERROR: 'SERVER_ERROR',
});

// ==================== é”™è¯¯æ¶ˆæ¯ ====================
// ä¸å‰ç«¯ ERROR_MESSAGES é£æ ¼ä¸€è‡´
const ERROR_MESSAGES = Object.freeze({
  USER_NOT_FOUND: 'ç”¨æˆ·ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥ç”¨æˆ·IDæˆ–é‡æ–°ç™»å½•',
  VOCABULARY_NOT_FOUND: 'è¯æ±‡ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥è¯æ±‡ID',
  INVALID_PARAMS: 'å‚æ•°æ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥è¾“å…¥',
  INVALID_MASTERY: 'æ— æ•ˆçš„æŒæ¡ç¨‹åº¦ï¼Œå…è®¸å€¼: é™Œç”Ÿ/æ¨¡ç³Š/è®°å¾—',
  UNKNOWN_ACTION: 'æœªçŸ¥æ“ä½œç±»å‹',
  SERVER_ERROR: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•',
});

// ==================== æ”¯æŒçš„ Actions ====================
const SUPPORTED_ACTIONS = Object.freeze([
  'getTodayWords',
  'updateMastery',
  'toggleSkipWord',
  'getVocabularyDetail',
  'getReviewStatistics',
  'getVocabularyList',
  'getSkippedWords',
  'getLetterTest',
  'submitLetterTest',
  'passLetterTest',
  'getTodayMemories',
  'submitMemoryResult',
  'submitRoundEvaluation',
  'checkModuleAccess',
  'getUserProgress',
  'getAlphabetLessons',
]);

module.exports = {
  // é›†åˆ
  COLLECTIONS,

  // æšä¸¾
  MasteryLevel,
  LEVELS,
  ErrorCodes,

  // ç®—æ³•å‚æ•°
  SM2_PARAMS,
  EARLY_INTERVALS,

  // é…ç½®
  DAILY_LEARNING_CONFIG,

  // æ¶ˆæ¯
  ERROR_MESSAGES,
  SUPPORTED_ACTIONS,
};
</file>

<file path="cloudbase/functions/memory-engine/utils/database.js">
const cloud = require('wx-server-sdk');

cloud.init({
    env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();
const _ = db.command;

const collections = {
    users: db.collection('users'),
    vocabulary: db.collection('vocabulary'),
    letters: db.collection('letters'),
    sentences: db.collection('sentences'),
    memory_status: db.collection('memory_status'),
    user_progress: db.collection('user_progress'),
    user_vocabulary_progress: db.collection('user_vocabulary_progress')
};

module.exports = {
    db,
    _,
    userCollection: collections.users,
    vocabularyCollection: collections.vocabulary,
    letterCollection: collections.letters,
    sentenceCollection: collections.sentences,
    memoryStatusCollection: collections.memory_status,
    userProgressCollection: collections.user_progress,
    progressCollection: collections.user_vocabulary_progress,
    collections
};
</file>

<file path="cloudbase/functions/memory-engine/utils/response.js">
/**
 * å“åº”æ ¼å¼åŒ–æ¨¡å—
 * 
 * ç»Ÿä¸€ API å“åº”æ ¼å¼
 * ä¸å‰ç«¯ ApiResponse<T> ç±»å‹å®šä¹‰ä¿æŒä¸€è‡´
 */

'use strict';

const { ErrorCodes, ERROR_MESSAGES } = require('./constants');

/**
 * åˆ›å»ºæ ‡å‡†åŒ– API å“åº”
 * 
 * å¯¹åº”å‰ç«¯ç±»å‹:
 * interface ApiResponse<T> {
 *   success: boolean;
 *   data?: T;
 *   message?: string;
 *   errorCode?: string;
 *   timestamp: string;
 * }
 * 
 * @param {boolean} success - æ˜¯å¦æˆåŠŸ
 * @param {Object} data - è¿”å›æ•°æ®
 * @param {string} message - æç¤ºæ¶ˆæ¯
 * @param {string} errorCode - é”™è¯¯ç 
 * @returns {Object} æ ‡å‡†åŒ–å“åº”å¯¹è±¡
 */
function createResponse(success, data = null, message = '', errorCode = null) {
  return {
    success,
    data,
    message,
    errorCode,
    timestamp: new Date().toISOString(),
  };
}

/**
 * åˆ›å»ºæˆåŠŸå“åº”
 * 
 * @param {Object} data - è¿”å›æ•°æ®
 * @param {string} message - æˆåŠŸæ¶ˆæ¯
 * @returns {Object} æˆåŠŸå“åº”å¯¹è±¡
 */
function successResponse(data, message = 'æ“ä½œæˆåŠŸ') {
  return createResponse(true, data, message, null);
}

/**
 * åˆ›å»ºé”™è¯¯å“åº”
 * 
 * @param {string} errorCode - é”™è¯¯ç  (æ¥è‡ª ErrorCodes)
 * @param {string} customMessage - è‡ªå®šä¹‰æ¶ˆæ¯ (å¯é€‰)
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function errorResponse(errorCode, customMessage = null) {
  const message = customMessage || ERROR_MESSAGES[errorCode] || 'æœªçŸ¥é”™è¯¯';
  return createResponse(false, null, message, errorCode);
}

/**
 * åˆ›å»ºå‚æ•°é”™è¯¯å“åº”
 * 
 * @param {string} detail - é”™è¯¯è¯¦æƒ…
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function invalidParamsResponse(detail) {
  return errorResponse(ErrorCodes.INVALID_PARAMS, detail);
}

/**
 * åˆ›å»ºç”¨æˆ·ä¸å­˜åœ¨å“åº”
 * 
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function userNotFoundResponse() {
  return errorResponse(ErrorCodes.USER_NOT_FOUND);
}

/**
 * åˆ›å»ºè¯æ±‡ä¸å­˜åœ¨å“åº”
 * 
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function vocabularyNotFoundResponse() {
  return errorResponse(ErrorCodes.VOCABULARY_NOT_FOUND);
}

/**
 * åˆ›å»ºæœåŠ¡å™¨é”™è¯¯å“åº”
 * 
 * @param {Error} error - é”™è¯¯å¯¹è±¡
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function serverErrorResponse(error) {
  // ç”Ÿäº§ç¯å¢ƒä¸æš´éœ²é”™è¯¯è¯¦æƒ…
  const message = process.env.NODE_ENV === 'development' 
    ? `æœåŠ¡å™¨é”™è¯¯: ${error.message}`
    : ERROR_MESSAGES.SERVER_ERROR;
  
  return errorResponse(ErrorCodes.SERVER_ERROR, message);
}

module.exports = {
  createResponse,
  successResponse,
  errorResponse,
  invalidParamsResponse,
  userNotFoundResponse,
  vocabularyNotFoundResponse,
  serverErrorResponse,
};
</file>

<file path="cloudbase/functions/memory-engine/utils/sm2.js">
/**
 * SM-2 é—´éš”é‡å¤ç®—æ³•æ¨¡å—ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
 * 
 * åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–:
 * - æ—©æœŸå¤ä¹ é—´éš”æ›´å¯†é›†: 1â†’2â†’4â†’7â†’14 å¤©
 * - "æ¨¡ç³Š"çŠ¶æ€ç¼©çŸ­é—´éš”è€Œéç»´æŒä¸å˜
 * - "é™Œç”Ÿ"çŠ¶æ€é‡ç½®å¤ä¹ è¿›åº¦
 * 
 * ç®—æ³•è®ºæ–‡: https://www.supermemo.com/en/archives1990-2015/english/ol/sm2
 */

'use strict';

const { MasteryLevel, SM2_PARAMS, EARLY_INTERVALS } = require('./constants');

/**
 * å°†æŒæ¡ç¨‹åº¦æ˜ å°„åˆ° SM-2 Quality å€¼
 * 
 * SM-2 Quality å®šä¹‰:
 * 0 - å®Œå…¨ä¸è®°å¾—
 * 1 - é”™è¯¯å›ç­”ï¼Œä½†çœ‹åˆ°æ­£ç¡®ç­”æ¡ˆåæƒ³èµ·
 * 2 - é”™è¯¯å›ç­”ï¼Œæ­£ç¡®ç­”æ¡ˆçœ‹èµ·æ¥å¾ˆç†Ÿæ‚‰
 * 3 - æ­£ç¡®å›ç­”ï¼Œä½†å›°éš¾è¾ƒå¤§
 * 4 - æ­£ç¡®å›ç­”ï¼Œæœ‰äº›çŠ¹è±«
 * 5 - æ­£ç¡®å›ç­”ï¼Œæ¯«æ— å›°éš¾
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦
 * @returns {number} Qualityå€¼ (1-5)
 */
function masteryToQuality(mastery) {
    switch (mastery) {
        case MasteryLevel.UNFAMILIAR:
            return 1;  // å®Œå…¨ä¸è®°å¾—
        case MasteryLevel.FUZZY:
            return 3;  // æœ‰å°è±¡ä½†ä¸ç¡®å®š
        case MasteryLevel.REMEMBERED:
            return 5;  // å®Œå…¨è®°å¾—
        default:
            return 1;
    }
}

/**
 * è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸï¼ˆä¼˜åŒ–ç‰ˆ SM-2 ç®—æ³•ï¼‰
 * 
 * æ”¹è¿›ç‚¹:
 * 1. æ—©æœŸé˜¶æ®µï¼ˆå‰5æ¬¡ï¼‰ä½¿ç”¨å›ºå®šçš„æ¸è¿›é—´éš” [1,2,4,7,14]
 * 2. "æ¨¡ç³Š"æ—¶ç¼©çŸ­é—´éš”è€Œéç»´æŒä¸å˜
 * 3. "é™Œç”Ÿ"æ—¶å®Œå…¨é‡ç½®å¤ä¹ è¿›åº¦
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦: å¿˜è®°/æ¨¡ç³Š/è®¤è¯†
 * @param {number} currentInterval - å½“å‰å¤ä¹ é—´éš”ï¼ˆå¤©ï¼‰
 * @param {number} easinessFactor - ç®€æ˜“åº¦å› å­ï¼ˆ1.3-2.5+ï¼‰
 * @param {number} reviewCount - å·²å¤ä¹ æ¬¡æ•°
 * @returns {Object} ç®—æ³•è®¡ç®—ç»“æœ
 * 
 * @example
 * const result = calculateSM2Optimized('è®¤è¯†', 2, 2.5, 1);
 * // {
 * //   nextInterval: 4,
 * //   nextEasinessFactor: 2.6,
 * //   nextReviewDate: "2025-12-01T10:00:00Z",
 * //   shouldResetCount: false
 * // }
 * */
function calculateSM2Optimized(
    mastery,
    currentInterval = 1,
    easinessFactor = SM2_PARAMS.INITIAL_EASINESS_FACTOR,
    reviewCount = 0
) {
    let nextInterval = currentInterval;
    let nextEF = easinessFactor;
    let shouldResetCount = false;

    const quality = masteryToQuality(mastery);

    // ==================== æ ¸å¿ƒç®—æ³•é€»è¾‘ ====================

    if (quality < 3) {
        // ========== å¿˜è®°: å®Œå…¨é‡ç½® ==========
        // ç”¨æˆ·å®Œå…¨ä¸è®°å¾—ï¼Œéœ€è¦ä»å¤´å¼€å§‹å­¦ä¹ 
        nextInterval = 1;
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF - 0.2);
        shouldResetCount = true;

    } else if (quality === 3) {
        // ========== æ¨¡ç³Š: ç¼©çŸ­é—´éš”ï¼ŒåŠ å¼ºå¤ä¹  ==========
        // æ”¹è¿›: ä¸æ˜¯ç»´æŒä¸å˜ï¼Œè€Œæ˜¯ç¼©çŸ­20%
        nextInterval = Math.max(1, Math.round(currentInterval * SM2_PARAMS.FUZZY_MULTIPLIER));
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF - 0.1);

    } else {
        // ========== è®°å¾—: ä½¿ç”¨ä¼˜åŒ–çš„é—´éš”åºåˆ— ==========
        if (reviewCount < EARLY_INTERVALS.length) {
            // æ—©æœŸé˜¶æ®µ: ä½¿ç”¨é¢„å®šä¹‰çš„æ¸è¿›é—´éš”
            // è¿™æ˜¯å…³é”®æ”¹è¿›: 1â†’2â†’4â†’7â†’14 è€ŒéåŸç‰ˆçš„ 1â†’6
            nextInterval = EARLY_INTERVALS[reviewCount];
        } else {
            // åæœŸé˜¶æ®µ: ä½¿ç”¨ EF è®¡ç®—æŒ‡æ•°å¢é•¿
            nextInterval = Math.round(currentInterval * nextEF);
        }

        // æé«˜ç®€æ˜“åº¦ (æ ‡å‡† SM-2 å…¬å¼)
        nextEF = nextEF + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF);
    }

    // é™åˆ¶æœ€å¤§é—´éš”
    nextInterval = Math.min(nextInterval, SM2_PARAMS.MAX_INTERVAL_DAYS);

    // è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸ
    const nextReviewDate = new Date();
    nextReviewDate.setDate(nextReviewDate.getDate() + nextInterval);

    // è®¡ç®—æ–°çš„å¤ä¹ æ¬¡æ•°
    const newRepetitions = shouldResetCount ? 0 : reviewCount + 1;

    return {
        // === å…¼å®¹ memoryEngine.js çš„æ—§æ¥å£ ===
        interval: nextInterval,
        easinessFactor: parseFloat(nextEF.toFixed(2)),
        repetitions: newRepetitions,

        // === æ–°æ¥å£ï¼ˆä¿ç•™ä¾›æœªæ¥ä½¿ç”¨ï¼‰===
        nextInterval,
        nextEasinessFactor: parseFloat(nextEF.toFixed(2)),
        nextReviewDate: nextReviewDate.toISOString(),
        shouldResetCount,
    };
}

/**
 * ç”Ÿæˆé¢„è®¡å¤ä¹ æ—¶é—´çº¿
 * 
 * ç”¨äºå‰ç«¯å±•ç¤ºæœªæ¥çš„å¤ä¹ è®¡åˆ’
 * 
 * @param {number} currentReviewCount - å½“å‰å¤ä¹ æ¬¡æ•°
 * @param {number} maxItems - è¿”å›çš„æ—¶é—´çº¿é¡¹æ•° (é»˜è®¤5)
 * @returns {Array} æœªæ¥å¤ä¹ è®¡åˆ’
 * 
 * @example
 * generateReviewTimeline(2);
 * // [
 * //   { reviewNumber: 3, intervalDays: 4 },
 * //   { reviewNumber: 4, intervalDays: 7 },
 * //   { reviewNumber: 5, intervalDays: 14 },
 * //   ...
 * // ]
 */
function generateReviewTimeline(currentReviewCount, maxItems = 5) {
    const timeline = [];
    let interval = 1;
    let ef = SM2_PARAMS.INITIAL_EASINESS_FACTOR;

    for (let i = currentReviewCount; i < currentReviewCount + maxItems; i++) {
        if (i < EARLY_INTERVALS.length) {
            interval = EARLY_INTERVALS[i];
        } else {
            interval = Math.round(interval * ef);
        }
        interval = Math.min(interval, SM2_PARAMS.MAX_INTERVAL_DAYS);

        timeline.push({
            reviewNumber: i + 1,
            intervalDays: interval,
        });
    }

    return timeline;
}

/**
 * è·å–ä»Šå¤©çš„æ—¶é—´èŒƒå›´ (UTC)
 * 
 * @returns {Object} { startOfDay, endOfDay, timestamp }
 */
function getTodayRange() {
    const now = new Date();
    const startOfDay = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate(),
        0, 0, 0, 0
    ));
    const endOfDay = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate() + 1,
        0, 0, 0, 0
    ));

    return {
        startOfDay: startOfDay.toISOString(),
        endOfDay: endOfDay.toISOString(),
        timestamp: now.toISOString(),
    };
}

/**
 * è·å–ç®—æ³•ä¿¡æ¯ (ç”¨äºå‰ç«¯å±•ç¤º)
 * 
 * @returns {Object} ç®—æ³•å…ƒä¿¡æ¯
 */
function getAlgorithmInfo() {
    return {
        name: 'Optimized SM-2',
        version: '1.1.0',
        earlyIntervals: EARLY_INTERVALS,
        maxInterval: SM2_PARAMS.MAX_INTERVAL_DAYS,
        description: 'åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–çš„é—´éš”é‡å¤ç®—æ³•',
    };
}

module.exports = {
    calculateSM2Optimized,
    generateReviewTimeline,
    getTodayRange,
    getAlgorithmInfo,
    masteryToQuality,
};
</file>

<file path="cloudbase/functions/memory-engine/utils/validators.js">
/**
 * å‚æ•°éªŒè¯æ¨¡å—
 * 
 * ç”¨æˆ·ã€è¯æ±‡éªŒè¯åŠé€šç”¨éªŒè¯å·¥å…·
 */

'use strict';

const { userCollection, vocabularyCollection } = require('./database');
const { MasteryLevel } = require('./constants');

/**
 * éªŒè¯ç”¨æˆ·æ˜¯å¦å­˜åœ¨
 * 
 * @param {string} userId - ç”¨æˆ·ID
 * @returns {Promise<Object|null>} ç”¨æˆ·å¯¹è±¡æˆ– null
 */
async function validateUser(userId) {
    if (!userId || typeof userId !== 'string') {
        return null;
    }

    try {
        const { data } = await userCollection
            .where({ userId })
            .limit(1)
            .get();

        return data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('[validateUser] Error:', error);
        return null;
    }
}

/**
 * éªŒè¯è¯æ±‡æ˜¯å¦å­˜åœ¨
 * 
 * @param {string} vocabularyId - è¯æ±‡ID
 * @returns {Promise<Object|null>} è¯æ±‡å¯¹è±¡æˆ– null
 */
async function validateVocabulary(vocabularyId) {
    if (!vocabularyId || typeof vocabularyId !== 'string') {
        return null;
    }

    try {
        const { data } = await vocabularyCollection
            .where({ vocabularyId })
            .limit(1)
            .get();

        return data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('[validateVocabulary] Error:', error);
        return null;
    }
}

/**
 * éªŒè¯æŒæ¡ç¨‹åº¦æ˜¯å¦æœ‰æ•ˆ
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦
 * @returns {boolean} æ˜¯å¦æœ‰æ•ˆ
 */
function isValidMastery(mastery) {
    const validValues = Object.values(MasteryLevel);
    return validValues.includes(mastery);
}

/**
 * éªŒè¯å¹¶è§„èŒƒåŒ–åˆ†é¡µå‚æ•°
 * 
 * @param {number} limit - é™åˆ¶æ•°é‡
 * @param {number} offset - åç§»é‡
 * @param {number} maxLimit - æœ€å¤§é™åˆ¶ (é»˜è®¤100)
 * @returns {Object} éªŒè¯åçš„åˆ†é¡µå‚æ•°
 */
function validatePagination(limit, offset, maxLimit = 100) {
    return {
        limit: Math.min(Math.max(1, parseInt(limit) || 20), maxLimit),
        offset: Math.max(0, parseInt(offset) || 0),
    };
}

/**
 * éªŒè¯å¿…å¡«å­—ç¬¦ä¸²å‚æ•°
 * 
 * @param {string} value - å‚æ•°å€¼
 * @param {string} name - å‚æ•°å (ç”¨äºé”™è¯¯æ¶ˆæ¯)
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateRequiredString(value, name) {
    if (!value || typeof value !== 'string' || value.trim() === '') {
        return {
            valid: false,
            error: `${name} æ˜¯å¿…å¡«å‚æ•°ä¸”ä¸èƒ½ä¸ºç©º`,
        };
    }
    return { valid: true };
}

/**
 * éªŒè¯å¸ƒå°”å‚æ•°
 * 
 * @param {any} value - å‚æ•°å€¼
 * @param {string} name - å‚æ•°å
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateBoolean(value, name) {
    if (typeof value !== 'boolean') {
        return {
            valid: false,
            error: `${name} å¿…é¡»æ˜¯å¸ƒå°”å€¼`,
        };
    }
    return { valid: true };
}
/**
 * é€šç”¨å‚æ•°éªŒè¯å‡½æ•°
 * 
 * @param {Object} params - éœ€è¦éªŒè¯çš„å‚æ•°å¯¹è±¡
 * @param {Array<string>} requiredFields - å¿…éœ€å­—æ®µåˆ—è¡¨
 * @returns {Object} { isValid: boolean, message?: string }
 */
function validateParams(params, requiredFields) {
    const missing = [];

    for (const field of requiredFields) {
        if (params[field] === undefined || params[field] === null || params[field] === '') {
            missing.push(field);
        }
    }

    if (missing.length > 0) {
        return {
            isValid: false,
            message: `ç¼ºå°‘å¿…å¡«å‚æ•°: ${missing.join(', ')}`
        };
    }

    return { isValid: true };
}

module.exports = {
    validateUser,
    validateVocabulary,
    isValidMastery,
    validatePagination,
    validateRequiredString,
    validateBoolean,
    validateParams,
};
</file>

<file path="cloudbase/functions/memory-engine/package.json">
{
  "name": "memory-engine",
  "version": "1.0.0",
  "description": "Unified Memory Engine Cloud Function",
  "main": "index.js",
  "scripts": {
    "deploy": "tcb fn deploy memory-engine",
    "logs": "tcb fn log memory-engine",
    "test": "tcb fn invoke memory-engine --data '{\"action\":\"checkModuleAccess\",\"data\":{\"userId\":\"test\"}}'"
  },
  "dependencies": {
    "wx-server-sdk": "~2.6.3"
  },
  "author": "Liang JianYu",
  "license": "MIT",
  "engines": {
    "node": "18.20.0"
  }
}
</file>

<file path="cloudbase/test-all-apis.sh">
#!/bin/bash

MEMORY_ENGINE_URL="https://cloud1-1gjcyrdd7ab927c6-1387301748.ap-shanghai.app.tcloudbase.com/memory-engine"
LEARN_VOCAB_URL="https://cloud1-1gjcyrdd7ab927c6-1387301748.ap-shanghai.app.tcloudbase.com/learn-vocab"
USER_ID="u_1764867682959_dwqxjcjoo"

echo "======================================"
echo "Thai Learning App - æ­£ç¡®çš„ API æµ‹è¯•"
echo "======================================"
echo ""

# ============ memory-engine æµ‹è¯• ============
echo "ğŸ“¦ memory-engine äº‘å‡½æ•°æµ‹è¯•"
echo "========================================="
echo ""

echo "1ï¸âƒ£ submitMemoryResult (âœ… æ­£ç¡®ç«¯ç‚¹)"
curl -s -X POST "$MEMORY_ENGINE_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"submitMemoryResult\",
    \"data\": {
      \"userId\": \"$USER_ID\",
      \"results\": [{
        \"entityType\": \"letter\",
        \"entityId\": \"TH_C_02\",
        \"quality\": \"æ¨¡ç³Š\"
      }]
    }
  }" | jq .
echo ""
echo ""

echo "2ï¸âƒ£ getTodayMemories (âœ… æ­£ç¡®ç«¯ç‚¹)"
curl -s -X POST "$MEMORY_ENGINE_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"getTodayMemories\",
    \"data\": {
      \"userId\": \"$USER_ID\",
      \"entityType\": \"letter\",
      \"limit\": 20
    }
  }" | jq .
echo ""
echo ""

# ============ learn-vocab æµ‹è¯• ============
echo "ğŸ“š learn-vocab äº‘å‡½æ•°æµ‹è¯•"
echo "========================================="
echo ""

echo "3ï¸âƒ£ getTodayWords"
curl -s -X POST "$LEARN_VOCAB_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"getTodayWords\",
    \"data\": {
      \"userId\": \"$USER_ID\",
      \"limit\": 20,
      \"offset\": 0
    }
  }" | jq .
echo ""
echo ""

echo "4ï¸âƒ£ getReviewStatistics"
curl -s -X POST "$LEARN_VOCAB_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"getReviewStatistics\",
    \"data\": {
      \"userId\": \"$USER_ID\"
    }
  }" | jq .
echo ""
echo ""

echo "5ï¸âƒ£ getVocabularyList"
curl -s -X POST "$LEARN_VOCAB_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"getVocabularyList\",
    \"data\": {
      \"limit\": 5,
      \"offset\": 0
    }
  }" | jq .
echo ""
echo ""

echo "6ï¸âƒ£ getVocabularyDetail"
curl -s -X POST "$LEARN_VOCAB_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"getVocabularyDetail\",
    \"data\": {
      \"userId\": \"$USER_ID\",
      \"vocabularyId\": \"BEGINNER_A_7\"
    }
  }" | jq .
echo ""
echo ""

echo "7ï¸âƒ£ updateMastery"
curl -s -X POST "$LEARN_VOCAB_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"updateMastery\",
    \"data\": {
      \"userId\": \"$USER_ID\",
      \"vocabularyId\": \"BEGINNER_A_7\",
      \"mastery\": \"è®°å¾—\"
    }
  }" | jq .
echo ""
echo ""

echo "8ï¸âƒ£ toggleSkipWord"
curl -s -X POST "$LEARN_VOCAB_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"toggleSkipWord\",
    \"data\": {
      \"userId\": \"$USER_ID\",
      \"vocabularyId\": \"BEGINNER_A_7\",
      \"skipped\": true
    }
  }" | jq .
echo ""
echo ""

echo "9ï¸âƒ£ getSkippedWords"
curl -s -X POST "$LEARN_VOCAB_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"getSkippedWords\",
    \"data\": {
      \"userId\": \"$USER_ID\",
      \"limit\": 10,
      \"offset\": 0
    }
  }" | jq .
echo ""
echo ""

echo "======================================"
echo "âœ… æµ‹è¯•å®Œæˆ!"
echo "======================================"
</file>

<file path="docs/project-freeze/ai-module-spec.md">
# AI æ¨¡å—è½»é‡è§„æ ¼è¯´æ˜ï¼ˆAI Module Spec, Liteï¼‰

> ç›®å½•ï¼š`docs/project-freeze/ai-module-spec.md`  
> èŒƒå›´ï¼š**AI è¾…åŠ©èƒ½åŠ›è®¾è®¡ï¼Œé¦–å‘ç‰ˆæœ¬ä»¥ Lite / MVP å½¢å¼çœŸæ­£æ¥å…¥æ ¸å¿ƒ 4 ä¸ª Action**ã€‚  
> ç›®æ ‡ï¼šåœ¨ä¸é˜»å¡å½“å‰ 2 ä¸ªæœˆä¸Šçº¿ç›®æ ‡çš„å‰æä¸‹ï¼Œå†»ç»“ AI æ¨¡å—çš„æ¥å£ä¸è¾¹ç•Œï¼Œç¡®ä¿é¦–å‘ç‰ˆæœ¬å…·å¤‡åŸºç¡€ AI èƒ½åŠ›ï¼ŒåŒæ—¶ä¸ºåç»­ç‰ˆæœ¬ä¿ç•™æ‰©å±•ç©ºé—´ã€‚

---

## 1. æ¨¡å—æ¦‚è¿°ä¸å­æ¨¡å—åˆ’åˆ†

AI æ¨¡å—åœ¨é¦–å‘ç‰ˆæœ¬ä¸­åŒ…å«å››ä¸ªå­èƒ½åŠ›ï¼Œå…¨éƒ¨é€šè¿‡ä¸€ä¸ª CloudBase äº‘å‡½æ•°ç»Ÿä¸€æš´éœ²ï¼š

- äº‘å‡½æ•°ï¼š`ai-engine`ï¼ˆåç§°å¯è°ƒæ•´ï¼Œä½†å¿…é¡»å•ä¸€å…¥å£ + å¤š Actionï¼‰ã€‚  
- é¦–å‘å¿…é¡»å®ç°çš„ Action åˆ—è¡¨ï¼š
  1. `analyzePronunciation` â€“ AI å‘éŸ³åé¦ˆå¼•æ“ï¼ˆé¦–å‘å®ç° MVP ç‰ˆï¼Œæä¾›åŸºç¡€æ‰“åˆ†ä¸æ–‡å­—åé¦ˆï¼‰ï¼›  
  2. `generateWeaknessVocabulary` â€“ åŸºäºå¼±é¡¹çš„è¯æ±‡å¼ºåŒ–å»ºè®®ï¼›  
  3. `generateMicroReading` â€“ å¾®é˜…è¯»ææ–™ç”Ÿæˆï¼ˆ1â€“2 å¥çŸ­æ–‡ï¼‰ï¼›  
  4. `explainVocabulary` â€“ è¯æ±‡è§£æä¸è¡¥å……ä¾‹å¥ï¼ˆä»…åšè§£é‡Šå’Œç¤ºä¾‹æ‰©å±•ï¼Œä¸ç›´æ¥ä¿®æ”¹è®°å¿†çŠ¶æ€ï¼‰ã€‚

### 1.1 ä¸å…¶ä»–æ¨¡å—çš„å…³ç³»

- Alphabet / Vocabulary æ¨¡å—ä»æ˜¯**å­¦ä¹ ä¸»è§’**ï¼›AI æ¨¡å—åªæä¾›**é¢å¤–ç»ƒä¹  & åé¦ˆ**ã€‚  
- æ‰€æœ‰è°ƒç”¨éƒ½å¿…é¡»é€šè¿‡å‰ç«¯ `callCloudFunction('ai-engine', { action, data })` å®Œæˆï¼›  
- AI æ¨¡å—ä¸ç›´æ¥ä¿®æ”¹ `memory_status` / `learningStatus`ï¼Œåªè¿”å›å»ºè®®ï¼Œç”±å‰ç«¯é€‰æ‹©æ˜¯å¦è®°å…¥é”™é¢˜æˆ–æç¤ºã€‚

---

## 2. äº‘å‡½æ•°æ¥å£è®¾è®¡ï¼š`ai-engine`

### 2.1 é€šç”¨å…¥å£

```ts
// HTTP / CloudBase å…¥å£è§„èŒƒ
type AiEngineAction =
  | 'analyzePronunciation'
  | 'generateWeaknessVocabulary'
  | 'generateMicroReading'
  | 'explainVocabulary';

interface AiEngineRequest<T = unknown> {
  action: AiEngineAction;
  data: T;
}

interface AiEngineResponse<T = unknown> {
  success: boolean;
  data: T | null;
  message: string;
  errorCode: string | null;
}
```

å‰ç«¯è°ƒç”¨ç¤ºä¾‹ï¼ˆå‘éŸ³åé¦ˆï¼‰ï¼š

```ts
await callCloudFunction<AiEngineResponse<PronunciationFeedback>>('ai-engine', {
  action: 'analyzePronunciation',
  data: { /* AnalyzePronunciationRequest */ },
});
```

å‰ç«¯è°ƒç”¨ç¤ºä¾‹ï¼ˆè¯æ±‡è§£æï¼‰ï¼š

```ts
await callCloudFunction<AiEngineResponse<ExplainVocabularyResponse>>('ai-engine', {
  action: 'explainVocabulary',
  data: { /* ExplainVocabularyRequest */ },
});
```

### 2.2 Action: analyzePronunciationï¼ˆAI å‘éŸ³åé¦ˆï¼‰

**ç”¨é€”ï¼š**  
åœ¨å­—æ¯æ¨¡å—æˆ–è¯æ±‡æ¨¡å—ä¸­ï¼Œç”¨æˆ·æœ—è¯»æŸä¸ªå­—æ¯ / å•è¯ / å¥å­åï¼Œå°†å½•éŸ³ä¸Šä¼ ï¼Œè·å¾— AI ç”Ÿæˆçš„åé¦ˆä¸å»ºè®®ç»ƒä¹ ç‚¹ã€‚

è¯·æ±‚ä½“ï¼ˆåˆç‰ˆï¼‰ï¼š

```ts
interface AnalyzePronunciationRequest {
  userId: string;
  targetType: 'letter' | 'word' | 'sentence';
  targetId: string;              // letterId æˆ– vocabularyId æˆ–è‡ªå®šä¹‰å¥å­ ID
  targetText: string;           // ç›®æ ‡æ–‡æœ¬ï¼ˆæ³°æ–‡ï¼‰
  audioUrl: string;             // å·²ä¸Šä¼ åˆ° COS çš„éŸ³é¢‘ URL / key
  alphabetContext?: {
    // å¯é€‰ï¼šå½“å‰å­—æ¯çš„è¾…éŸ³ç±»åˆ«ã€å£°è°ƒç­‰ä¿¡æ¯ï¼Œä¾¿äº LLM ä½¿ç”¨æœ¯è¯­
    consonantClass?: 'high' | 'mid' | 'low';
    toneMark?: string | null;
  };
}

interface PronunciationFeedback {
  overallScore: number;          // 0â€“100 ç»¼åˆè¯„åˆ†
  level: 'éœ€è¦åŠ å¼º' | 'åˆæ ¼' | 'ä¼˜ç§€';
  issues: Array<{
    type: 'tone' | 'vowel' | 'consonant' | 'rhythm';
    description: string;        // ä¸­æ–‡è§£é‡Šé—®é¢˜
    suggestion: string;         // ä¸­æ–‡ç»ƒä¹ å»ºè®®
  }>;
  syllableBreakdown?: Array<{
    syllable: string;
    tone: string;
    score: number;
  }>;
  recommendedDrills?: string[];  // å»ºè®®é‡å¤ç»ƒä¹ çš„çŸ­è¯æˆ–çŸ­å¥
}
```

è¿”å›ç¤ºä¾‹ï¼ˆç®€åŒ–ï¼‰ï¼š

```json
{
  "success": true,
  "data": {
    "overallScore": 78,
    "level": "åˆæ ¼",
    "issues": [
      {
        "type": "tone",
        "description": "ç¬¬ä¸€ä¸ªéŸ³èŠ‚å£°è°ƒåä½ï¼Œå¬èµ·æ¥æ¥è¿‘äºŒå£°",
        "suggestion": "ç»ƒä¹ ä»ä¸­è¾…éŸ³å¹³è°ƒå‘é«˜è°ƒè¿‡æ¸¡ï¼Œå¯ä»¥å…ˆå¤¸å¼ ä¸€ç‚¹è¯»é«˜"
      }
    ],
    "syllableBreakdown": [
      { "syllable": "à¸à¸°", "tone": "é«˜", "score": 70 },
      { "syllable": "à¸›à¸µ", "tone": "å¹³", "score": 85 }
    ],
    "recommendedDrills": [
      "à¸à¸°à¸›à¸µ",
      "à¸›à¸µà¹ƒà¸«à¸¡à¹ˆ"
    ]
  },
  "message": "åˆ†ææˆåŠŸ",
  "errorCode": null
}
```

### 2.3 Action: generateWeaknessVocabularyï¼ˆå¼±é¡¹è¯æ±‡å¼ºåŒ–ï¼‰

**ç”¨é€”ï¼š**  
åŸºäºç”¨æˆ·åœ¨ `memory_status` / `user_vocabulary_progress` ä¸­çš„é”™è¯¯ç»Ÿè®¡ï¼Œ**ç»“åˆå‰ç«¯ä¼ å…¥çš„æœ¬åœ°é”™é¢˜æœ¬ï¼ˆå¦‚æœ‰ï¼‰**ï¼Œä¸ºè¯æ±‡æ¨¡å—ç”Ÿæˆé¢å¤–ç»ƒä¹ å»ºè®®ï¼ˆä¾‹å¥ã€è®°å¿†æç¤ºç­‰ï¼‰ï¼Œä½†ä¸ç›´æ¥ä¿®æ”¹è®°å¿†é˜Ÿåˆ—ã€‚

è¯·æ±‚ä½“ï¼š

```ts
interface GenerateWeaknessVocabularyRequest {
  userId: string;
  topN?: number;                     // é»˜è®¤ 5

  // å¯é€‰ï¼šå‰ç«¯æœ¬åœ°é”™é¢˜æœ¬ï¼ˆå½“æ—¥ä¼šè¯å†…çš„é”™è¯ï¼‰
  focusVocabularyIds?: string[];     // æ¥è‡ª VocabularySessionState.wrongWordIds
  source?: string;                   // è¯¾ç¨‹æ¥æºï¼Œç”¨äºé™å®šæ•™æèŒƒå›´
}

interface WeakVocabularySuggestion {
  vocabularyId: string;
  thaiWord: string;
  meaning: string;
  currentMastery: 'é™Œç”Ÿ' | 'æ¨¡ç³Š' | 'è®°å¾—';
  aiExamples: Array<{
    scene: string;
    thai: string;
    chinese: string;
  }>;
  mnemonic?: string;                 // AI ç”Ÿæˆè”æƒ³è®°å¿†
}
```

è¿”å›ï¼š

```ts
type GenerateWeaknessVocabularyResponse = WeakVocabularySuggestion[];
```

å‰ç«¯å‘ˆç°æ–¹å¼ï¼ˆå»ºè®®ï¼‰ï¼š

- åœ¨è¯æ±‡æ¨¡å—å®Œæˆé¡µæˆ–â€œAI æ¨èâ€é¡µå±•ç¤ºâ€œä½ çš„è–„å¼±è¯æ±‡ TopNâ€ï¼›  
- ç”¨æˆ·å¯ç‚¹å‡»æŸä¸ªè¯ç›´æ¥è¿›å…¥ NewWordView / å¤ä¹ é¢˜æ¨¡å¼ï¼›  
- è‹¥ä¼ å…¥äº† `focusVocabularyIds`ï¼ŒUI å¯æ ‡è®°â€œæ¥è‡ªæœ¬æ¬¡é”™é¢˜â€çš„è¯æ±‡ã€‚

### 2.4 Action: generateMicroReadingï¼ˆå¾®é˜…è¯»ææ–™ï¼‰

**ç”¨é€”ï¼š**  
æ ¹æ®ç”¨æˆ·çš„å¼±é¡¹è¯æ±‡/å­—æ¯ï¼Œè‡ªåŠ¨ç”Ÿæˆ 1â€“2 å¥çŸ­æ–‡ï¼Œç”¨äº**æœ—è¯» + å‘éŸ³åé¦ˆ**çš„é—­ç¯ç»ƒä¹ ã€‚

è¯·æ±‚ä½“ï¼š

```ts
interface GenerateMicroReadingRequest {
  userId: string;
  focusType: 'letter' | 'word' | 'mixed';
  focusIds?: string[];          // letterId / vocabularyIdï¼ˆå¯ä¸é”™é¢˜åˆ—è¡¨ä¸€è‡´ï¼‰
  length?: 'short' | 'medium';  // 1 å¥æˆ– 2 å¥ï¼Œé»˜è®¤ short

  // å¯é€‰ï¼šæœ¬åœ°é”™é¢˜ä¿¡æ¯ï¼Œä¾¿äº LLM ç²¾å‡†é’ˆå¯¹å¼±é¡¹ç”Ÿæˆå†…å®¹
  wrongLetters?: string[];      // ä»Šæ—¥é”™è¯¯å­—æ¯ ID
  wrongVocabularyIds?: string[];// ä»Šæ—¥é”™è¯¯å•è¯ ID
}

interface MicroReading {
  id: string;
  thaiText: string;
  chineseHint: string;
  highlightWords: string[];     // éœ€è¦ç‰¹åˆ«å…³æ³¨çš„è¯
}
```

è¿”å›ï¼š

```ts
type GenerateMicroReadingResponse = MicroReading;
```

å‰ç«¯æµç¨‹å»ºè®®ï¼š

1. AI é¢æ¿å±•ç¤ºç”Ÿæˆçš„çŸ­æ–‡ï¼›  
2. ç”¨æˆ·ç‚¹å‡»â€œå¼€å§‹æœ—è¯»â€ï¼Œå½•éŸ³å®Œæˆåè‡ªåŠ¨è°ƒç”¨ `analyzePronunciation`ï¼›  
3. å°†åé¦ˆç»“æœä¸åŸæ–‡å¹¶æ’å±•ç¤ºï¼Œå½¢æˆ â€œAI â†’ ç”¨æˆ· â†’ AI â†’ ç”¨æˆ·â€ å¾ªç¯ã€‚

---

## 3. æ–°å¢ Actionï¼šexplainVocabularyï¼ˆåŸºç¡€è¯æ±‡è§£æï¼‰

**ç”¨é€”ï¼š**  
ä¸ºç”¨æˆ·æä¾›æŸä¸ªå•è¯çš„è¯¦ç»†è§£é‡Šå’Œè¡¥å……ä¾‹å¥ï¼Œç”¨äºâ€œçœ‹ä¸å¤ªæ‡‚/è®°ä¸ç‰¢â€æ—¶çš„ä¸€é”®è§£æã€‚åªä½œä¸ºå­¦ä¹ è¾…åŠ©ï¼Œä¸ç›´æ¥æ”¹å˜è®°å¿†ç­–ç•¥ã€‚

è¯·æ±‚ä½“ï¼š

```ts
interface ExplainVocabularyRequest {
  userId: string;
  vocabularyId?: string;   // æ¨èä½¿ç”¨ vocabulary é›†åˆä¸­çš„ _id
  thaiWord?: string;       // å¤‡é€‰ï¼šå½“æ²¡æœ‰ id æ—¶å¯ç›´æ¥ä¼ è¯å½¢
}

interface ExplainVocabularyItem {
  vocabularyId: string;
  thaiWord: string;
  meaning: string;
  breakdown?: string;      // æ‹†è§£/è®°å¿†æç¤º
  extraExamples?: Array<{
    scene?: string;
    thai: string;
    chinese: string;
  }>;
}

type ExplainVocabularyResponse = ExplainVocabularyItem;
```

å‰ç«¯è°ƒç”¨ç¤ºä¾‹ï¼š

```ts
await callCloudFunction<AiEngineResponse<ExplainVocabularyResponse>>('ai-engine', {
  action: 'explainVocabulary',
  data: {
    userId,
    vocabularyId,
  },
}, {
  endpoint: API_ENDPOINTS.AI.ENGINE.cloudbase,
});
```

---

## 4. å‰ç«¯æ¥å…¥çº¦æŸ

### 4.1 ç»Ÿä¸€è°ƒç”¨è·¯å¾„

- æ‰€æœ‰ AI è°ƒç”¨å¿…é¡»é€šè¿‡ç»Ÿä¸€ utilï¼š

```ts
import { callCloudFunction } from '@/src/utils/apiClient';

await callCloudFunction('ai-engine', { action, data }, {
  endpoint: API_ENDPOINTS.AI.ENGINE.cloudbase,
});
```

- ä¸å…è®¸åœ¨ç»„ä»¶ä¸­ç›´æ¥å†™æ­» URL æˆ–ä½¿ç”¨ `fetch`ã€‚

### 4.2 çŠ¶æ€ç®¡ç†

- AI æ¨¡å—ä¸å•ç‹¬å»ºç«‹å¤§å‹ Storeï¼ŒåŸåˆ™ä¸Šä½¿ç”¨ï¼š
  - å±€éƒ¨ç»„ä»¶çŠ¶æ€ï¼ˆå¦‚å½“å‰åé¦ˆç»“æœï¼‰ï¼›  
  - æˆ–åœ¨ `learningStore` ä¸­å¢åŠ è½»é‡å­—æ®µï¼š

```ts
interface AiUsageSnapshot {
  lastPronunciationScore?: number;
  lastMicroReadingId?: string;
  lastExplainVocabularyId?: string;
  totalPronunciationSessions: number;
}
```

### 4.3 ä¸è®°å¿†å¼•æ“çš„å…³ç³»

- AI æ¨¡å—ä¸ç›´æ¥ä¿®æ”¹ `memory_status` / `learningStatus`ï¼›  
- è‹¥éœ€è¦æŠŠ AI ç»ƒä¹ ç»“æœè½¬åŒ–ä¸ºè®°å¿†è´¨é‡ï¼Œå¿…é¡»èµ°ç°æœ‰çš„ `submitMemoryResult` / `updateMastery` æ¥å£ï¼Œç”±å‰ç«¯å†³å®šä»€ä¹ˆæ—¶å€™æäº¤ï¼ˆä¾‹å¦‚ç”¨æˆ·åœ¨ AI ç»ƒä¹ ä¸­è¿ç»­ 3 æ¬¡è¯»å¯¹æŸä¸ªè¯ï¼‰ã€‚

---

## 5. ä»»åŠ¡æ¸…å•ä¸ä¼˜å…ˆçº§ï¼ˆæ›´æ–°åï¼‰

> ä»¥ä¸‹ä»»åŠ¡ä¸­ï¼ŒP0 æ˜¯é¦–å‘ç‰ˆæœ¬å¿…é¡»å®Œæˆçš„èŒƒå›´ï¼›P1 åŠä»¥åå¯ä»¥åœ¨é¦–å‘åè¿­ä»£å¢å¼ºã€‚

### 5.1 P0ï¼šai-engine äº‘å‡½æ•° + å››å¤§ Actionï¼ˆé¦–å‘å¿…åšï¼Œçº¦ 2â€“3 å‘¨ï¼‰

- [ ] åˆ›å»º `cloudbase/functions/ai-engine` äº‘å‡½æ•°éª¨æ¶ï¼Œæ”¯æŒ `action` åˆ†å‘å’Œ `createResponse`ã€‚  
- [ ] åœ¨ `API_ENDPOINTS` ä¸­å¢åŠ  `AI.ENGINE` é…ç½®ã€‚  
- [ ] åœ¨ `utils/apiClient.ts` ä¸­å¢åŠ  `callAiEngine` è½»é‡å°è£…ï¼ˆå¯é€‰ï¼‰ã€‚  
- [ ] å®ç° `generateWeaknessVocabulary`ï¼Œå¹¶åœ¨è¯æ±‡æ¨¡å—å®Œæˆé¡µæä¾›â€œAI å¼ºåŒ–ç»ƒä¹ â€å…¥å£ã€‚  
- [ ] å®ç° `generateMicroReading`ï¼Œå¹¶ä¸ `analyzePronunciation` ç»„åˆæˆä¸€ä¸ªâ€œçŸ­æ–‡æœ—è¯» + AI åé¦ˆâ€çš„é—­ç¯ç»ƒä¹ é¡µé¢ã€‚  
- [ ] å®ç° `explainVocabulary`ï¼Œåœ¨ NewWordView æˆ–è¯æ±‡è¯¦æƒ…é¡µæä¾›â€œä¸€é”® AI è§£é‡Š/ä¾‹å¥è¡¥å……â€å…¥å£ã€‚  
- [ ] å®ç° `analyzePronunciation` çš„ MVPï¼šå½•éŸ³ â†’ ä¸Šä¼  COS â†’ è°ƒç”¨äº‘å‡½æ•° â†’ è¿”å›åŸºç¡€è¯„åˆ†å’Œæ–‡å­—åé¦ˆï¼Œå¹¶åœ¨å­—æ¯/è¯æ±‡æ¨¡å—ä¸­å„æ¥å…¥ä¸€ä¸ªå…¥å£åœºæ™¯ã€‚

### 5.2 P1ï¼šæ•ˆæœä¼˜åŒ–ä¸é«˜çº§èƒ½åŠ›ï¼ˆé¦–å‘åè¿­ä»£ï¼Œçº¦ 2â€“3 å‘¨ï¼‰

- [ ] åŸºäºçœŸå®ç”¨æˆ·æ•°æ®è¿­ä»£å‘éŸ³è¯„åˆ†é˜ˆå€¼å’Œåé¦ˆæ–‡æ¡ˆã€‚  
- [ ] åœ¨ AI æ¨¡å—å†…å®ç°æ›´æ™ºèƒ½çš„é¢˜ç›®æ¨èç­–ç•¥ï¼Œä¸é”™é¢˜æœ¬å’Œ memory-engine æ›´ç´§å¯†ç»“åˆã€‚  
- [ ] æ‰©å±• `generateMicroReading` æ”¯æŒæ›´ä¸°å¯Œçš„æ–‡æœ¬ä½“è£ä¸é•¿åº¦é…ç½®ã€‚  
- [ ] å®ç° `generateMicroReading`ï¼Œå¹¶ä¸ `analyzePronunciation` ç»„åˆæˆä¸€ä¸ªé—­ç¯ç»ƒä¹ é¡µé¢ã€‚  
- [ ] å°† AI ç»ƒä¹ ç»“æœåŒæ­¥åˆ° `learningStore` ä½œä¸ºç»Ÿè®¡ä¿¡æ¯ã€‚

---

æœ¬è½»é‡è§„æ ¼æ–‡æ¡£åªå†»ç»“ AI æ¨¡å—çš„**è¾¹ç•Œã€Action åç§°ä¸å…¸å‹æ•°æ®ç»“æ„**ï¼Œå®ç°ç»†èŠ‚ï¼ˆå…·ä½“æ¨¡å‹ã€æç¤ºè¯ã€è¯„åˆ†ç®—æ³•ï¼‰å¯åœ¨åç»­è¿­ä»£ä¸­é€æ­¥å®Œå–„ã€‚  
é¦–å‘ç‰ˆæœ¬å¯ä»¥å®Œå…¨ä¸æ¥å…¥ AI åŠŸèƒ½ï¼Œè€Œä¸ä¼šå½±å“ Alphabet / Vocabulary æ¨¡å—çš„æ ¸å¿ƒæµç¨‹ã€‚***
</file>

<file path="docs/project-freeze/alphabet-module-spec.md">
# æ³°è¯­å­—æ¯æ¨¡å—æœ€ç»ˆè§„æ ¼è¯´æ˜ï¼ˆAlphabet Module Spec, Final v3.0ï¼‰

> **çŠ¶æ€**: Frozenï¼ˆå†»ç»“ï¼‰  
> **ç‰ˆæœ¬**: v3.0  
> **æœ€åæ›´æ–°**: 2026-01-05  
> **ç›®å½•**: `docs/project-freeze/alphabet-module-spec.md`  
> **é€‚ç”¨èŒƒå›´**: Alphabet æ¨¡å—å…¨éƒ¨ä»£ç ï¼ˆå‰ç«¯ + åç«¯ memory-engineï¼‰  
> **æƒå¨æ€§å£°æ˜**: æœ¬æ–‡ä»¶æ˜¯ Alphabet æ¨¡å—çš„**å”¯ä¸€æƒå¨è§„èŒƒ**ï¼Œä¼˜å…ˆäºæ‰€æœ‰å†å²ä»£ç ã€å†å²æ–‡æ¡£ã€AI å»ºè®®  
> **ä¿®è®¢æ‘˜è¦**: v3.0 åˆå¹¶äº† FINAL_FACTSã€IMPLEMENTATION_SKELETONã€P0ä¿®å¤è§„èŒƒï¼Œè½åœ° lesson-scoped roundã€completedLessons æƒå¨æ¥æºã€å››æ®µé˜Ÿåˆ—ç»“æ„ã€isNew è¯­ä¹‰è¾¹ç•Œç­‰æœ€ç»ˆè§„åˆ™  
> **ç›®æ ‡**: è®©ä»»ä½•å¼€å‘è€…åœ¨ä¸é€šè¯»å…¨éƒ¨ä»£ç çš„å‰æä¸‹ï¼Œä»…å‡­æœ¬è§„æ ¼ + ç›¸å…³ç±»å‹å®šä¹‰ï¼Œå³å¯å®ç° / é‡æ„ / æ‰©å±•å­—æ¯æ¨¡å—çš„æ‰€æœ‰åŠŸèƒ½ï¼Œè€Œä¸ä¼šç ´åå…¨å±€æ¶æ„

---

## 0. é¦–å‘ç‰ˆå†»ç»“å£°æ˜ï¼ˆå½“å‰çœŸå®å®ç°ï¼‰

> ç¦æ­¢åœ¨æ­¤é˜¶æ®µåˆå¹¶é¢˜å‹ä½“ç³» / é‡æ„ Phase / å•è¾¹åˆ é™¤é˜Ÿåˆ—æ’å…¥é€»è¾‘ã€‚

- å•ä¸€æƒå¨ï¼ˆSource of Truthï¼‰
  - è¯¾ç¨‹å­—æ¯ï¼šDB `letters.curriculumLessonIds` + `getTodayMemories` (handlers/getTodayMemories.js 167-184)ï¼›å‰åç«¯ `lessonMetadata` ä»…å±•ç¤º/å›é€€ï¼Œä¸” **lesson1 å…ƒéŸ³å­˜åœ¨ä¸ä¸€è‡´**ï¼ˆå‰ç«¯ ['à¸²','à¸µ','à¸¹']ï¼Œåç«¯ ['à¸²','à¸°','à¸´']ï¼‰ã€‚
  - é˜Ÿåˆ—ç”Ÿæˆï¼šåç«¯ `getTodayMemories` å…ˆå–å¤ä¹ ï¼ˆä¸æŒ‰ lesson è¿‡æ»¤ï¼Œå­˜åœ¨è·¨è¯¾æ··å…¥é£é™©ï¼‰+ 3æ–°1å¤æ’å…¥ï¼Œç„¶åå‰ç«¯ `buildAlphabetQueue` å†åš mini-review(æ¯3ä¸ªæ–°å­—æ¯å›æ”¾) + final-review å…¨é‡ + error-review è¿½åŠ ã€‚
  - é¢˜å‹ï¼šå®é™…æ¸²æŸ“ä½¿ç”¨ `AlphabetGameType` + `lettersQuestionGenerator`ï¼ˆSOUND_TO_LETTER / LETTER_TO_SOUND / CONSONANT_CLASS / INITIAL_SOUND / FINAL_SOUNDï¼›TONE_CALCULATION/PHONICS_MATH ä»ä¸ºå ä½ï¼‰ã€‚`QuestionType` / `alphabetQuestionTypes` / `alphabetQuestionGenerator` ä¸ºå†å²å®šä¹‰ï¼Œæœªåœ¨é¦–å‘ç‰ˆç”Ÿæ•ˆã€‚
  - Phaseï¼šUI/é€»è¾‘ä»¥ `queue.source`ï¼ˆnew/mini-review/final-review/error-reviewï¼‰æ´¾ç”Ÿï¼Œ`LearningPhase` æšä¸¾çš„ 7 é˜¶æ®µæœªè¢«å½“å‰å®ç°é©±åŠ¨ã€‚

- å·²çŸ¥åå·®ï¼ˆéœ€åç»­æ²»ç†ï¼Œå½“å‰ä¸æ”¹ä»£ç ï¼‰
  - è¯¾ç¨‹å…ƒæ•°æ®å‰åç«¯ä¸ä¸€è‡´ï¼›`SEQUENCE_LESSONS` ä¸è¯¾ç¨‹åˆ—è¡¨æ•°é‡ä¸å¯¹é½ã€‚
  - å¤ä¹ æ± ä¸æŒ‰ lesson è¿‡æ»¤ï¼Œå¯èƒ½å°†å…¶ä»–è¯¾åˆ°æœŸå­—æ¯æ··å…¥æœ¬è¯¾é˜Ÿåˆ—ã€‚
  - åŒå±‚ 3æ–°1å¤æ’å…¥å¯¼è‡´èŠ‚å¥ä¸å†»ç»“è®¾è®¡ä¸å®Œå…¨ä¸€è‡´ã€‚
  - å¤šå¥—é¢˜å‹/Phase å®šä¹‰å¹¶å­˜ï¼Œå¯èƒ½å¯¼è‡´æ–°ä»£ç è¯¯ç”¨å†å²æ¥å£ã€‚

- æ–‡æ¡£ä½¿ç”¨æç¤º
  - æœ¬èŠ‚æè¿°çš„æ˜¯â€œé¦–å‘ç‰ˆç°çŠ¶â€ï¼Œä½œä¸ºå†»ç»“è®°å½•ï¼›åç»­è¿­ä»£éœ€åœ¨æ˜ç¡®æ²»ç†è®¡åˆ’åå†è°ƒæ•´æƒå¨å®šä¹‰ã€‚

## 1. æ¨¡å—å®šä½ä¸è¾¹ç•Œ

### 1.1 æ¨¡å—èŒè´£

å­—æ¯æ¨¡å—ï¼ˆAlphabet Moduleï¼‰è´Ÿè´£ï¼š

- æä¾›ä¸€å¥— **å¾ªåºæ¸è¿›çš„æ³°è¯­å­—æ¯è¯¾ç¨‹**ï¼ˆå½“å‰ä¸º Lesson1~7ï¼‰ï¼›  
- é€šè¿‡ memory-engine çš„ç»Ÿä¸€è®°å¿†é˜Ÿåˆ—ï¼Œå®ç°ï¼š
  - æ˜¨æ—¥å¤ä¹  â†’ ä»Šæ—¥å­¦ä¹  â†’ å°å¤ä¹ ï¼ˆMini Reviewï¼‰â†’ æœ«å°¾å¤ä¹ ï¼ˆFinal Reviewï¼‰â†’ ä»Šæ—¥è¡¥æ•‘ï¼ˆToday Remedyï¼‰â†’ ä¸‰è½®è¯„ä¼°ï¼ˆRound Evaluationï¼‰ï¼›
  - å°†æ¯ä¸ªå­—æ¯çš„è®°å¿†æƒ…å†µå†™å…¥ `memory_status`ï¼Œå¹¶å°†æ¯è¯¾ä¸‰è½®ç»Ÿè®¡å†™å…¥ `user_alphabet_progress`ï¼›
- æä¾›é¢˜å‹é©±åŠ¨çš„å­¦ä¹ ä½“éªŒï¼ˆå½“å‰ç”± `lettersQuestionGenerator` æä¾›å¤šç§é¢˜å‹ï¼Œæœªæ¥ç”± 6 å¤§é¢˜å‹åè®®æ¥ç®¡ï¼‰ã€‚

### 1.2 æ¨¡å—è¾¹ç•Œï¼ˆä¸å…¶ä»–æ¨¡å—çš„å…³ç³»ï¼‰

- **å­—æ¯æ¨¡å—ä½¿ç”¨çš„å…±äº«è®¾æ–½ï¼š**
  - ç»Ÿä¸€è®°å¿†å¼•æ“ï¼š`cloudbase/functions/memory-engine`
  - å…¨å±€è¿›åº¦ / è§£é”ï¼š`moduleAccessStore` + memory-engine handlers
  - å…¨å±€è¯¾ç¨‹å…¥å£ï¼šCourses é¡µ + `learningStore`ï¼ˆå½“å‰å­¦ä¹ çš„ä¸»è¯¾ç¨‹ / å­—æ¯å¤§è¯¾ç¨‹ï¼‰
  - è¯¾ç¨‹å…ƒæ•°æ®ï¼š`alphabet_lessons` + `phonics_rules`ï¼ˆDBï¼‰ + `lessonMetadata.config.ts`ï¼ˆå‰ç«¯å›é€€ï¼‰
  - å­—æ¯å®ä½“æ•°æ®ï¼š`letters` é›†åˆï¼ˆæ¥æºäº `assets/courses/letters_final.enriched.json`ï¼‰

- **å­—æ¯æ¨¡å—ä¸åšçš„äº‹æƒ…ï¼š**
  - ä¸ç›´æ¥æ“ä½œ `memory_status` / `user_*_progress`ï¼ˆå…¨éƒ¨äº¤ç»™ memory-engine handlersï¼‰ï¼›
  - ä¸åœ¨ç»„ä»¶ä¸­ç›´æ¥æ‹¼æ¥äº‘å‡½æ•° URLï¼ˆç»Ÿä¸€é€šè¿‡ `callCloudFunction`ï¼‰ï¼›
  - ä¸å®šä¹‰ç”¨æˆ·è®¤è¯ / ä¸»è¯¾ç¨‹é€‰æ‹©ï¼ˆç”± Auth æ¨¡å— + Courses æ¨¡å—å¤„ç†ï¼‰ã€‚

---

## 2. ç›¸å…³ä»£ç æ–‡ä»¶æ€»è§ˆï¼ˆâ€œç±»å›¾è§†è§’â€ï¼‰

æœ¬èŠ‚åˆ—å‡ºå­—æ¯æ¨¡å—æ¶‰åŠçš„æ‰€æœ‰å…³é”®æ–‡ä»¶å’Œå…¶èŒè´£ï¼Œç±»ä¼¼â€œç±»å›¾ + åŒ…å›¾â€çš„æ–‡å­—ç‰ˆæœ¬ã€‚

### 2.1 å‰ç«¯è·¯ç”±å±‚ï¼ˆapp/ï¼‰

- `app/(tabs)/courses.tsx`
  - èŒè´£ï¼š
    - å±•ç¤ºå…¨éƒ¨è¯¾ç¨‹ï¼ˆåŸºç¡€æ³°è¯­ 1~4 + å­—æ¯é¡¹ç›®ç­‰ï¼‰ï¼›
    - å­—æ¯å…¥å£ä½¿ç”¨ `AlphabetCourseCard` æ¸²æŸ“ï¼›
    - ç‚¹å‡»å­—æ¯å¡ç‰‡æ—¶å¯¼èˆªåˆ° `app/alphabet/index.tsx`ã€‚
  - ä¸å­—æ¯æ¨¡å—çš„å…³ç³»ï¼š
    - åªä½œä¸ºâ€œå…¥å£è§¦å‘å™¨â€ï¼Œæœ¬èº«ä¸åŒ…å«å­—æ¯é€»è¾‘ã€‚

- `app/alphabet/index.tsx`ï¼ˆå½“å‰ï¼š**å­—æ¯è¯¾ç¨‹æ€»è§ˆé¡µï¼Œå°è¯¾ç¨‹åˆ—è¡¨**ï¼‰
  - èŒè´£ï¼š
    - å±•ç¤ºå½“å‰å­—æ¯è¯¾ç¨‹åˆ—è¡¨ï¼ˆLesson1~7ï¼‰ï¼›
    - è®¡ç®—æ•´ä½“å®Œæˆåº¦ï¼ˆä½¿ç”¨ `useAlphabetStore` çš„ `completedCount` / `totalCount`ï¼‰ï¼›
    - ä»åç«¯æ‹‰å–è¯¾ç¨‹å…ƒæ•°æ®ï¼ˆ`getAlphabetLessons`ï¼‰æˆ–å›é€€åˆ°å‰ç«¯ `lessonMetadata.config.ts`ï¼›
    - æŒ‰â€œç´¯è®¡å·²å®Œæˆå­—æ¯æ•°â€å†³å®šè¯¾ç¨‹è§£é”ä¸â€œå½“å‰è¯¾ç¨‹â€çŠ¶æ€ï¼›
    - ç‚¹å‡»â€œå¼€å§‹å­¦ä¹ â€æŒ‰é’®æ—¶è·³è½¬åˆ° `/alphabet/[lessonId]`ã€‚
  - æœªæ¥è§„åˆ’ï¼š
    - å¯ä»¥æ¼”åŒ–ä¸ºâ€œå¤§è¯¾ç¨‹å…¥å£é¡µ + å°è¯¾ç¨‹åˆ—è¡¨é¡µâ€çš„ç»„åˆï¼Œç›®å‰ä»ä½œä¸ºâ€œå°è¯¾ç¨‹åˆ—è¡¨é¡µâ€ä½¿ç”¨ã€‚

- `app/alphabet/[lessonId].tsx`
  - èŒè´£ï¼š
    - ä»è·¯ç”±å‚æ•°è·å– `lessonId`ï¼›
    - è°ƒç”¨ `useAlphabetLearningEngine(lessonId)` åˆå§‹åŒ–å­¦ä¹ å¼•æ“ï¼›
    - å°† Hook è¿”å›çš„çŠ¶æ€ä¸å›è°ƒå…¨éƒ¨ä¼ å…¥ `AlphabetLearningEngineView`ï¼›
    - å¤„ç†â€œè¿”å›â€å¯¼èˆªï¼ˆ`router.back()`ï¼‰ã€‚

### 2.2 å­—æ¯æ¨¡å—è°ƒç”¨æ ˆæ¦‚è§ˆ

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ React Native Screens / Components           â”‚
â”‚ app/(tabs)/courses.tsx                      â”‚
â”‚ app/alphabet/*                              â”‚
â”‚ src/components/learning/alphabet/*          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â”‚ é€šè¿‡ props / äº‹ä»¶è°ƒç”¨
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ä¸šåŠ¡ Hooks                                   â”‚
â”‚ src/hooks/useAlphabetLearningEngine.ts       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â”‚ è°ƒç”¨ Zustand Store
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Zustand Stores                              â”‚
â”‚ src/stores/alphabetStore.ts                 â”‚
â”‚ src/stores/moduleAccessStore.ts             â”‚
â”‚ src/stores/userStore.ts                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â”‚ ä½¿ç”¨ apiClient / callCloudFunction
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ apiClient / callCloudFunction               â”‚
â”‚ src/utils/apiClient.ts                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â”‚ HTTP è°ƒç”¨ CloudBase HTTP è§¦å‘å™¨
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CloudBase Functions                         â”‚
â”‚ cloudbase/functions/memory-engine           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â”‚ é€šè¿‡ wx-server-sdk è®¿é—® DB
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CloudBase DB                                â”‚
â”‚ letters, alphabet_lessons, phonics_rules    â”‚
â”‚ memory_status, user_alphabet_progress       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 å‰ç«¯ç»„ä»¶å±‚ï¼ˆsrc/components/learning/alphabetï¼‰

- `AlphabetLearningEngineView.tsx`
  - èŒè´£ï¼š
    - **å­—æ¯å­¦ä¹  UI å®¹å™¨**ï¼šå°è¯¾å†…æ‰€æœ‰ Phase çš„ç»Ÿä¸€æ¸²æŸ“å…¥å£ï¼›
    - æŒ‰ `phase` å†³å®šæ¸²æŸ“å“ªç§å­è§†å›¾ï¼š
      - æ˜¨æ—¥å¤ä¹  / æ˜¨æ—¥è¡¥æ•‘ / Final Review / Today Remedy â†’ `AlphabetReviewView`
      - Mini Review â†’ `MiniReviewQuestionComponent`ï¼ˆmini é¢˜å‹ç»„ä»¶ï¼‰
      - ä»Šæ—¥å­¦ä¹  â†’ `PhonicsRuleCard` æˆ– `AlphabetLearningView`
      - å®Œæˆ â†’ æˆç»©æ±‡æ€»è§†å›¾ï¼ˆå±•ç¤ºä¸‰è½®è¯„ä¼°ç»“æœï¼‰
    - ä¸ç›´æ¥è°ƒç”¨ Store æˆ– cloud functionï¼Œæ‰€æœ‰ä¸šåŠ¡è¡Œä¸ºé€šè¿‡ props å›è°ƒä¸Šæµ®ç»™ Hookã€‚

- `AlphabetLearningView.tsx`
  - èŒè´£ï¼š
    - â€œæ•™å­¦å¡â€è§†å›¾ï¼šå±•ç¤ºå•ä¸ªå­—æ¯çš„è¯¦ç»†ä¿¡æ¯ï¼ˆå­—å½¢ã€ç½—é©¬éŸ³ã€éŸ³èŠ‚ã€ä¾‹è¯ã€é”®ç›˜é”®ç­‰ï¼‰å¹¶æ”¯æŒæ’­æ”¾å‘éŸ³ï¼›
    -ä½¿ç”¨ `AlphabetLearningState` ä½œä¸ºè¾“å…¥ï¼Œå†…éƒ¨ä» `letter` å­—æ®µä¸­æ‹†å‡ºéœ€è¦å±•ç¤ºçš„å„ç§å±æ€§ï¼›
    - åˆ©ç”¨ Expo AV æ’­æ”¾æœ¬åœ°éŸ³é¢‘ï¼š
      - ä¼˜å…ˆä½¿ç”¨ `letter.fullSoundLocalPath / syllableSoundLocalPath / letterPronunciationLocalPath`ï¼›
      - å›é€€æ—¶å¯ä½¿ç”¨ `alphabet.audioUrl`ï¼ˆç”± Store é¢„ä¸‹è½½å¡«å……ï¼‰ã€‚

- `AlphabetReviewView.tsx`
  - èŒè´£ï¼š
    - â€œå¤ä¹ é¢˜ç›®è§†å›¾â€ï¼šé’ˆå¯¹å½“å‰å­—æ¯ç”Ÿæˆä¸€é“é¢˜ç›®å¹¶å±•ç¤ºï¼›
    - ä½¿ç”¨ `generateAlphabetQuestion(letter, pool, preferredType)` ç”Ÿæˆé¢˜ç›®ï¼›
    - æ¸²æŸ“å¤šç§â€œåŸºç¡€é¢˜å‹â€ï¼ˆå¬éŸ³é€‰å­—ã€çœ‹å­—é€‰éŸ³ã€syllable æ‹¼è¯»ç­‰ï¼‰ï¼›
    - åœ¨ç”¨æˆ·ç­”é¢˜åè°ƒç”¨ `onAnswer(isCorrect)`ï¼Œå†æ ¹æ®éœ€è¦è°ƒç”¨ `onNext()` / `onBack()`ã€‚

> æ³¨æ„ï¼šå½“å‰ `AlphabetReviewView`+`lettersQuestionGenerator` æä¾›çš„æ˜¯â€œæ—§ç‰ˆé¢˜å‹ç³»ç»Ÿâ€ï¼Œ  
> æœªæ¥ä¼šè¢« `docs/project-freeze/DESIGN_SPEC.md` ä¸­å®šä¹‰çš„ 6 å¤§é¢˜å‹åè®®å’Œ Question Engine æ¸è¿›æ›¿æ¢ã€‚

### 2.3 Hooks å±‚ï¼ˆsrc/hooksï¼‰

- `useAlphabetLearningEngine.ts`
  - èŒè´£ï¼š
    - **è¯¾ç¨‹çº§å­¦ä¹ å¼•æ“**ï¼Œå³ä½ è®¾è®¡çš„ 8 Phase + 3 è½®è¯„ä¼°é€»è¾‘çš„å‰ç«¯å®ç°ï¼›
    - å…³é”®èŒè´£æ‹†åˆ†ï¼š
      1) åˆå§‹åŒ–å½“å‰ Lesson çš„ä¼šè¯çŠ¶æ€ï¼šè°ƒç”¨ `alphabetStore.initializeSession(userId, { lessonId })`ï¼›
      2) ç®¡ç† Phase çŠ¶æ€æœºï¼š
         - `phase: 'yesterday-review' | 'yesterday-remedy' | 'today-learning' | 'today-mini-review' | 'today-final-review' | 'today-remedy' | 'finished'` ç­‰ï¼›
         - å†³å®šä½•æ—¶è§¦å‘ Mini Reviewã€Final Reviewã€Today Remedyã€ä¸‰è½®è¯„ä¼°ï¼›
      3) å¤„ç†ç­”é¢˜é€»è¾‘ï¼š
         - å°† UI çš„ isCorrect æ˜ å°„åˆ° `alphabetStore.submitResult(userId, isCorrect)`ï¼›
         - ç»´æŠ¤é”™é¢˜é›†åˆ `wrongAnswers`ï¼Œä¾› Round Evaluation ä½¿ç”¨ï¼›
      4) ç®¡ç†ä¸‰è½®è¯„ä¼°ï¼š
         - `currentRound: 1 | 2 | 3`ï¼›
         - `roundEvaluation` è®°å½•æ¯è½®æ­£ç¡®ç‡ä¸æ˜¯å¦é€šè¿‡ï¼›
         - å½“ä¸‰è½®å®Œæˆä¸”é€šè¿‡æ—¶ï¼Œè°ƒç”¨ `markAlphabetLessonCompleted(lessonId)`ï¼ˆæ¥è‡ª `moduleAccessStore`ï¼‰ã€‚
    - å¯¹å¤–æš´éœ²ï¼š
      - `initialized`ï¼šæ˜¯å¦å®Œæˆåˆå§‹åŒ–ï¼›
      - `phase` / `currentRound` / `roundEvaluation`ï¼›
      - `currentItem: AlphabetLearningState | null`ï¼›
      - `currentQuestionType`ï¼ˆå¤ä¹ é¢˜å‹åå¥½ï¼‰ï¼›
      - `letterPool: Letter[]`ï¼ˆä»Šæ—¥æ¶‰åŠçš„æ‰€æœ‰å­—æ¯ï¼Œä¾›é¢˜å‹å¼•æ“ä½¿ç”¨ï¼‰ï¼›
      - å›è°ƒï¼š
        - `onAnswer(isCorrect, questionType)`ï¼›
        - `onNext()`ï¼›
        - `onSkipYesterdayReview()`ï¼›
        - `onCompletePhonicsRule()`ï¼›
        - `onMiniReviewAnswer()` / `onMiniReviewNext()`ã€‚

- `useModuleAccess.ts`
  - ä¸å­—æ¯æ¨¡å—å…³ç³»ï¼š
    - æä¾› `markAlphabetLessonCompleted(lessonId)` ç»™ `useAlphabetLearningEngine` ä½¿ç”¨ï¼›
    - å®é™…å†™å…¥ `user_alphabet_progress` / `user_progress` ç›¸å…³å­—æ®µçš„èŒè´£åœ¨åç«¯ memory-engine + learn-vocabã€‚

### 2.4 Store å±‚ï¼ˆsrc/storesï¼‰

- `alphabetStore.ts`
  - å·²åœ¨ snapshot æ–‡æ¡£ä¸­æœ‰è¯¦ç»†ä»‹ç»ï¼Œè¿™é‡Œèšç„¦ä¸å­—æ¯æ¨¡å—çš„è¿æ¥ç‚¹ï¼š
  - æ ¸å¿ƒçŠ¶æ€ï¼ˆèŠ‚é€‰ï¼‰ï¼š
    - `queue: AlphabetLearningState[]`ï¼šæœ¬æ¬¡ä¼šè¯çš„å­—æ¯é˜Ÿåˆ—ï¼›
    - `currentIndex: number` / `currentItem: AlphabetLearningState | null`ï¼›
    - `completedCount: number` / `totalCount: number`ï¼šæœ¬è®¾å¤‡ä¸Šå·²å®Œæˆå­—æ¯æ•°é‡å’Œæ€»æ•°ï¼ˆç”¨äºè¯¾ç¨‹è§£é”ï¼‰ï¼›
    - `lessonMetadata: LessonMetadata | null`ï¼šå½“å‰ Lesson çš„å…ƒæ•°æ®ï¼›
    - `phonicsRule: PhonicsRule | null`ï¼šå½“å‰ Lesson çš„æ‹¼è¯»è§„åˆ™ï¼›
    - `cachedAudioKeys: string[]`ï¼šå·²é¢„ä¸‹è½½éŸ³é¢‘çš„ key åˆ—è¡¨ï¼›
    - `phase: LearningPhase`ï¼šä¼šè¯çº§åˆ«ï¼ˆIDLE/COMPLETED ç­‰ï¼‰ã€‚
  - å…³é”®æ–¹æ³•ï¼š
    - `initializeSession(userId, { limit?, lessonId? })`
      - è°ƒç”¨ `callCloudFunction('getTodayMemories', { userId, entityType: 'letter', limit, includeNew: true, lessonId }, { endpoint: API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase })`ï¼›
      - å°†è¿”å›çš„ `items` æ˜ å°„ä¸º `AlphabetLearningState` é˜Ÿåˆ—ï¼›
      - è®¾ç½® `lessonMetadata` / `phonicsRule`ï¼›
      - å¯åŠ¨é¢„ä¸‹è½½ä»»åŠ¡ï¼Œå°† COS éŸ³é¢‘ä¸‹è½½åˆ°æœ¬åœ°å¹¶æ›´æ–° `letter.*LocalPath` å’Œ `audioUrl`ã€‚
    - `submitResult(userId, isCorrect)`
      - å°† `isCorrect` æ˜ å°„ä¸º `QualityButton.KNOW | QualityButton.FORGET`ï¼›
      - è°ƒç”¨ `callCloudFunction('submitMemoryResult', { userId, entityType: 'letter', entityId: currentItem.alphabetId, quality }, { endpoint: API_ENDPOINTS.MEMORY.SUBMIT_MEMORY_RESULT.cloudbase })`ï¼›
      - æ›´æ–°æœ¬åœ° `currentAttempts` / `qualityHistory` / `isCompleted`ï¼›
      - è°ƒç”¨ `next()` è‡ªåŠ¨è¿›å…¥ä¸‹ä¸€é¢˜æˆ–æ ‡è®° `phase=COMPLETED`ã€‚
    - `submitRoundEvaluation(params)`
      - è°ƒç”¨ `callCloudFunction('submitRoundEvaluation', { userId, entityType: 'letter', lessonId, roundNumber, totalQuestions, correctCount, accuracy }, { endpoint: API_ENDPOINTS.MEMORY.SUBMIT_ROUND_EVALUATION.cloudbase })`ï¼›
      - ä¸æ”¹å˜è®°å¿†é˜Ÿåˆ—ï¼Œåªåšç»Ÿè®¡å†™å…¥ã€‚

### 2.5 é…ç½® / ç±»å‹ / å·¥å…·å±‚

- `src/config/alphabet/lessonMetadata.config.ts`
  - å‰ç«¯ç‰ˆè¯¾ç¨‹å…ƒæ•°æ®ï¼ˆLesson1~7ï¼‰ï¼š
    - `LESSON_METADATA: Record<string, LessonMetadata>`ï¼›
    - `LessonMetadata` å®šä¹‰ï¼ˆæ¥è‡ª `phonicsRule.types.ts`ï¼‰åŒ…æ‹¬ï¼š
      - lessonId, title, description, consonants[], vowels[], tones[];
      - phonicsRuleId, totalCount, minPassRate, miniReviewInterval, orderã€‚
  - æä¾›è¾…åŠ©å‡½æ•°ï¼š
    - `getLessonMetadata(lessonId)`ï¼šæŒ‰ id è·å–ï¼›
    - `getAllLessons()`ï¼šæŒ‰ order æ’åºè¿”å›æ‰€æœ‰è¯¾ç¨‹ï¼›
    - `getLessonByLetter(thaiChar)`ï¼šé€šè¿‡å­—æ¯åæŸ¥è¯¾ç¨‹ã€‚

- `src/entities/types/alphabet.types.ts`
  - å®šä¹‰ä¸å­—æ¯æ¨¡å—ç›¸å…³çš„ TypeScript ç±»å‹ï¼š
    - `AlphabetLearningState`ï¼šä¸ `alphabetStore` ä¸­åŒåç±»å‹ç›¸å¯¹åº”ï¼›
    - `AlphabetTest`, `AlphabetTestQuestion`, `AlphabetTestResult`ï¼šç”¨äºå•ç‹¬å­—æ¯æµ‹è¯•åŠŸèƒ½ï¼ˆé 3-Round ä¸»æµï¼‰ã€‚

- `src/entities/enums/LearningPhase.enum.ts`
  - å®šä¹‰å…¨å±€å­¦ä¹ é˜¶æ®µæšä¸¾ `LearningPhase`ï¼Œå­—æ¯æ¨¡å—ä½¿ç”¨å…¶ä¸­çš„ IDLE / COMPLETED ç­‰çŠ¶æ€ã€‚

- `src/utils/lettersQuestionGenerator.ts`
  - èŒè´£ï¼š
    - é’ˆå¯¹å•ä¸ª `Letter` + å­—æ¯æ±  `pool` ç”Ÿæˆå¤ä¹ é¢˜ç›®ï¼›
    - é¢˜å‹ `QuestionType` åŒ…æ‹¬ï¼šSOUND_TO_LETTERã€LETTER_TO_SOUNDã€SYLLABLEã€REVERSE_SYLLABLEã€MISSING_LETTERã€FINAL_CONSONANTã€CLASS_CHOICEã€LETTER_NAME ç­‰ï¼›
    - ç”Ÿæˆç»“æ„ï¼š
      - `AlphabetQuestion`ï¼šåŒ…å« `type`, `stem`, `options`, `correct`, `audioUrl`ï¼›
    - ä½¿ç”¨ `getLetterAudioUrl(letter, 'letter' | 'syllable')` å†³å®šæ’­æ”¾å“ªä¸ªéŸ³é¢‘ã€‚
  - å½“å‰ä½œç”¨ï¼š
    - è¢« `AlphabetReviewView` ä½¿ç”¨ï¼Œä½œä¸ºâ€œåŸºç¡€é¢˜å‹â€ç”Ÿæˆå™¨ï¼›
    - åœ¨æœªæ¥ä¼šä¸ `project-freeze/DESIGN_SPEC.md` ä¸­çš„ 6 å¤§é¢˜å‹æ•´åˆã€‚

### 2.6 åç«¯ memory-engineï¼ˆcloudbase/functions/memory-engineï¼‰

- `index.js`
  - èŒè´£ï¼š
    - CloudBase äº‘å‡½æ•°å…¥å£ï¼›
    - è§£æ HTTP è¯·æ±‚ bodyï¼ŒæŠ½å– `{ action, data }`ï¼›
    - æ ¹æ® action åˆ†å‘è‡³ï¼š
      - `getTodayMemories`, `submitMemoryResult`, `submitRoundEvaluation`, `checkModuleAccess`, `getUserProgress`, `getAlphabetLessons` ç­‰ã€‚

- `handlers/getTodayMemories.js`
  - å­—æ¯åˆ†æ”¯é€»è¾‘ï¼š
    - å½“ `entityType === 'letter'` æ—¶ï¼š
      1. ä» `alphabet_lessons` ä¸­è¯»å– `lessonId` å¯¹åº”é…ç½®ï¼ˆconsonants/vowels/tonesï¼‰ï¼›
      2. ä» `letters` é›†åˆæŸ¥è¯¢å±äºè¯¥è¯¾ç¨‹çš„å­—æ¯ï¼ˆä½¿ç”¨ curriculumLessonIds å­—æ®µï¼‰ï¼›
      3. ä» `memory_status` ä¸­è¯»å–æ¯ä¸ªå­—æ¯çš„è®°å¿†çŠ¶æ€ï¼›
      4. å¯ä» `user_alphabet_progress` / `phonics_rules` ä¸­è¡¥å…… lessonMetadata / phonicsRuleï¼›
      5. è¿”å›ï¼š
         - `items: Array<Letter & { memoryState?: MemoryStatus }>`ï¼›
         - `summary: { total, newCount, reviewCount, entityType: 'letter' }`ï¼›
         - `lessonMetadata`ï¼›
         - `phonicsRule`ã€‚

- `handlers/submitMemoryResult.js`
  - å­—æ¯åˆ†æ”¯é€»è¾‘ï¼š
    - æ ¹æ® `userId + entityType = 'letter' + entityId` æŸ¥æ‰¾ `memory_status` æ–‡æ¡£ï¼›
    - ä½¿ç”¨ç»Ÿä¸€ç®—æ³• `computeNextReview(doc, quality)` æ›´æ–° masteryLevel / reviewStage / nextReviewAt ç­‰ï¼›
    - æ›´æ–°æˆ–æ’å…¥è¯¥æ–‡æ¡£ã€‚

- `handlers/submitRoundEvaluation.js`
  - å­—æ¯ä¸“ç”¨ï¼š
    - å°† `{ userId, entityType: 'letter', lessonId, roundNumber, totalQuestions, correctCount, accuracy }` å†™å…¥ `user_alphabet_progress`ï¼›
    - æ›´æ–° `currentRound`ï¼Œåœ¨ `roundHistory` æ•°ç»„ä¸­è¿½åŠ æ–°è®°å½•ã€‚

- `handlers/getAlphabetLessons.js`
  - èŒè´£ï¼š
    - è¿”å› `alphabet_lessons` é›†åˆä¸­çš„æ‰€æœ‰è¯¾ç¨‹é…ç½®ï¼›
    - åœ¨å‰ç«¯ `app/alphabet/index.tsx` ä¸­ç”¨ä½œè¯¾ç¨‹æ€»è§ˆæ•°æ®æºã€‚

---

## 3. é¡µé¢ä¸å¯¼èˆªé€»è¾‘ï¼ˆå‰ç«¯è·¯ç”± Flowï¼‰

æœ¬èŠ‚ä»â€œç”¨æˆ·è¿›å…¥å­—æ¯æ¨¡å—â€çš„è§’åº¦ï¼Œæ¢³ç†è·¯ç”±ä¸ç»„ä»¶çš„è°ƒç”¨æ¬¡åºã€‚

### 3.1 ä» Courses é¡µè¿›å…¥å­—æ¯æ¨¡å—

ï¼ˆå½“å‰å®ç°ï¼›æœªæ¥å¤§è¯¾ç¨‹é¡µä¼šå¢åŠ ä¸€å±‚ï¼Œä½†æ€»ä½“è·¯çº¿ä¸å˜ï¼‰

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ app/(tabs)/courses.tsx                      â”‚
â”‚ è¯¾ç¨‹æ€»è§ˆé¡µ                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”‚ ç‚¹å‡»â€œæ³°è¯­å­—æ¯â€å¡ç‰‡
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ app/alphabet/index.tsx                      â”‚
â”‚ å­—æ¯è¯¾ç¨‹æ€»è§ˆï¼ˆLesson1~7 åˆ—è¡¨ï¼‰              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”‚ ç‚¹å‡»æŸä¸ª Lesson å¡ç‰‡çš„â€œå¼€å§‹å­¦ä¹ â€
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ app/alphabet/[lessonId].tsx                â”‚
â”‚ å•è¯¾å­¦ä¹ æµï¼ˆ3 è½® + Phase çŠ¶æ€æœºï¼‰           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 å­—æ¯è¯¾ç¨‹æ€»è§ˆé¡µï¼š`app/alphabet/index.tsx`

- åˆå§‹åŒ–æµç¨‹ï¼š
  1. ç»„ä»¶æŒ‚è½½åï¼Œè°ƒç”¨ `callCloudFunction('getAlphabetLessons')`ï¼š
     - endpoint ä½¿ç”¨ `API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase`ï¼ˆå¤ç”¨ memory-engine HTTP å…¥å£ï¼‰ï¼›
     - è‹¥æˆåŠŸï¼Œä½¿ç”¨è¿”å›çš„ `lessons: LessonMetadata[]`ï¼›
     - è‹¥å¤±è´¥ï¼Œä½¿ç”¨ `getAllLessons()` ä»æœ¬åœ° `lessonMetadata.config.ts` è·å–è¯¾ç¨‹è¡¨ï¼›
  2. å°† `LessonMetadata[]` æ˜ å°„ä¸ºæœ¬åœ° `LessonCardProps[]`ï¼š
     - `id` = lessonIdï¼›
     - `title` / `description` = å…ƒæ•°æ®ï¼›
     - `letterKeys` = `consonants + vowels + tones`ï¼›
     - `progress.total` = `lesson.totalCount`ã€‚

- è§£é”é€»è¾‘ï¼š
  - ä» `useAlphabetStore()` è¯»å–ï¼š
    - `completedCount`ï¼šæœ¬åœ°å·²å®Œæˆå­—æ¯æ•°ï¼›
    - `totalCount`ï¼šå½“å‰ä¼šè¯ä¸­å­—æ¯æ€»æ•°ã€‚
  - é€šè¿‡ `lessons.reduce` è®¡ç®—æ¯è¯¾çš„ç´¯è®¡å­—æ¯æ•°é‡ `cumulativeCounts`ï¼›
  - å¯¹äºç¬¬ i è¯¾ï¼š
    - `unlocked = index === 0 || completedCount >= cumulativeCounts[index - 1]`ï¼›
    - `isCurrent = completedCount < cumulativeCounts[index] && unlocked`ã€‚

- UI è¡Œä¸ºï¼š
  - æ¯ä¸ª Lesson å¡ç‰‡æ˜¾ç¤ºï¼š
    - æ ‡é¢˜ / æè¿°ï¼›
    - æœ¬è¯¾å­—æ¯æ•°ï¼›
    - å½“å‰è¿›åº¦ï¼ˆæš‚ä»¥ completedCount ä¸ cumulativeCounts è®¡ç®—ï¼‰ã€‚
  - ç‚¹å‡»â€œå¼€å§‹å­¦ä¹ â€æŒ‰é’®ï¼š
    - `router.push(`/alphabet/${lesson.id}`)`ï¼›
    - ä¸ç›´æ¥æ“ä½œ Storeï¼ŒStore åˆå§‹åŒ–åœ¨ `[lessonId]` é¡µé¢è¿›è¡Œã€‚

### 3.3 å•è¯¾å­¦ä¹ å…¥å£ï¼š`app/alphabet/[lessonId].tsx`

```ts
// å…³é”®ä¼ªä»£ç ç»“æ„
const { lessonId } = useLocalSearchParams<{ lessonId: string }>();
const router = useRouter();

const engine = useAlphabetLearningEngine(lessonId);

return (
  <AlphabetLearningEngineView
    {...engine}
    onBack={() => router.back()}
  />
);
```

- `[lessonId]` é¡µé¢ä¸ç›´æ¥å…³å¿ƒï¼š
  - é˜Ÿåˆ—å¦‚ä½•ç”Ÿæˆï¼›
  - Phase å¦‚ä½•åˆ‡æ¢ï¼›
  - é¢˜å‹å¦‚ä½•æ¸²æŸ“ã€‚
- å…¨éƒ¨äº¤ç»™ï¼š
  - `useAlphabetLearningEngine`ï¼ˆä¸šåŠ¡çŠ¶æ€æœºï¼‰ï¼›
  - `AlphabetLearningEngineView`ï¼ˆè§†å›¾è·¯ç”±å™¨ï¼‰ã€‚

---

## 4. å­¦ä¹ å¼•æ“ï¼šuseAlphabetLearningEngineï¼ˆPhase é€»è¾‘ï¼‰

### 4.1 Phase çŠ¶æ€ä¸ Round æ¦‚å¿µ

åœ¨ Hook å†…éƒ¨ï¼Œæˆ‘ä»¬æœ‰ä¸¤å±‚â€œé˜¶æ®µâ€ï¼š

- **Phaseï¼ˆé˜¶æ®µï¼‰**ï¼šä»£è¡¨å½“å‰ UI æ‰€åœ¨çš„ä¸šåŠ¡é˜¶æ®µï¼š
  - `yesterday-review`ï¼šæ˜¨æ—¥å¤ä¹ ï¼›
  - `yesterday-remedy`ï¼šæ˜¨æ—¥é”™é¢˜è¡¥æ•‘ï¼›
  - `today-learning`ï¼šä»Šæ—¥å­¦ä¹ ï¼›
  - `today-mini-review`ï¼šä»Šæ—¥å°å¤ä¹ ï¼ˆæ¯å­¦ 3 ä¸ªå­—æ¯è§¦å‘ä¸€æ¬¡ï¼‰ï¼›
  - `today-final-review`ï¼šä»Šæ—¥æœ«å°¾å¤ä¹ ï¼›
  - `today-remedy`ï¼šä»Šæ—¥é”™é¢˜è¡¥æ•‘ï¼›
  - `finished`ï¼šè¯¾ç¨‹ä¸‰è½®è¯„ä¼°ç»“æŸã€‚
- **Roundï¼ˆä¸‰è½®è¯„ä¼°è½®æ¬¡ï¼‰**ï¼š
  - `currentRound: 1 | 2 | 3`ï¼›
  - å¯¹åº”ä½ è®¾è®¡çš„ï¼š
    - Round1ï¼šè®¤çŸ¥ï¼ˆè®¤å­—/å¬éŸ³ï¼‰ï¼›
    - Round2ï¼šå±æ€§ï¼ˆè¾…éŸ³ç±»åˆ«ç­‰ï¼‰ï¼›
    - Round3ï¼šåº”ç”¨ï¼ˆå˜å½¢/å£°è°ƒç­‰ï¼Œæœªæ¥ç”± Question Engine ä½“ç°ï¼‰ã€‚

### 4.1.0 å­—æ¯è¯¾ç¨‹æ•´ä½“é˜¶æ®µæµç¨‹å›¾ï¼ˆç±»ä¼¼ç¬¬ä¸€å¼ å›¾ï¼‰

> è¿™å¼ å›¾æ˜¯ **â€œç†æƒ³çŠ¶æ€ / ç›®æ ‡è®¾è®¡â€** çš„çº¿æ€§æµç¨‹å›¾ï¼Œ  
> å±•ç¤ºä» Lesson Start åˆ°ä¸‰è½®è¯„ä¼°å®Œæˆçš„ Phase æµç¨‹ä¸å…³é”®æ–¹æ³•è°ƒç”¨ã€‚

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Lesson Start                                â”‚
â”‚ é¦–æ¬¡è¿›å…¥ /alphabet/[lessonId]               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â”‚ è°ƒç”¨ useAlphabetLearningEngine(lessonId)
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ åˆå§‹åŒ–åç«¯é˜Ÿåˆ—                               â”‚
â”‚ alphabetStore.initializeSession(userId,{    â”‚
â”‚   lessonId                                  â”‚
â”‚ })                                          â”‚
â”‚ â†’ callCloudFunction('getTodayMemories',â€¦)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â”‚ è¿”å› items[] = æ˜¨æ—¥éœ€å¤ä¹  + ä»Šæ—¥æ–°å­—æ¯
                       â”‚ ï¼ˆmemory-engine æŒ‰è¯¾ç¨‹ + SRS è¿‡æ»¤ï¼‰
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 1: yesterday-reviewï¼ˆæ˜¨æ—¥å¤ä¹ ï¼‰       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                     â”‚
        â”‚ ç­”å¯¹                â”‚ ç­”é”™
        â–¼                     â–¼
  nextInQueue()      wrongAnswers.add(alphabetId)
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 2: yesterday-remedyï¼ˆæ˜¨æ—¥è¡¥æ•‘ï¼‰       â”‚
â”‚ æŒ‰ wrongAnswers å‡ºå¤ä¹ é¢˜                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”œâ”€â”€ ä»æœ‰é”™é¢˜ â†’ å›åˆ°è¡¥æ•‘é˜¶æ®µå‡ºé¢˜
        â”‚
        â””â”€â”€ é”™é¢˜æ¸…ç©º â†’ è¿›å…¥ä»Šæ—¥å­¦ä¹ 
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 3: today-learningï¼ˆä»Šæ—¥å­¦ä¹ ï¼‰         â”‚
â”‚ ä¸‰æ–°ä¸€å¤ä¹  + Mini Review                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 4: today-mini-review / final-review   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 5: today-remedyï¼ˆä»Šæ—¥è¡¥æ•‘ï¼‰           â”‚
â”‚ é’ˆå¯¹ä»Šæ—¥é”™é¢˜ç»§ç»­å‡ºé¢˜                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”œâ”€â”€ ä»æœ‰é”™é¢˜ â†’ ç•™åœ¨è¡¥æ•‘é˜¶æ®µ
        â””â”€â”€ é”™é¢˜æ¸…ç©º â†’ è¿›å…¥ä¸‰è½®åˆ¤å®š
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 6: round-evaluationï¼ˆä¸‰è½®è¯„ä¼°ï¼‰       â”‚
â”‚ submitRoundResults() â†’ submitRoundEvaluationâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”œâ”€â”€ è‹¥ currentRound < 3 ä¸”æœ¬è½®é€šè¿‡ â†’   â”‚
        â”‚    currentRound + 1, phase='yesterday-review'
        â”‚
        â””â”€â”€ è‹¥ currentRound = 3 ä¸”é€šè¿‡ â†’       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 7: finishedï¼ˆè¯¾ç¨‹å®Œæˆï¼‰               â”‚
â”‚ markAlphabetLessonCompleted(lessonId)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.1.1 å­—æ¯å­¦ä¹  Phase + æ–¹æ³•è°ƒç”¨æ€»è§ˆï¼ˆMermaidï¼‰

```text
ã€è°ƒç”¨å…³ç³»æ¦‚è§ˆã€‘

app/alphabet/[lessonId].tsx
  â””â”€ è°ƒç”¨ useAlphabetLearningEngine(lessonId)
       â”œâ”€ åˆå§‹åŒ–é˜¶æ®µï¼š
       â”‚    â””â”€ alphabetStore.initializeSession(userId,{ lessonId })
       â”‚         â””â”€ callCloudFunction('getTodayMemories', { entityType:'letter', lessonId })
       â”‚              â””â”€ memory-engine.handlers.getTodayMemories
       â”‚                   â””â”€ è¿”å› items + memoryState + lessonMetadata + phonicsRule
       â”‚
       â”œâ”€ Phase = 'yesterday-review' / 'today-final-review' / 'today-remedy'
       â”‚    â””â”€ AlphabetLearningEngineView â†’ AlphabetReviewView
       â”‚         â””â”€ ç”¨æˆ·ç­”é¢˜ onAnswer(isCorrect, qType)
       â”‚              â””â”€ useAlphabetLearningEngine.handleAnswer
       â”‚                   â””â”€ alphabetStore.submitResult(userId, isCorrect)
       â”‚                        â”œâ”€ callCloudFunction('submitMemoryResult', {...})
       â”‚                        â””â”€ æ›´æ–°æœ¬åœ° currentAttempts / isCompleted
       â”‚                             â””â”€ alphabetStore.nextInQueue()
       â”‚                                  â””â”€ åˆ‡æ¢ currentItem
       â”‚
       â”œâ”€ Phase = 'today-learning'
       â”‚    â”œâ”€ è‹¥ showPhonicsRuleCard â†’ PhonicsRuleCard
       â”‚    â””â”€ å¦åˆ™ â†’ AlphabetLearningViewï¼ˆæ•™å­¦å¡ï¼‰
       â”‚
       â”œâ”€ Phase = 'today-mini-review'
       â”‚    â””â”€ MiniReviewQuestionComponent
       â”‚         â””â”€ onMiniReviewAnswer / onMiniReviewNext
       â”‚            ï¼ˆå½“å‰åªå½±å“æœ¬åœ° miniReview é˜Ÿåˆ—ï¼Œä¸è°ƒç”¨åç«¯ï¼‰
       â”‚
       â””â”€ ä¸‰è½®ç»“æŸï¼š
            â””â”€ submitRoundResults()
                 â”œâ”€ alphabetStore.submitRoundEvaluation({ userId, lessonId, ... })
                 â”‚    â””â”€ callCloudFunction('submitRoundEvaluation', {...})
                 â”‚         â””â”€ memory-engine.handlers.submitRoundEvaluation
                 â””â”€ è‹¥ currentRound < 3 â†’ currentRound++ï¼Œphase='yesterday-review'
                    è‹¥ = 3 â†’ moduleAccessStore.markAlphabetLessonCompleted(lessonId)ï¼Œphase='finished'
```

### 4.2 åˆå§‹åŒ–ï¼šè°ƒç”¨ alphabetStore.initializeSession

æ ¸å¿ƒé€»è¾‘ï¼ˆä¼ªä»£ç ï¼‰ï¼š

```ts
const { queue, currentItem, lessonMetadata, phonicsRule, initializeSession, submitResult, submitRoundEvaluation: submitRoundToStore, next: nextInQueue } = useAlphabetStore();
const { markAlphabetLessonCompleted } = useModuleAccessStore();
const { currentUser } = useUserStore();
const userId = currentUser?.userId ?? 'test-user';

useEffect(() => {
  let cancelled = false;

  (async () => {
    try {
      await initializeSession(userId, { lessonId });  // è°ƒç”¨ memory-engine.getTodayMemories
    } catch (e) {
      if (!cancelled) {
        setInitialized(true);
        setPhase('finished'); // å‡ºé”™æ—¶è§†ä¸ºæ— æ³•å­¦ä¹ ï¼Œç›´æ¥å®Œæˆ
      }
      return;
    }
    if (!cancelled) setInitialized(true);
  })();

  return () => { cancelled = true; };
}, [lessonId, userId, initializeSession]);
```

- ä¾èµ–ï¼š
  - `alphabetStore.initializeSession(...)` å®Œæˆä¸ memory-engine çš„äº¤äº’ï¼Œå‡†å¤‡å¥½ `queue` å’Œ `currentItem`ï¼›
  - `lessonMetadata` / `phonicsRule` è¢«ä¿å­˜åœ¨ `alphabetStore` ä¸­ï¼Œä¾› UI ä½¿ç”¨ã€‚

### 4.3 æ˜¨æ—¥å¤ä¹ ä¸è·³è¿‡é€»è¾‘

- åˆå§‹åŒ–å Phase é»˜è®¤è¿›å…¥ `'yesterday-review'`ã€‚
- ä½¿ç”¨ä¸€ä¸ª effect åˆ¤æ–­æ˜¯å¦å­˜åœ¨â€œéæ–°å­—æ¯â€ï¼š

```ts
useEffect(() => {
  if (!initialized) return;
  if (phase !== 'yesterday-review') return;

  const hasNonNew = queue.some(
    (item) => item.memoryState && item.memoryState.isNew === false,
  );

  if (!hasNonNew) {
    setPhase('today-learning'); // æ²¡æœ‰æ—§å­—æ¯æ—¶è·³è¿‡æ˜¨æ—¥å¤ä¹ 
  }
}, [initialized, phase, queue]);
```

- `onSkipYesterdayReview`ï¼š
  - æš´éœ²ç»™ UIï¼Œåœ¨ `AlphabetLearningEngineView` æ˜¾ç¤ºâ€œè·³è¿‡æ˜¨æ—¥å¤ä¹ â€æŒ‰é’®ï¼›
  - ç‚¹å‡»æ—¶ç›´æ¥ `setPhase('today-learning')`ã€‚

#### 4.3.1 yesterday-review çš„æ•°æ®æ¥æºä¸åˆ¤å®šè§„åˆ™

- **æ•°æ®æ¥æºï¼š**
  - æ‰€æœ‰é¢˜ç›®æ•°æ®éƒ½æ¥è‡ª `alphabetStore.queue`ï¼Œè€Œ `queue` åˆå®Œå…¨ç”± `memory-engine.getTodayMemories` è¿”å›çš„ `items` æ˜ å°„è€Œæ¥ï¼š
    - `items: Array<Letter & { memoryState?: MemoryStatus }>`ï¼›
    - æ¯ä¸ª `item.memoryState` ç”±åç«¯æ ¹æ® `memory_status` è®¡ç®—å¾—åˆ°ã€‚
  - å‰ç«¯æœ¬èº«**ä¸ä¼šå•ç‹¬å†æŸ¥ DB**ï¼Œæ‰€æœ‰â€œæ˜¨æ—¥å¤ä¹ /ä»Šæ—¥æ–°å­—æ¯â€çš„åˆ¤æ–­éƒ½åŸºäº `memoryState`ã€‚

- **ä»€ä¹ˆå†…å®¹ä¼šè¢«è®¤ä¸ºæ˜¯â€œæ˜¨æ—¥å¤ä¹ â€ï¼Ÿ**
  - memory-engine åœ¨å­—æ¯åˆ†æ”¯ä¸­è¿”å› `summary.newCount` / `summary.reviewCount`ï¼Œå¹¶ä¸ºæ¯ä¸ªå­—æ¯é™„åŠ ï¼š
    - `memoryState.isNew: boolean`ï¼š
      - `true`ï¼šåç«¯è®¤ä¸ºè¯¥å­—æ¯æ˜¯â€œæ–°å­—æ¯â€ï¼ˆæ²¡æœ‰å†å²è®°å¿†è®°å½•ï¼‰ï¼›
      - `false`ï¼šå·²æœ‰è®°å¿†è®°å½•ï¼Œéœ€è¦å¤ä¹ ã€‚
  - åœ¨å‰ç«¯ï¼š
    - **æ˜¯å¦å­˜åœ¨æ˜¨æ—¥å¤ä¹ é˜¶æ®µ**ï¼šä»…æ£€æŸ¥
      ```ts
      queue.some(
        (item) => item.memoryState && item.memoryState.isNew === false,
      );
      ```
      - è‹¥å­˜åœ¨ä»»æ„ `isNew === false` çš„å­—æ¯ï¼Œåˆ™ä¿ç•™ `'yesterday-review'` Phaseï¼›
      - è‹¥æ‰€æœ‰å­—æ¯ `isNew === true`ï¼Œåˆ™è®¤ä¸ºæ²¡æœ‰â€œæ—§å­—æ¯â€ï¼Œç›´æ¥è¿›å…¥ `'today-learning'`ã€‚
    - **åœ¨ `'yesterday-review'` é˜¶æ®µå±•ç¤ºçš„å†…å®¹**ï¼š
      - å½“å‰å®ç°ä¸­ï¼Œ`AlphabetLearningEngineView` å¹¶ä¸å¯¹ `queue` å†åšåˆ†æ®µï¼Œè€Œæ˜¯ä¾èµ– memory-engine å¯¹é˜Ÿåˆ—é¡ºåºçš„çº¦å®šï¼š
        - åç«¯è´Ÿè´£å°†â€œéœ€å¤ä¹ çš„å­—æ¯â€ä¸â€œæ–°å­—æ¯â€æ··æ’/æ’åºï¼›
        - å‰ç«¯åœ¨ `'yesterday-review'` Phase ä¸‹ï¼Œå¯¹ `currentItem` è¿›è¡Œå¤ä¹ ï¼›
        - ä¸€æ—¦åç«¯è¿”å›çš„é˜Ÿåˆ—ä¸­å·²æ— éæ–°å­—æ¯ï¼ˆæ‰€æœ‰å‰©ä½™é¡¹ `isNew === true`ï¼‰ï¼Œå³å¯åˆ‡æ¢åˆ° `'today-learning'`ã€‚
      - ç®€åŒ–ç†è§£ï¼š**å‡¡æ˜¯ `memoryState.isNew === false` çš„å­—æ¯ï¼Œéƒ½ä¼šåœ¨ Yesterday Review é˜¶æ®µè¢«å½“ä½œâ€œå¤ä¹ é¡¹ç›®â€å¤„ç†**ï¼Œå…·ä½“â€œæ˜¯å¦çœŸçš„æ¥è‡ªæ˜¨å¤©â€ç”± memory-engineï¼ˆSRS ç®—æ³•ï¼‰è´Ÿè´£ï¼Œå‰ç«¯ä¸åŒºåˆ†â€œæ˜¨å¤© vs æ›´æ—©â€ã€‚

- **ä¸ Today Learning çš„å…³ç³»ï¼š**
  - `'today-learning'` é˜¶æ®µä¸»è¦é¢å‘ `isNew === true` çš„å­—æ¯ï¼›
  - è¿™äº›å­—æ¯åœ¨æœ¬è½®å®Œæˆåä¼šé€šè¿‡ `submitMemoryResult` å†™å…¥ `memory_status`ï¼Œä»ä¸‹ä¸€æ¬¡è¿›å…¥æœ¬è¯¾èµ·ï¼Œå°†è¢«è§†ä¸ºâ€œæœ‰è®°å¿†è®°å½•â€çš„å¤ä¹ å¯¹è±¡ã€‚

### 4.4 ä»Šæ—¥å­¦ä¹  + Mini Review

- `handleNext()` é€»è¾‘ï¼š

```ts
const handleNext = useCallback(() => {
  if (phase === 'today-learning') {
    setTodayList((prev) => [...prev, currentItem!]);
    setLearnedCount((prev) => prev + 1);

    const newCount = learnedCount + 1;
    if (newCount % MINI_REVIEW_INTERVAL === 0) {
      triggerMiniReview();   // è¿›å…¥ today-mini-review
      return;
    }
  }

  nextInQueue(); // è°ƒç”¨ alphabetStore.nextï¼Œåˆ‡åˆ°ä¸‹ä¸€ä¸ªå­—æ¯
}, [...]);
```

- Mini Reviewï¼š
  - `triggerMiniReview()` ä¼šä½¿ç”¨æœ€è¿‘å­¦ä¹ è¿‡çš„è‹¥å¹²å­—æ¯æ„é€  `miniReviewQuestions` åˆ—è¡¨ï¼›
  - Phase åˆ‡æ¢ä¸º `'today-mini-review'`ï¼›
  - UI ä½¿ç”¨ `MiniReviewQuestionComponent` æ¸²æŸ“ï¼›
  - æ‰€æœ‰ mini é¢˜ç­”å®Œä¸”é”™é¢˜æ¸…ç©ºåï¼Œå›åˆ° `'today-learning'`ã€‚

### 4.5 ç­”é¢˜æäº¤ä¸é”™é¢˜è®°å½•

- `handleAnswer(isCorrect, questionType)`ï¼š

```ts
const handleAnswer = useCallback(
  async (isCorrect: boolean, questionType: QuestionType) => {
    if (!currentItem) return;

    await submitResult(userId, isCorrect); // alphabetStore â†’ memory-engine.submitMemoryResult

    if (!isCorrect) {
      setWrongAnswers((prev) => new Set(prev).add(currentItem.alphabetId));
    }
  },
  [currentItem, userId, submitResult]
);
```

- æ³¨æ„ï¼š
  - æ‰€æœ‰â€œé¢˜ç›®å¯¹/é”™â€ä¿¡æ¯éƒ½ä¼šä¼ ç»™ `alphabetStore.submitResult`ï¼Œåè€…å†è°ƒç”¨ memory-engineï¼›
  - æœ¬åœ°é¢å¤–ç»´æŠ¤ä¸€ä¸ª `wrongAnswers: Set<string>`ï¼ˆæŒ‰ alphabetIdï¼‰ï¼Œä¾›ä¸‰è½®è¯„ä¼°ä½¿ç”¨ã€‚

### 4.6 ä¸‰è½®è¯„ä¼°ä¸ç»“æŸæ¡ä»¶

- `submitRoundResults()`ï¼š

```ts
const submitRoundResults = useCallback(async () => {
  const roundData = {
    roundNumber: currentRound,
    totalQuestions: todayList.length,
    correctCount: todayList.length - wrongAnswers.size,
    accuracy: (todayList.length - wrongAnswers.size) / todayList.length,
    passed: wrongAnswers.size / todayList.length <= 0.1, // é”™é¢˜ â‰¤ 10%
  };

  setRoundEvaluation((prev) => ({
    ...prev,
    currentRound: currentRound,
    rounds: [...prev.rounds, roundData],
  }));

  await submitRoundToStore({
    userId,
    lessonId,
    ...roundData,
  });

  if (currentRound < 3) {
    setCurrentRound((currentRound + 1) as 1 | 2 | 3);
    setWrongAnswers(new Set());
    setPhase('yesterday-review');  // æ–°ä¸€è½®ä»æ˜¨æ—¥å¤ä¹ å¼€å§‹
  } else {
    markAlphabetLessonCompleted(lessonId); // é€šçŸ¥æ¨¡å—è®¿é—® Store
    setPhase('finished');
  }
}, [...]);
```

- ç»“æŸæ¡ä»¶ï¼š
  - ä¸‰è½®éƒ½é€šè¿‡ï¼ˆæ¯è½®é”™é¢˜æ¯”ä¾‹ â‰¤ 10%ï¼‰ï¼›
  - Phase è¿›å…¥ `'finished'`ï¼›
  - `AlphabetLearningEngineView` åœ¨è¯¥ phase å±•ç¤ºä¸‰è½®ç»“æœï¼Œå¹¶å¯æä¾›â€œè¿”å›è¯¾ç¨‹åˆ—è¡¨â€ç­‰æ“ä½œã€‚

---

## 5. è§†å›¾å±‚ï¼šAlphabetLearningEngineView çš„ Phase æ¸²æŸ“

### 5.1 Props æ¥å£

```ts
interface AlphabetLearningEngineViewProps {
  initialized: boolean;
  phase: Phase;                        // useAlphabetLearningEngine ä¸­å®šä¹‰çš„ç±»å‹
  currentRound: 1 | 2 | 3;
  roundEvaluation?: RoundEvaluationState;

  currentItem: AlphabetLearningState | null;
  currentQuestionType: QuestionType | null;
  letterPool: Letter[];

  // æ ¸å¿ƒäº¤äº’
  onAnswer: (isCorrect: boolean, type: QuestionType) => void;
  onNext: () => void;
  onBack?: () => void;

  // æ˜¨æ—¥å¤ä¹ æ§åˆ¶
  onSkipYesterdayReview?: () => void;

  // æ‹¼è¯»è§„åˆ™å¡
  phonicsRule: PhonicsRule | null;
  showPhonicsRuleCard: boolean;
  onCompletePhonicsRule?: () => void;

  // Mini Review
  miniReviewQuestion: MiniReviewQuestionType | null;
  onMiniReviewAnswer?: (isCorrect: boolean) => void;
  onMiniReviewNext?: () => void;
}
```

### 5.2 Phase â†’ è§†å›¾æ˜ å°„

- `!initialized || !currentItem`ï¼š
  - å±•ç¤ºåŠ è½½ä¸­çš„ `ActivityIndicator`ã€‚

- `phase === 'yesterday-review' | 'yesterday-remedy' | 'today-final-review' | 'today-remedy'`ï¼š
  - æ¸²æŸ“ï¼š

```tsx
<SafeAreaView style={{ flex: 1 }}>
  <RoundHeader currentRound={currentRound} />
  {phase === 'yesterday-review' && onSkipYesterdayReview && (
    // å³ä¸Šè§’â€œè·³è¿‡æ˜¨æ—¥å¤ä¹ â€æŒ‰é’®
  )}
  <AlphabetReviewView
    alphabet={currentItem}
    letterPool={letterPool}
    preferredType={currentQuestionType ?? undefined}
    onAnswer={onAnswer}
    onNext={onNext}
    onBack={onBack}
  />
</SafeAreaView>
```

- `phase === 'today-mini-review'`ï¼š
  - å¦‚æœæœ‰ `miniReviewQuestion`ï¼š
    - ä½¿ç”¨ `MiniReviewQuestionComponent` æ¸²æŸ“ï¼›
  - å¦åˆ™å›é€€ä¸º `AlphabetReviewView`ã€‚

- `phase === 'today-learning'`ï¼š
  - å¦‚æœ `showPhonicsRuleCard && phonicsRule`ï¼š
    - æ¸²æŸ“ `PhonicsRuleCard`ï¼ˆå±•ç¤ºæ‹¼è¯»è§„åˆ™ï¼Œç”¨æˆ·è¯»å®Œåç‚¹å‡»â€œå®Œæˆâ€ï¼Œè°ƒç”¨ `onCompletePhonicsRule`ï¼‰ï¼›
  - å¦åˆ™æ¸²æŸ“ `AlphabetLearningView`ï¼ˆå•å­—æ¯æ•™å­¦å¡ï¼‰ã€‚

- `phase === 'finished'`ï¼š
  - å±•ç¤ºä¸‰è½®è¯„ä¼°ç»“æœï¼ˆ`roundEvaluation.rounds`ï¼‰ï¼›
  - æ˜¾ç¤ºæ¯ä¸€è½®çš„æ­£ç¡®ç‡å’Œæ˜¯å¦é€šè¿‡ï¼›
  - å¯ä»¥åœ¨æ­¤å¤„æ·»åŠ â€œè¿”å›è¯¾ç¨‹åˆ—è¡¨â€ç­‰æŒ‰é’®ã€‚

---

## 6. é¢˜å‹ä¸ Question Engineï¼ˆç°çŠ¶ä¸è§„åˆ’ï¼‰

### 6.1 ç°çŠ¶ï¼šlettersQuestionGenerator æä¾›çš„é¢˜å‹

å½“å‰å¤ä¹ é¢˜ä¸»è¦ç”± `src/utils/lettersQuestionGenerator.ts` æä¾›ï¼š

- è¾“å…¥ï¼š
  - `letter: Letter`ï¼šå½“å‰å¤ä¹ çš„å­—æ¯ï¼›
  - `pool: Letter[]`ï¼šä»Šæ—¥æ‰€æœ‰å­—æ¯ï¼Œç”¨äºç”Ÿæˆå¹²æ‰°é¡¹ï¼›
  - `preferredType?: QuestionType`ï¼šå¯ä»¥æŒ‡å®šé¢˜å‹ã€‚
- è¾“å‡ºï¼š
  - `AlphabetQuestion`ï¼š
    - `type: QuestionType`ï¼›
    - `stem: string`ï¼šé¢˜å¹²ï¼›
    - `options: string[]`ï¼šé€‰é¡¹ï¼›
    - `correct: string`ï¼šæ­£ç¡®ç­”æ¡ˆï¼›
    - `audioUrl?: string`ï¼šå…³è”éŸ³é¢‘ã€‚

é¢˜å‹ç¤ºä¾‹ï¼š

- SOUND_TO_LETTERï¼šå¬éŸ³é€‰å­—æ¯ï¼›
- LETTER_TO_SOUNDï¼šçœ‹å­—é€‰å‘éŸ³ï¼›
- SYLLABLEï¼šå­—æ¯ + å…ƒéŸ³çš„æ‹¼è¯»ï¼›
- REVERSE_SYLLABLEï¼šç»™è¯»éŸ³åæ¨å­—æ¯ï¼›
- MISSING_LETTERï¼šç¼ºå­—å¡«ç©ºï¼›
- FINAL_CONSONANTï¼šè€ƒå¯Ÿå°¾è¾…éŸ³å‘éŸ³ï¼›
- CLASS_CHOICEï¼šè¾…éŸ³ç±»åˆ«é€‰æ‹©ï¼ˆä¸­/é«˜/ä½ï¼‰ï¼›
- LETTER_NAMEï¼šå­—æ¯åç§°åˆ¤æ–­ã€‚

### 6.2 è§„åˆ’ï¼šç»Ÿä¸€ Question Engineï¼ˆæœ¬æ¨¡å—å†…éƒ¨å®šä¹‰ï¼‰

æœ¬æ¨¡å—æœªæ¥ç‰ˆæœ¬ä¸­ï¼Œå­—æ¯é¢˜å‹å°†ç”±ç»Ÿä¸€çš„ Question Engine åè®®é©±åŠ¨ï¼š

- æšä¸¾ `GameType`ï¼šæ˜ å°„ 6 å¤§é¢˜å‹ï¼ˆåŸºç¡€å¬è§‰/è§†è§‰é¢˜ + æ‹¼è¯»æ•°å­¦ + å£°è°ƒè®¡ç®—å™¨ç­‰ï¼‰ï¼›  
- ç»“æ„åŒ–çš„ `QueueItem` / `InstructItem` / `QuizItem`ï¼›  
- å„é¢˜å‹çš„ä¸“ç”¨ payloadï¼ˆä¾‹å¦‚ ConsonantClassSortã€SpellingMathã€ToneCalculator ç­‰ï¼‰ã€‚

ä¸å­—æ¯æ¨¡å—çš„å…³ç³»ï¼š

- æœªæ¥æ”¹é€ åŸåˆ™ï¼š
  - `useAlphabetLearningEngine` ä¸ç›´æ¥ä¾èµ– `lettersQuestionGenerator`ï¼›  
  - è€Œæ˜¯åœ¨ Phase å†…è°ƒç”¨ `generateQueueItems(FlowContext)`ï¼›  
  - `AlphabetLearningEngineView` ä¸ç›´æ¥æ¸²æŸ“ `AlphabetReviewView`ï¼Œè€Œæ˜¯æ¸²æŸ“ `GameContainer + StepRenderer`ã€‚

åœ¨å½“å‰ç‰ˆæœ¬ï¼Œæœ¬ spec åªè¦æ±‚ç†è§£ç°æœ‰å®ç°ï¼›  
åç»­çœŸæ­£è¿ç§»åˆ° 6 å¤§é¢˜å‹æ—¶ï¼Œåº”åœ¨æœ¬èŠ‚å†…ç»™å‡º `GameType` / payload çš„æ­£å¼å®šä¹‰ï¼Œå¹¶æ®æ­¤å®ç°ã€‚

### 6.3 Question Engine é›†æˆæµç¨‹å›¾

> æœ¬å°èŠ‚è¯´æ˜ Question Engine å°†å¦‚ä½•åµŒå…¥å­—æ¯æ¨¡å—ï¼Œæ˜¯æœªæ¥å®ç°æ—¶çš„ç»“æ„å‚è€ƒã€‚

```text
AlphabetLessonFlow / app/alphabet/[lessonId].tsx
  â””â”€ useAlphabetLearningEngine
       â””â”€ åœ¨æ¯ä¸ª Phase / Round å†…æ„é€  FlowContextï¼š
            { lessonId, round, phase, letters, userStats? }
             â–¼
       è°ƒç”¨ generateQueueItems(FlowContext)
             â–¼
       è¿”å› QueueItem[] = [
         { kind:'INSTRUCT', ... },
         { kind:'QUIZ', gameType:GameType.X, payload:{...} },
         ...
       ]
             â–¼
       äº¤ç»™ GameContainer æ¸²æŸ“æœ¬è½®é˜Ÿåˆ—ï¼š
         - ç»´æŠ¤ currentIndex / å½“å‰ QueueItem
         - ç»´æŠ¤ wrongPoolï¼ˆé”™é¢˜æ± ï¼‰
         - å°†å½“å‰ QueueItem äº¤ç»™ StepRenderer
             â–¼
       StepRenderer:
         - æ ¹æ® gameType å†³å®šå…·ä½“ç»„ä»¶ï¼š
             LISTEN_SELECT          â†’ <ListenSelectView />
             CONSONANT_CLASS_SORT   â†’ <ConsonantClassSorter />
             SPELLING_MATH          â†’ <SpellingMathView />
             TONE_CALCULATOR        â†’ <ToneCalculatorView />
             ...
         - ç”¨æˆ·ä½œç­” â†’ onAnswer(isCorrect)
             â–¼
       GameContainer:
         - è‹¥éœ€è¦ï¼Œè°ƒç”¨ alphabetStore.submitResult(userId, isCorrect)
         - è‹¥é”™è¯¯ï¼Œå°†é¢˜ç›®/å­—æ¯åŠ å…¥ wrongPool
         - é˜Ÿåˆ—ç»“æŸæ—¶ï¼Œå›è°ƒ onQueueComplete({ stats, wrongPool })
             â–¼
       useAlphabetLearningEngine:
         - æ ¹æ® stats / wrongPool å†³å®šï¼š
             * æ˜¯å¦è¿›å…¥è¡¥æ•‘é˜¶æ®µ
             * æ˜¯å¦è¿›å…¥ä¸‹ä¸€è½® Round
             * æ˜¯å¦è¿›å…¥ finished
```

- åœ¨è¿™ä¸€è®¾è®¡ä¸‹ï¼š
  - **Hook å±‚**ï¼ˆ`useAlphabetLearningEngine`ï¼‰åªè´Ÿè´£ Phase çŠ¶æ€æœºï¼Œä¸é¢˜å‹æ— å…³ï¼›
  - **Question Engine å±‚**è´Ÿè´£ï¼š
    - æ ¹æ® Round/Phase å†³å®šä½¿ç”¨å“ªäº› `GameType`ï¼›
    - ä¸ºæ¯ç§ `GameType` ç”Ÿæˆç»“æ„åŒ– payloadï¼›
  - **GameContainer + StepRenderer** å°† `QueueItem` æ˜ å°„ä¸ºå…·ä½“ UI ç»„ä»¶ï¼Œå¹¶åœ¨ç­”é¢˜åç»Ÿä¸€è°ƒç”¨ `submitResult`ã€‚

---

## 7. æ•°æ®ç»“æ„ä¸å­—æ®µä½¿ç”¨ï¼ˆLetters / Lessons / Memoryï¼‰

### 7.1 å­—æ¯å®ä½“ï¼šLETTERS é›†åˆ

- æ¥æºï¼š`assets/courses/letters_final.enriched.json`ï¼›
- å…³é”®å­—æ®µï¼ˆèŠ‚é€‰ï¼‰ï¼š
  - `_id: string`ï¼ˆå¦‚ `TH_C_01`ï¼‰
  - `type: 'consonant' | 'vowel' | 'tone'`
  - `thaiChar: string`
  - `nameThai: string`
  - `nameEnglish: string`
  - `initialSound: string`
  - `finalSound: string`
  - `class: 'high' | 'mid' | 'low' | null`
  - `category: string`ï¼ˆå¦‚ `mid_consonant`, `vowel`ï¼‰
  - `subCategory: string`
  - éŸ³é¢‘ç›¸å…³ï¼š
    - `fullSoundUrl`, `syllableSoundUrl`, `endSyllableSoundUrl`, `letterPronunciationUrl`
    - ä»¥åŠ Store é¢„ä¸‹è½½åé™„åŠ çš„ `fullSoundLocalPath`, `syllableSoundLocalPath`, `endSyllableSoundLocalPath`, `letterPronunciationLocalPath`
  - è¯¾ç¨‹æ˜ å°„ï¼š
    - `curriculumLessonIds: string[]`
    - `curriculumLessonOrders: number[]`
    - `primaryCurriculumLessonId: string`
    - `primaryCurriculumLessonOrder: number`

å­—æ¯æ¨¡å—ä¸­ï¼š

- `alphabetStore.initializeSession` ä¼šæ ¹æ® `lessonId` ä»åç«¯å–å›åŒ…å«è¿™äº›å­—æ®µçš„ `Letter` æ–‡æ¡£ï¼›
- `AlphabetLearningState.letter` ä¸­å®Œæ•´ä¿å­˜äº† `Letter`ï¼Œä¾› `AlphabetLearningView` / é¢˜å‹å¼•æ“ä½¿ç”¨ã€‚

### 7.2 è¯¾ç¨‹å…ƒæ•°æ®ï¼šALPHABET_LESSONS é›†åˆ + lessonMetadata.config.ts

- åç«¯é›†åˆ `ALPHABET_LESSONS`ï¼š
  - å­—æ®µä¸ `LessonMetadata` å¯¹é½ï¼›
  - ç”¨äº memory-engine å’Œå‰ç«¯ `getAlphabetLessons` handlerã€‚

- å‰ç«¯ `lessonMetadata.config.ts`ï¼š
  - æœ¬åœ°å¤‡ä»½ï¼ˆå›é€€é€»è¾‘ä½¿ç”¨ï¼‰ï¼›
  - å­—æ®µï¼š
    - `lessonId`, `title`, `description`ï¼›
    - `consonants[]`, `vowels[]`, `tones[]`ï¼›
    - `phonicsRuleId`, `totalCount`, `minPassRate`, `miniReviewInterval`, `order`ã€‚

### 7.3 è®°å¿†çŠ¶æ€ï¼šMEMORY_STATUS + USER_ALPHABET_PROGRESS

- `MEMORY_STATUS`ï¼š
  - `userId`, `entityType = 'letter'`, `entityId`ï¼›
  - `masteryLevel`, `reviewStage`, `correctCount`, `wrongCount`, `streakCorrect`, `nextReviewAt`, `isNew`ã€‚
  - æ‰€æœ‰å¯¹/é”™ç»“æœé€šè¿‡ `submitMemoryResult` å†™å…¥ã€‚

- `USER_ALPHABET_PROGRESS`ï¼š
  - `userId`, `lessonId`, `currentRound`, `roundHistory[]`ï¼›
  - ä¸‰è½®è¯„ä¼°ç»“æœé€šè¿‡ `submitRoundEvaluation` å†™å…¥ã€‚

### 7.4 å­—æ¯æ¨¡å—â€œåˆ†æ•° / ç»Ÿè®¡â€å¦‚ä½•è®¡ç®—

å­—æ¯æ¨¡å—ç›®å‰æœ‰ä¸¤å±‚â€œåˆ†æ•°/ç»Ÿè®¡â€ï¼Œåˆ†åˆ«å¯¹åº”çŸ­æœŸå’Œé•¿æœŸï¼š

1. **çŸ­æœŸï¼šå•è¯¾ä¸‰è½®è¯„ä¼°ï¼ˆRoundEvaluationï¼‰**
   - åœ¨ `useAlphabetLearningEngine.submitRoundResults` ä¸­æŒ‰å¦‚ä¸‹æ–¹å¼è®¡ç®—ï¼š
     - `totalQuestions = todayList.length`ï¼ˆæœ¬è¯¾å½“å‰è½®æ¬¡å®é™…å‡ºç°è¿‡çš„å­—æ¯æ•°é‡ï¼‰ï¼›
     - `wrongAnswers: Set<string>` è®°å½•å½“å‰è½®ä¸­â€œæ›¾ç»ç­”é”™è¿‡çš„å­—æ¯ IDâ€ï¼ˆæŒ‰ alphabetId å»é‡ï¼‰ï¼›
     - `correctCount = totalQuestions - wrongAnswers.size`ï¼›
     - `accuracy = correctCount / totalQuestions`ï¼ˆ0~1 ä¹‹é—´ï¼‰ï¼›
     - `passed = wrongAnswers.size / totalQuestions <= 0.1`ï¼ˆé”™é¢˜æ¯”ä¾‹ â‰¤ 10% è§†ä¸ºé€šè¿‡ï¼‰ã€‚
   - è¯¥ç»Ÿè®¡ç»“æœï¼š
     - ä¸€æ–¹é¢ä¿å­˜åœ¨ Hook çš„æœ¬åœ°çŠ¶æ€ `roundEvaluation.rounds` ä¸­ï¼Œç”¨äºå®Œæˆé¡µå±•ç¤ºï¼›
     - å¦ä¸€æ–¹é¢é€šè¿‡ `alphabetStore.submitRoundEvaluation` å†™å…¥ `user_alphabet_progress.roundHistory`ï¼Œä¾›åç«¯ç»Ÿè®¡ä¸è§£é”é€»è¾‘ä½¿ç”¨ã€‚

2. **é•¿æœŸï¼šè®°å¿†æ›²çº¿ä¸ masteryï¼ˆmemory-engineï¼‰**
   - æ¯é“é¢˜çš„å¯¹/é”™éƒ½ä¼šè°ƒç”¨ `submitMemoryResult(userId, quality)`ï¼š
     - å‰ç«¯åªåŒºåˆ† `isCorrect: boolean`ï¼›
     - Store å°†å…¶æ˜ å°„ä¸º `QualityButton.KNOW | QualityButton.FORGET`ï¼Œå‘é€ç»™ memory-engineï¼›
   - memory-engine å†…éƒ¨é€šè¿‡ `computeNextReview(doc, quality)`ï¼š
     - æ›´æ–° `masteryLevel`, `reviewStage`, `nextReviewAt`, `correctCount`, `wrongCount`, `streakCorrect` ç­‰ï¼›
     - è¿™äº›å­—æ®µå†³å®šæœªæ¥è¯¥å­—æ¯å‡ºç°åœ¨â€œæ˜¨æ—¥å¤ä¹  / ä»Šæ—¥å¤ä¹ â€çš„é¢‘ç‡å’Œæ—¶æœºã€‚
   - å‰ç«¯çš„ `alphabetStore.completedCount`ï¼š
     - ä»…ä½œä¸ºâ€œæœ¬è®¾å¤‡æœ¬æ¬¡å­¦ä¹ ä¼šè¯çš„å®Œæˆæ•°é‡ç»Ÿè®¡â€ï¼Œç”¨äºè¯¾ç¨‹è§£é”ï¼›
     - ä¸ç›´æ¥ç­‰åŒäº `masteryLevel`ï¼Œè€Œæ˜¯ä¸€ä¸ªæ›´â€œç²—ç²’åº¦â€çš„è§†è§’ã€‚

---

## 8. å…¸å‹ç”¨ä¾‹ä¸ç«¯åˆ°ç«¯æ—¶åºï¼ˆä»ç‚¹å‡»â€œå¼€å§‹å­¦ä¹ â€åˆ°è¯¾ç¨‹å®Œæˆï¼‰

### 8.1 ä» Lesson å¡ç‰‡åˆ°å¼€å§‹åˆ·é¢˜ï¼ˆæ›´ç»†è‡´è°ƒç”¨ç¤ºæ„ï¼‰

```text
æ­¥éª¤è§†å›¾ï¼ˆä¸Šâ†’ä¸‹ï¼‰ï¼š

  [User]
    ç‚¹å‡» app/alphabet/index.tsx ä¸­ LessonX å¡ç‰‡ä¸Šçš„ã€Œå¼€å§‹å­¦ä¹ ã€æŒ‰é’®
        â”‚
        â–¼
  [app/alphabet/index.tsx]
    è°ƒç”¨ router.push('/alphabet/lessonX')
        â”‚
        â–¼
  [expo-router]
    åŒ¹é…åˆ° app/alphabet/[lessonId].tsx
        â”‚
        â–¼
  [app/alphabet/[lessonId].tsx]
    1. é€šè¿‡ useLocalSearchParams() è·å– lessonId='lessonX'
    2. è°ƒç”¨ const engine = useAlphabetLearningEngine(lessonId)
    3. å°† engine è¿”å›çš„å…¨éƒ¨å­—æ®µé€ä¼ ç»™ <AlphabetLearningEngineView {...engine} />
        â”‚
        â–¼
  [useAlphabetLearningEngine(lessonId)]
    é¦–æ¬¡æ¸²æŸ“æ—¶ useEffect è§¦å‘ï¼š
      a. è°ƒç”¨ alphabetStore.initializeSession(userId, { lessonId })
           â”‚
           â–¼
      b. alphabetStore.initializeSession å†…éƒ¨ï¼š
           - ç»„è£…è¯·æ±‚ä½“ï¼š
               action = 'getTodayMemories'
               data   = { userId, entityType:'letter', limit, includeNew:true, lessonId }
           - è°ƒç”¨ callCloudFunction<TodayLettersResponse>(
               'getTodayMemories',
               data,
               { endpoint: API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase }
             )
               â”‚
               â–¼
      c. callCloudFunctionï¼š
           - é€šè¿‡ apiClient.post() è°ƒç”¨åç«¯ HTTP è§¦å‘å™¨ /memory-engine
           - å‘é€ body: { action:'getTodayMemories', data:{...} }
               â”‚
               â–¼
  [memory-engine/index.js]
    - è§£æ event.bodyï¼Œå¾—åˆ° { action:'getTodayMemories', data }
    - åˆ†å‘åˆ° handlers/getTodayMemories(db, data)
        â”‚
        â–¼
  [handlers/getTodayMemories.js]
    1. ä» alphabet_lessons ä¸­æŸ¥è¯¢ lessonId å¯¹åº”çš„è¯¾ç¨‹å®šä¹‰ï¼›
    2. ä» letters é›†åˆä¸­æŸ¥è¯¢å±äºè¯¥ lessonId çš„æ‰€æœ‰å­—æ¯ï¼›
    3. ä» memory_status ä¸­æŸ¥è¯¢ userId + entityType:'letter' + entityId çš„è®°å¿†çŠ¶æ€ï¼›
    4. ç»„è£…ï¼š
       items: Array<Letter & { memoryState?: MemoryStatus }>
       summary: { total, newCount, reviewCount, entityType:'letter' }
       lessonMetadata: å½“å‰è¯¾çš„å…ƒæ•°æ®
       phonicsRule: å½“å‰è¯¾çš„æ‹¼è¯»è§„åˆ™
    5. ä½¿ç”¨ createResponse(true, { items, summary, lessonMetadata, phonicsRule }, ...) è¿”å›
        â”‚
        â–¼
  [callCloudFunction / alphabetStore.initializeSession]
    - å°† response.data.items æ˜ å°„ä¸º queue: AlphabetLearningState[]
    - è®¾ç½® currentItem = queue[0]
    - å†™å…¥ lessonMetadata / phonicsRule åˆ° alphabetStore
    - å¯åŠ¨é¢„ä¸‹è½½éŸ³é¢‘ä»»åŠ¡ï¼Œå¡«å…… letter.*LocalPath / alphabet.audioUrl
        â”‚
        â–¼
  [useAlphabetLearningEngine]
    - çœ‹åˆ° initializeSession æˆåŠŸï¼Œè®¾ç½®ï¼š
        initialized = true
        phase = 'yesterday-review'ï¼ˆè‹¥é˜Ÿåˆ—å­˜åœ¨éæ–°å­—æ¯ï¼‰ï¼›å¦åˆ™ç›´æ¥ 'today-learning'
    - è®¡ç®— letterPool = queue.map(item => item.letter)
        â”‚
        â–¼
  [AlphabetLearningEngineView]
    - æ ¹æ® phase æ¸²æŸ“ï¼š
        'yesterday-review' â†’ AlphabetReviewViewï¼ˆå¤ä¹ ï¼‰
        'today-learning'   â†’ AlphabetLearningView / PhonicsRuleCard
        ...
```

### 8.2 ç”¨æˆ·ç­”é¢˜å¹¶å®Œæˆä¸€è½®ï¼ˆå•é¢˜ç²’åº¦ï¼‰

```text
å‚ä¸è€…ï¼š
  User           ç”¨æˆ·
  AlphabetLearningEngineViewï¼ˆç®€ç§° EngineViewï¼‰
  AlphabetReviewView / MiniReviewQuestionComponent / å…¶ä»–é¢˜ç›®ç»„ä»¶
  useAlphabetLearningEngineï¼ˆç®€ç§° Engineï¼‰
  alphabetStoreï¼ˆç®€ç§° Storeï¼‰
  callCloudFunctionï¼ˆç®€ç§° APIï¼‰
  memory-engine.submitMemoryResultï¼ˆç®€ç§° CFï¼‰

è¯¦ç»†æ­¥éª¤ï¼ˆä»¥æ™®é€šå¤ä¹ é¢˜ä¸ºä¾‹ï¼‰ï¼š

1. EngineView æ ¹æ®å½“å‰ phase æ¸²æŸ“ AlphabetReviewViewï¼š
     - props ä¸­å¸¦å…¥ï¼š
         alphabet        = currentItem
         letterPool      = letterPool
         preferredType   = currentQuestionType
         onAnswer        = Engine.onAnswer
         onNext          = Engine.onNext

2. AlphabetReviewView å†…ï¼š
     a. è°ƒç”¨ generateAlphabetQuestion(letter, pool, preferredType)
        å¾—åˆ° question: { stem, options, correct, audioUrl, type }
     b. æ¸²æŸ“é¢˜å¹²å’Œé€‰é¡¹ï¼Œç”¨æˆ·ç‚¹å‡»æŸä¸ªé€‰é¡¹ã€‚

3. ç”¨æˆ·ç‚¹å‡»é€‰é¡¹åï¼ŒAlphabetReviewView åšæœ¬åœ°åˆ¤å®šï¼š
     - isCorrect = (é€‰ä¸­çš„ value === question.correct)
     - è°ƒç”¨ onAnswer(isCorrect, question.type)

4. Engine.onAnswer(isCorrect, questionType) å†…éƒ¨ï¼š
     a. è‹¥ currentItem ä¸ºç©ºåˆ™ç›´æ¥ returnï¼›
     b. è°ƒç”¨ Store.submitResult(userId, isCorrect)ï¼š
          - è´¨é‡æ˜ å°„ï¼š
              isCorrect === true  â†’ QualityButton.KNOW
              isCorrect === false â†’ QualityButton.FORGET
          - è°ƒç”¨ API.post('/memory-engine', {
                action: 'submitMemoryResult',
                data: { userId, entityType:'letter', entityId: currentItem.alphabetId, quality }
            })
     c. å¦‚æœ isCorrect === falseï¼š
          wrongAnswers = wrongAnswers âˆª { currentItem.alphabetId }

5. memory-engine.submitMemoryResultï¼š
     a. åœ¨ memory_status é›†åˆä¸­æ ¹æ® { userId, entityType:'letter', entityId } æŸ¥è¯¢å½“å‰è®°å½•ï¼›
     b. ä½¿ç”¨ computeNextReview(doc, quality) è®¡ç®—ä¸‹ä¸€æ¬¡å¤ä¹ å‚æ•°ï¼š
          - æ›´æ–° masteryLevelã€reviewStageã€nextReviewAtã€correctCountã€wrongCount ç­‰ï¼›
     c. æ›´æ–°æˆ–æ’å…¥è¯¥è®°å½•ï¼›
     d. è¿”å› createResponse(true, null, 'æäº¤è®°å¿†ç»“æœæˆåŠŸ')ã€‚

6. Store.submitResult æ”¶åˆ°æˆåŠŸå“åº”åï¼š
     a. åœ¨æœ¬åœ° queue[currentIndex] ä¸Šæ›´æ–°ï¼š
          currentAttempts += ATTEMPTS_INCREMENT_MAP[quality]
          qualityHistory.push(QUALITY_SCORE_MAP[quality])
          è‹¥ currentAttempts >= requiredAttempts â†’ isCompleted = true
     b. é‡æ–°è®¡ç®— completedCount = é˜Ÿåˆ—ä¸­ isCompleted === true çš„é¡¹æ•°ï¼›
     c. è°ƒç”¨ Store.next()ï¼ˆå³ Engine çœ‹åˆ°çš„ nextInQueueï¼‰ï¼š
          - è‹¥è¿˜æœ‰ä¸‹ä¸€é¡¹ï¼š
              currentIndex++
              currentItem = queue[currentIndex]
          - è‹¥é˜Ÿåˆ—ç»“æŸï¼š
              phase = LearningPhase.COMPLETEDï¼ˆä¼šè¯çº§ï¼‰

7. EngineView åœ¨ç”¨æˆ·ç‚¹å‡»â€œä¸‹ä¸€é¢˜â€æŒ‰é’®æ—¶è°ƒç”¨ Engine.onNext()ï¼š
     a. Engine.onNext å†…éƒ¨ï¼š
          - è‹¥ phase === 'today-learning'ï¼š
              å°† currentItem è¿½åŠ åˆ° todayListï¼Œå¹¶é€’å¢ learnedCountï¼›
              æ¯å­¦æ»¡ MINI_REVIEW_INTERVALï¼ˆ3ï¼‰ä¸ªï¼Œè°ƒç”¨ triggerMiniReview() è¿›å…¥ today-mini-reviewï¼›
          - ä¸æ»¡è¶³ä¸Šè¿°æ¡ä»¶æ—¶ï¼Œç›´æ¥è°ƒç”¨ nextInQueue()ï¼ˆå³ Store.nextï¼‰ï¼›
     b. ä¸‹ä¸€æ¬¡ render æ—¶ï¼ŒEngineView ä¼šä½¿ç”¨æ–°çš„ currentItem æ¸²æŸ“ä¸‹ä¸€é“é¢˜ã€‚
```

### 8.3 ä¸‰è½®è¯„ä¼°ç»“æŸå¹¶æ ‡è®°è¯¾ç¨‹å®Œæˆï¼ˆè¯¾ç¨‹ç²’åº¦ï¼‰

```text
å‚ä¸è€…ï¼š
  useAlphabetLearningEngineï¼ˆEngineï¼‰
  alphabetStoreï¼ˆStoreï¼‰
  callCloudFunctionï¼ˆAPIï¼‰
  memory-engine.submitRoundEvaluationï¼ˆCFï¼‰
  moduleAccessStoreï¼ˆModuleStoreï¼‰

èƒŒæ™¯ï¼š
  - æ¯ä¸€è½®å­¦ä¹ ç»“æŸæ—¶ï¼ŒEngine ä¸­ä¼šç»´æŠ¤ï¼š
      todayList: AlphabetLearningState[]   // æœ¬è½®çœŸæ­£å‡ºè¿‡é¢˜çš„æ‰€æœ‰å­—æ¯
      wrongAnswers: Set<string>           // æœ¬è½®æ›¾ç»ç­”é”™è¿‡çš„å­—æ¯ ID é›†åˆ

æ­¥éª¤ï¼š

1. ä¸€è½®ï¼ˆcurrentRoundï¼‰çš„æ‰€æœ‰ Phase ç»“æŸåï¼ŒEngine è°ƒç”¨ submitRoundResults()ï¼š
     - totalQuestions = todayList.length
     - wrongCount     = wrongAnswers.size
     - correctCount   = totalQuestions - wrongCount
     - accuracy       = correctCount / totalQuestions
     - passed         = (wrongCount / totalQuestions) <= 0.1
     - roundData = {
         roundNumber: currentRound,
         totalQuestions,
         correctCount,
         accuracy,
         passed
       }

2. Engine å°† roundData åˆå¹¶åˆ°æœ¬åœ° roundEvaluation çŠ¶æ€ï¼š
     roundEvaluation.rounds.push(roundData)
     roundEvaluation.currentRound = currentRound

3. Engine è°ƒç”¨ Store.submitRoundEvaluation({
       userId,
       entityType: 'letter',
       lessonId,
       roundNumber,
       totalQuestions,
       correctCount,
       accuracy,
     })ã€‚

4. Store.submitRoundEvaluation é€šè¿‡ API è°ƒç”¨ï¼š
     callCloudFunction('submitRoundEvaluation', { ... }, { endpoint: /memory-engine })
     â†’ memory-engine.handlers.submitRoundEvaluationï¼š
         - åœ¨ user_alphabet_progress é›†åˆä¸­ï¼š
             * å¦‚æœä¸å­˜åœ¨ { userId, lessonId } è®°å½•ï¼Œåˆ™åˆ›å»ºï¼›
             * æ›´æ–° currentRound = roundNumberï¼›
             * ä½¿ç”¨ db.command.push(roundData) å°†è¯¥è½®ç»“æœè¿½åŠ åˆ° roundHistoryã€‚

5. æˆåŠŸè¿”å›åï¼ŒEngine æ ¹æ® currentRound ä¸ passed è¿›è¡Œåˆ†æ”¯ï¼š
     a. è‹¥ currentRound < 3 ä¸” passed === trueï¼š
          - setCurrentRound(currentRound + 1 as 1|2|3)
          - setWrongAnswers(new Set())    // æ¸…ç©ºé”™é¢˜æ± 
          - setPhase('yesterday-review')  // ä¸‹ä¸€è½®ä»æ˜¨æ—¥å¤ä¹  Phase å†èµ°ä¸€éæµç¨‹

     b. è‹¥ currentRound == 3 ä¸” passed === trueï¼š
          - è°ƒç”¨ moduleAccessStore.markAlphabetLessonCompleted(lessonId)ï¼š
               * ç”¨äºæ›´æ–°æ¨¡å—è§£é”çŠ¶æ€ï¼ˆä¾‹å¦‚è§£é”åç»­è¯¾ç¨‹/æ¨¡å—ï¼‰
          - setPhase('finished')ï¼š
               * AlphabetLearningEngineView åœ¨è¯¥ Phase ä¸‹å±•ç¤ºä¸‰è½®è¯„ä¼°ç»“æœå’Œè¯¾ç¨‹å®Œæˆæç¤ºã€‚

     c. è‹¥æŸè½® passed === falseï¼ˆé”™è¯¯ç‡ > 10%ï¼‰ï¼š
          - Engine å¯ä»¥æ ¹æ®ä¸šåŠ¡éœ€è¦ï¼š
               * å›åˆ° today-remedy / today-final-review ç­‰ Phase åŠ å¼ºç»ƒä¹ ï¼›
               * æˆ–ä¿æŒ currentRound ä¸å˜ï¼Œè¦æ±‚ç”¨æˆ·é‡æ–°åˆ·ä¸€è½®ï¼ˆå®ç°ç»†èŠ‚å¯æŒ‰åç»­è®¾è®¡è¡¥å……ï¼‰ã€‚
```
```

---

## 9. æ‰©å±•ä¸å®ç°æ³¨æ„äº‹é¡¹

1. **ä¸è¦åœ¨ç»„ä»¶ä¸­ç›´æ¥è°ƒç”¨äº‘å‡½æ•°**  
   - æ‰€æœ‰ç½‘ç»œè¯·æ±‚å¿…é¡»é€šè¿‡ Store / Hookï¼ˆ`alphabetStore` + `useAlphabetLearningEngine`ï¼‰å®Œæˆï¼›
   - `AlphabetLearningView` / `AlphabetReviewView` åº”ä¿æŒçº¯ UI + å±€éƒ¨äº¤äº’ã€‚

2. **ä¸è¦åœ¨å‰ç«¯å†™æ­»è¯¾ç¨‹ç»“æ„**  
   - è¯¾ç¨‹è¡¨ä»¥ `alphabet_lessons` + `phonics_rules` ä¸ºå‡†ï¼›
   - `lessonMetadata.config.ts` ä»…ä½œä¸ºå›é€€æ•°æ®ï¼›
   - è‹¥è¯¾ç¨‹å¢å‡ï¼Œè¯·åŒæ—¶æ›´æ–°è¿™ä¸¤å¤„å¹¶åœ¨æ­¤ spec æ–‡æ¡£ä¸­æ³¨æ˜ã€‚

3. **æ–°å¢é¢˜å‹æ—¶éµå®ˆ Question Engine åè®®**  
   - æ–°é¢˜å‹å¿…é¡»å…ˆåœ¨æœ¬ spec çš„ Question Engine å°èŠ‚ä¸­å®šä¹‰ `GameType` + payload ç»“æ„ï¼›  
   - ç„¶ååœ¨ QuestionRenderer ä¸­å¢åŠ  caseï¼›  
   - å†ç”± FlowGenerator å†³å®šåœ¨å“ªä¸ª Round / Phase ä½¿ç”¨ã€‚

4. **ç¡®ä¿éŸ³é¢‘åªä»æœ¬åœ°æ’­æ”¾**  
   - æ–°å¢ä»»ä½•å­—æ¯éŸ³é¢‘å­—æ®µæ—¶ï¼Œåº”éµå®ˆï¼š
     - åç«¯ï¼šåªå­˜å‚¨ COS key / ç›¸å¯¹è·¯å¾„ï¼›
     - å‰ç«¯ï¼šåœ¨ `alphabetStore.initializeSession` é¢„ä¸‹è½½åˆ° `file://`ï¼Œå¹¶å†™å…¥ `*LocalPath` å­—æ®µï¼›
     - ç»„ä»¶åªä½¿ç”¨æœ¬åœ°è·¯å¾„ã€‚

5. **æ‰€æœ‰å¯¹/é”™éƒ½è¦è¿›å…¥ memory-engine**  
   - ç¦æ­¢åœ¨å‰ç«¯â€œä¸´æ—¶æä¸€ä¸ªé”™é¢˜æœ¬é›†åˆâ€ï¼›  
   - é”™é¢˜æ± åªåœ¨ Hook å†…å­˜ä¸­å­˜åœ¨ï¼Œç”¨äºä¸‰è½®è¯„ä¼°ï¼Œä¸è¿›å…¥ DBï¼›  
   - é•¿æœŸè®°å¿†/å¤ä¹ ç»Ÿä¸€é€šè¿‡ `memory_status` å’Œåç«¯ç®—æ³•ç®¡ç†ã€‚

---

### 9.1 Session çŠ¶æ€ vs è®°å¿†å¼•æ“çŠ¶æ€ï¼ˆå‰ç«¯ / åç«¯åˆ†å·¥ï¼‰

> ä¸ºé¿å…â€œå‰ç«¯å†é€ ä¸€å¥—è®°å¿†å¼•æ“â€ï¼Œå¿…é¡»æ¸…æ™°åŒºåˆ†ï¼š  
> å“ªäº›çŠ¶æ€åªåœ¨æœ¬åœ° Session ä½¿ç”¨ï¼Œå“ªäº›å¿…é¡»å†™å…¥ memory-engineã€‚

**æœ¬åœ° Session çº§çŠ¶æ€ï¼ˆåªå½±å“å½“å¤©è¯¥è¯¾çš„è„šæœ¬ä¸ UIï¼Œä¿å­˜åœ¨ alphabetStore / Hook ä¸­ï¼Œå¯æŒä¹…åŒ–ï¼‰ï¼š**

- `queue`ï¼šæœ¬æ¬¡è¿›å…¥è¯¥è¯¾æ—¶çš„å­—æ¯é˜Ÿåˆ—ï¼ˆæ¥è‡ª getTodayMemories æ•´è¯¾è¿”å›ï¼‰ã€‚  
- `todayList`ï¼šä»Šæ—¥åœ¨ Round1 å†…å·²ç»å­¦ä¹ è¿‡çš„æ–°å­—æ¯åˆ—è¡¨ã€‚  
- `todayNewLetters: Set<alphabetId>`ï¼šä»Šæ—¥å‡ºç°è¿‡çš„æ‰€æœ‰æ–°å­—æ¯ IDã€‚  
- `todayReviewedLetters: Set<alphabetId>`ï¼šåœ¨å½“æ—¥è½»é‡é¢˜ / Mini Review ä¸­å·²ç»åšè¿‡é¢˜çš„æ–°å­—æ¯ IDã€‚  
- `wrongAnswers: Set<alphabetId>`ï¼šå½“å‰ Round å†…æ›¾ç»ç­”é”™è¿‡çš„å­—æ¯ IDï¼ˆç”¨äºç»Ÿè®¡ & è¡¥æ•‘ï¼‰ã€‚  
- `currentRound: 1 | 2 | 3`ï¼šå½“å‰è½®æ¬¡ã€‚  
- `roundEvaluation`ï¼šä»…ç”¨äº UI å±•ç¤ºæ¯è½® accuracy/passedï¼Œä¸ç›´æ¥å‚ä¸ SM-2ã€‚  
- `phase`ï¼šä»Šæ—¥è¯¾ç¨‹è„šæœ¬çš„é˜¶æ®µï¼ˆæ˜¨æ—¥å¤ä¹  / ä»Šæ—¥å­¦ä¹  / Mini Review / Final Review / Remedy / finishedï¼‰ã€‚  

è¿™äº›çŠ¶æ€å¯ä»¥ç”¨ AsyncStorage åšè½»é‡æŒä¹…åŒ–ï¼Œç”¨äºâ€œä¸­é€”é€€å‡º â†’ ä¸‹æ¬¡æ¢å¤åˆ°ç›¸è¿‘é˜¶æ®µâ€ï¼Œä½†**ä¸è¢«åç«¯ä¾èµ–**ã€‚

**è®°å¿†å¼•æ“çº§çŠ¶æ€ï¼ˆå”¯ä¸€çœŸç›¸ï¼Œå­˜æ”¾åœ¨ CloudBase DB ä¸­ï¼‰ï¼š**

- `memory_status`ï¼šper-letter è®°å¿†çŠ¶æ€ï¼Œç®—æ³•åªå…³å¿ƒï¼š
  - `userId, entityType:'letter', entityId`ï¼›  
  - `masteryLevel, reviewStage, nextReviewAt, correctCount, wrongCount, streakCorrect, isNew` ç­‰ã€‚  
- `user_alphabet_progress`ï¼šper-lesson è½®æ¬¡ç»Ÿè®¡ï¼Œç”¨äºæ¨¡å—è§£é” / æŠ¥å‘Šå±•ç¤ºï¼š  
  - `currentRound, roundHistory[]`ã€‚

**çº¦æŸï¼š**

- Session çº§çŠ¶æ€å¯ä»¥éšå‰ç«¯ç‰ˆæœ¬æ¼”è¿›è€Œå˜åŒ–ï¼Œåªè¦ä¸ç¯¡æ”¹ DBï¼›  
- è®°å¿†å¼•æ“çº§çŠ¶æ€åªèƒ½é€šè¿‡ `submitMemoryResult` / `submitRoundEvaluation` ä¿®æ”¹ï¼›  
- `getTodayMemories(entityType:'letter', lessonId)` çš„å®ç°åº”æŒ‰ lessonId è¯­ä¹‰è¿”å›â€œæ•´è¯¾å­—æ¯é›† + memoryStateâ€ï¼Œä¸è¯»å–å‰ç«¯ Session çŠ¶æ€ã€‚

### 9.2 è½®æ¬¡ä¸è¯„åˆ†è§„åˆ™ï¼ˆæŒ‰å­—æ¯èšåˆè´¨é‡ï¼‰

> 3 è½®æœºåˆ¶ = è¯¾ç¨‹çº§è®­ç»ƒè„šæœ¬ï¼›SM-2 = è·¨å¤©è®°å¿†è°ƒåº¦ï¼Œä¸¤è€…é€šè¿‡â€œè´¨é‡å€¼ Qualityâ€è¡”æ¥ã€‚

**å½“å‰ç­–ç•¥ï¼ˆé¢˜çº§æäº¤ï¼Œå·²å®ç°ï¼‰ï¼š**

- æ¯é“é¢˜ç»“æŸæ—¶è°ƒç”¨ `submitResult(userId, isCorrect)`ï¼š  
  - å‰ç«¯å°† `isCorrect` æ˜ å°„ä¸º `QualityButton.KNOW / FORGET`ï¼›  
  - Store å†…éƒ¨è°ƒç”¨ `submitMemoryResult` å†™å…¥ `memory_status`ï¼›  
  - Session çº§é”™é¢˜é›†åˆ `wrongAnswers` åªç”¨äº RoundEvaluation å’Œè¡¥æ•‘é€»è¾‘ã€‚
- ä¼˜ç‚¹ï¼šå®ç°ç®€å•ï¼Œå·²æœ‰ä»£ç å¯ç”¨ï¼›  
- ç¼ºç‚¹ï¼šåŒä¸€ä¸ªå­—æ¯åœ¨ä¸€è½®å†…å¯èƒ½å¤šæ¬¡å†™å…¥ qualityï¼ŒSM-2 ç®—æ³•éœ€è¦è€ƒè™‘â€œé«˜é¢‘è§‚æµ‹â€çš„å½±å“ã€‚

**å¯é€‰å‡çº§ç­–ç•¥ï¼ˆæ¯å­—æ¯æ¯è½®ä¸€æ¬¡æäº¤ï¼Œæœªæ¥è¿­ä»£ï¼‰ï¼š**

- åœ¨ Hook ä¸­è®°å½• per-letter / per-round è¡Œä¸ºï¼Œä¾‹å¦‚ï¼š

  ```ts
  type LetterRoundStats = {
    attempts: number;
    wrongCount: number;
    everCorrect: boolean;
    usedHint: boolean;
  };
  // Map<alphabetId, LetterRoundStats>
  ```

- å½“æŸä¸ªå­—æ¯åœ¨å½“å‰ Round çš„â€œæ‰€æœ‰é¢˜ + é”™é¢˜è¡¥æ•‘â€ç»“æŸæ—¶ï¼š
  - ä½¿ç”¨ `wrongCount / attempts / everCorrect / usedHint` è®¡ç®—å‡º 3 æ¡£è´¨é‡ï¼š
    - è®°å¾—ï¼ˆKNOWï¼‰ï¼šå…¨ç¨‹æ— é”™ï¼Œä¸”æ›¾ç­”å¯¹ï¼›  
    - æ¨¡ç³Šï¼ˆFUZZYï¼‰ï¼šæœ‰ 1~2 æ¬¡é”™è¯¯ï¼Œä½†æœ€ç»ˆç­”å¯¹ä¸”æœªä¾èµ–å®Œæ•´ç­”æ¡ˆï¼›  
    - å¿˜è®°ï¼ˆFORGETï¼‰ï¼šé”™è¯¯ â‰¥3 æ¬¡ï¼Œæˆ–éœ€è¦çœ‹ç­”æ¡ˆã€‚  
  - ä»…æäº¤ä¸€æ¬¡ï¼š

    ```ts
    submitMemoryResult({
      userId,
      entityType: 'letter',
      entityId: alphabetId,
      quality: QualityButton.KNOW | FUZZY | FORGET,
    });
    ```

- Round1/2/3 å¯ä»¥å„æäº¤ä¸€æ¬¡è´¨é‡ï¼›RoundEvaluation ä»åªåšè¯¾ç¨‹çº§ç»Ÿè®¡ä¸è§£é”åˆ¤å®šã€‚

### 9.3 Round ä¸è¯¾ç¨‹çº§å¤ä¹  / é•¿æœŸå¤ä¹ çš„å…³ç³»ï¼ˆè®¾è®¡çº¦å®šï¼‰

- **è¯¾ç¨‹çº§è®­ç»ƒæ¨¡å¼ï¼ˆlessonId æ¨¡å¼ï¼‰**ï¼š
  - å½“å‰å­—æ¯æ¨¡å—ä¸»è¦ä½¿ç”¨ `getTodayMemories(entityType:'letter', lessonId)`ï¼›  
  - çº¦å®šï¼šåªè¦è¯¥è¯¾ `currentRound < 3`ï¼Œè¯¥æ¥å£åº”è¿”å›æ•´è¯¾æ‰€æœ‰å­—æ¯ï¼ˆä¸æŒ‰ SM-2 è¿‡æ»¤ï¼‰ï¼Œä»¥ä¾¿å®Œæˆè¯¾ç¨‹å†… 3 è½®è®­ç»ƒè„šæœ¬ã€‚  
  - å³ä¾¿ Round è¢«æ‹†æˆå¤šå¤©å®Œæˆï¼Œä»è§†ä¸ºâ€œè¯¾ç¨‹è®­ç»ƒè¿‡ç¨‹çš„ä¸€éƒ¨åˆ†â€ï¼Œä¸å¼ºåˆ¶æŒ‰æ—¥åˆ‡ç‰‡ã€‚

- **é•¿æœŸ SRS æ¨¡å¼ï¼ˆæœªæ¥å¯é€‰ï¼Œæ—  lessonIdï¼‰**ï¼š
  - è‹¥å°†æ¥æ–°å¢â€œå­—æ¯ç»¼åˆå¤ä¹ ä¸­å¿ƒâ€ï¼Œå¯è°ƒç”¨ä¸å¸¦ lessonId çš„ï¼š
    `getTodayMemories({ entityType:'letter', includeNew:false })`ï¼Œè®© SM-2 æŒ‰ `nextReviewAt` è‡ªç”±è°ƒåº¦æ‰€æœ‰è¯¾ä¸­çš„åˆ°æœŸå­—æ¯ã€‚  
  - è¯¥æ¨¡å¼ä¸è¯¾ç¨‹çº§è®­ç»ƒæ¨¡å¼ç‹¬ç«‹ï¼Œä¸å½±å“å½“å‰ Lesson æµç¨‹ä¸è§£é”é€»è¾‘ã€‚

- **è¯¾ç¨‹ç»“æŸä¸â€œé€€å½¹â€å­—æ¯ï¼š**
  - å½“ `moduleAccessStore.userProgress.letterCompleted === true`ï¼ˆæ ¸å¿ƒ 6 è¯¾å®Œæˆï¼‰æ—¶ï¼Œ  
    é»˜è®¤ä¸å†è°ƒç”¨ `getTodayMemories(letter, lessonId)` ä½œä¸ºæ¯æ—¥ä»»åŠ¡ï¼›  
  - å­—æ¯ä¸ä¼šåœ¨æ—¥å¸¸å­¦ä¹ ï¼ˆä¾‹å¦‚è¯æ±‡æ¨¡å—ï¼‰ä¸­åå¤å‡ºç°ï¼Œé™¤éç”¨æˆ·æ˜¾å¼è¿›å…¥æŸä¸ªâ€œå­—æ¯å¤ä¹ æ¨¡å¼â€ã€‚

---

## 10. å®æ–½å·¥å•ä¸é‡Œç¨‹ç¢‘ï¼ˆAlphabet Moduleï¼‰

> æœ¬å°èŠ‚ä¸ºå¼€å‘è½åœ°å‡†å¤‡ä¸€ä¸ª checklistï¼ŒæŒ‰ä¼˜å…ˆçº§è§„åˆ’è¿­ä»£ã€‚

### 10.1 P0ï¼šä¿æŒç°æœ‰è¡Œä¸ºï¼Œè¡¥é½è§£é”é€»è¾‘ä¸æ–‡æ¡£

ç›®æ ‡ï¼šåœ¨ä¸å¤§æ”¹ä»£ç çš„å‰æä¸‹ï¼Œä½¿å½“å‰å®ç°ä¸ Spec çš„â€œè§£é”æ¡ä»¶ / è¯¾ç¨‹æµç¨‹â€åŸºæœ¬ä¸€è‡´ã€‚

- [ ] æ˜ç¡® `submitRoundResults` è°ƒç”¨æ—¶æœºï¼Œå¹¶åœ¨å®ç°ä¸­ç¡®ä¿åªåœ¨å®Œæ•´è½®æ¬¡ç»“æŸæ—¶è°ƒç”¨ã€‚  
- [ ] åœ¨ `useAlphabetLearningEngine` ä¸­ï¼Œåªæœ‰å½“ `passed === true` ä¸” `currentRound === 3` æ—¶æ‰è°ƒç”¨ `markAlphabetLessonCompleted(lessonId)`ï¼ˆæˆ–æ ¹æ®éœ€è¦è®¾ç½®é€šè¿‡é˜ˆå€¼ï¼‰ï¼Œé¿å…â€œæœªé€šè¿‡ä¹Ÿè§£é”ä¸‹ä¸€è¯¾â€ã€‚  
- [ ] æ ¹æ®å®é™…å®ç°ï¼Œå¯¹æ–‡æ¡£ä¸­çš„ Round æµç¨‹ä¸è§£é”æ¡ä»¶è¿›è¡Œä¸€æ¬¡æœ€ç»ˆæ ¸å¯¹ï¼ˆæœ¬ Spec å·²ç»™å‡ºç›®æ ‡è®¾è®¡ï¼Œå¯æ®æ­¤æ¯”å¯¹ä»£ç ï¼‰ã€‚

### 10.2 P1ï¼šå®Œå–„ Phase æµç¨‹ä¸é”™é¢˜è¡¥æ•‘ï¼ˆRound1 å†…ï¼‰

ç›®æ ‡ï¼šè®© Round1 å†…çš„â€œæ˜¨æ—¥å¤ä¹  â†’ ä»Šæ—¥å­¦ä¹  + ä¸‰æ–°ä¸€å¤ â†’ Final Reviewï¼ˆè¡¥é½ä»Šæ—¥æœªå¤ä¹ å­—æ¯ï¼‰â†’ ä»Šæ—¥é”™é¢˜è¡¥æ•‘â€é€»è¾‘å®Œæ•´å¯ç”¨ã€‚

- [ ] åœ¨ `useAlphabetLearningEngine` ä¸­å®ç°ï¼š  
  - `yesterday-remedy` Phaseï¼šåŸºäºæ˜¨æ—¥é”™é¢˜é›†åˆï¼ˆä¾‹å¦‚ `yesterdayWrongIds`ï¼‰å‡ºé¢˜ï¼Œå…¨éƒ¨åšå¯¹åæ‰è¿›å…¥ `today-learning`ï¼›  
  - `today-final-review` Phaseï¼š  
    - ç»´æŠ¤ `todayNewLetters` / `todayReviewedLetters` é›†åˆï¼›  
    - å¯¹ `pendingFinal = todayNewLetters - todayReviewedLetters` ä¸­çš„å­—æ¯ï¼Œæ¯ä¸ªå‡º 2 é“é€»è¾‘/æ•´åˆé¢˜ï¼›  
  - `today-remedy` Phaseï¼š  
    - é’ˆå¯¹ä»Šæ—¥æ‰€æœ‰é”™é¢˜å‡ºé¢˜ï¼Œç›´åˆ°å…¨éƒ¨ç­”å¯¹ã€‚  
- [ ] åœ¨ Spec ä¸­å·²æœ‰çš„ ASCII æµç¨‹å›¾åŸºç¡€ä¸Šï¼Œä¸ºæ–°å¢ Phase è¡¥å……æ›´è¯¦ç»†çš„æ³¨é‡Šï¼Œä¾¿äºå¯¹ç…§å®ç°ã€‚

### 10.3 P2ï¼šä¸ memory-engine çš„è´¨é‡æäº¤ç­–ç•¥ç»Ÿä¸€

ç›®æ ‡ï¼šå†³å®šå¹¶å®ç°â€œé¢˜çº§æäº¤ vs å­—æ¯/è½®æ¬¡çº§æäº¤â€çš„æœ€ç»ˆæ–¹æ¡ˆã€‚

- [ ] è‹¥ç»§ç»­ä½¿ç”¨â€œæ¯é¢˜æäº¤â€æ–¹æ¡ˆï¼š  
  - å°†å…¶åœ¨ Spec ä¸­æ ‡è®°ä¸ºâ€œæ­£å¼ç­–ç•¥â€ï¼›  
  - ç¡®è®¤ `alphabetStore.submitResult` å§‹ç»ˆåŒ…å« `entityType:'letter'` ä¸æ­£ç¡®çš„ `entityId`ï¼Œå¹¶åœ¨ CloudBase æ—¥å¿—ä¸­éªŒè¯ã€‚  
- [ ] è‹¥æ¼”è¿›ä¸ºâ€œæ¯å­—æ¯æ¯è½®ä¸€æ¬¡è´¨é‡â€ï¼š  
  - åœ¨ Hook å†…å¢åŠ  per-letter per-round ç»Ÿè®¡ç»“æ„ï¼›  
  - å®ç° `computeLetterQualityForRound(letterId, stats)`ï¼›  
  - åœ¨è¯¥å­—æ¯æœ¬è½®æ‰€æœ‰é¢˜ + è¡¥æ•‘é¢˜ç»“æŸæ—¶è°ƒç”¨ä¸€æ¬¡ `submitMemoryResult`ï¼›  
  - ä¿ç•™ `submitRoundEvaluation` ä»…ç”¨äºè¯¾ç¨‹çº§å±•ç¤º/è§£é”ã€‚

### 10.4 P3ï¼šQuestion Engine é›†æˆä¸é¢˜å‹å‡çº§

ç›®æ ‡ï¼šå°†æœ¬ spec ä¸­è§„åˆ’çš„ 6 å¤§é¢˜å‹é€æ­¥æ›¿æ¢ç°æœ‰ `lettersQuestionGenerator` é¢˜å‹ã€‚

- [ ] åœ¨å‰ç«¯å®ç° `generateQueueItems(FlowContext)`ï¼Œå¹¶åœ¨ `useAlphabetLearningEngine` ä¸­å¯¹æ¥ã€‚  
- [ ] æ–°å¢ `GameContainer + StepRenderer`ï¼Œæ›¿æ¢ `AlphabetReviewView` ä¸ MiniReview å•ç‚¹é€»è¾‘ã€‚  
- [ ] åˆ†é˜¶æ®µå¼•å…¥ï¼š  
  - ç¬¬ä¸€é˜¶æ®µï¼šä¿æŒå½“å‰é¢˜å‹ï¼Œä»…é€šè¿‡ Question Engine ç»Ÿä¸€è°ƒåº¦ï¼›  
  - ç¬¬äºŒé˜¶æ®µï¼šå¼•å…¥æ‹¼è¯»æ•°å­¦ã€å£°è°ƒè®¡ç®—ç­‰é€»è¾‘é¢˜å‹ã€‚

### 10.5 é‡Œç¨‹ç¢‘è§„åˆ’

- **M1ï¼šè§£é”é€»è¾‘ä¿®æ­£ + æ–‡æ¡£å¯¹é½ï¼ˆçº¦ 1 å‘¨ï¼‰**  
  - å®Œæˆ P0ï¼›  
  - ç¡®ä¿ä¸‰è½®é€šè¿‡åæ‰è§£é”ä¸‹ä¸€è¯¾ï¼›  
  - æ›´æ–°æ–‡æ¡£ä¸ UI æ–‡æ¡ˆè¯´æ˜ã€‚  

- **M2ï¼šPhase + é”™é¢˜è¡¥æ•‘å®Œæ•´è½åœ°ï¼ˆçº¦ 2â€“3 å‘¨ï¼‰**  
  - å®Œæˆ P1ï¼›  
  - Round1 å†… Phase æµç¨‹ä¸é”™é¢˜è¡¥æ•‘å¯ç”¨ï¼›  
  - å›å½’æµ‹è¯•æ‰€æœ‰ Phase è½¬ç§»åœºæ™¯ã€‚  

- **M3ï¼šè´¨é‡æäº¤ç­–ç•¥å®šç‰ˆ + memory-engine å¯¹é½ï¼ˆçº¦ 1â€“2 å‘¨ï¼‰**  
  - å®Œæˆ P2ï¼ˆé€‰æ‹©é¢˜çº§æˆ–å­—æ¯/è½®æ¬¡çº§æ–¹æ¡ˆä¹‹ä¸€å¹¶å®ç°ï¼‰ï¼›  
  - ç¡®è®¤ CloudBase æ—¥å¿—ä¸­è´¨é‡å‚æ•°æ­£å¸¸ï¼Œ`memory_status` æ›´æ–°ç¬¦åˆé¢„æœŸã€‚  

- **M4ï¼šé¢˜å‹å‡çº§ä¸ Question Engine åˆæ­¥é›†æˆï¼ˆåç»­è¿­ä»£ï¼‰**  
  - å®Œæˆ P3 çš„ç¬¬ä¸€é˜¶æ®µï¼›  
  - è§†æ—¶é—´ä¸äº§å“è§„åˆ’å†³å®šæ˜¯å¦å¼•å…¥æ–°é¢˜å‹ã€‚  

---

æœ¬è§„æ ¼æ–‡æ¡£è¦†ç›–äº†å­—æ¯æ¨¡å—ä»è·¯ç”±ã€ç»„ä»¶ã€Hookã€Storeã€äº‘å‡½æ•°åˆ°æ•°æ®åº“å­—æ®µçš„å®Œæ•´é“¾è·¯ï¼Œå¹¶å¯¹ Session çº§çŠ¶æ€ä¸è®°å¿†å¼•æ“çŠ¶æ€çš„åˆ†å·¥ã€è½®æ¬¡è¯„åˆ†ç­–ç•¥åŠå®æ–½é‡Œç¨‹ç¢‘åšå‡ºäº†çº¦æŸã€‚  
åç»­æ–°å¢åŠŸèƒ½ï¼ˆå¦‚ 6 å¤§é¢˜å‹ Question Engineã€AI å‘éŸ³è®­ç»ƒï¼‰å¿…é¡»åœ¨æœ¬è§„èŒƒåŸºç¡€ä¸Šæ‰©å±•ï¼Œä¸å¾—ç»•å¼€æ—¢æœ‰è¾¹ç•Œã€‚

---

## 11. V2 èšåˆè¯„åˆ†ä¸ä¼šè¯æ¢å¤æ–¹æ¡ˆï¼ˆæœ€ç»ˆå®šç¨¿ï¼‰

> æœ¬èŠ‚æ˜¯åœ¨ä¸äº§å“è®¨è®ºåçš„**æœ€ç»ˆç‰ˆå­—æ¯è®°å¿†æ–¹æ¡ˆ**ï¼Œç”¨äºè¦†ç›–å’Œç»†åŒ–ä¸Šæ–‡ 9.2 / 10.3 ä¸­çš„è®¾è®¡å»ºè®®ã€‚  
> å¦‚æœæœ¬èŠ‚ä¸å‰æ–‡å­˜åœ¨å†²çªï¼Œä»¥æœ¬èŠ‚ä¸ºå‡†ã€‚

### 11.1 è®¾è®¡ç›®æ ‡å›é¡¾

- é™ä½ç½‘ç»œè°ƒç”¨é¢‘ç‡ï¼šä¸å†æŒ‰â€œæ¯é¢˜ä¸€æ¬¡â€è°ƒç”¨ `submitMemoryResult`ï¼Œæ”¹ä¸º**æ¯å­—æ¯æ¯è½®ä¸€æ¬¡**ã€‚  
- å…è®¸ç”¨æˆ·åœ¨ Round ä¸­é€”é€€å‡ºï¼Œå¹¶åœ¨ä¸‹ä¸€æ¬¡è¿›å…¥æ—¶æ— ç¼æ¢å¤ã€‚  
- è®©â€œå­—æ¯è¯¾ç¨‹â€ä¿æŒè¯¾ç¨‹çº§çš„ä¸‰è½®è®­ç»ƒé€»è¾‘ï¼Œè€Œä¸æ˜¯ä¸¥æ ¼çš„æ—¥çº§ SRSã€‚  
- ä¸ºåç»­è¯æ±‡æ¨¡å—å¤ç”¨åŒä¸€å¥—â€œå‰ç«¯èšåˆ + ç»Ÿä¸€æäº¤â€æ€è·¯æ‰“åŸºç¡€ã€‚

### 11.2 AlphabetSessionStateï¼ˆå»ºè®®ç»“æ„ï¼‰

```ts
export interface AlphabetSessionState {
  userId: string;
  lessonId: string;
  currentRound: 1 | 2 | 3;
  phase: Phase; // yesterday-review / today-learning / ...

  queue: AlphabetLearningState[];
  cursorIndex: number;

  todayNewLetters: string[];      // alphabetId[]
  todayReviewedLetters: string[]; // å·²ç»åœ¨è½»é‡é¢˜ / é€»è¾‘é¢˜ä¸­è¢«è€ƒè¿‡
  wrongLetterIds: string[];       // æœ¬è½®æ›¾ç»å‡ºé”™è¿‡

  perLetterStats: Record<
    string,
    {
      attempts: number;
      wrongCount: number;
      lastPhase: Phase;
    }
  >;

  roundFinished: boolean;         // æœ¬è½®æ˜¯å¦å·²ç»å®Œæˆå¹¶æˆåŠŸæäº¤
  updatedAt: string;              // ISO æ—¶é—´æˆ³ï¼Œæ–¹ä¾¿è°ƒè¯•
}
```

- å®é™…å®ç°æ—¶å¯ä»¥æ”¾åœ¨ `alphabetStore` ä¸­ï¼Œé€šè¿‡ `getState()` / `setState()` ç®¡ç†ï¼Œå¹¶å®šæœŸå†™å…¥ AsyncStorageã€‚  
- å½“ App é‡æ–°æ‰“å¼€æˆ–ç”¨æˆ·å†æ¬¡è¿›å…¥è¯¥è¯¾æ—¶ï¼Œè‹¥å‘ç° `roundFinished === false` çš„ Sessionï¼Œåˆ™ç›´æ¥æ¢å¤ï¼Œä¸é‡æ–°ç”Ÿæˆé˜Ÿåˆ—ã€‚

### 11.3 è´¨é‡è®¡ç®—è§„åˆ™ï¼ˆFORGET / FUZZY / KNOWï¼‰

åœ¨ä¸€ä¸ª Round å†…ï¼Œå¯¹åŒä¸€ä¸ªå­—æ¯å¯èƒ½å‡ºç°å¤šé“é¢˜ + å¤šæ¬¡é”™é¢˜è¡¥æ•‘ï¼Œæœ€ç»ˆèšåˆä¸º 3 æ¡£è´¨é‡ï¼š

```ts
type LetterRoundQuality = 'FORGET' | 'FUZZY' | 'KNOW';

function computeLetterQuality(
  stats: { attempts: number; wrongCount: number },
): LetterRoundQuality {
  if (stats.attempts === 0) return 'FORGET';   // ç†è®ºå…œåº•
  if (stats.wrongCount === 0) return 'KNOW';   // å…¨ç¨‹æ— é”™
  if (stats.wrongCount === 1) return 'FUZZY';  // è½»åº¦é”™è¯¯
  return 'FORGET';                             // é”™è¯¯ â‰¥2 è§†ä¸ºæ²¡æŒæ¡
}
```

æ˜ å°„åˆ° memory-engine / SMâ€‘2ï¼š

```ts
function mapQualityToSm2Score(q: LetterRoundQuality): number {
  if (q === 'KNOW') return 5;   // è®°å¾—
  if (q === 'FUZZY') return 3;  // æ¨¡ç³Š
  return 0;                     // å¿˜è®°
}
```

### 11.4 æ‰¹é‡æäº¤æ—¶æœºä¸ä¼ªä»£ç 

åœ¨ Round å®Œæˆæˆ–ç”¨æˆ·ç‚¹å‡»â€œç»“æŸä»Šå¤©å­¦ä¹ â€æ—¶ï¼š

```ts
async function syncAlphabetRoundResults(state: AlphabetSessionState) {
  const { userId, lessonId, currentRound, perLetterStats } = state;

  const payloads = Object.entries(perLetterStats).map(([entityId, stats]) => ({
    userId,
    entityType: 'letter' as const,
    entityId,
    quality: mapQualityToSm2Score(computeLetterQuality(stats)),
  }));

  // 1. æ‰¹é‡ memory ç»“æœ
  for (const p of payloads) {
    await callCloudFunction('submitMemoryResult', p, {
      endpoint: API_ENDPOINTS.MEMORY.SUBMIT_MEMORY_RESULT.cloudbase,
    });
  }

  // 2. è¯¾ç¨‹çº§è½®æ¬¡ç»Ÿè®¡
  const totalQuestions = Object.values(perLetterStats).reduce(
    (sum, s) => sum + s.attempts,
    0,
  );
  const wrongCount = Object.values(perLetterStats).reduce(
    (sum, s) => sum + s.wrongCount,
    0,
  );

  await callCloudFunction(
    'submitRoundEvaluation',
    {
      userId,
      entityType: 'letter',
      lessonId,
      roundNumber: currentRound,
      totalQuestions,
      correctCount: totalQuestions - wrongCount,
      accuracy: totalQuestions === 0 ? 0 : (totalQuestions - wrongCount) / totalQuestions,
    },
    { endpoint: API_ENDPOINTS.MEMORY.SUBMIT_ROUND_EVALUATION.cloudbase },
  );
}
```

å®ç°çº¦æŸï¼š

- åŒä¸€ä¸ª `(userId, lessonId, currentRound)` åœ¨ä¸€ä¸ªè‡ªç„¶æ—¥å†…åªè°ƒç”¨ä¸€æ¬¡ `syncAlphabetRoundResults`ã€‚  
- è‹¥ç½‘ç»œé”™è¯¯ï¼Œå¯åœ¨ä¸‹æ¬¡è¿›å…¥è¯¾ç¨‹æ—¶é‡è¯•ï¼Œç›´åˆ°æˆåŠŸä¸ºæ­¢ã€‚  
- å½“ Round3 çš„åŒæ­¥å®Œæˆå¹¶é€šè¿‡é˜ˆå€¼åï¼Œæ‰å…è®¸è§£é”ä¸‹ä¸€è¯¾ã€‚

### 11.5 ä¸ä»»åŠ¡åˆ—è¡¨çš„å…³ç³»

- ç¬¬ 9 ç« ä¸­å…³äºâ€œSession çŠ¶æ€ vs è®°å¿†å¼•æ“çŠ¶æ€â€çš„åˆ†å·¥ä¿æŒæœ‰æ•ˆã€‚  
- ç¬¬ 10 ç« ä¸­çš„ P2ï¼ˆè´¨é‡æäº¤ç­–ç•¥ï¼‰åº”æŒ‰æœ¬èŠ‚æ–¹æ¡ˆå®ç°ï¼Œå³**æŒ‰å­—æ¯èšåˆ + æ‰¹é‡æäº¤**ï¼Œä¸å†æ¨èâ€œæ¯é¢˜æäº¤â€ã€‚  
- è‹¥å°†æ¥éœ€è¦è¿›ä¸€æ­¥ä¼˜åŒ–ï¼Œå¯åœ¨ memory-engine å¢åŠ  `submitBatchMemoryResults`ï¼Œä½†å‰ç«¯åè®®ï¼ˆæŒ‰å­—æ¯èšåˆåæäº¤ï¼‰ä¿æŒä¸å˜ã€‚

è‡³æ­¤ï¼Œå­—æ¯æ¨¡å—çš„è®°å¿†ç­–ç•¥å·²å†»ç»“ï¼š  
**å‰ç«¯è´Ÿè´£é¢˜ç›®è„šæœ¬ã€é”™é¢˜ç»Ÿè®¡ä¸è´¨é‡èšåˆï¼›åç«¯åªè´Ÿè´£æŒä¹…åŒ– SMâ€‘2 çŠ¶æ€ä¸è·¨å¤©è°ƒåº¦ã€‚**

---

## ğŸ“Œ v3.0 æ–°å¢ç« èŠ‚ï¼ˆ2026-01-05 P0ä¿®å¤åè¡¥å……ï¼‰

> **è¯´æ˜**: ä»¥ä¸‹ç« èŠ‚åŸºäº P0 çº§ Bug ä¿®å¤åˆå¹¶è€Œæ¥ï¼ŒåŒ…å« lesson-scoped roundã€completedLessons æƒå¨æ¥æºã€isNew è¯­ä¹‰è¾¹ç•Œã€free-play è§„åˆ™ã€AsyncStorageè§„åˆ™ç­‰æœ€ç»ˆè§„åˆ™ã€‚è¿™äº›è§„åˆ™**ä¼˜å…ˆäº**æ–‡æ¡£å‰é¢éƒ¨åˆ†çš„ä»»ä½•å†²çªæè¿°ã€‚

---

## 12. lesson-scoped Round æ¨å¯¼è§„åˆ™ï¼ˆP0-A ä¿®å¤ï¼‰

### 12.1 é—®é¢˜èƒŒæ™¯

**å†å²é”™è¯¯**ï¼ˆå·²åºŸå¼ƒï¼‰ï¼š
- å‰ç«¯ç›´æ¥è¯»å– `progress.currentRound` å¹¶ä¼ ç»™ `getTodayMemories`
- å¯¼è‡´ Lesson2 ä» Round2 å¼€å§‹ï¼ˆå› ä¸ºLesson1 Round1 passed å currentRound è¢«å†™ä¸º2ï¼‰

**æœ€ç»ˆè§„åˆ™**ï¼š
- Round å¿…é¡»æŒ‰ **lesson-scoped** æ¨å¯¼ï¼Œä¸å—å…¶ä»–è¯¾ç¨‹å½±å“
- å…¬å¼ï¼š`computedRound = Math.min(Math.max(lastPassedRound + 1, 1), 3)`
- å…¶ä¸­ `lastPassedRound` = å½“å‰ lessonId åœ¨ roundHistory ä¸­ passed=true çš„æœ€å¤§ roundNumber

### 12.2 å®ç°è¦ç‚¹ï¼ˆå‰ç«¯ï¼‰

**æ–‡ä»¶**: `src/stores/alphabetStore.ts`  
**ä½ç½®**: `initializeSession` æ–¹æ³•ä¸­

```typescript
// ğŸ”¥ P0-A: lesson-scoped round æ¨å¯¼ï¼ˆä¸å†ä½¿ç”¨å…¨å±€ currentRoundï¼‰
if (!options?.round && lessonId) {
  const roundHistory = progress.roundHistory || [];
  
  // è¿‡æ»¤å‡ºå½“å‰è¯¾ç¨‹ä¸” passed çš„ round è®°å½•
  const lessonHistoryRounds = roundHistory
    .filter((r: any) => r.lessonId === lessonId && r.passed === true)
    .map((r: any) => r.roundNumber);
  
  const lastPassedRound = lessonHistoryRounds.length > 0 
    ? Math.max(...lessonHistoryRounds) 
    : 0;
  
  const computedRound = Math.min(Math.max(lastPassedRound + 1, 1), 3);
  round = computedRound;
  
  console.log(`ğŸ” [P0-A] lessonId: ${lessonId}, backendCurrentRound: ${progress.currentRound || 'N/A'}, computedRound: ${computedRound}, lessonHistoryRounds: [${lessonHistoryRounds.join(',')}]`);
}
```

### 12.3 éªŒè¯è§„åˆ™

- Lesson1 Round1 passed â†’ è¿›å…¥ Lesson2 â†’ `computedRound` **å¿…é¡»**ä¸º 1ï¼ˆä¸å— Lesson1 å½±å“ï¼‰
- Lesson2 Round1 passed â†’ ç»§ç»­ Lesson2 â†’ `computedRound` **å¿…é¡»**ä¸º 2
- ä»»ä½• lesson çš„ Round3 passed â†’ `computedRound` **å¿…é¡»**é‡ç½®ä¸º 1ï¼ˆä¸‹æ¬¡è¿›å…¥è¯¥ lesson æ—¶ï¼‰

---

## 13. completedLessons æƒå¨æ¥æºä¸è¯¾ç¨‹è§£é”ï¼ˆP0-B ä¿®å¤ï¼‰

### 13.1 å”¯ä¸€å†™å…¥æ—¶æœºï¼ˆå¼ºåˆ¶ï¼‰

```typescript
mode === 'learning'
  AND roundNumber === 3
  AND passed === true
```

**ç¦æ­¢**åœ¨ä»¥ä¸‹æƒ…å†µå†™å…¥ï¼š
- free-play æ¨¡å¼
- Round1/Round2ï¼ˆå³ä½¿ passedï¼‰
- Round3 ä½† passed=false

### 13.2 åç«¯å®ç°ï¼ˆsubmitRoundEvaluation.jsï¼‰

```javascript
// ğŸ”¥ P0-B: Round3 passed æ—¶å†™å…¥ completedLessons
let updatedCompletedLessons = Array.isArray(doc.completedLessons) 
  ? [...doc.completedLessons] 
  : [];

if (passed && roundNumber === 3 && lessonId) {
  if (!updatedCompletedLessons.includes(lessonId)) {
    updatedCompletedLessons.push(lessonId);
  }
}

await col.doc(docId).update({
  data: {
    completedLessons: updatedCompletedLessons,
    // ...å…¶ä»–å­—æ®µ
  },
});
```

### 13.3 è¯¾ç¨‹è§£é”åˆ¤å®šå…¬å¼

**æ–‡ä»¶**: `app/alphabet/index.tsx`

```typescript
const isLessonUnlocked = (lessonIndex: number) => {
  if (lessonIndex === 0) return true; // Lesson1 æ°¸è¿œè§£é”
  
  const prevLessonId = lessons[lessonIndex - 1].id;
  return completedAlphabetLessons.includes(prevLessonId);
};
```

**æƒå¨æ¥æº**ï¼š
- âœ… åç«¯è¿”å›çš„ `progress.completedLessons`
- âŒ ç¦æ­¢ä½¿ç”¨ `alphabetStore.completedCount`ï¼ˆä¼šè¯æ€ï¼Œä¸å‡†ç¡®ï¼‰

### 13.4 nextRound é‡ç½®è§„åˆ™ï¼ˆé˜²æ­¢è·¨è¯¾æ±¡æŸ“ï¼‰

```javascript
// submitRoundEvaluation.js
const nextRound = passed
  ? (roundNumber < 3 ? roundNumber + 1 : 1)  // Round3 passed é‡ç½®ä¸º 1
  : 1;                                       // failed ä¹Ÿé‡ç½®ä¸º 1
```

**ç†ç”±**: é¿å… `currentRound` å…¨å±€æ±¡æŸ“å¯¼è‡´ Lesson2 ä» Round2 å¼€å§‹

---

## 14. å››æ®µé˜Ÿåˆ—ç»“æ„ä¸ previous-review æ¥æºï¼ˆP0-C/D ä¿®å¤ï¼‰

### 14.1 å››æ®µç»“æ„ï¼ˆæ‰€æœ‰ round å¿…é¡»åŒ…å«ï¼‰

| æ®µè½ | åç§° | æ˜¯å¦å…è®¸ä¸ºç©º | ç”¨é€” |
|------|------|--------------|------|
| 1 | `previous-review` | âœ… å…è®¸ï¼ˆä»… Lesson1 Round1ï¼‰ | ä¸Šä¸€è½®/ä¸Šä¸€è¯¾å¤ä¹  |
| 2 | `new-learning` | âŒ å¿…é¡»æœ‰å†…å®¹ | æ–°å­—æ¯å­¦ä¹  |
| 3 | `mini-review` | âŒ å¿…é¡»æœ‰å†…å®¹ | æ¯3ä¸ªæ–°å­—æ¯å›æ”¾ |
| 4 | `final-review` | âŒ å¿…é¡»æœ‰å†…å®¹ | å…¨é‡å¤ä¹  |

### 14.2 previous-review æ•°æ®æ¥æºè§„åˆ™

| Round | Lesson | previous-review æ¥æº | å®ç°æ–¹å¼ |
|-------|--------|---------------------|----------|
| Round1 | Lesson1 | **ç©ºæ•°ç»„** | å‰ç«¯: `reviewLetters = []` |
| Round1 | Lesson2+ | **Lesson(N-1) å­—æ¯** | åç«¯æ˜¾å¼æ³¨å…¥ + å‰ç«¯æŒ‰ lessonId åˆ‡åˆ† |
| Round2/3 | ä»»æ„ | **å½“å‰ Lesson å­—æ¯** | å‰ç«¯æŒ‰ lessonId åˆ‡åˆ†ï¼ˆåŒä¸€æ‰¹å­—æ¯å¤ç”¨ï¼‰ |

### 14.3 åç«¯æ˜¾å¼æ³¨å…¥ï¼ˆP0-Cï¼Œä»… Round1 ä¸” lesson>1ï¼‰

**æ–‡ä»¶**: `cloudbase/functions/memory-engine/handlers/getTodayMemories.js`

```javascript
// ğŸ”¥ P0-C: æ˜¾å¼è·å– Round1 è·¨è¯¾ç¨‹ previous-review
if (entityType === 'letter' && roundNumber === 1 && params.lessonId && params.lessonId !== 'lesson1') {
  const currentLessonMeta = await getLessonMetadataFromDb(db, params.lessonId);
  if (currentLessonMeta && currentLessonMeta.order && currentLessonMeta.order > 1) {
    const prevLessonId = `lesson${currentLessonMeta.order - 1}`;
    
    // æŸ¥è¯¢ä¸Šä¸€è¯¾çš„å­—æ¯
    const prevLettersResult = await db.collection('letters')
      .where({ curriculumLessonIds: db.command.in([prevLessonId]) })
      .limit(20)
      .get();
    
    const explicitPrevMemories = [];
    
    for (const letter of prevLettersResult.data) {
      const mem = await getOrCreateMemory(db, userId, entityType, letter._id, false);
      if (mem) {
        // ğŸ”¥ æµ…æ‹·è´é¿å…å‰¯ä½œç”¨ï¼Œå¼ºåˆ¶ reviewStage >= 1
        const patched = { 
          ...mem, 
          reviewStage: Math.max(mem.reviewStage || 0, 1) 
        };
        explicitPrevMemories.push(patched);
      }
    }
    
    // åˆå¹¶åˆ° reviewMemoriesï¼ˆå»é‡ï¼‰
    const existingIds = new Set(reviewMemories.map(m => m.entityId));
    const uniquePrev = explicitPrevMemories.filter(m => !existingIds.has(m.entityId));
    reviewMemories = [...uniquePrev, ...reviewMemories];
    
    console.log(`ğŸ” [P0-C] lessonId: ${params.lessonId}, prevLessonId: ${prevLessonId}, explicitPrevCount: ${explicitPrevMemories.length}`);
  }
}
```

**å…³é”®ç‚¹**ï¼š
- `reviewStage >= 1` ç¡®ä¿ `isNew = false`
- ä»…å½±å“æœ¬æ¬¡è¿”å›ï¼Œä¸æŒä¹…åŒ–åˆ° DB
- å»é‡é˜²æ­¢é‡å¤å­—æ¯

### 14.4 å‰ç«¯æŒ‰ lessonId åˆ‡åˆ†ï¼ˆP0-Dï¼‰

**æ–‡ä»¶**: `src/stores/alphabetStore.ts`

```typescript
// ğŸ”¥ P0-D: æŒ‰ lessonId åˆ‡åˆ†ï¼ˆä¸ä¾èµ– isNewï¼‰
const currentLessonLetters = learningItems.filter(
  (item) => lessonId && item.letter.curriculumLessonIds?.includes(lessonId)
);

const nonCurrentLessonLetters = learningItems.filter(
  (item) => lessonId && !item.letter.curriculumLessonIds?.includes(lessonId)
);

let reviewLetters: AlphabetLearningState[];
let newLetters: AlphabetLearningState[];

if (round === 1) {
  // Round1: previous = éæœ¬è¯¾å­—æ¯ï¼ˆè·¨è¯¾ï¼‰ï¼Œnew = æœ¬è¯¾å­—æ¯
  reviewLetters = nonCurrentLessonLetters;
  newLetters = currentLessonLetters;
} else {
  // Round2/3: previous = æœ¬è¯¾å­—æ¯ï¼ˆåŒè¯¾å¤ä¹ ï¼‰ï¼Œnew = æœ¬è¯¾å­—æ¯ï¼ˆä¿è¯å››æ®µï¼‰
  reviewLetters = currentLessonLetters;
  newLetters = currentLessonLetters;
}

const queue = buildAlphabetQueue({
  lessonLetters: newLetters,
  round,
  mode,
  previousRoundLetters: reviewLetters,
});
```

**Round2/3 é˜Ÿåˆ—é‡å¤è¯´æ˜**ï¼š
- `reviewLetters` å’Œ `newLetters` éƒ½æŒ‡å‘ `currentLessonLetters`
- åŒä¸€å­—æ¯ä¼šåœ¨ `previous-review` å’Œ `new-learning` ä¸­é‡å¤å‡ºç°
- âœ… **å…è®¸**è¿™ç§é‡å¤ï¼ˆä¸ºä¿è¯å››æ®µç»“æ„å­˜åœ¨ï¼‰
- âš ï¸ é˜Ÿåˆ—æ€»é•¿åº¦ä¼šå¢åŠ ï¼Œéœ€è§‚å¯Ÿç”¨æˆ·å®Œæˆæ—¶é•¿

---

## 15. isNew æ•°æ®è¯­ä¹‰è¾¹ç•Œï¼ˆP0-D è¡¥å……ï¼‰

### 15.1 ç²¾ç¡®å®šä¹‰

- `memoryState.isNew`ï¼šè¡¨ç¤º**è®°å¿†çŠ¶æ€çš„æ–°æ—§**
  - `true`ï¼šè¯¥å­—æ¯åœ¨ `memory_status` ä¸­æ— è®°å½•æˆ– `reviewStage === 0`
  - `false`ï¼šè¯¥å­—æ¯å·²æœ‰å­¦ä¹ è®°å½•ä¸” `reviewStage > 0`

### 15.2 è¯­ä¹‰è¾¹ç•Œï¼ˆç¦æ­¢æ··æ·†ï¼‰

âŒ **`isNew` ä¸ç­‰ä»·äº** "æ˜¯å¦ä¸ºæœ¬è¯¾æ–°å­—æ¯"  
âŒ **`isNew` ä¸ç­‰ä»·äº** "æ˜¯å¦åº”è¿›å…¥ previous-review"  
âœ… **`isNew` ä»…è¡¨ç¤º** "è¯¥å­—æ¯æ˜¯å¦æœ‰å­¦ä¹ å†å²"

### 15.3 æ­£ç¡®ç”¨æ³• vs é”™è¯¯ç”¨æ³•

**âœ… æ­£ç¡®ç”¨æ³•**ï¼šåˆ¤æ–­æ˜¯å¦è·¨è¯¾å¤ä¹ 
```typescript
const hasNonNew = queue.some(item => item.memoryState?.isNew === false);
if (!hasNonNew) setPhase('today-learning'); // è·³è¿‡ yesterday-review
```

**âŒ é”™è¯¯ç”¨æ³•**ï¼ˆå·²ç¦ç”¨ï¼‰ï¼šç”¨äºåˆ†ç»„ previous/new
```typescript
// è¿™ä¼šå¯¼è‡´ Round1 çš„ previous-review ä¸ºç©ºï¼ˆå› ä¸ºä¸Šä¸€è¯¾å­—æ¯çš„ isNew å¯èƒ½ä¸º trueï¼‰
const reviewLetters = learningItems.filter(item => item.memoryState?.isNew === false);
const newLetters = learningItems.filter(item => item.memoryState?.isNew === true);
```

**âœ… æ­£ç¡®æ›¿ä»£æ–¹æ¡ˆ**ï¼šæŒ‰ `curriculumLessonIds` åˆ‡åˆ†ï¼ˆè§ 14.4 èŠ‚ï¼‰

---

## 16. free-play æ¨¡å¼è§„åˆ™ï¼ˆåˆå¹¶è‡ª IMPLEMENTATION_SKELETONï¼‰

### 16.1 å”¯ä¸€åˆ¤å®šæ¡ä»¶

```typescript
mode = user_alphabet_progress.letterCompleted === true
  ? 'free-play'
  : 'learning'
```

âŒ **ç¦æ­¢**ä½¿ç”¨ round/phase/è¿›åº¦ç™¾åˆ†æ¯”æ¨æ–­ mode  
âœ… `letterCompleted` æ˜¯å”¯ä¸€åˆæ³•æ¥æº

### 16.2 free-play è¯­ä¹‰

- free-play â‰  "é‡å¤è¿›å…¥å·²å®Œæˆè¯¾ç¨‹"
- free-play = "Alphabet æ•™å­¦æ•´ä½“ç»“æŸï¼Œè¿›å…¥åªè¯»å¤ä¹ çŠ¶æ€"
- free-play æ˜¯**å…¨å±€çŠ¶æ€**ï¼Œä¸æ˜¯**è¯¾ç¨‹çŠ¶æ€**

### 16.3 ç¦æ­¢å†™å…¥è§„åˆ™ï¼ˆå¼ºåˆ¶ï¼‰

free-play æ¨¡å¼ä¸‹**ç¦æ­¢**å†™å…¥ä»¥ä¸‹ä»»ä½•å­—æ®µï¼š

âŒ `currentRound`  
âŒ `roundHistory`  
âŒ `completedLessons`  
âŒ `letterProgress`  
âŒ `letterCompleted`  
âŒ ä»»ä½•è§£é”å­—æ®µ

**å®ç°è¦ç‚¹**ï¼ˆå‰ç«¯ï¼‰ï¼š
```typescript
// useAlphabetLearningEngine.ts: submitRoundResults
if (mode === 'learning') {
  // æ­£å¸¸å†™å…¥
  await submitRoundToStore({ ... });
  if (currentRound === 3 && passed) {
    markAlphabetLessonCompleted(lessonId);
  }
} else {
  // free-play: åªæ¸…é™¤ sessionï¼Œä¸å†™ä»»ä½•è¿›åº¦
  setPhase('round-completed');
}
```

### 16.4 æœªå®Œæˆ Alphabet æ—¶çš„è¡Œä¸ºè§„åˆ™

**åœºæ™¯**: ç”¨æˆ·åªå®Œæˆäº† Lesson1~5ï¼Œç¬¬6è¯¾å·²è§£é”ï¼Œ`letterCompleted === false`

**å†»ç»“è¡Œä¸º**ï¼ˆå¿…é¡»éµå®ˆï¼‰ï¼š

1. ç”¨æˆ·è¿›å…¥ä»»ä½•å·²è§£é”è¯¾ç¨‹ â†’ `mode = 'learning'`ï¼ˆä¸è¿›å…¥ `free-play`ï¼‰
2. ç”¨æˆ·è¿›å…¥å·² Round3 å®Œæˆçš„æ—§è¯¾ç¨‹ â†’ ä»æŒ‰ `learning` æ¨¡å¼è¿è¡Œ
   - `previous-review` ä»…æ¥è‡ªè¯¥è¯¾ç¨‹è‡ªèº«
   - âŒ **ç¦æ­¢**è·¨è¯¾ç¨‹å–å­—æ¯
3. ä¸å¾—äº§ç”Ÿä»»ä½•æ±¡æŸ“ï¼š
   - âŒ ä¸å½±å“ä¸‹ä¸€è¯¾çš„ `previous-review`
   - âŒ ä¸å½±å“è¯¾ç¨‹è§£é”é¡ºåº

---

## 17. AsyncStorage è§„åˆ™ï¼ˆv3.0 æ–°å¢ï¼‰

### 17.1 userId-scope è§„åˆ™ï¼ˆå¼ºåˆ¶ï¼‰

âœ… **å¿…é¡»**æ‰€æœ‰ç¼“å­˜ key åŒ…å« `userId`
```typescript
const key = `alphabet_progress_${userId}`;
```

âŒ **ç¦æ­¢**ä½¿ç”¨å…¨å±€ keyï¼ˆå¦‚ `alphabet_completedLessons`ï¼‰

### 17.2 æ—§å…¨å±€ key è¿ç§»/åˆ é™¤

```typescript
const oldData = await AsyncStorage.getItem('alphabet_completedLessons');
if (oldData) {
  await AsyncStorage.setItem(`alphabet_completedLessons_${userId}`, oldData);
  await AsyncStorage.removeItem('alphabet_completedLessons');
}
```

### 17.3 logout æ—¶çš„ç¼“å­˜æ¸…ç†ç­–ç•¥

**æ¨èç­–ç•¥**ï¼š
- âœ… ä¿ç•™ userId-scope ç¼“å­˜ï¼ˆä¸‹æ¬¡ç™»å½•åŒè´¦å·æ—¶å¤ç”¨ï¼‰
- âœ… æ¸…é™¤ session çº§åˆ«ç¼“å­˜ï¼ˆå¦‚ `alphabet_session_${userId}`ï¼‰
- âŒ ä¸æ¸…é™¤æŒä¹…åŒ–è¿›åº¦ç¼“å­˜ï¼ˆå‡å°‘ç½‘ç»œè¯·æ±‚ï¼‰

**å¯é€‰ä¸¥æ ¼ç­–ç•¥**ï¼š
- å¦‚éœ€ä¸¥æ ¼éšç§ä¿æŠ¤ï¼Œlogout æ—¶æ¸…é™¤æ‰€æœ‰ userId-scope ç¼“å­˜
- ä¸‹æ¬¡ç™»å½•æ—¶é‡æ–°ä»åç«¯åŒæ­¥

---

## 18. å…³é”®æ—¥å¿—/æ’æ¡©å»ºè®®ï¼ˆDEV/çŸ­æœŸï¼‰

### 18.1 æ—¥å¿—ç›®çš„

- âœ… éªŒè¯ P0 ä¿®å¤æ˜¯å¦ç”Ÿæ•ˆ
- âœ… å®šä½ previous-review æ¥æºé—®é¢˜
- âœ… ç¡®è®¤ round æ¨å¯¼æ­£ç¡®æ€§
- âš ï¸ æ‰€æœ‰æ—¥å¿—ä»…ç”¨äºå¼€å‘/æµ‹è¯•é˜¶æ®µ

### 18.2 å¿…è¦æ—¥å¿—ç‚¹ï¼ˆâ‰¤8 æ¡ï¼‰

#### Log 1: lesson-scoped round æ¨å¯¼
**æ–‡ä»¶**: `alphabetStore.ts`  
```typescript
console.log(`ğŸ” [P0-A] lessonId: ${lessonId}, computedRound: ${computedRound}, lessonHistoryRounds: [${lessonHistoryRounds.join(',')}]`);
```

#### Log 2: è·¨è¯¾ç¨‹ previous-review æ³¨å…¥
**æ–‡ä»¶**: `getTodayMemories.js`  
```javascript
console.log(`ğŸ” [P0-C] lessonId: ${params.lessonId}, prevLessonId: ${prevLessonId}, explicitPrevCount: ${explicitPreviousCount}`);
```

#### Log 3: å‰ç«¯ lessonId åˆ‡åˆ†ç»“æœ
**æ–‡ä»¶**: `alphabetStore.ts`  
```typescript
console.log('ğŸ“Š [buildQueue] sourceCounts:', sourceCounts); // {'previous-review': 5, 'new-learning': 12, ...}
```

#### Log 4: completedLessons å†™å…¥
**æ–‡ä»¶**: `submitRoundEvaluation.js`  
```javascript
console.log(`ğŸ” [P0-B] completedAfter: [${updatedCompletedLessons.join(',')}]`);
```

#### Log 5-8: getUserProgress roundHistoryã€nextRound é‡ç½®ã€free-play åˆ¤å®šã€Phase åˆ‡æ¢
è¯¦è§ v2.1 è§„èŒƒç¬¬ 8.2 èŠ‚ã€‚

### 18.3 ç§»é™¤è®¡åˆ’

- âœ… éªŒè¯é€šè¿‡åï¼ˆçº¦ 2 å‘¨å†…ï¼‰
- âœ… ç§»é™¤æ‰€æœ‰å¸¦ `ğŸ” [P0-*]` æ ‡è®°çš„æ—¥å¿—
- âœ… ä¿ç•™å…³é”®é”™è¯¯æ—¥å¿—ï¼ˆ`console.error`ï¼‰

---

## 19. å¼ºåˆ¶æ‰§è¡Œæ¸…å•ï¼ˆAI / å¼€å‘è€…å¿…è¯»ï¼‰

åœ¨ä¿®æ”¹ Alphabet æ¨¡å—ä»»ä½•ä»£ç å‰ï¼Œ**å¿…é¡»**ç¡®è®¤ï¼š

- [ ] æˆ‘å·²å®Œæ•´é˜…è¯»æœ¬å†»ç»“è§„èŒƒ
- [ ] æˆ‘çš„ä¿®æ”¹ç¬¦åˆå››æ®µé˜Ÿåˆ—ç»“æ„
- [ ] æˆ‘çš„ä¿®æ”¹ä¸ä¾èµ– `isNew` åˆ†ç»„ previous/new
- [ ] æˆ‘çš„ä¿®æ”¹ä½¿ç”¨ lesson-scoped round æ¨å¯¼
- [ ] æˆ‘çš„ä¿®æ”¹åœ¨ Round3 passed æ—¶å†™å…¥ completedLessons
- [ ] æˆ‘çš„ä¿®æ”¹åœ¨ free-play æ¨¡å¼ä¸‹ä¸å†™å…¥ä»»ä½•è¿›åº¦
- [ ] æˆ‘çš„ä¿®æ”¹ä½¿ç”¨ AsyncStorage userId-scope key

è‹¥ä»»æ„ä¸€é¡¹ä¸º "å¦"ï¼Œ**ç«‹å³åœæ­¢**å¹¶é‡æ–°å®¡æŸ¥è®¾è®¡ã€‚

---

## 20. æ–‡æ¡£ä¼˜å…ˆçº§ä¸å†²çªè§£å†³ï¼ˆv3.0 æœ€ç»ˆï¼‰

### 20.1 æ–‡æ¡£ä¼˜å…ˆçº§

1. **æœ¬æ–‡ä»¶ v3.0** (`alphabet-module-spec.md`)
2. ~~ALPHABET_MODULE_IMPLEMENTATION_SKELETON.md~~ï¼ˆå·²å½’æ¡£ï¼‰
3. ~~ALPHABET_MODULE_FINAL_FACTS.md~~ï¼ˆå·²å½’æ¡£ï¼‰
4. å†å²ä»£ç 
5. AI å»ºè®®

### 20.2 å†²çªè§£å†³åŸåˆ™

- æ–‡æ¡£å†…éƒ¨å†²çªï¼š**ç¬¬ 12-20 èŠ‚ï¼ˆv3.0 æ–°å¢ï¼‰ä¼˜å…ˆäºå‰é¢ç« èŠ‚**
- è‹¥ä»£ç ä¸æœ¬æ–‡ä»¶å†²çªï¼š**ä¿®æ”¹ä»£ç **
- è‹¥éœ€ä¿®æ”¹æœ¬æ–‡ä»¶ï¼š**å¿…é¡»é€šè¿‡æ­£å¼è¯„å®¡å¹¶æ›´æ–°ç‰ˆæœ¬å·è‡³ v3.1+**

### 20.3 æ—§æ–‡æ¡£å½’æ¡£è¯´æ˜

ä»¥ä¸‹æ–‡æ¡£å·²åˆå¹¶åˆ°æœ¬æ–‡ä»¶ï¼Œ**ä¸å†å…·å¤‡è§„èŒƒæ•ˆåŠ›**ï¼š

- `docs/ALPHABET_MODULE_FINAL_FACTS.md` â†’ å·²å½’æ¡£è‡³ `docs/OLD/`
- `docs/ALPHABET_MODULE_IMPLEMENTATION_SKELETON.md` â†’ å·²å½’æ¡£è‡³ `docs/OLD/`
- `.gemini/.../alphabet_module_freeze_spec_v2.1.md` â†’ ä¸´æ—¶æ–‡ä»¶ï¼Œå·²åˆ é™¤

**ç¦æ­¢å¼•ç”¨**ä»¥ä¸Šæ–‡æ¡£ã€‚å¦‚æœ‰å†²çªï¼Œä»¥æœ¬æ–‡ä»¶ä¸ºå‡†ã€‚

---

## 21. ç‰ˆæœ¬å†å²

| ç‰ˆæœ¬ | æ—¥æœŸ | ä¿®è®¢å†…å®¹ |
|------|------|----------|
| v3.0 | 2026-01-05 | **é‡å¤§æ›´æ–°**: åˆå¹¶ FINAL_FACTSã€IMPLEMENTATION_SKELETONã€P0ä¿®å¤è§„èŒƒã€‚æ–°å¢ç¬¬12-20èŠ‚ï¼šlesson-scoped roundã€completedLessonsæƒå¨ã€å››æ®µé˜Ÿåˆ—ã€isNewè¯­ä¹‰ã€free-playè§„åˆ™ã€AsyncStorageè§„åˆ™ã€æ—¥å¿—å»ºè®®ã€‚å†²çªè§£å†³ï¼šåºŸå¼ƒå…¨å±€currentRoundã€isNewåˆ†ç»„ã€Round2/3ä¸¤æ®µç»“æ„ç­‰å†å²é”™è¯¯ |
| v2.0.1 | 2025-12-XX | åˆç‰ˆè¯¦ç»†è§„æ ¼ï¼ŒåŒ…å«ä»£ç æ–‡ä»¶èŒè´£ã€è°ƒç”¨é“¾ã€Phaseæµç¨‹å›¾ã€æ•°æ®åº“schema |

---

## 22. å½“å‰æ¨¡å—çŠ¶æ€ä¸æœªæ¥å·¥ä½œï¼ˆ2026-01-17 æ›´æ–°ï¼‰

> **çŠ¶æ€**: æ¨¡å—åŸºæœ¬è·‘é€šï¼Œè¿›å…¥ä¼˜åŒ–é˜¶æ®µ  
> **æœ€åæ›´æ–°**: 2026-01-17

### 22.1 å·²å®Œæˆå·¥ä½œ

#### æµ‹è¯•é¡µé¢é‡æ„ï¼ˆapp/alphabet/test.tsxï¼‰
- å®¢æˆ·ç«¯é¢˜ç›®ç”Ÿæˆ + æœ¬åœ°åˆ¤åˆ†
- åå°éŸ³é¢‘é¢„åŠ è½½ï¼ˆä½¿ç”¨ expo-file-systemï¼‰
- ç­”æ¡ˆæ ¼å¼ä¿®å¤ï¼ˆé¿å…å¤šé€‰ bugï¼‰

#### åç«¯ç®€åŒ–
- submitLetterTest: ç§»é™¤åˆ¤åˆ†é€»è¾‘
- passLetterTest: å®ç° upsert é€»è¾‘

### 22.2 å·²çŸ¥é—®é¢˜

#### éŸ³é¢‘æ’­æ”¾ Bugï¼ˆP1ï¼‰
éƒ¨åˆ†å­—æ¯æ— å£°éŸ³ï¼Œæ€€ç–‘éŸ³é¢‘æ–‡ä»¶è·¯å¾„ä¸å­—æ¯å­—æ®µä¸åŒ¹é…ã€‚

### 22.3 å¾…ä¼˜åŒ–é¡¹

- æµ‹è¯•é¡µé¢ UI ä¼˜åŒ–ï¼ˆP2ï¼‰
- å¤ä¹ é¢˜ä¼˜åŒ–ï¼ˆP2ï¼‰

### 22.4 æœªæ¥å¢å¼º

- çœŸå®æ³°è¯­å‘éŸ³æ›¿æ¢ï¼ˆP3ï¼‰
- æ³°è¯­æ‹¼è¯»æ˜¾ç¤ºï¼ˆP3ï¼Œå‚è€ƒ PRONUNCIATION_RESTORATION_MODULE_SPEC_FROZEN_v1.0.mdï¼‰

---

**æœ¬æ–‡ä»¶ï¼ˆv3.0ï¼‰å³ä¸º Alphabet æ¨¡å—çš„å”¯ä¸€æƒå¨è§„èŒƒã€‚**
</file>

<file path="docs/project-freeze/PROJECT_OVERVIEW_SPEC.md">
# æ³°è¯­å­¦ä¹ åº”ç”¨é¡¹ç›®æ€»çº² & æ¶æ„è§„æ ¼ï¼ˆProject Overview Spec, Freeze V2.0.1ï¼‰

> ç›®å½•ï¼š`docs/project-freeze/PROJECT_OVERVIEW_SPEC.md`  
> ä½œç”¨ï¼šä½œä¸º **é¡¹ç›®å”¯ä¸€çš„é¡¶å±‚ç®¡ç†æ–‡æ¡£**ï¼Œç»Ÿæ‘„ Alphabet / Vocabulary / Courses & LearningStore / Backend Memory Engine / AI æ¨¡å—çš„è§„æ ¼ä¸è¿›åº¦ã€‚  
> ç¡¬æ€§çº¦æŸï¼šåç»­æ‰€æœ‰å¼€å‘ä¸è¯„å®¡åªèƒ½ä¿¡ä»»æœ¬æ–‡ä»¶ + å¯¹åº”æ¨¡å— Spec + åç«¯è®°å¿†å¼•æ“ Spec + æ•°æ®åº“ç»“æ„æ–‡æ¡£ (`docs/database_schema.md`)ï¼Œå…¶ä»–ä»»ä½•æ–‡æ¡£ä¸€å¾‹è§†ä¸ºã€Œå†å²èµ„æ–™ã€ï¼Œä¸å¾—ä½œä¸ºå®ç°ä¾æ®ã€‚  
> è¦æ±‚ï¼šä»»ä½•æ¶æ„æˆ–æ¥å£è°ƒæ•´ï¼Œå¿…é¡»å…ˆæ›´æ–°æœ¬æ–‡ä»¶ï¼Œå†åŒæ­¥æ›´æ–°å¯¹åº”æ¨¡å—çš„ Specã€åç«¯ Spec ä¸æ•°æ®åº“ç»“æ„æ–‡æ¡£ã€‚

---

## 1. é¡¹ç›®ç›®æ ‡ä¸ä¸Šçº¿èŒƒå›´

### 1.1 äº§å“ç›®æ ‡ï¼ˆé¦–å‘ç‰ˆæœ¬ï¼‰

- é¢å‘ä¸­æ–‡ç”¨æˆ·çš„æ³°è¯­å…¥é—¨å­¦ä¹  Appï¼Œé¦–å‘ç‰ˆæœ¬åŒ…å«ï¼š
  - **å­—æ¯æ¨¡å—ï¼ˆAlphabet Moduleï¼‰**ï¼šLesson1â€“7ï¼Œå¸¦ä¸‰è½®è¯¾ç¨‹çº§è®­ç»ƒä¸é€»è¾‘é¢˜å‹åŸºç¡€ï¼›
  - **è¯æ±‡æ¨¡å—ï¼ˆVocabulary Moduleï¼‰**ï¼šè‡³å°‘ 1 é—¨åŸºç¡€æ³°è¯­è¯¾ç¨‹ï¼ˆThai_1ï¼‰ï¼Œæ”¯æŒä¾‹å¥/å¯¹è¯/ç”¨æ³•ç²¾è®²ä¸è½»é‡åŒ–å¤ä¹ ï¼›
  - **è¯¾ç¨‹å…¥å£ + å­¦ä¹ ä»ªè¡¨ç›˜**ï¼šç»Ÿä¸€çš„ Courses é¡µ + LearningStore ç»Ÿè®¡ï¼›
  - **ç»Ÿä¸€è®°å¿†å¼•æ“ï¼ˆSMâ€‘2ï¼‰**ï¼šé€šè¿‡ `memory-engine` / `vocabulary` äº‘å‡½æ•°ç®¡ç†é•¿æœŸå¤ä¹ ï¼›
  - **è½»é‡ AI æ¨¡å—ï¼ˆAI Module, Liteï¼‰**ï¼šåœ¨é¦–å‘ä¸­çœŸæ­£æ¥å…¥ä»¥ä¸‹å››ç±» AI èƒ½åŠ›ï¼š
    - åŸºäºé”™é¢˜å’Œå­¦ä¹ è¿›åº¦çš„**å¼±é¡¹è¯æ±‡å¼ºåŒ–ç»ƒä¹ **ï¼ˆ`generateWeaknessVocabulary`ï¼‰ï¼›
    - åŸºäºç”¨æˆ·é€‰æ‹©è¯/é”™é¢˜ç”Ÿæˆçš„**å¾®é˜…è¯»çŸ­æ–‡**ï¼ˆ`generateMicroReading`ï¼‰ï¼›
    - é’ˆå¯¹å•è¯çš„**åŸºç¡€è¯æ±‡è§£æ/è¡¥å……ä¾‹å¥**ï¼ˆ`explainVocabulary`ï¼Œä»…åšè§£é‡Šä¸ä¾‹å¥æ‰©å±•ï¼Œä¸ç›´æ¥ä¿®æ”¹è®°å¿†çŠ¶æ€ï¼‰ï¼›
    - é’ˆå¯¹å­—æ¯ / å•è¯ / å¥å­çš„**å‘éŸ³åˆ†æä¸åé¦ˆ**ï¼ˆ`analyzePronunciation` çš„é¦–å‘ MVP ç‰ˆï¼Œç”¨äºåŸºç¡€æ‰“åˆ†ä¸æ–‡å­—åé¦ˆï¼‰ã€‚
- AI æ¨¡å—ä»ä¿æŒ **Lite / é¦–å‘ MVP** çš„å®šä½ï¼šåªè¦†ç›–ä»¥ä¸Š 4 ç±»ä¸å­¦ä¹ é—­ç¯å¼ºç›¸å…³çš„èƒ½åŠ›ï¼Œå…¶ä½™é«˜é˜¶åŠŸèƒ½ï¼ˆå¤æ‚æ¨èç³»ç»Ÿã€æ›´ä¸°å¯Œçš„é˜…è¯»ç†è§£åœºæ™¯ç­‰ï¼‰ä½œä¸ºåç»­ç‰ˆæœ¬æ‰©å±•ã€‚

### 1.2 æ¶æ„åŸºçº¿

- å‰ç«¯ï¼šReact Native + Expo Router + TypeScript + Zustandï¼›
- åç«¯ï¼šCloudBase äº‘å‡½æ•°ï¼ˆwx-server-sdkï¼‰+ NoSQL é›†åˆï¼›
- è®°å¿†å¼•æ“ï¼šç»Ÿä¸€çš„ `memory_status` + ä¼˜åŒ–ç‰ˆ SMâ€‘2 ç®—æ³•ï¼›
- æ–‡æ¡£ï¼š**ä»¥ `docs/project-freeze` ç›®å½•ä¸‹çš„ Spec + `docs/database_schema.md` ä¸ºæƒå¨ä¿¡æ¯æº**ï¼Œä»“åº“ä¸­å…¶ä»–æ–‡æ¡£ï¼ˆå«æ—§è®¾è®¡ç¨¿ã€å‘¨æŠ¥ã€å¤‡ä»½è¯´æ˜ç­‰ï¼‰åªå¯ä½œä¸ºå†å²å‚è€ƒï¼Œä¸å¯ä¾èµ–ã€‚

---

## 2. æ¨¡å—åˆ’åˆ†ä¸ä¸»è¦æ–‡æ¡£

| æ¨¡å— | è¯´æ˜ | å¯¹åº” Spec |
|------|------|-----------|
| Frontend Shell & Navigation | é¦–é¡µã€Tab å¯¼èˆªã€ç”¨æˆ·ä¸­å¿ƒã€åŸºç¡€è®¾ç½® | `frontend-shell-module-spec.md` |
| Alphabet Module | å­—æ¯è¯¾ç¨‹å­¦ä¹ ä¸ä¸‰è½®è®­ç»ƒ | `alphabet-module-spec.md` |
| Vocabulary Module | å•è¯ç²¾è®²ä¸ SRS å¤ä¹  | `vocabulary-module-spec.md` |
| Courses + LearningStore | è¯¾ç¨‹å…¥å£ã€å…¨å±€å­¦ä¹ ä»ªè¡¨ç›˜ | `courses-and-learningstore-spec.md` |
| Backend Memory Engine | ç»Ÿä¸€è®°å¿†å¼•æ“ + æ¨¡å—è§£é” | `backend-memory-engine-spec.md` |
| AI Module (Lite) | å‘éŸ³åé¦ˆã€å¼±é¡¹å¼ºåŒ–ã€å¾®é˜…è¯»ï¼ˆè®¾è®¡çº§ï¼‰ | `ai-module-spec.md` |

> é¡¶å±‚ç»„ä»¶å’Œè°ƒç”¨å…³ç³»ä»¥ç¬¬ 2.1 èŠ‚ä¸‹æ–¹çš„ Mermaid ç±»å›¾ä¸ºå”¯ä¸€æ¶æ„è“å›¾ï¼Œåç»­è¿­ä»£ä¸å¾—éšæ„å¢åˆ å›¾ä¸­çš„ç»„ä»¶ï¼Œåªèƒ½åœ¨å…¶å†…éƒ¨æ¼”åŒ–å®ç°ã€‚

### 2.1 é¡¶å±‚ç»„ä»¶/ç±»å›¾ï¼ˆå†»ç»“ç‰ˆï¼Œå…¨é¡¹ç›®å”¯ä¸€æ¶æ„ï¼‰

```mermaid
classDiagram

%% ===================================================================
%% 1. Frontend Shell & Navigation
%% ===================================================================
class TabsLayout {
  +tabs
}

class HomeScreen {
  +render()
  +handleBubbleClick()
  +getCurrentCourse()
}
class CoursesScreen {
  +render()
  +handleStartAlphabet()
  +handleStartWordCourse()
}
class ProfileScreen {
  +render()
  +updateDailyLimit()
  +handleLogout()
}
class LanguageSwitcher {
  +render()
  +setLanguage()
}
class FloatingBubbles {
  +render()
  +onOpenReview()
}
class ThaiPatternBackground {
  +render()
}

TabsLayout <|-- HomeScreen
TabsLayout <|-- CoursesScreen
TabsLayout <|-- ProfileScreen

HomeScreen --> UserStore
HomeScreen --> ModuleAccessStore
HomeScreen --> LearningStore
HomeScreen --> FloatingBubbles
HomeScreen --> ThaiPatternBackground

CoursesScreen --> VocabularyStore
CoursesScreen --> ModuleAccessStore

ProfileScreen --> UserStore
ProfileScreen --> LearningStore
ProfileScreen --> ModuleAccessStore
ProfileScreen --> LanguageSwitcher
ProfileScreen --> LearningPreferenceStore

%% ===================================================================
%% 2. Stores & Global State
%% ===================================================================
class UserStore {
  +currentUser
  +login()
  +logout()
}
class ModuleAccessStore {
  +userProgress
  +fetchUserProgress()
}
class LearningStore {
  +currentCourseId
  +currentAlphabetProgramId
  +streakDays
  +totalStudyMinutes
  +lastStudyAt
  +setCurrentCourse()
  +setCurrentAlphabetProgram()
  +registerStudySession()
}
class LearningPreferenceStore {
  +dailyLimitsWord
  +dailyLimitsLetter
  +setDailyLimit()
}

UserStore --> Users
ModuleAccessStore --> ApiClient
LearningStore --> ApiClient

%% ===================================================================
%% 3. Alphabet Module
%% ===================================================================
class AlphabetLessonListScreen {
  +render()
  +fetchLessons()
  +handleStartLesson()
}
class AlphabetLessonScreen {
  +render()
  +lessonId
}
class AlphabetLearningEngineView {
  +render()
}
class AlphabetLearningView {
  +renderLetter()
}
class AlphabetReviewView {
  +renderQuestion()
}
class GameContainer {
  +queue
  +currentIndex
  +wrongPool
  +next()
}
class StepRenderer {
  +render()
}

class AlphabetQuestionEngine {
  +generateQueueItems()
}
class LettersQuestionGenerator {
  +generate()
}

class AlphabetSessionState {
  +userId
  +lessonId
  +currentRound
  +phase
  +queue
  +cursorIndex
  +todayNewLetters
  +todayReviewedLetters
  +wrongLetterIds
  +perLetterStats
  +roundFinished
  +updatedAt
}

class AlphabetStore {
  +state
  +initializeSession()
  +loadSession()
  +saveSession()
  +clearSession()
  +submitRoundResults()
}

class UseAlphabetLearningEngine {
  +phase
  +currentRound
  +handleAnswer()
  +handleNext()
  +submitRoundResults()
}

AlphabetLessonListScreen --> AlphabetStore
AlphabetLessonListScreen --> AlphabetLessonScreen
AlphabetLessonScreen --> UseAlphabetLearningEngine
UseAlphabetLearningEngine --> AlphabetStore
UseAlphabetLearningEngine --> AlphabetLearningEngineView
AlphabetLearningEngineView --> GameContainer
GameContainer --> StepRenderer
StepRenderer --> AlphabetLearningView
StepRenderer --> AlphabetReviewView

UseAlphabetLearningEngine --> AlphabetQuestionEngine
AlphabetQuestionEngine --> LettersQuestionGenerator

AlphabetStore --> AlphabetSessionState
AlphabetStore --> ApiClient
AlphabetStore --> AsyncStorage

%% ===================================================================
%% 4. Vocabulary Module
%% ===================================================================
class WordLearningScreen {
  +render()
}
class NewWordView {
  +renderRichCard()
}
class ReviewWordView {
  +renderQuestion()
}
class VocabularyQuestionView {
  +renderMCQ()
  +renderSpelling()
}

class VocabularyQuestionEngine {
  +pickQuestionTypes()
  +buildQuestion()
}

class VocabularyQuestionRecord {
  +vocabularyId
  +questionType
  +isCorrect
  +usedHint
}

class VocabularyPerWordStats {
  +attempts
  +wrongCount
  +usedHint
  +questionTypes
}

class VocabularySessionState {
  +userId
  +courseSource
  +dateKey
  +reviewQueue
  +newQueue
  +currentIndex
  +mode
  +perWordStats
  +wrongWordIds
  +wrongRecords
  +submitted
}

class VocabularyStore {
  +state
  +initializeSession()
  +answerQuestion()
  +skipReviewAndLearnNew()
  +finishSession()
  +resetCourseProgress()
}

WordLearningScreen --> VocabularyStore
WordLearningScreen --> NewWordView
WordLearningScreen --> VocabularyQuestionView
VocabularyQuestionView --> ReviewWordView
VocabularyQuestionView --> VocabularyQuestionEngine
VocabularyStore --> VocabularyQuestionEngine

VocabularyStore --> VocabularySessionState
VocabularySessionState --> VocabularyPerWordStats
VocabularySessionState --> VocabularyQuestionRecord

VocabularyStore --> ApiClient
VocabularyStore --> AsyncStorage

%% ===================================================================
%% 5. AI Module
%% ===================================================================
class AiPronunciationScreen {
  +render()
  +startRecording()
  +submitRecording()
}
class AiWeaknessPracticeScreen {
  +render()
  +loadWeakVocab()
}
class AiMicroReadingScreen {
  +render()
  +generateReading()
  +submitReadingRecording()
}

class AiEngineCF {
  +analyzePronunciation()
  +generateWeaknessVocabulary()
  +generateMicroReading()
  +explainVocabulary()
}

AiPronunciationScreen --> ApiClient
AiWeaknessPracticeScreen --> ApiClient
AiMicroReadingScreen --> ApiClient

AiWeaknessPracticeScreen --> VocabularyStore
AiMicroReadingScreen --> VocabularyStore
AiPronunciationScreen --> AlphabetStore
AiPronunciationScreen --> VocabularyStore

%% ===================================================================
%% 6. Courses & Access
%% ===================================================================
CoursesScreen --> LearningPreferenceStore
CoursesScreen --> LearningStore
HomeScreen --> LearningStore
HomeScreen --> ModuleAccessStore
ProfileScreen --> LearningPreferenceStore
ProfileScreen --> LearningStore
ProfileScreen --> ModuleAccessStore

ModuleAccessStore --> MemoryEngineCF
LearningStore --> MemoryEngineCF

%% ===================================================================
%% 7. Backend Cloud Functions
%% ===================================================================
class ApiClient {
  +callCloudFunction()
}

class MemoryEngineCF {
  +getTodayMemories()
  +submitMemoryResult()
  +submitRoundEvaluation()
  +checkModuleAccess()
  +getUserProgress()
  +getAlphabetLessons()
  +registerStudySession()
}

class LearnVocabCF {
  +getTodayWords()
  +updateMastery()
  +getVocabularyDetail()
  +getReviewStatistics()
  +getVocabularyList()
  +getSkippedWords()
}

ApiClient --> MemoryEngineCF
ApiClient --> LearnVocabCF
ApiClient --> AiEngineCF

AlphabetStore --> MemoryEngineCF
UseAlphabetLearningEngine --> MemoryEngineCF
VocabularyStore --> LearnVocabCF
VocabularyStore --> MemoryEngineCF
ModuleAccessStore --> MemoryEngineCF
LearningStore --> MemoryEngineCF

%% ===================================================================
%% 8. Database Collectionsï¼ˆç®€ç•¥ï¼‰
%% ===================================================================
class Users {
  +userId
  +nickname
  +avatarUrl
  +createdAt
}
class Letters {
  +_id
  +thaiChar
  +type
  +class
  +curriculumLessonIds
}
class Vocabulary {
  +_id
  +source
  +lessonNumber
  +thaiWord
  +meaning
}
class MemoryStatus {
  +userId
  +entityType
  +entityId
  +masteryLevel
  +nextReviewAt
}
class UserProgress {
  +userId
  +letterCompleted
  +letterProgress
  +wordUnlocked
  +wordProgress
  +totalStudyDays
  +streakDays
  +lastStudyDate
  +totalStudyMinutes
}
class UserAlphabetProgress {
  +userId
  +letterProgress
  +letterCompleted
}
class UserVocabularyProgress {
  +userId
  +vocabularyId
  +mastery
  +nextReviewDate
}

MemoryEngineCF --> Letters
MemoryEngineCF --> Vocabulary
MemoryEngineCF --> MemoryStatus
MemoryEngineCF --> UserProgress
MemoryEngineCF --> UserAlphabetProgress
LearnVocabCF --> Vocabulary
LearnVocabCF --> UserVocabularyProgress
AiEngineCF --> MemoryStatus
AiEngineCF --> Vocabulary
AiEngineCF --> Letters
```

### 2.2 é¡¶å±‚ç”¨ä¾‹å›¾ï¼ˆå†»ç»“ç‰ˆï¼Œå…¨é¡¹ç›®å”¯ä¸€ç”¨ä¾‹é›†åˆï¼‰

```mermaid
flowchart TD
  %% Actor
  U[User]

  %% Core use cases (â‰¤10)
  UC_Auth((Sign Up / Sign In / Sign Out))
  UC_Home((View Home & Current Course))
  UC_SelectCourse((Browse & Select Course))
  UC_AlphabetLearn((Learn Alphabet Lessons))
  UC_VocabLearn((Learn Vocabulary Lessons))
  UC_Review((Review Learned Items))
  UC_ViewProgress((View Progress & Achievements))
  UC_Settings((Change Study Settings))
  UC_AIPractice((AI-assisted Practice))

  %% Actor â†’ Use case
  U --> UC_Auth
  U --> UC_Home
  U --> UC_SelectCourse
  U --> UC_AlphabetLearn
  U --> UC_VocabLearn
  U --> UC_Review
  U --> UC_ViewProgress
  U --> UC_Settings
  U --> UC_AIPractice

  %% Relationships between use cases
  UC_SelectCourse -. includes .-> UC_AlphabetLearn
  UC_SelectCourse -. includes .-> UC_VocabLearn
  UC_AlphabetLearn -. includes .-> UC_Review
  UC_VocabLearn -. includes .-> UC_Review
  UC_AIPractice -. extends .-> UC_Review
```

> ä»¥ä¸Šç”¨ä¾‹å›¾ä¸ºæœ¬é¡¹ç›®å”¯ä¸€çš„â€œä¸šåŠ¡åœºæ™¯é›†åˆâ€ã€‚åç»­å¦‚éœ€æ–°å¢/åˆ é™¤ç”¨ä¾‹ï¼Œå¿…é¡»é¦–å…ˆæ›´æ–°æœ¬å›¾ï¼Œå†åŒæ­¥è°ƒæ•´å¯¹åº”æ¨¡å— Specã€‚

### 2.3 å…³é”®ç”¨ä¾‹æ—¶åºå›¾ï¼ˆæŒ‰ç”¨ä¾‹åˆ†ç»„ï¼‰

#### 2.3.1 UC_Auth â€“ Sign Up / Sign In / Sign Out

```mermaid
sequenceDiagram
  actor U as User
  participant AuthScreen as Auth Screen
  participant UserStore
  participant ApiClient
  participant UserCF as user-* CF
  participant Users as users collection

  U ->> AuthScreen: enter credentials / tap login
  AuthScreen ->> UserStore: login(email,password)
  UserStore ->> ApiClient: callCloudFunction('user-login',data)
  ApiClient ->> UserCF: main({action:'login',data})
  UserCF ->> Users: query user by email
  Users -->> UserCF: user document
  UserCF -->> ApiClient: success + user profile
  ApiClient -->> UserStore: response
  UserStore -->> AuthScreen: update currentUser\nnavigate to Home

  U ->> ProfileScreen: tap logout
  ProfileScreen ->> UserStore: logout()
  UserStore -->> ProfileScreen: clear currentUser\nnavigate to Login
```

#### 2.3.2 UC_Home â€“ View Home & Current Course

```mermaid
sequenceDiagram
  actor U as User
  participant HomeScreen
  participant UserStore
  participant ModuleAccessStore
  participant LearningStore

  U ->> HomeScreen: open app / switch to Home tab
  HomeScreen ->> UserStore: get currentUser
  UserStore -->> HomeScreen: currentUser
  HomeScreen ->> ModuleAccessStore: userProgress (if not loaded)
  ModuleAccessStore -->> HomeScreen: letterProgress,wordProgress,...
  HomeScreen ->> LearningStore: get currentCourseId / stats
  LearningStore -->> HomeScreen: streakDays,totalStudyMinutes
  HomeScreen ->> HomeScreen: compute currentCourse via getCurrentCourse()
  HomeScreen -->> U: render greeting, hero card,\nfloating bubbles, stats
```

#### 2.3.3 UC_SelectCourse â€“ Browse & Select Course

```mermaid
sequenceDiagram
  actor U as User
  participant CoursesScreen
  participant LearningPreferenceStore
  participant LearningStore
  participant ModuleAccessStore
  participant Router as expo-router

  U ->> CoursesScreen: open Courses tab
  CoursesScreen ->> LearningPreferenceStore: read dailyLimits
  CoursesScreen ->> ModuleAccessStore: read userProgress (locks)
  CoursesScreen -->> U: render alphabet & vocab course cards

  U ->> CoursesScreen: tap Alphabet course
  CoursesScreen ->> LearningStore: setCurrentAlphabetProgram('alphabet')
  CoursesScreen ->> Router: push('/alphabet')

  U ->> CoursesScreen: tap Vocabulary course
  CoursesScreen ->> LearningStore: setCurrentCourse(courseId)
  CoursesScreen ->> Router: push('/learning?module=word&source=courseSource')
```

#### 2.3.4 UC_AlphabetLearn â€“ Learn Alphabet Lessons

```mermaid
sequenceDiagram
  actor U as User
  participant AlphabetLessonListScreen as LessonList
  participant AlphabetLessonScreen as LessonScreen
  participant UseAlphabetLearningEngine as Hook
  participant AlphabetStore
  participant ApiClient
  participant MemoryEngineCF as memory-engine

  U ->> LessonList: open alphabet course
  LessonList ->> ApiClient: callCloudFunction('memory-engine',{action:'getAlphabetLessons'})
  ApiClient ->> MemoryEngineCF: getAlphabetLessons
  MemoryEngineCF -->> ApiClient: lessons[]
  ApiClient -->> LessonList: lessons[]
  LessonList -->> U: render Lesson1..7 cards

  U ->> LessonList: tap "Start" on LessonN
  LessonList ->> LessonScreen: navigate with lessonId

  LessonScreen ->> Hook: useAlphabetLearningEngine(lessonId)
  Hook ->> AlphabetStore: initializeSession(userId,lessonId)
  AlphabetStore ->> ApiClient: callCloudFunction('memory-engine',{action:'getTodayMemories',data:{entityType:'letter',lessonId}})
  ApiClient ->> MemoryEngineCF: getTodayMemories(letter,lessonId)
  MemoryEngineCF ->> MemoryStatus: read existing memory records
  MemoryEngineCF ->> Letters: query letters in lesson
  MemoryEngineCF -->> ApiClient: items + lessonMetadata + phonicsRule
  ApiClient -->> AlphabetStore: items
  AlphabetStore -->> Hook: queue,sessionState
  Hook -->> U: render LessonScreen via AlphabetLearningEngineView
```

#### 2.3.5 UC_VocabLearn â€“ Learn Vocabulary Lessons

```mermaid
sequenceDiagram
  actor U as User
  participant WordLearningScreen as WordScreen
  participant VocabularyStore
  participant ApiClient
  participant LearnVocabCF as vocabulary

  U ->> WordScreen: navigate from Courses or Home\n(module=word, source)
  WordScreen ->> VocabularyStore: initializeSession(userId,source)
  VocabularyStore ->> ApiClient: callCloudFunction('vocabulary',{action:'getTodayWords',data:{userId,limit,level}})
  ApiClient ->> LearnVocabCF: getTodayWords
  LearnVocabCF ->> UserVocabularyProgress: read review items
  LearnVocabCF ->> Vocabulary: read vocab documents
  LearnVocabCF -->> ApiClient: words + summary
  ApiClient -->> VocabularyStore: todayWords
  VocabularyStore -->> WordScreen: sessionState (reviewQueue,newQueue)
  WordScreen -->> U: render NewWordView + VocabularyQuestionView
```

#### 2.3.6 UC_Review â€“ Review Learned Items

```mermaid
sequenceDiagram
  actor U as User
  participant WordScreen
  participant AlphabetLessonScreen as AlphaScreen
  participant VocabularyStore
  participant AlphabetStore
  participant ApiClient
  participant MemoryEngineCF as memory-engine
  participant LearnVocabCF as vocabulary

  U ->> AlphaScreen: answer alphabet quiz
  AlphaScreen ->> AlphabetStore: submitResult(userId,isCorrect)
  AlphabetStore ->> ApiClient: callCloudFunction('memory-engine',{action:'submitMemoryResult',data:{userId,entityType:'letter',entityId,quality}})
  ApiClient ->> MemoryEngineCF: submitMemoryResult
  MemoryEngineCF ->> MemoryStatus: update letter memory

  U ->> WordScreen: answer vocabulary question
  WordScreen ->> VocabularyStore: answerQuestion(vocabId,isCorrect,type)
  VocabularyStore ->> VocabularyStore: update perWordStats & wrongWordIds
  Note right of VocabularyStore: At end of session\ncompute mastery per word
  VocabularyStore ->> ApiClient: callCloudFunction('vocabulary',{action:'updateMastery',data:{userId,vocabularyId,mastery}})
  ApiClient ->> LearnVocabCF: updateMastery
  LearnVocabCF ->> UserVocabularyProgress: update record
```

#### 2.3.7 UC_ViewProgress â€“ View Progress & Achievements

```mermaid
sequenceDiagram
  actor U as User
  participant ProfileScreen
  participant ModuleAccessStore
  participant LearningStore

  U ->> ProfileScreen: open Profile tab
  ProfileScreen ->> ModuleAccessStore: get userProgress
  ModuleAccessStore -->> ProfileScreen: letterProgress,wordProgress,...
  ProfileScreen ->> LearningStore: get progress (streakDays,totalStudyMinutes)
  LearningStore -->> ProfileScreen: stats
  ProfileScreen -->> U: render achievements, stats cards
```

#### 2.3.8 UC_Settings â€“ Change Study Settings

```mermaid
sequenceDiagram
  actor U as User
  participant ProfileScreen
  participant LearningPreferenceStore
  participant ModuleAccessStore

  U ->> ProfileScreen: open settings section
  U ->> ProfileScreen: tap "Daily Study Goal"
  ProfileScreen ->> LearningPreferenceStore: setDailyLimit(module,limit)
  ProfileScreen ->> ModuleAccessStore: update local userProgress.dailyLimit
  Note right of ProfileScreen: ä¸‹æ¬¡å­¦ä¹ æ—¶ï¼Œå­¦ä¹ æ¨¡å—\nä¼šæŠŠæ–°çš„ dailyLimit ä¼ ç»™ memory-engine\nå¹¶ç”±åç«¯æŒä¹…åŒ–

  U ->> ProfileScreen: select language
  ProfileScreen ->> LanguageSwitcher: setLanguage(lang)
  LanguageSwitcher -->> ProfileScreen: reload i18n resources
```

#### 2.3.9 UC_AIPractice â€“ AI-assisted Practice

```mermaid
sequenceDiagram
  actor U as User
  participant AiWeaknessPracticeScreen as WeakScreen
  participant AiPronunciationScreen as PronScreen
  participant AiMicroReadingScreen as ReadScreen
   participant AiExplainVocabScreen as ExplainScreen
  participant VocabularyStore
  participant AlphabetStore
  participant ApiClient
  participant AiEngineCF as ai-engine

  U ->> WeakScreen: open AI Weak Vocabulary
  WeakScreen ->> VocabularyStore: get wrongWordIds,courseSource
  WeakScreen ->> ApiClient: callCloudFunction('ai-engine',{action:'generateWeaknessVocabulary',data:{userId,focusVocabularyIds}})
  ApiClient ->> AiEngineCF: generateWeaknessVocabulary
  AiEngineCF -->> ApiClient: suggestions[]
  ApiClient -->> WeakScreen: suggestions[]
  WeakScreen -->> U: render AI extra examples & mnemonics

  U ->> ReadScreen: open AI Micro Reading
  ReadScreen ->> VocabularyStore: get wrongWordIds
  ReadScreen ->> ApiClient: callCloudFunction('ai-engine',{action:'generateMicroReading',data:{userId,focusType:'word',focusIds:wrongWordIds}})
  ApiClient ->> AiEngineCF: generateMicroReading
  AiEngineCF -->> ApiClient: microReading
  ApiClient -->> ReadScreen: microReading
  ReadScreen -->> U: display Thai text + hint

  U ->> ExplainScreen: request AI explanation for a word
  ExplainScreen ->> VocabularyStore: get current vocabularyId / thaiWord
  ExplainScreen ->> ApiClient: callCloudFunction('ai-engine',{action:'explainVocabulary',data:{userId,vocabularyId}})
  ApiClient ->> AiEngineCF: explainVocabulary
  AiEngineCF -->> ApiClient: explanation
  ApiClient -->> ExplainScreen: explanation
  ExplainScreen -->> U: show meaning, breakdown, extra examples

  U ->> PronScreen: record pronunciation
  PronScreen ->> ApiClient: callCloudFunction('ai-engine',{action:'analyzePronunciation',data:{userId,targetType,targetId,audioUrl}})
  ApiClient ->> AiEngineCF: analyzePronunciation
  AiEngineCF -->> ApiClient: feedback
  ApiClient -->> PronScreen: feedback
  PronScreen -->> U: show scores & suggestions
```

> æ—§ç‰ˆé¡¹ç›®å¿«ç…§æ–‡æ¡£ï¼ˆ`docs/Document/project-snapshot-*` ç­‰ï¼‰å·²åˆ é™¤ï¼Œä»»ä½•æ–°éœ€æ±‚å¿…é¡»åŸºäºä»¥ä¸Š Spec æ›´æ–°ã€‚

---

## 3. å½“å‰å®ç°çŠ¶æ€æ¦‚è§ˆï¼ˆæŒ‰æ¨¡å—ï¼‰

çŠ¶æ€ä½¿ç”¨ï¼š`âœ… å®Œæˆ` / `ğŸŸ¡ éƒ¨åˆ†å®ç°` / `â³ è§„åˆ’ä¸­`

### 3.1 Alphabet Module

- è·¯ç”± & ç»„ä»¶ç»“æ„ï¼š`app/alphabet/*` + `AlphabetLearningEngineView`ï¼šğŸŸ¡ éƒ¨åˆ†å®ç°  
  - ç°æœ‰å®ç°åŒ…å«åŸºæœ¬â€œæ˜¨æ—¥å¤ä¹  + ä»Šæ—¥å­¦ä¹  + Mini Review + ä¸‰è½®è¯„ä¼°â€é€»è¾‘ï¼Œä½†ä¸‰æ–°ä¸€å¤/Final Review/é”™é¢˜è¡¥æ•‘å°šæœªå®Œå…¨æŒ‰ Spec å®è£…ã€‚  
- Store & Hookï¼š`alphabetStore` + `useAlphabetLearningEngine`ï¼šğŸŸ¡ éƒ¨åˆ†å®ç°  
  - å·²å¯¹æ¥ `memory-engine.getTodayMemories` / `submitMemoryResult` / `submitRoundEvaluation`ï¼›  
  - å°šæœªå¼•å…¥ç¬¬ 11 ç« å®šä¹‰çš„æœ¬åœ° `AlphabetSessionState` èšåˆè¯„åˆ†ä¸ä¼šè¯æ¢å¤ã€‚  
- Question Engineï¼ˆ6 å¤§é¢˜å‹ï¼‰ï¼šâ³ è§„åˆ’ä¸­  
  - ç›®å‰ä»ä½¿ç”¨ `lettersQuestionGenerator` çš„å¤šé¢˜å‹å‡½æ•°ï¼Œæœªåˆ‡æ¢åˆ°ç»Ÿä¸€ GameType åè®®ã€‚

### 3.2 Vocabulary Module

- è·¯ç”± & é¡µé¢ï¼š`app/learning/index.tsx` ä¸­çš„ `WordSession`ï¼šğŸŸ¡ éƒ¨åˆ†å®ç°ï¼ˆä½¿ç”¨ mock é˜Ÿåˆ—ï¼‰  
  - å½“å‰ç‰ˆæœ¬ä½¿ç”¨å›ºå®šçš„ `MOCK_OLD_WORDS` / `MOCK_NEW_WORDS` é˜Ÿåˆ—æ¨¡æ‹Ÿå¤ä¹ ä¸æ–°è¯ï¼›  
  - å°šæœªæ¥å…¥ `vocabulary` äº‘å‡½æ•°çš„ `getTodayWords`ï¼Œä¹Ÿæœªä½¿ç”¨ç»Ÿä¸€è®°å¿†å¼•æ“æäº¤åˆ†æ•°ã€‚  
- Storeï¼š`src/stores/vocabularyStore.ts`ï¼šğŸŸ¡ éƒ¨åˆ†å®ç°  
  - å·²å…·å¤‡ `initSession` / `submitAnswer` ç­‰æ¥å£ï¼Œä½†å­—æ®µå’Œåç«¯æ–°é›†åˆç»“æ„å­˜åœ¨åå·®ï¼›  
  - éœ€è¦æŒ‰ `vocabulary-module-spec.md` é‡æ„ä¸º `VocabularySessionState` é©±åŠ¨ã€‚  
- é¢˜å‹ä½“ç³»ï¼ˆ4 ä¸ªé€‰æ‹©é¢˜ + 2 ä¸ªæ‹¼å†™é¢˜ï¼‰ï¼šâ³ è§„åˆ’ä¸­  
  - ç›®å‰æ²¡æœ‰ç»Ÿä¸€çš„é¢˜å‹æšä¸¾å’Œå®¹å™¨ç»„ä»¶ï¼ŒNewWordView / ReviewWordView ä¸»è¦ç”¨äº Web ç«¯åŸå‹ã€‚

### 3.3 Courses + LearningStore

- Courses é¡µé¢ï¼š`app/(tabs)/courses.tsx`ï¼šâœ… å®Œæˆï¼ˆé¦–å‘éœ€æ±‚ï¼‰  
  - å·²èƒ½æ ¹æ® `alphabetCourses.json` å’Œ `courses.json` å±•ç¤ºè¯¾ç¨‹å¡ç‰‡ï¼Œå¹¶è·³è½¬åˆ° `/alphabet` æˆ– `/learning`ï¼›  
  - æ”¯æŒæŒ‰ category / æœç´¢è¿‡æ»¤è¯¾ç¨‹ã€‚  
- LearningPreferenceStoreï¼ˆæ¯æ—¥ä¸Šé™ï¼‰ï¼šâœ… å®Œæˆ  
  - å·²å¯é…ç½® `dailyLimits.word` / `dailyLimits.letter`ï¼Œå¹¶åœ¨ `WordSession` / `AlphabetSession` ä¸­ä½¿ç”¨ã€‚  
- LearningStoreï¼ˆå…¨å±€ä»ªè¡¨ç›˜ï¼‰ï¼šğŸŸ¡ éƒ¨åˆ†å®ç°  
  - å½“å‰ `learningStore` ä»æ˜¯ demo å‹å®ç°ï¼Œæœªå®Œå…¨æŒ‰ spec çš„ `currentCourseId` / `streakDays` ç­‰å­—æ®µé‡æ„ã€‚  

### 3.4 Backend Memory Engine

- `memory-engine` äº‘å‡½æ•°ï¼šâœ… å®Œæˆ  
  - `getTodayMemories` / `submitMemoryResult` / `submitRoundEvaluation` / `checkModuleAccess` / `getUserProgress` å·²ä¸Šçº¿å¹¶è¢« Alphabet / éƒ¨åˆ†å‰ç«¯é€»è¾‘ä½¿ç”¨ã€‚  
- `learn-vocab` äº‘å‡½æ•°ï¼šâœ… å®Œæˆï¼ˆè€ç‰ˆè¯æ±‡ APIï¼‰  
  - `getTodayWords` / `updateMastery` / `getVocabularyDetail` / `getReviewStatistics` ç­‰å·²å®ç°ï¼›  
  - å°†é€æ­¥ä¸æ–°çš„ Vocabulary Module Spec å¯¹é½ã€‚

### 3.5 AI Module

- äº‘å‡½æ•° `ai-engine`ï¼šâ³ è§„åˆ’ä¸­ï¼ˆæœªåˆ›å»ºï¼‰  
- å‰ç«¯å…¥å£ï¼ˆé¡µé¢/æŒ‰é’®ï¼‰ï¼šâ³ è§„åˆ’ä¸­  
- ä»…åœ¨ Spec ä¸­å®šä¹‰äº† Action å’Œæ•°æ®ç»“æ„ï¼Œä¸å½±å“é¦–å‘ã€‚

---

## 4. å…¨å±€ä»»åŠ¡åˆ—è¡¨ï¼ˆæŒ‰æ¨¡å—é¡ºåºï¼Œä¸æ··åˆå¼€å‘ï¼‰

> ä»»åŠ¡çŠ¶æ€ï¼š`[x] å·²å®Œæˆ` / `[~] è¿›è¡Œä¸­` / `[ ] å¾…åš`  
> å¼€å‘é¡ºåºï¼š**å…ˆå®Œæˆä¸€ä¸ªæ¨¡å—çš„æ ¸å¿ƒä»»åŠ¡å†è¿›å…¥ä¸‹ä¸€ä¸ªæ¨¡å—**ï¼Œé¿å…è·¨æ¨¡å—æ¥å›åˆ‡æ¢ã€‚

### 4.1 Phase 0ï¼šæ¶æ„ä¸æ–‡æ¡£åŸºçº¿ï¼ˆå·²å®Œæˆï¼‰

- [x] åˆ é™¤æ‰€æœ‰æ—§ç‰ˆé¡¹ç›®å¿«ç…§æ–‡æ¡£ï¼ˆ`docs/Document/project-snapshot-*`ï¼‰ã€‚  
- [x] ä¸º Alphabet / Vocabulary / Courses & LearningStore / Backend / AI å„æ¨¡å—ç”Ÿæˆå†»ç»“ Specã€‚  
- [x] æŠ½å–ç»Ÿä¸€è®°å¿†å¼•æ“ + SMâ€‘2 è¡Œä¸ºåˆ° `backend-memory-engine-spec.md`ã€‚  
- [x] æ–°å¢é¡¹ç›®æ€»çº²æ–‡æ¡£ `PROJECT_OVERVIEW_SPEC.md` ä½œä¸ºé¡¶å±‚å…¥å£ã€‚  

> ä»æœ¬é˜¶æ®µç»“æŸèµ·ï¼Œæ‰€æœ‰è®¾è®¡ä¸å®ç°ä»¥ `project-freeze` ä¸‹çš„ Spec + å®é™…ä»£ç ä¸ºå”¯ä¸€ä¾æ®ã€‚

### 4.2 Phase 1ï¼šå¯¹é½å­—æ¯æ¨¡å—ä¸ç»Ÿä¸€è®°å¿†å¼•æ“ï¼ˆå½“å‰ä¼˜å…ˆä»»åŠ¡ï¼‰

> ç›®æ ‡ï¼šå…ˆå½»åº•æŠŠ Alphabet Module ä¸ `memory-engine` å¯¹é½ï¼Œä¿è¯è¯¾ç¨‹çº§ä¸‰è½®é€»è¾‘ + SMâ€‘2 è´¨é‡æäº¤æµç¨‹å®Œå…¨é—­ç¯ï¼Œç„¶åå†å¯åŠ¨ä¸‹ä¸€ä¸ªæ¨¡å—ã€‚

- [~] A1ï¼šæ ¡å‡†å­—æ¯è¯¾ç¨‹è§£é”é€»è¾‘ï¼ˆ`alphabet-module-spec.md` ç¬¬ 10 ç« ï¼‰ã€‚  
  - åªåœ¨ Round3 å®Œæˆä¸”é€šè¿‡æ—¶ï¼Œè°ƒç”¨ `markAlphabetLessonCompleted(lessonId)` è§£é”ä¸‹ä¸€è¯¾ã€‚  
  - ä¸ `user_alphabet_progress.currentRound` / `roundHistory` å­—æ®µä¿æŒä¸€è‡´ã€‚  
- [ ] A2ï¼šå®ç° `AlphabetSessionState` ä¸ä¼šè¯æ¢å¤ï¼ˆç¬¬ 11 ç« ï¼‰ã€‚  
  - åœ¨ `alphabetStore` ä¸­å¢åŠ  Session çŠ¶æ€ç»“æ„ï¼›  
  - ä½¿ç”¨ AsyncStorage ä»¥ `alphabet-session:${userId}:${lessonId}` ä¸º key æŒä¹…åŒ–ï¼›  
  - æ”¯æŒåœ¨ Yesterday Review / ä¸‰æ–°ä¸€å¤ / Final Review / é”™é¢˜é›†ä»»æ„é˜¶æ®µä¸­é€”é€€å‡ºå¹¶æ¢å¤ã€‚  
- [ ] A3ï¼šæŒ‰â€œå­—æ¯ Ã— è½®æ¬¡ Ã— å½“å¤©â€èšåˆè´¨é‡ï¼Œå¹¶åˆ‡æ¢åˆ°æ‰¹é‡ `submitMemoryResult`ã€‚  
  - åœ¨ Hook å†…ç»´æŠ¤ `perLetterStats`ï¼›  
  - Round ç»“æŸæˆ–ç”¨æˆ·ç‚¹å‡»â€œç»“æŸä»Šå¤©å­¦ä¹ â€æ—¶ï¼Œæ„é€  `{ results: [{ entityType:'letter', entityId, quality }, ...] }` è°ƒç”¨ memory-engineï¼›  
  - ç¡®è®¤ CloudBase æ—¥å¿—ä¸­æ¯ä¸ªå­—æ¯æ¯è½®æœ€å¤šåªäº§ç”Ÿä¸€æ¬¡è´¨é‡è®°å½•ã€‚  
- [ ] A4ï¼šä¸ `backend-memory-engine-spec.md` çš„ `getTodayMemories(letter, lessonId)` çº¦å®šå¯¹é½ã€‚  
  - è¯¾ç¨‹é˜Ÿåˆ—ä¸»è¦ç”±å‰ç«¯æ„å»ºï¼›  
  - è‹¥ä»ä½¿ç”¨ `getTodayMemories` åˆå§‹åŒ–é˜Ÿåˆ—ï¼Œéœ€è¦ç¡®ä¿åªä½œä¸ºâ€œæ•´è¯¾å­—æ¯ + memoryStateâ€çš„æ•°æ®æºï¼Œè€Œä¸ä¸å‰ç«¯ Session é˜Ÿåˆ—é€»è¾‘å†²çªã€‚  

> åªæœ‰å½“ A1â€“A4 å®Œæ•´é€šè¿‡è‡ªæµ‹å¹¶ç¨³å®šåï¼Œæ‰å¼€å§‹ Phase 2ã€‚

### 4.3 Phase 2ï¼šAlphabet é¢˜å‹ä¸ä½“éªŒå®Œå–„

- [ ] B1ï¼šå®ç°ç»Ÿä¸€çš„ Alphabet Question Engineï¼ˆæ¥å£å®šä¹‰è§æœ¬æ–‡ä»¶ä¸ `alphabet-module-spec.md` ç¬¬ 6 ç« ï¼‰ã€‚  
  - å®šä¹‰ `GameType / QueueItem` åè®®ï¼›  
  - å°†ç°æœ‰ `lettersQuestionGenerator` è¿ç§»åˆ°æ–°åè®®ä¸‹ã€‚  
- [ ] B2ï¼šå®ç°ä¸‰æ–°ä¸€å¤ + Final Review çš„é¢˜å‹ç¼–æ’ã€‚  
  - ä¸‰æ–°ä¸€å¤ï¼šä½¿ç”¨è½»é‡é¢˜å‹ï¼ˆå¬éŸ³é€‰å­— / çœ‹å­—é€‰éŸ³ï¼‰ï¼›  
  - Final Reviewï¼šä½¿ç”¨é€»è¾‘/æ•´åˆé¢˜ï¼ˆæ‹¼è¯»æ•°å­¦ / å£°è°ƒè®¡ç®—ç­‰ï¼‰ã€‚  
- [ ] B3ï¼šå®Œå–„é”™é¢˜é›†ä¸ä¸‰è½®è¯„ä¼°å±•ç¤ºã€‚  
  - Round ç»“æœé¡µå±•ç¤ºæ¯è½®æ­£ç¡®ç‡ä¸â€œé”™è¯¯æœ€å¤šçš„è‹¥å¹²å­—æ¯â€ï¼›  
  - ä¸ºåç»­ AI æ¨¡å—æä¾›è¾“å…¥æ•°æ®ã€‚

### 4.4 Phase 3ï¼šVocabulary Module é‡æ„ï¼ˆåœ¨ Phase 2 å®Œæˆåå¯åŠ¨ï¼‰

- [ ] C1ï¼šæ¥å…¥ `vocabulary.getTodayWords`ï¼Œç§»é™¤ `WordSession` ä¸­çš„ mock é˜Ÿåˆ—ã€‚  
  - `WordSession` ä½¿ç”¨ `vocabularyStore.initializeSession` è·å–ä»Šæ—¥å¤ä¹  + æ–°è¯åˆ—è¡¨ã€‚  
- [ ] C2ï¼šé‡æ„ `vocabularyStore`ï¼Œå®ç° `VocabularySessionState` + `perWordStats` + ä¼šè¯æ¢å¤ã€‚  
  - ç»“æ„ä¸å­—æ¯æ¨¡å—çš„ Session æ€è·¯å¯¹é½ï¼Œä½†ä»ä½¿ç”¨ `learn-vocab.updateMastery` æäº¤ç»“æœã€‚  
- [ ] C3ï¼šå®ç° 4 ç§é€‰æ‹©é¢˜é¢˜å‹å®¹å™¨ï¼Œå¹¶æ¥å…¥ `ReviewWordView`ã€‚  
  - çœ‹æ³°è¯­é€‰ä¸­æ–‡ã€çœ‹ä¸­æ–‡é€‰æ³°è¯­ã€å¬éŸ³é€‰æ³°è¯­ã€å¬éŸ³é€‰ä¸­æ–‡ã€‚  
- [ ] C4ï¼ˆå¯é€‰ï¼‰ï¼šå®ç° 2 ç§æ‹¼å†™é¢˜ï¼Œå¹¶æ¥å…¥ç»Ÿè®¡ã€‚  
- [ ] C5ï¼šç¡®å®šè¯æ±‡æœ€ç»ˆä½¿ç”¨çš„è®°å¿†åç«¯ï¼ˆ`user_vocabulary_progress` vs `memory_status`ï¼‰ï¼Œå¹¶å®Œæˆåˆ°ç»Ÿä¸€æ¥æºçš„è¿ç§»ã€‚

### 4.5 Phase 4ï¼šCourses + LearningStore æ”¶å°¾

- [x] D0ï¼šCourses é¡µé¢æ¥å…¥å­—æ¯/å•è¯è¯¾ç¨‹ JSON å¹¶å±•ç¤ºã€‚  
- [ ] D1ï¼šLearningStore é‡æ„ä¸ºè½»é‡ä»ªè¡¨ç›˜ï¼ˆ`currentCourseId` / `currentAlphabetProgramId` / `streakDays` / `totalStudyMinutes` ç­‰ï¼‰ã€‚  
- [ ] D2ï¼šåœ¨ Courses ç‚¹å‡»è¯¾ç¨‹æ—¶æ›´æ–° LearningStoreã€‚  
  - å­—æ¯è¯¾ç¨‹ï¼š`setCurrentAlphabetProgram('alphabet')`ï¼›  
  - è¯æ±‡è¯¾ç¨‹ï¼š`setCurrentCourse(courseId)`ã€‚  
- [ ] D3ï¼šé¦–é¡µ/ä¸ªäººä¸­å¿ƒæ ¹æ® `learningStore` å’Œ `moduleAccessStore` å±•ç¤ºå­¦ä¹ æ¦‚è§ˆï¼ˆå½“å‰åœ¨å­¦è¯¾ç¨‹ã€æœ€è¿‘å­¦ä¹ æ—¶é—´ã€å­¦ä¹ æ—¶é•¿ç­‰ï¼‰ã€‚

### 4.6 Phase 5ï¼šAI æ¨¡å—å ä½ä¸ MVP

- [ ] E1ï¼šåˆ›å»º `ai-engine` äº‘å‡½æ•°éª¨æ¶ + API_ENDPOINTS å ä½ã€‚  
- [ ] E2ï¼šåœ¨å­—æ¯/è¯æ±‡æ¨¡å—ä¸­å¢åŠ â€œAI å‘éŸ³ç»ƒä¹ â€å…¥å£ï¼ˆä»…è°ƒç”¨å ä½æ¥å£ï¼Œè¿”å›å›ºå®šæ–‡æ¡ˆï¼‰ã€‚  
- [ ] E3ï¼ˆå¯é€‰ï¼‰ï¼šå®ç°å‘éŸ³åé¦ˆ MVPï¼ˆå½•éŸ³ â†’ ä¸Šä¼  â†’ `analyzePronunciation`ï¼‰ã€‚  


---

## 5. é‡Œç¨‹ç¢‘è§„åˆ’ï¼ˆä»ç°åœ¨èµ·çº¦ 2 ä¸ªæœˆï¼‰

> æ—¶é—´ä¼°ç®—ä»¥â€œå…¨èŒå¼€å‘è€…â€ä¸ºå‚è€ƒï¼Œå¯æ ¹æ®å®é™…äººåŠ›è°ƒæ•´ã€‚

### M1ï¼ˆç¬¬ 1â€“2 å‘¨ï¼‰ï¼šæ¶æ„ç¨³å®š & Alphabet P0

- å®Œæˆäº‹é¡¹ï¼š
  - [x] åˆ é™¤æ—§å¿«ç…§æ–‡æ¡£ï¼Œå†»ç»“ project-freeze ç»“æ„ï¼›  
  - [x] åç«¯ memory-engine / learn-vocab è¡Œä¸ºæ¢³ç†å®Œæ¯•ï¼›  
  - [~] ä¿®æ­£ Alphabet è§£é”é€»è¾‘ï¼Œä½¿ Round3 é€šè¿‡åæ‰è§£é”ä¸‹ä¸€è¯¾ã€‚  
- è¾“å‡ºï¼š
  - å¯ç¨³å®šä½¿ç”¨çš„å­—æ¯è¯¾ç¨‹æµç¨‹ï¼ˆå³ä½¿ Question Engine å°šæœªå®Œå…¨ä¸Šçº¿ï¼‰ã€‚

### M2ï¼ˆç¬¬ 3â€“4 å‘¨ï¼‰ï¼šAlphabet ä¼šè¯æ¢å¤ + Vocabulary æ¥å…¥åç«¯

- ç›®æ ‡ï¼š
  - [ ] å®ç° Alphabet `AlphabetSessionState` + ä¼šè¯æ¢å¤ +æ‰¹é‡æäº¤ï¼›  
  - [ ] è¯æ±‡æ¨¡å—æ¥å…¥ `getTodayWords`ï¼Œç§»é™¤ mock é˜Ÿåˆ—ï¼›  
  - [ ] åˆæ­¥å®ç° VocabularySessionStateï¼ˆä¸å«æ‹¼å†™é¢˜ï¼‰ã€‚

### M3ï¼ˆç¬¬ 5â€“6 å‘¨ï¼‰ï¼šé¢˜å‹å®Œå–„ + LearningStore é‡æ„

- ç›®æ ‡ï¼š
  - [ ] Alphabet / Vocabulary çš„é€‰æ‹©é¢˜é¢˜å‹å®¹å™¨ç¨³å®šï¼›  
  - [ ] LearningStore é‡æ„å®Œæˆï¼Œé¦–é¡µ/è¯¾ç¨‹é¡µæ­£ç¡®æ˜¾ç¤ºå½“å‰è¯¾ç¨‹å’Œå­¦ä¹ ç»Ÿè®¡ï¼›  
  - [ ] å›å½’æµ‹è¯•å¤šæ¨¡å—åˆ‡æ¢ä¸è§£é”é€»è¾‘ã€‚

### M4ï¼ˆè§†æ—¶é—´è€Œå®šï¼‰ï¼šæ‹¼å†™é¢˜ + AI å ä½

- ç›®æ ‡ï¼š
  - [ ] è‡³å°‘å®ç°ä¸€ç±»æ‹¼å†™é¢˜ï¼ˆçœ‹ä¸­æ–‡æ‹¼å†™æ³°è¯­ï¼‰å¹¶æ¥å…¥ç»Ÿè®¡ï¼›  
  - [ ] å®Œæˆ `ai-engine` äº‘å‡½æ•°éª¨æ¶å’Œå‰ç«¯å…¥å£ï¼ˆæŒ‰é’®/é¡µé¢ï¼‰ï¼Œä½¿åç»­ AI èƒ½åŠ›å¯ä»¥å¹³æ»‘æ¥å…¥ã€‚

---

## 6. å¼€å‘çº¦å®šä¸å˜æ›´æµç¨‹

1. **ä»¥ä»£ç ä¸ºå‡†ï¼Œä½†å¿…é¡»åŒæ­¥æ›´æ–° Specï¼š**
   - æ‰€æœ‰ä¸šåŠ¡/æ¥å£å˜æ›´å¿…é¡»å…ˆåœ¨å¯¹åº”æ¨¡å— Spec ä¸­ä¿®æ”¹ï¼Œå†æ›´æ–°å®ç°ï¼›  
   - è‹¥å‘ç° Spec ä¸ä»£ç ä¸ä¸€è‡´ï¼Œä»¥**å½“å‰ä»£ç  + æœ¬æ€»çº²**ä¸ºåŸºå‡†ä¿®æ­£æ–‡æ¡£ã€‚
2. **ç¦æ­¢æ–°å¢â€œç¬¬äºŒå¥—é€»è¾‘â€ï¼š**
   - è®°å¿†é˜Ÿåˆ— / è¯„åˆ† / æ¨¡å—è§£é”åªèƒ½é€šè¿‡ç»Ÿä¸€è®°å¿†å¼•æ“ + å„æ¨¡å— Spec çº¦å®šçš„ Storeï¼›  
   - ä¸å¾—åœ¨ç»„ä»¶å†…éƒ¨å·å·æ·»åŠ æ–°çš„çŠ¶æ€æˆ–åç«¯é›†åˆã€‚
3. **æ–‡æ¡£ä½ç½®çº¦å®šï¼š**
   - æ–°æ¨¡å—ã€æ–°äº‘å‡½æ•°çš„è§„æ ¼å¿…é¡»æ”¾åœ¨ `docs/project-freeze` ä¸‹ï¼Œå¹¶ä» `PROJECT_OVERVIEW_SPEC.md` é“¾æ¥å‡ºå»ã€‚  

æœ¬æ–‡ä»¶ä¸åŒç›®å½•ä¸‹å…¶ä»– Spec ä¸€èµ·ï¼Œæ„æˆæœ¬é¡¹ç›®çš„â€œæœ€ç»ˆå†»ç»“è“å›¾â€ã€‚  
åç»­å¼€å‘äººå‘˜åªéœ€éµå®ˆæœ¬æ€»çº²å’Œå„æ¨¡å— Specï¼Œå³å¯åœ¨ä¸ç ´åæ•´ä½“æ¶æ„çš„å‰æä¸‹è¿­ä»£å®ç°åŠŸèƒ½ã€‚

---

## 7. é¡¹ç›®ä»£ç å¿«ç…§ï¼ˆæŒ‰å½“å‰ä»“åº“çŠ¶æ€ï¼‰

> æœ¬èŠ‚ä»…ç”¨äº**å¿«é€Ÿäº†è§£å½“å‰ä»£ç ç»“æ„ä¸å®ç°èŒƒå›´**ï¼Œä¸é¢å¤–å¼•å…¥æ–°è®¾è®¡ã€‚  
> ä»»ä½•è¡Œä¸ºå®šä¹‰ä»ä»¥å„æ¨¡å— Spec + å®é™…ä»£ç ä¸ºå‡†ã€‚

### 7.1 å‰ç«¯ç›®å½•å¿«ç…§ï¼ˆsrc/ï¼‰

- `src/components/`
  - `learning/`
    - `NewWordView.tsx`ï¼šWeb é£æ ¼è¯æ±‡ç²¾è®²å¡ç‰‡ç»„ä»¶ï¼Œç›®å‰ä¸»è¦ç”¨äºè®¾è®¡å‚è€ƒï¼Œç§»åŠ¨ç«¯å­¦ä¹ æš‚æœªå®Œå…¨æ¥å…¥ã€‚  
    - `ReviewWordView.tsx`ï¼šæ—§ç‰ˆè¯æ±‡å¤ä¹ ç»„ä»¶ï¼Œå†…éƒ¨ä»ä½¿ç”¨â€œå¿˜è®°/æ¨¡ç³Š/è®°å¾—â€ä¸‰æŒ‰é’®ã€‚  
    - `alphabet/AlphabetLearningView.tsx`ï¼šå•å­—æ¯æ•™å­¦å¡ï¼ˆå±•ç¤ºå­—å½¢ã€åç§°ã€å‘éŸ³æŒ‰é’®ç­‰ï¼‰ã€‚  
    - `alphabet/AlphabetReviewView.tsx`ï¼šå­—æ¯å¤ä¹ ç»„ä»¶ï¼Œè°ƒç”¨ `lettersQuestionGenerator` ç”Ÿæˆé¢˜ç›®ã€‚  
  - `courses/AlphabetCourseCard.tsx`ï¼šå­—æ¯å¤§è¯¾ç¨‹å¡ç‰‡ï¼›`CourseCard.tsx`ï¼šè¯æ±‡è¯¾ç¨‹å¡ç‰‡ã€‚
  - `common/ThaiPatternBackground.tsx`ï¼šé€šç”¨èƒŒæ™¯è£…é¥°ã€‚

- `src/stores/`
  - `alphabetStore.ts`ï¼šå­—æ¯å­¦ä¹  Storeï¼Œç»´æŠ¤ `queue / currentAlphabet / completedCount / totalCount`ï¼Œå¯¹æ¥ `memory-engine`ã€‚  
  - `vocabularyStore.ts`ï¼šè¯æ±‡ Storeï¼Œå½“å‰å®ç°ä»åŸºäºæ—§ç‰ˆ `TodayVocabularyResponse` å’Œæœ¬åœ°è¿›åº¦ï¼Œéœ€è¦æŒ‰ Spec é‡æ„ã€‚  
  - `moduleAccessStore.ts`ï¼šåŒ…è£…åç«¯ `getUserProgress / checkModuleAccess`ï¼Œæä¾›æ¨¡å—è§£é”çŠ¶æ€ç»™å‰ç«¯ã€‚  
  - `learningPreferenceStore.ts`ï¼šæ¯æ—¥å­¦ä¹ ä¸Šé™è®¾ç½®ï¼ˆå­—æ¯/å•è¯ï¼‰ã€‚  
  - `learningStore.ts`ï¼šæ—§ç‰ˆå…¨å±€å­¦ä¹ ä»ªè¡¨ç›˜ï¼Œå«å†™æ­» demo æ•°æ®ã€‚  
  - `userStore.ts`ï¼šç™»å½•ç”¨æˆ·ä¿¡æ¯ã€‚

- `src/hooks/`
  - `useAlphabetLearningEngine.ts`ï¼šå­—æ¯ä¸‰è½®å­¦ä¹ ä¸šåŠ¡ Hookï¼Œé©±åŠ¨ `AlphabetLearningEngineView`ï¼›éƒ¨åˆ† Phase ä¸é”™é¢˜è¡¥æ•‘é€»è¾‘å°šæœªå®Œå…¨å®ç°ã€‚  
  - å…¶ä»–ä¸šåŠ¡ Hookï¼ˆå¦‚å…¬ç”¨ API è°ƒç”¨ç­‰ï¼‰ã€‚

- `src/entities/types/`
  - `alphabet.types.ts`ï¼šå­—æ¯å®ä½“ç±»å‹ã€å­¦ä¹ çŠ¶æ€ç±»å‹ç­‰ã€‚  
  - `vocabulary.types.ts`ï¼šæ–°ç‰ˆè¯æ±‡ç±»å‹ï¼Œä¸æ•°æ®åº“ schema å¯¹é½ï¼ˆåŒ…å«ä¾‹å¥ã€å¯¹è¯ã€ç”¨æ³•ç­‰å¯Œå­—æ®µï¼‰ã€‚  
  - å…¶ä»–åŸºç¡€ç±»å‹å®šä¹‰ã€‚

- `src/utils/`
  - `apiClient.ts`ï¼š`callCloudFunction` å°è£…ï¼Œè´Ÿè´£ HTTP è§¦å‘å™¨è°ƒç”¨ã€‚  
  - `lettersQuestionGenerator.ts`ï¼šå½“å‰å­—æ¯é¢˜ç›®ç”Ÿæˆå™¨ï¼ˆSOUND_TO_LETTER ç­‰å¤šé¢˜å‹ï¼‰ã€‚  

### 7.2 è·¯ç”±ç»“æ„å¿«ç…§ï¼ˆapp/ï¼‰

- `app/(tabs)/_layout.tsx`ï¼šåº•éƒ¨ Tab å¯¼èˆªå¸ƒå±€ã€‚  
- `app/(tabs)/courses.tsx`ï¼šè¯¾ç¨‹æ€»è§ˆé¡µï¼Œè¯»å– `alphabetCourses.json` + `courses.json`ï¼Œå±•ç¤ºè¯¾ç¨‹å¡ç‰‡ã€‚  
- `app/alphabet/index.tsx`ï¼šå­—æ¯è¯¾ç¨‹åˆ—è¡¨é¡µï¼ˆå½“å‰ç›´æ¥åˆ—å‡º Lesson1~7ï¼‰ï¼Œç‚¹å‡»è·³è½¬åˆ° `/alphabet/[lessonId]`ã€‚  
- `app/alphabet/[lessonId].tsx`ï¼šå•è¯¾å­—æ¯å­¦ä¹ å…¥å£ï¼Œè°ƒç”¨ `useAlphabetLearningEngine(lessonId)`ã€‚  
- `app/learning/index.tsx`ï¼š
  - æ ¹æ® `module` åŒºåˆ† `WordSession`ï¼ˆè¯æ±‡ï¼‰ä¸ `AlphabetSession`ï¼ˆå­—æ¯ï¼‰ï¼›  
  - å½“å‰ `WordSession` ä»ä½¿ç”¨ç¡¬ç¼–ç çš„ `MOCK_OLD_WORDS` / `MOCK_NEW_WORDS` é˜Ÿåˆ—ï¼›  
  - `AlphabetSession` ä½œä¸ºæ—§ç‰ˆå­—æ¯å­¦ä¹ å…¥å£å­˜åœ¨ï¼Œåç»­å°†ä»¥ `/alphabet/*` ç»“æ„ä¸ºä¸»ã€‚  
- `app/learning/setup.tsx`ï¼šè®¾ç½®æ¯æ—¥å­¦ä¹ è®¡åˆ’é¡µé¢ï¼ˆå­—æ¯/å•è¯æ¯æ—¥ä¸Šé™ï¼‰ã€‚
- `app/auth/*`ï¼šç™»å½•ã€æ³¨å†Œç­‰è®¤è¯é¡µã€‚

### 7.3 äº‘å‡½æ•°ä¸åç«¯å¿«ç…§ï¼ˆcloudbase/functions/ï¼‰

- `memory-engine/`
  - `index.js`ï¼šç»Ÿä¸€è®°å¿†å¼•æ“å…¥å£ï¼Œè§£æ HTTP bodyï¼ŒæŒ‰ `action` åˆ†å‘ã€‚  
  - `handlers/getTodayMemories.js`ï¼šåŸºäº `memory_status` + å®ä½“é›†åˆç”Ÿæˆä»Šæ—¥å­—æ¯/å•è¯/å¥å­é˜Ÿåˆ—ï¼›æ”¯æŒå­—æ¯è¯¾ç¨‹çš„ `lessonId` æ¨¡å¼ã€‚  
  - `handlers/submitMemoryResult.js`ï¼šæ”¯æŒå•æ¡æˆ–æ‰¹é‡å­¦ä¹ ç»“æœæäº¤ï¼Œå†…éƒ¨è°ƒç”¨ `updateMemoryAfterReview`ã€‚  
  - `handlers/submitRoundEvaluation.js`ï¼šå­—æ¯ä¸‰è½®è¯„ä¼°ç»“æœå†™å…¥ `user_alphabet_progress`ã€‚  
  - `utils/memoryEngine.js`ï¼š`getOrCreateMemory` / `updateMemoryAfterReview` / `checkModuleAccess` / `initUserProgress`ã€‚  
  - `utils/sm2.js`ï¼šä¼˜åŒ–ç‰ˆ SMâ€‘2 ç®—æ³•å®ç°ã€‚  

- `learn-vocab/`
  - `index.js`ï¼šè¯æ±‡ä¸“ç”¨äº‘å‡½æ•°å…¥å£ï¼ŒåŠ¨ä½œåŒ…æ‹¬ `getTodayWords` / `updateMastery` / `getVocabularyDetail` / `getReviewStatistics` ç­‰ã€‚  
  - `handlers/getTodayWords.js`ï¼šä» `user_vocabulary_progress` + `vocabulary` æ„å»ºä»Šæ—¥è¯æ±‡åˆ—è¡¨ã€‚  
  - `handlers/updateMastery.js`ï¼šæ ¹æ® `mastery` å­—æ®µæ›´æ–°è¯æ±‡ SRS ä¿¡æ¯ã€‚  

- å…¶ä»–ï¼š
  - `alphabet/`ï¼šä¸å­—æ¯æ•°æ®ç®¡ç†ç›¸å…³çš„è¾…åŠ©äº‘å‡½æ•°ï¼ˆå¦‚æ‰¹é‡å¯¼å…¥ç­‰ï¼Œé¦–å‘ä¸å¿…ä¾èµ–ï¼‰ã€‚  
  - `user-*`ï¼šç”¨æˆ·æ³¨å†Œã€ç™»å½•ã€é‡ç½®å¯†ç ã€æ›´æ–°ä¿¡æ¯ã€‚  
  - `storage-download` / `shared`ï¼šå…¬å…±å·¥å…·ä¸æ–‡ä»¶ä¸‹è½½ã€‚

### 7.4 æ•°æ®åº“ç»“æ„å¿«ç…§ï¼ˆå…³é”®é›†åˆï¼‰

> è¯¦ç»†å­—æ®µè§„èŒƒä»¥ `docs/database_schema.md` ä¸ºå‡†ï¼›  
> æœ¬èŠ‚åªåšç®€è¦ç´¢å¼•ï¼Œæ–¹ä¾¿ä»ä»£ç å¿«ç…§è·³è½¬åˆ°æ•°æ®åº“æ–‡æ¡£ã€‚

- `letters`ï¼ˆå­—æ¯/å…ƒéŸ³/å£°è°ƒè¡¨ï¼‰
  - ç»“æ„ï¼šè§ `database_schema.md` 1.4ï¼›  
  - ç”¨é€”ï¼šå­—æ¯æ¨¡å—è¯¾ç¨‹æ•°æ®ã€é¢˜ç›®ç”Ÿæˆã€‚

- `vocabulary`ï¼ˆè¯æ±‡è¡¨ï¼‰
  - ç»“æ„ï¼šè§ `database_schema.md` 1.2ï¼›  
  - ç”¨é€”ï¼šè¯æ±‡æ¨¡å—å­¦ä¹ /å¤ä¹ ã€å¯Œåª’ä½“å†…å®¹ï¼ˆä¾‹å¥ã€å¯¹è¯ã€åŒæºè¯ï¼‰ã€‚

- `memory_status`ï¼ˆç»Ÿä¸€è®°å¿†çŠ¶æ€è¡¨ï¼‰
  - ç»“æ„ï¼šè§ `database_schema.md` 1.7ï¼›  
  - ç”¨é€”ï¼šç»Ÿä¸€ SRS å¼•æ“æ ¸å¿ƒè®°å½•ï¼ŒAlphabet / Vocabulary å‡å¯ä½¿ç”¨ã€‚

- `user_progress`ã€`user_alphabet_progress`ã€`user_vocabulary_progress`
  - ç»“æ„ï¼šè§ `database_schema.md` 1.8â€“1.9 / 1.3ï¼›  
  - ç”¨é€”ï¼šæ¨¡å—è§£é”ã€å­—æ¯ä¸‰è½®è¯„ä¼°ç»Ÿè®¡ã€æ—§ç‰ˆè¯æ±‡è¿›åº¦ã€‚
  - å…³é”®å­—æ®µï¼š  
    - `userId`: stringï¼›  
    - `letterProgress`: numberï¼›`letterCompleted`: booleanï¼›  
    - `completedLessons`: string[]ï¼›`masteredLetterCount`: numberï¼›`totalLetterCount`: numberï¼›  
    - `currentRound`: numberï¼›`roundHistory`: Array\<{ lessonId, roundNumber, totalQuestions, correctCount, accuracy, passed, updatedAt }\>ï¼›  
    - `createdAt` / `updatedAt`: stringã€‚

- `user_vocabulary_progress`ï¼ˆæ—§ç‰ˆè¯æ±‡ SRS çŠ¶æ€ï¼‰
  - æºï¼š`learn-vocab/handlers/getTodayWords.js` / `updateMastery.js`ã€‚  
  - å…³é”®å­—æ®µï¼š  
    - `userId`: stringï¼›`vocabularyId`: string | nullï¼›  
    - `mastery`: `'UNFAMILIAR' | 'FUZZY' | 'REMEMBERED' | null`ï¼›  
    - `skipped`: booleanï¼›  
    - `reviewCount`: numberï¼›`lastReviewed`: string | nullï¼›`nextReviewDate`: string | nullï¼›  
    - `intervalDays`: numberï¼›`easinessFactor`: numberï¼›  
    - `createdAt` / `updatedAt`: stringã€‚

---

æœ¬èŠ‚è®°å½•çš„æ˜¯å½“å‰ä»“åº“çš„**ä»£ç ç»“æ„ä¸å®ç°å¿«ç…§**ï¼Œç”¨äºå¸®åŠ©åç»­å¼€å‘è€…å¿«é€Ÿå»ºç«‹æ•´ä½“è®¤çŸ¥ã€‚  
å¦‚ä»£ç ç»“æ„å‘ç”Ÿé‡å¤§è°ƒæ•´ï¼Œè¯·åœ¨å®Œæˆé‡æ„åæ›´æ–°æœ¬å¿«ç…§ä»¥åŠç›¸å…³æ¨¡å— Specã€‚***
</file>

<file path="docs/project-freeze/README.md">
# project-freeze è¯´æ˜

æœ¬ç›®å½•ä¸‹çš„æ–‡æ¡£ç”¨äºå†»ç»“ ThaiLearningApp çš„æ ¸å¿ƒæ¶æ„ä¸æ¨¡å—è§„æ ¼ï¼Œ  
æ‰€æœ‰åç»­å¼€å‘åº”ä¼˜å…ˆå‚è€ƒè¿™é‡Œçš„ Specï¼Œè€Œä¸æ˜¯ç›´æ¥å‡­æ„Ÿè§‰æ”¹ä»£ç ã€‚

å½“å‰åŒ…å«ï¼ˆæŒ‰æ¨¡å—åˆ’åˆ†ï¼Œä¸€æ¨¡å—ä¸€æ–‡æ¡£ï¼‰ï¼š

- `PROJECT_OVERVIEW_SPEC.md`  
  - é¡¹ç›®æ€»çº²ï¼šæ¨¡å—åˆ’åˆ†ã€é˜¶æ®µä»»åŠ¡ã€é‡Œç¨‹ç¢‘ã€ä»£ç å¿«ç…§ä¸æ•°æ®åº“æ–‡æ¡£çº¦å®šã€‚

- `frontend-shell-module-spec.md`  
  - å‰ç«¯å£³å±‚ä¸å¯¼èˆªæ¨¡å—ï¼šTab å¯¼èˆªã€é¦–é¡µå±•ç¤ºã€ç”¨æˆ·ä¸­å¿ƒä¸åŸºç¡€è®¾ç½®ã€‚

- `alphabet-module-spec.md`  
  - å­—æ¯æ¨¡å—ï¼ˆAlphabet Moduleï¼‰å®Œæ•´è§„æ ¼ï¼šè·¯ç”±ã€Hookã€Storeã€memory-engineã€æ•°æ®ç»“æ„ä¸æµç¨‹ã€‚

- `courses-and-learningstore-spec.md`  
  - Courses å…¥å£é¡µ + LearningStore å…¨å±€å­¦ä¹ ç®¡ç†å±‚è§„æ ¼ã€‚

- `backend-memory-engine-spec.md`  
  - ç»Ÿä¸€è®°å¿†å¼•æ“ï¼ˆmemory-engine + learn-vocabï¼‰ä¸æ¨¡å—è§£é”é€»è¾‘ã€‚

- `vocabulary-module-spec.md`  
  - è¯æ±‡æ¨¡å—ï¼ˆVocabulary Moduleï¼‰è§„æ ¼ï¼šé¢˜å‹ã€ä¼šè¯çŠ¶æ€ã€ä¸ learn-vocab/memory-engine çš„å¯¹æ¥ã€‚

- `ai-module-spec.md`  
  - è½»é‡ AI æ¨¡å—è®¾è®¡ï¼šå‘éŸ³åé¦ˆã€å¼±é¡¹è¯æ±‡å¼ºåŒ–ã€å¾®é˜…è¯»ç”Ÿæˆã€è¯æ±‡è§£æã€‚

- `database_schema.md`  
  - æ•°æ®åº“ç»“æ„è§„èŒƒï¼ˆV2.1.0ï¼‰ï¼šä»¥ local_cleaner è¾“å‡ºä¸å½“å‰äº‘å‡½æ•°ä¸ºå‡†ã€‚

æ‰€æœ‰æ–°æ¨¡å—ã€æ–°äº‘å‡½æ•°ã€æ–° Store åœ¨è½åœ°ä¹‹å‰éƒ½åº”å…ˆåœ¨æœ¬ç›®å½•ä¸‹è¡¥å……å¯¹åº” Specï¼Œå¹¶åœ¨ `PROJECT_OVERVIEW_SPEC.md` ä¸­ç™»è®°ã€‚***
</file>

<file path="src/components/common/FloatingBubbles.tsx">
// src/components/common/FloatingBubbles.tsx
import React from 'react';
import { View, Text, Pressable, StyleSheet, Dimensions } from 'react-native';
import { Sparkles, PlayCircle } from 'lucide-react-native';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { ReviewItem } from '../../entities/types/entities';

interface FloatingBubblesProps {
  reviews: ReviewItem[];
  onOpenReview: () => void;
}

const { width } = Dimensions.get('window');

export const FloatingBubbles: React.FC<FloatingBubblesProps> = ({
  reviews,
  onOpenReview,
}) => {
  if (reviews.length === 0) return null;

  return (
    <View style={styles.container}>
      {/* Floating Title */}
      <View style={styles.titleContainer}>
        <View style={styles.titleBadge}>
          <Sparkles size={12} color={Colors.thaiGold} />
          <Text style={styles.titleText}>å¾…å¤ä¹ å†…å®¹</Text>
        </View>
      </View>

      {/* Card Stack */}
      <View>
        <Pressable
          onPress={onOpenReview}
          style={styles.cardStackContainer}
        >
          {reviews.slice(0, 3).reverse().map((review, index) => (
            <Card key={review.id} review={review} index={index} />
          ))}

          {/* Notification Badge */}
          <View style={styles.badge}>
            <Text style={styles.badgeText}>{reviews.length}</Text>
          </View>
        </Pressable>
      </View>
    </View>
  );
};

interface CardProps {
  review: ReviewItem;
  index: number;
}

const Card: React.FC<CardProps> = ({ review, index }) => {
  const offsetY = index * 10;
  const scale = 1 - index * 0.04;
  const cardOpacity = 1 - index * 0.1;
  const rotate = index % 2 === 0 ? '-1.5deg' : '1.5deg';

  return (
    <View
      style={[
        styles.card,
        {
          transform: [
            { translateY: offsetY },
            { scale },
            { rotate },
          ],
          zIndex: 30 - index,
          opacity: cardOpacity,
        },
      ]}
    >
      {/* Content */}
      <View style={styles.cardContent}>
        {/* Top Row */}
        <View style={styles.cardTopRow}>
          <View style={styles.typeTag}>
            <Text style={styles.typeTagText}>
              {review.type === 'New' ? 'æ–°è¯' : 'å¤ä¹ '}
            </Text>
          </View>
          <View style={styles.statusDot} />
        </View>

        {/* Middle */}
        <View style={styles.cardMiddleRow}>
          <View>
            <Text style={styles.charText}>{review.char}</Text>
            <Text style={styles.phoneticText}>{review.phonetic}</Text>
          </View>
          <View style={styles.playButton}>
            <PlayCircle size={20} color={Colors.white} />
          </View>
        </View>

        {/* Bottom Progress */}
        <View style={styles.progressBarContainer}>
          <View style={styles.progressBar} />
        </View>
      </View>

      {/* Background Gradient */}
      <View style={styles.backgroundGradient} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    height: 340,
    marginBottom: 32,
    alignItems: 'center',
    justifyContent: 'flex-end',
  },
  titleContainer: {
    position: 'absolute',
    top: 30,
    left: 0,
    right: 0,
    alignItems: 'center',
  },
  titleBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    backgroundColor: 'rgba(26, 26, 26, 0.9)',
    paddingHorizontal: 16,
    paddingVertical: 6,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: 'rgba(212, 175, 55, 0.3)',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  titleText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 11,
    fontWeight: '700',
    letterSpacing: 1.5,
    color: Colors.white,
  },
  cardStackContainer: {
    width: Math.min(320, width - 48),
    height: 280,
    alignItems: 'center',
    justifyContent: 'center',
  },
  card: {
    position: 'absolute',
    width: 256,
    height: 176,
    backgroundColor: Colors.ink,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: 'rgba(212, 175, 55, 0.2)',
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 15 },
    shadowOpacity: 0.2,
    shadowRadius: 40,
    elevation: 10,
  },
  cardContent: {
    flex: 1,
    padding: 20,
    justifyContent: 'space-between',
    zIndex: 10,
  },
  cardTopRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
  },
  typeTag: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 4,
    borderWidth: 1,
    borderColor: 'rgba(212, 175, 55, 0.3)',
  },
  typeTagText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 10,
    fontWeight: '700',
    letterSpacing: 1.5,
    color: Colors.thaiGold,
    textTransform: 'uppercase',
  },
  statusDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    backgroundColor: Colors.thaiGold,
  },
  cardMiddleRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  charText: {
    fontFamily: Typography.sarabunRegular,
    fontSize: 36,
    lineHeight: 40,
    color: Colors.white,
    marginBottom: 4,
  },
  phoneticText: {
    fontFamily: Typography.playfairRegular,
    fontSize: 14,
    fontStyle: 'italic',
    color: 'rgba(229, 226, 219, 0.8)',
  },
  playButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    alignItems: 'center',
    justifyContent: 'center',
  },
  progressBarContainer: {
    width: '100%',
    height: 4,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 2,
    overflow: 'hidden',
    marginTop: 8,
  },
  progressBar: {
    width: '66%',
    height: '100%',
    backgroundColor: Colors.thaiGold,
  },
  backgroundGradient: {
    position: 'absolute',
    top: -40,
    right: -40,
    width: 128,
    height: 128,
    borderRadius: 64,
    backgroundColor: 'rgba(212, 175, 55, 0.1)',
  },
  badge: {
    position: 'absolute',
    top: -2,
    right: 1,
    width: 24,
    height: 24,
    borderRadius: 12,
    backgroundColor: '#DC2626',
    borderWidth: 2,
    borderColor: Colors.paper,
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 40,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 4,
    elevation: 5,
  },
  badgeText: {
    fontSize: 12,
    fontWeight: '700',
    color: Colors.white,
  },
});
</file>

<file path="src/config/constants.ts">
// src/config/constants.ts

/**
 * åº”ç”¨å¸¸é‡é…ç½®
 *
 * ç›®æ ‡ï¼š
 * 1. ç»Ÿä¸€ç®¡ç†å…¨å±€å¸¸é‡ï¼ˆé›†åˆå / è¶…æ—¶ / æ–‡æœ¬ç­‰ï¼‰ï¼Œé¿å…åœ¨ä»£ç ä¸­æ•£è½ç¡¬ç¼–ç å­—ç¬¦ä¸²ï¼›
 * 2. COLLECTIONS ä¸­åªæ”¾â€œçœŸå®å­˜åœ¨æˆ–è§„åˆ’ä¸­çš„é›†åˆåâ€ï¼Œå¹¶é€šè¿‡æ³¨é‡ŠåŒºåˆ†ã€Œå·²ä½¿ç”¨ã€ä¸ã€Œé¢„ç•™/åºŸå¼ƒã€ã€‚
 */

// ==================== æ•°æ®åº“é›†åˆåç§° ====================
export const COLLECTIONS = {
  // ===== æ ¸å¿ƒç”¨æˆ·ä¸è¿›åº¦é›†åˆï¼ˆCloudBase å·²å®é™…ä½¿ç”¨ï¼‰ =====
  USERS: 'users',
  USER_PROGRESS: 'user_progress',
  USER_ALPHABET_PROGRESS: 'user_alphabet_progress',
  USER_VOCABULARY_PROGRESS: 'user_vocabulary_progress',

  // ===== å­¦ä¹ å®ä½“é›†åˆï¼ˆCloudBase å·²å®é™…ä½¿ç”¨ï¼‰ =====
  LETTERS: 'letters',
  VOCABULARY: 'vocabulary',
  VOCABULARIES: 'vocabularies', // ç‰¹å®š handlerï¼ˆgetSkippedWordsï¼‰ä½¿ç”¨çš„è¯æ±‡é›†åˆ
  SENTENCES: 'sentences',
  MEMORY_STATUS: 'memory_status',

  // ===== å­—æ¯è¯¾ç¨‹ä¸æ‹¼è¯»è§„åˆ™ï¼ˆå·²è¿ç§»çš„è¯¾ç¨‹é…ç½®ï¼‰ =====
  ALPHABET_LESSONS: 'alphabet_lessons',
  PHONICS_RULES: 'phonics_rules',

  // ===== å­—æ¯æµ‹è¯•ç›¸å…³ =====
  LETTER_TEST_BANK: 'letter_test_bank',

  // ===== é¢„ç•™ / è§„åˆ’ä¸­çš„é›†åˆï¼ˆå½“å‰ä»£ç ä¸­æœªå®é™…ä½¿ç”¨ï¼‰ =====
  COURSES: 'courses',
  LESSONS: 'lessons',
  EXERCISES: 'exercises',
  ARTICLES: 'articles',
  PRONUNCIATION_RECORDS: 'pronunciationRecords',
  PROGRESS: 'progress',
  REVIEW_SCHEDULES: 'reviewSchedules',
  LEARNING_RECORDS: 'learningRecords',

  // ===== å·²åºŸå¼ƒå‘½åï¼ˆä»…å…¼å®¹æ—§ç‰ˆæœ¬ï¼Œä¸æ¨èå†ä½¿ç”¨ï¼‰ =====
  // æ—§ç‰ˆå­—æ¯é›†åˆï¼Œç°å·²ç»Ÿä¸€ä½¿ç”¨ LETTERS: 'letters'
  ALPHABETS: 'alphabets',
} as const;

// ==================== API è¶…æ—¶é…ç½® ====================
export const API_TIMEOUT = {
  DEFAULT: 10000,   // 10 ç§’ - ä¸€èˆ¬è¯·æ±‚
  UPLOAD: 30000,    // 30 ç§’ - æ–‡ä»¶ä¸Šä¼ 
  LONG: 60000,      // 60 ç§’ - é•¿æ—¶é—´æ“ä½œï¼ˆå¦‚å‘éŸ³è¯„ä¼°ï¼‰
};

// ==================== é”™è¯¯æ¶ˆæ¯ ====================
export const ERROR_MESSAGES = {
  NETWORK_ERROR: 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œã€‚',
  TIMEOUT_ERROR: 'è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•ã€‚',
  AUTH_ERROR: 'èº«ä»½éªŒè¯å¤±è´¥ï¼Œè¯·é‡æ–°ç™»å½•ã€‚',
  TOKEN_EXPIRED: 'ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•ã€‚',
  SERVER_ERROR: 'æœåŠ¡å™¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚',
  INVALID_INPUT: 'è¾“å…¥ä¿¡æ¯ä¸å®Œæ•´æˆ–æ ¼å¼é”™è¯¯ã€‚',
  UNKNOWN_ERROR: 'æœªçŸ¥é”™è¯¯ï¼Œè¯·è”ç³»å®¢æœã€‚',
};

// ==================== ç”¨æˆ·è§’è‰² ====================
export const USER_ROLES = {
  LEARNER: 'LEARNER',
  ADMIN: 'ADMIN',
} as const;

// ==================== å­¦ä¹ ç­‰çº§ ====================
export const LEVELS = {
  BEGINNER_A: 'BEGINNER_A',
  BEGINNER_B: 'BEGINNER_B',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED',
} as const;

// ==================== æŒæ¡ç¨‹åº¦ ====================
export const MASTER_LEVELS = {
  NOT_LEARNED: 'NOT_LEARNED',
  LEARNING: 'LEARNING',
  REVIEWING: 'REVIEWING',
  MASTERED: 'MASTERED',
} as const;

// ==================== å†…å®¹ç±»å‹ ====================
export const CONTENT_TYPES = {
  ALPHABET: 'alphabet',
  VOCABULARY: 'vocabulary',
  SENTENCE: 'sentence',
  ARTICLE: 'article',
} as const;
</file>

<file path="src/entities/enums/LearningPhase.enum.ts">
// src/entities/enums/LearningPhase.enum.ts

/**
 * å­¦ä¹ é˜¶æ®µæšä¸¾
 * 
 * ç”¨äºå­—æ¯å­¦ä¹ çš„7é˜¶æ®µæµç¨‹ + æµ‹è¯•ç›¸å…³é˜¶æ®µ
 * å¯¹åº”V3.0è¯¾ç¨‹æ–¹æ¡ˆçš„å®Œæ•´æµç¨‹
 * 
 * @version 2.0.0
 * @see project-snapshot-v2.0.0-V10.md ç¬¬7èŠ‚ å­¦ä¹ æµç¨‹
 */
export enum LearningPhase {
  // ===== åˆå§‹çŠ¶æ€ =====
  IDLE = 'IDLE',
  LOADING = 'LOADING',
  
  // ===== 7é˜¶æ®µå­¦ä¹ æµç¨‹ =====
  YESTERDAY_REVIEW = 'yesterday-review',
  YESTERDAY_REMEDY = 'yesterday-remedy',
  TODAY_LEARNING = 'today-learning',
  TODAY_MINI_REVIEW = 'today-mini-review',
  TODAY_FINAL_REVIEW = 'today-final-review',
  TODAY_REMEDY = 'today-remedy',
  ROUND_EVALUATION = 'round-evaluation',
  
  // ===== æµ‹è¯•ç›¸å…³(ç”¨äºè¯¾ç¨‹æµ‹è¯•) =====
  TEST_PROMPT = 'test-prompt',
  TESTING = 'testing',
  TEST_RESULT = 'test-result',
  
  // ===== å®ŒæˆçŠ¶æ€ =====
  FINISHED = 'finished',
  COMPLETED = 'COMPLETED',
}

/**
 * Phase ç±»å‹(ç”¨äºç±»å‹å®ˆå«)
 * å¯¹åº”AlphabetLearningEngineViewä¸­ä½¿ç”¨çš„å­—ç¬¦ä¸²å­—é¢é‡
 */
export type Phase = 
  | 'yesterday-review'
  | 'yesterday-remedy'
  | 'today-learning'
  | 'today-mini-review'
  | 'today-final-review'
  | 'today-remedy'
  | 'round-evaluation'
  | 'finished';

/**
 * Phase æ˜¾ç¤ºæ–‡æ¡ˆæ˜ å°„
 */
export const PHASE_LABELS: Record<Phase, string> = {
  'yesterday-review': 'æ˜¨æ—¥å¤ä¹ ',
  'yesterday-remedy': 'æ˜¨æ—¥è¡¥æ•‘',
  'today-learning': 'ä»Šæ—¥å­¦ä¹ ',
  'today-mini-review': 'å°å¤ä¹ ',
  'today-final-review': 'æœ«å°¾å¤ä¹ ',
  'today-remedy': 'ä»Šæ—¥è¡¥æ•‘',
  'round-evaluation': 'è½®æ¬¡è¯„ä¼°',
  'finished': 'å®Œæˆ',
};

/**
 * Phase å›¾æ ‡æ˜ å°„(ç”¨äºUIæ˜¾ç¤º)
 */
export const PHASE_ICONS: Record<Phase, string> = {
  'yesterday-review': 'ğŸ”„',
  'yesterday-remedy': 'ğŸ”§',
  'today-learning': 'ğŸ“š',
  'today-mini-review': 'âœ¨',
  'today-final-review': 'ğŸ¯',
  'today-remedy': 'ğŸ’ª',
  'round-evaluation': 'ğŸ“Š',
  'finished': 'ğŸ‰',
};

/**
 * Phase è¿›åº¦æƒé‡(ç”¨äºè¿›åº¦æ¡è®¡ç®—)
 */
export const PHASE_PROGRESS_WEIGHTS: Record<Phase, number> = {
  'yesterday-review': 0.1,
  'yesterday-remedy': 0.15,
  'today-learning': 0.4,
  'today-mini-review': 0.5,
  'today-final-review': 0.7,
  'today-remedy': 0.85,
  'round-evaluation': 0.95,
  'finished': 1.0,
};

/**
 * åˆ¤æ–­æ˜¯å¦ä¸ºå¤ä¹ é˜¶æ®µ
 */
export function isReviewPhase(phase: Phase): boolean {
  return [
    'yesterday-review',
    'yesterday-remedy',
    'today-mini-review',
    'today-final-review',
    'today-remedy',
  ].includes(phase);
}

/**
 * åˆ¤æ–­æ˜¯å¦ä¸ºå­¦ä¹ é˜¶æ®µ
 */
export function isLearningPhase(phase: Phase): boolean {
  return phase === 'today-learning';
}

/**
 * åˆ¤æ–­æ˜¯å¦ä¸ºè¡¥æ•‘é˜¶æ®µ
 */
export function isRemedyPhase(phase: Phase): boolean {
  return ['yesterday-remedy', 'today-remedy'].includes(phase);
}

/**
 * è·å–ä¸‹ä¸€ä¸ªé˜¶æ®µ
 */
export function getNextPhase(currentPhase: Phase): Phase | null {
  const phaseSequence: Phase[] = [
    'yesterday-review',
    'yesterday-remedy',
    'today-learning',
    'today-mini-review',
    'today-final-review',
    'today-remedy',
    'round-evaluation',
    'finished',
  ];
  
  const currentIndex = phaseSequence.indexOf(currentPhase);
  if (currentIndex === -1 || currentIndex === phaseSequence.length - 1) {
    return null;
  }
  
  return phaseSequence[currentIndex + 1];
}
</file>

<file path="src/i18n/index.ts">
import i18n from 'i18next';  // æ ¸å¿ƒåº“
import { initReactI18next } from 'react-i18next';  // React ç»‘å®š
import * as Localization from 'expo-localization';  // è·å–è®¾å¤‡è¯­è¨€
import AsyncStorage from '@react-native-async-storage/async-storage';  // æœ¬åœ°å­˜å‚¨

import zh from './locales/zh';  // ä¸­æ–‡ç¿»è¯‘
import en from './locales/en';  // è‹±æ–‡ç¿»è¯‘

const LANGUAGE_KEY = 'user-language';  // å­˜å‚¨è¯­è¨€çš„ key

// ã€æ ¸å¿ƒå‡½æ•°1ã€‘ä»æœ¬åœ°å­˜å‚¨è¯»å–ç”¨æˆ·ä¸Šæ¬¡é€‰æ‹©çš„è¯­è¨€
const getStoredLanguage = async (): Promise<string | null> => {
  try {
    return await AsyncStorage.getItem(LANGUAGE_KEY);  // è¯»å–æœ¬åœ°å­˜å‚¨
  } catch (error) {
    console.error('Error reading language:', error);
    return null;
  }
};

// ã€æ ¸å¿ƒå‡½æ•°2ã€‘è·å–è®¾å¤‡è¯­è¨€(å¦‚æœç”¨æˆ·æ²¡é€‰è¿‡)
const getDeviceLanguage = (): string => {
  const locales = Localization.getLocales();  // è·å–åŒºåŸŸè®¾ç½®æ•°ç»„
  if (!locales || locales.length === 0) {
    return 'zh'; // é»˜è®¤ä¸­æ–‡
  }
  const languageCode = locales[0].languageCode;  // ä¾‹å¦‚: "zh" æˆ– "en"
  return languageCode === 'zh' ? 'zh' : 'en';  // é»˜è®¤ä¸­æ–‡
};

// ã€æ ¸å¿ƒå‡½æ•°3ã€‘åˆå§‹åŒ– i18n
const initI18n = async () => {
  const storedLanguage = await getStoredLanguage();  // å…ˆè¯»æœ¬åœ°å­˜å‚¨
  const initialLanguage = storedLanguage || getDeviceLanguage();  // æœ¬åœ°æ²¡æœ‰å°±ç”¨è®¾å¤‡è¯­è¨€

  i18n
    .use(initReactI18next)  // ç»‘å®š React
    .init({  // é…ç½®
      resources: {  // ç¿»è¯‘èµ„æº
        zh: { translation: zh },  // ä¸­æ–‡
        en: { translation: en },  // è‹±æ–‡
      },
      lng: initialLanguage,  // åˆå§‹è¯­è¨€
      fallbackLng: 'zh',  // å¦‚æœç¿»è¯‘ç¼ºå¤±,å›é€€åˆ°ä¸­æ–‡
      interpolation: {
        escapeValue: false,  // React å·²ç»é˜² XSS äº†
      },
    });
};

initI18n();  // ç«‹å³æ‰§è¡Œåˆå§‹åŒ–

export default i18n;
</file>

<file path="src/utils/alphabet/audioHelper.ts">
// src/utils/alphabet/audioHelper.ts

import type { Letter } from '@/src/entities/types/letter.types';
import type { AudioRequirementType } from '@/src/entities/enums/QuestionType.enum';

/**
 * éŸ³é¢‘Base URL
 */
const LETTER_AUDIO_BASE =
  'https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/';

/**
 * å°†å¯èƒ½æ˜¯ã€Œå®Œæ•´ URLã€æˆ–ã€Œç›¸å¯¹è·¯å¾„ / keyã€çš„éŸ³é¢‘å­—æ®µè§„èŒƒåŒ–ä¸ºå®Œæ•´ URLã€‚
 */
function normalizeAudioSource(path?: string | null): string {
  if (!path) return '';
  if (path.startsWith('http://') || path.startsWith('https://') || path.startsWith('file://')) {
    return path;
  }
  return resolveAudioPath(path);
}

/**
 * éŸ³é¢‘ä¼˜å…ˆçº§ç­–ç•¥
 * 
 * @param letter - å­—æ¯å¯¹è±¡
 * @param type - éŸ³é¢‘éœ€æ±‚ç±»å‹
 * @returns éŸ³é¢‘URLï¼ˆå§‹ç»ˆä¸ºå®Œæ•´ HTTP URL æˆ–ç©ºå­—ç¬¦ä¸²ï¼‰
 */
export function getLetterAudioUrl(
  letter: Letter,
  type: AudioRequirementType = 'letter'
): string {
  // P0-Optimization: ä¼˜å…ˆä½¿ç”¨æœ¬åœ°ç¼“å­˜è·¯å¾„
  const getLocalOrRemote = (local?: string, remote?: string) => {
    return normalizeAudioSource(local) || normalizeAudioSource(remote);
  };

  switch (type) {
    case 'letter':
      // é»˜è®¤ä½¿ç”¨å®Œæ•´è¯»éŸ³:
      // fullSoundLocal > fullSoundUrl > ...
      return (
        getLocalOrRemote(letter.fullSoundLocalPath, letter.fullSoundUrl) ||
        getLocalOrRemote(letter.letterPronunciationLocalPath, letter.letterPronunciationUrl) ||
        resolveAudioPath(letter.audioPath)
      );

    case 'syllable':
      // éŸ³èŠ‚å‘éŸ³
      return (
        getLocalOrRemote(letter.syllableSoundLocalPath, letter.syllableSoundUrl) ||
        getLocalOrRemote(letter.fullSoundLocalPath, letter.fullSoundUrl) ||
        resolveAudioPath(letter.audioPath)
      );

    case 'minimal-pair':
      // æœ€å°å¯¹ç«‹ç»„(ä½¿ç”¨letterç±»å‹,ç”±è°ƒç”¨æ–¹å¤„ç†å¯¹æ¯”)
      return (
        getLocalOrRemote(letter.fullSoundLocalPath, letter.fullSoundUrl) ||
        getLocalOrRemote(letter.letterPronunciationLocalPath, letter.letterPronunciationUrl) ||
        resolveAudioPath(letter.audioPath)
      );

    case 'tone-set':
      // å£°è°ƒå˜ä½“(éœ€TTSç”Ÿæˆ,è¿”å›åŸºç¡€éŸ³é¢‘)
      return (
        getLocalOrRemote(letter.syllableSoundLocalPath, letter.syllableSoundUrl) ||
        getLocalOrRemote(letter.fullSoundLocalPath, letter.fullSoundUrl) ||
        resolveAudioPath(letter.audioPath)
      );

    default:
      return (
        getLocalOrRemote(letter.fullSoundLocalPath, letter.fullSoundUrl) ||
        resolveAudioPath(letter.audioPath)
      );
  }
}

/**
 * è§£æéŸ³é¢‘è·¯å¾„
 * 
 * @param path - éŸ³é¢‘è·¯å¾„
 * @returns å®Œæ•´URL
 */
function resolveAudioPath(path?: string | null): string {
  if (!path) return '';

  // å¦‚æœå·²ç»æ˜¯å®Œæ•´URL,ç›´æ¥è¿”å›
  if (path.startsWith('http://') || path.startsWith('https://')) {
    return path;
  }

  // å¯¹ç±»ä¼¼ "word-kai" / "sound-k" è¿™ç±» key è‡ªåŠ¨è¡¥å…¨ .mp3 åç¼€
  let finalPath = path;
  if (!/\.mp3($|\?)/.test(finalPath)) {
    finalPath = `${finalPath}.mp3`;
  }

  // æ‹¼æ¥Base URL
  return `${LETTER_AUDIO_BASE}${finalPath}`;
}

/**
 * è·å–æœ€å°å¯¹ç«‹ç»„çš„éŸ³é¢‘URLåˆ—è¡¨
 * 
 * @param letters - å­—æ¯åˆ—è¡¨(åŒ…å«ç›®æ ‡å­—æ¯+å¯¹æ¯”å­—æ¯)
 * @returns éŸ³é¢‘URLæ•°ç»„
 */
export function getMinimalPairAudioUrls(letters: Letter[]): string[] {
  return letters.map(letter => getLetterAudioUrl(letter, 'minimal-pair'));
}

/**
 * ç”Ÿæˆå£°è°ƒå˜ä½“éŸ³é¢‘URLs
 * 
 * âš ï¸ å½“å‰å®ç°:è¿”å›åŸºç¡€éŸ³é¢‘
 * ğŸ”® æœªæ¥å®ç°:è°ƒç”¨TTS APIç”Ÿæˆ5ä¸ªå£°è°ƒå˜ä½“
 * 
 * @param letter - å­—æ¯å¯¹è±¡
 * @param vowel - å…ƒéŸ³(å¯é€‰)
 * @returns 5ä¸ªå£°è°ƒéŸ³é¢‘URLæ•°ç»„
 */
export function getToneVariantAudioUrls(
  letter: Letter,
  vowel?: string
): string[] {
  const baseAudioUrl = getLetterAudioUrl(letter, 'tone-set');

  // å½“å‰ç­–ç•¥:è¿”å›ç›¸åŒçš„åŸºç¡€éŸ³é¢‘(ä¸´æ—¶æ–¹æ¡ˆ)
  // å‰ç«¯å¯ä»¥åœ¨UIä¸Šæ ‡æ³¨"éœ€TTSç”Ÿæˆ"
  return [
    baseAudioUrl, // ä¸­å¹³è°ƒ
    baseAudioUrl, // ä½é™è°ƒ
    baseAudioUrl, // é™è°ƒ
    baseAudioUrl, // é«˜è°ƒ
    baseAudioUrl, // å‡è°ƒ
  ];

  // ğŸ”® æœªæ¥å®ç°(éœ€åç«¯TTSæœåŠ¡):
  // return await ttsService.generateToneVariants(letter, vowel);
}

/**
 * è·å–æŸä¸ªå­—æ¯ç›¸å…³çš„æ‰€æœ‰éŸ³é¢‘ URLï¼ˆå»é‡åï¼‰ã€‚
 *
 * è®¾è®¡ç›®çš„ï¼š
 * - ç”¨äºè¯¾ç¨‹åˆå§‹åŒ–æ—¶ï¼Œä¸€æ¬¡æ€§é¢„ç¼“å­˜è¯¥å­—æ¯æ‰€æœ‰å¯èƒ½ä¼šç”¨åˆ°çš„éŸ³é¢‘ï¼›
 * - åŒ…å«ï¼š
 *   - letterPronunciationUrlï¼ˆå­—æ¯æ ‡å‡†è¯»éŸ³ï¼‰
 *   - fullSoundUrlï¼ˆå®Œæ•´è¯»éŸ³ï¼‰
 *   - syllableSoundUrlï¼ˆéŸ³èŠ‚å‘éŸ³ï¼‰
 *   - endSyllableSoundUrlï¼ˆå°¾éŸ³èŠ‚å‘éŸ³ï¼‰
 *   - audioPathï¼ˆæ—§ç‰ˆè·¯å¾„ï¼‰
 */
export function getAllLetterAudioUrls(letter: Letter): string[] {
  const rawSources: Array<string | null | undefined> = [
    // ä»¥å®é™…å­˜åœ¨çš„éŸ³é¢‘ä¸ºä¸»ï¼šfullSoundUrl ä¸å„ç±» *SoundUrl
    letter.fullSoundUrl,
    letter.syllableSoundUrl,
    letter.endSyllableSoundUrl,
    letter.audioPath,
  ];

  const urls = rawSources
    .map((src) => normalizeAudioSource(src ?? undefined))
    .filter((u): u is string => !!u);

  // å»é‡
  return Array.from(new Set(urls));
}

/**
 * æ£€æŸ¥éŸ³é¢‘æ˜¯å¦å¯ç”¨
 * 
 * @param url - éŸ³é¢‘URL
 * @returns æ˜¯å¦å¯ç”¨
 */
export async function checkAudioAvailable(url: string): Promise<boolean> {
  if (!url) return false;

  try {
    const response = await fetch(url, { method: 'HEAD' });
    return response.ok;
  } catch (error) {
    console.warn('[AudioHelper] éŸ³é¢‘ä¸å¯ç”¨:', url, error);
    return false;
  }
}
</file>

<file path="babel.config.js">
module.exports = function (api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      [
        'module-resolver',
        {
          root: ['./'],
          alias: {
            '@': './',
          },
        },
      ],
      'react-native-reanimated/plugin', // å¿…é¡»åœ¨æœ€å
    ],
  };
};
</file>

<file path="index.ts">
import 'react-native-gesture-handler';
import 'react-native-reanimated';
import 'expo-router/entry';
</file>

<file path="app/review-modal.tsx">
import { View, Text, StyleSheet } from 'react-native';
import { Stack } from 'expo-router';

export default function ReviewModal() {
  return (
    <View style={styles.container}>
      <Stack.Screen
        options={{
          title: 'Review',
        }}
      />
      <Text style={styles.text}>Review Modal Screen</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff',
  },
  text: {
    fontSize: 18,
    fontWeight: 'bold',
  },
});
</file>

<file path="cloudbase/functions/alphabet/handlers/submitLetterTest.js">
// âœ… æäº¤å­—æ¯æµ‹è¯•ç»“æœï¼ˆRoute Aï¼šå‰ç«¯åˆ¤åˆ†ï¼‰
const { createResponse } = require('../utils/response');
const passLetterTest = require('./passLetterTest');

/**
 * æäº¤å­—æ¯æµ‹è¯•ç»“æœ
 * @param {Object} db - æ•°æ®åº“å®ä¾‹
 * @param {Object} data - è¯·æ±‚æ•°æ® { userId, passed }
 */
async function submitLetterTest(db, data) {
    // 1. æ ¡éªŒå‚æ•°
    const { userId, passed } = data || {};

    if (!userId) {
        return createResponse(false, null, 'userId å‚æ•°ç¼ºå¤±', 'INVALID_PARAMS');
    }

    if (typeof passed !== 'boolean') {
        return createResponse(false, null, 'passed å‚æ•°å¿…é¡»ä¸ºå¸ƒå°”å€¼', 'INVALID_PARAMS');
    }

    // 2. å¦‚æœæœªé€šè¿‡ï¼Œç›´æ¥è¿”å›ï¼ˆä¸å†™æ•°æ®åº“ï¼‰
    if (!passed) {
        return createResponse(true, {
            passed: false,
            message: 'æœªé€šè¿‡æµ‹è¯•ï¼Œä¸è®°å½•è¿›åº¦'
        }, 'æµ‹è¯•æœªé€šè¿‡');
    }

    // 3. å¦‚æœé€šè¿‡ï¼Œè°ƒç”¨ passLetterTest å†™å…¥è§£é”è®°å½•
    try {
        await passLetterTest(db, { userId });

        return createResponse(true, {
            passed: true,
            message: 'æ­å–œé€šè¿‡å­—æ¯æµ‹è¯•ï¼æ‰€æœ‰æ¨¡å—å·²è§£é”ã€‚'
        }, 'æµ‹è¯•é€šè¿‡');
    } catch (error) {
        console.error('[submitLetterTest] passLetterTest å¤±è´¥ï¼š', error);
        return createResponse(false, null, 'å†™å…¥è¿›åº¦å¤±è´¥', 'DB_ERROR');
    }
}

module.exports = submitLetterTest;
</file>

<file path="cloudbase/functions/alphabet/index.js">
const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.SYMBOL_CURRENT_ENV });
const db = cloud.database();


// âœ… å¤„ç†å‡½æ•°
const { createResponse } = require('./utils/response');
const getLetterTest = require('./handlers/getLetterTest');
const submitLetterTest = require('./handlers/submitLetterTest');
const passLetterTest = require('./handlers/passLetterTest');
const getAllLetters = require('./handlers/getAllLetters');

exports.main = async (event, context) => {

    // ===== è§£æ HTTP è¯·æ±‚ =====
    let requestData = event;

    // HTTP è§¦å‘å™¨ï¼šbody å¯èƒ½æ˜¯å­—ç¬¦ä¸²æˆ–å¯¹è±¡
    if (event.body) {
        if (typeof event.body === 'string') {
            try {
                requestData = JSON.parse(event.body);
            } catch (e) {
                console.error('[alphabet] JSON è§£æå¤±è´¥:', e.message);
                return createResponse(false, null, 'Invalid JSON in request body', 'INVALID_JSON');
            }
        } else if (typeof event.body === 'object') {
            requestData = event.body;
        }
    }

    const { action, data } = requestData;

    try {
        switch (action) {

            // âœ… 0ï¸âƒ£ è·å–æ‰€æœ‰å­—æ¯ï¼ˆç”¨äºå‰ç«¯ç”Ÿæˆæµ‹è¯•é¢˜ï¼‰
            case 'getAllLetters':
                return await getAllLetters(db);

            // âœ… 1ï¸âƒ£ è·å–å­—æ¯æµ‹è¯•é¢˜ï¼ˆå›ºå®šé¢˜ï¼‰
            case 'getLetterTest':
                return await getLetterTest(db);

            // âœ… 2ï¸âƒ£ æäº¤å­—æ¯æµ‹è¯•å¹¶åˆ¤å®š
            case 'submitLetterTest':
                return await submitLetterTest(db, data);

            // âœ… 3ï¸âƒ£ ç›´æ¥é€šè¿‡å­—æ¯æµ‹è¯•ï¼ˆè°ƒè¯•/ç‰¹æ®Šé€»è¾‘ç”¨ï¼‰
            case 'passLetterTest':
                return await passLetterTest(db, data);

            default:
                return createResponse(false, null, 'æœªçŸ¥ action', 'INVALID_ACTION');
        }
    } catch (err) {
        console.error('learn-alphabet error:', err);
        return createResponse(false, null, err.message || 'æœåŠ¡å™¨é”™è¯¯', 'SERVER_ERROR');
    }
};
</file>

<file path="cloudbase/functions/learn-vocab/handlers/getVocabularyDetail.js">
/**
 * è·å–è¯æ±‡è¯¦æƒ…å¤„ç†å™¨
 * @action getVocabularyDetail
 */
'use strict';

const { createResponse } = require('../utils/response');

/**
 * è·å–è¯æ±‡è¯¦ç»†ä¿¡æ¯
 * @param {Object} db - æ•°æ®åº“å®ä¾‹
 * @param {Object} params
 * @param {string} params.vocabularyId - è¯æ±‡ID (å¿…å¡«)
 * @param {string} params.userId - ç”¨æˆ·ID (å¯é€‰ï¼Œç”¨äºè·å–å­¦ä¹ çŠ¶æ€)
 */
async function getVocabularyDetail(db, params) {
  const { vocabularyId, userId } = params;

  if (!vocabularyId) {
    return createResponse(false, null, 'ç¼ºå°‘è¯æ±‡ID', 'INVALID_PARAMS');
  }

  try {
    // 1. æ£€æŸ¥æƒé™ (å¦‚æœæœ‰ userId)
    if (userId) {
      const { checkModuleAccess } = require('../utils/memoryEngine');
      const accessResult = await checkModuleAccess(db, userId, 'word');

      if (!accessResult.allowed) {
        return createResponse(false, null, accessResult.message, accessResult.errorCode);
      }
    }

    // 2. è·å–è¯æ±‡è¯¦æƒ…
    // æ³¨æ„ï¼šæ ¹æ®ä½ çš„æ•°æ®åº“ç»“æ„ï¼Œå¦‚æœä¸»é”®æ˜¯ _idï¼Œè¯·ä½¿ç”¨ doc(id)ï¼›å¦‚æœæ˜¯ vocabularyId å­—æ®µï¼Œä½¿ç”¨ where
    // å‡è®¾ vocabularyId å­—æ®µå­˜å‚¨çš„æ˜¯ä¸šåŠ¡ID
    const vocabResult = await db.collection('vocabulary')
      .where({ vocabularyId: vocabularyId }) // æˆ–è€… .doc(vocabularyId) å¦‚æœå®ƒæ˜¯ _id
      .get();

    if (!vocabResult.data || vocabResult.data.length === 0) {
      // å°è¯•ç”¨ _id å†æŸ¥ä¸€æ¬¡ï¼Œå…¼å®¹ä¸åŒä¼ å‚
      const vocabByIdResult = await db.collection('vocabulary').doc(vocabularyId).get().catch(() => ({ data: [] }));
      if (!vocabByIdResult.data) {
        return createResponse(false, null, 'æœªæ‰¾åˆ°è¯¥è¯æ±‡', 'VOCABULARY_NOT_FOUND');
      }
      vocabResult.data = [vocabByIdResult.data];
    }

    const vocabulary = vocabResult.data[0];

    // 3. æ„å»ºè¯¦ç»†å“åº”
    const detail = {
      // åŸºæœ¬ä¿¡æ¯
      vocabularyId: vocabulary.vocabularyId || vocabulary._id,
      thaiWord: vocabulary.thaiWord,
      meaning: vocabulary.meaning,
      pronunciation: vocabulary.pronunciation,
      audioPath: vocabulary.audioPath,
      partOfSpeech: vocabulary.partOfSpeech,
      level: vocabulary.level,
      lessonNumber: vocabulary.lessonNumber,
      startingLetter: vocabulary.startingLetter,

      // æ‰©å±•å­¦ä¹ å†…å®¹
      cognates: vocabulary.cognates || [],
      dialogue: vocabulary.dialogue || null,
      exampleSentences: vocabulary.exampleSentences || {},
      usage: vocabulary.usage || {},
      mistakes: vocabulary.mistakes || {},

      // å…ƒæ•°æ®
      source: vocabulary.source,
      createdAt: vocabulary.createdAt,
    };

    // 4. å¦‚æœæä¾›äº† userIdï¼Œé™„åŠ å­¦ä¹ çŠ¶æ€
    if (userId) {
      const progressResult = await db.collection('user_vocabulary_progress')
        .where({ userId, vocabularyId: detail.vocabularyId }) // ç¡®ä¿IDåŒ¹é…
        .limit(1)
        .get();

      if (progressResult.data.length > 0) {
        const p = progressResult.data[0];
        detail.learningStatus = {
          mastery: p.mastery,
          skipped: p.skipped,
          reviewCount: p.reviewCount,
          lastReviewed: p.lastReviewed,
          nextReviewDate: p.nextReviewDate,
          intervalDays: p.intervalDays,
          easinessFactor: p.easinessFactor,
          isNew: false,
        };
      } else {
        detail.learningStatus = {
          mastery: null,
          skipped: false,
          reviewCount: 0,
          lastReviewed: null,
          nextReviewDate: null,
          intervalDays: 0,
          isNew: true,
        };
      }
    }

    return createResponse(true, detail, 'è·å–è¯æ±‡è¯¦æƒ…æˆåŠŸ');

  } catch (error) {
    console.error('getVocabularyDetail error:', error);
    return createResponse(false, null, error.message, 'SERVER_ERROR');
  }
}

module.exports = getVocabularyDetail;
</file>

<file path="cloudbase/functions/learn-vocab/handlers/getVocabularyList.js">
/**
 * è·å–è¯æ±‡åˆ—è¡¨å¤„ç†å™¨
 * @action getVocabularyList
 */
'use strict';

const { createResponse } = require('../utils/response');

/**
 * æ ¼å¼åŒ–è¯æ±‡ä¸ºåˆ—è¡¨é¡¹
 */
function formatVocabularyForList(vocab) {
  return {
    vocabularyId: vocab.vocabularyId || vocab._id,
    thaiWord: vocab.thaiWord,
    meaning: vocab.meaning,
    pronunciation: vocab.pronunciation,
    audioPath: vocab.audioPath,
    partOfSpeech: vocab.partOfSpeech,
    level: vocab.level,
    lessonNumber: vocab.lessonNumber,
  };
}

/**
 * è·å–è¯æ±‡åˆ—è¡¨
 * @param {Object} db - æ•°æ®åº“å®ä¾‹
 * @param {Object} params - å‚æ•°
 */
async function getVocabularyList(db, params) {
  const { filters = {}, limit = 20, offset = 0, userId } = params;

  try {
    // 1. æ£€æŸ¥ç”¨æˆ·æƒé™ (å¦‚æœä¼ äº† userId)
    if (userId) {
      const { checkModuleAccess } = require('../utils/memoryEngine');
      const accessResult = await checkModuleAccess(db, userId, 'word');

      if (!accessResult.allowed) {
        return createResponse(false, null, accessResult.message, accessResult.errorCode);
      }
    }

    // 2. éªŒè¯åˆ†é¡µå‚æ•°
    const validLimit = Math.max(1, Math.min(limit, 100));
    const validOffset = Math.max(0, offset);

    // 3. æ„å»ºæŸ¥è¯¢æ¡ä»¶
    const query = db.collection('vocabulary');
    const whereConditions = {};

    if (filters.level) whereConditions.level = filters.level;
    if (filters.lessonNumber) whereConditions.lessonNumber = filters.lessonNumber;
    if (filters.startingLetter) whereConditions.startingLetter = filters.startingLetter;
    if (filters.partOfSpeech) whereConditions.partOfSpeech = filters.partOfSpeech;

    let dbQuery = query;
    if (Object.keys(whereConditions).length > 0) {
      dbQuery = dbQuery.where(whereConditions);
    }

    // 4. è·å–æ€»æ•°
    const countResult = await dbQuery.count();
    const total = countResult.total;

    // 5. è·å–åˆ†é¡µæ•°æ®
    // æ³¨æ„ï¼šorderBy å­—æ®µéœ€è¦ç¡®ä¿æœ‰ç´¢å¼•ï¼Œå¦åˆ™å¯èƒ½æŠ¥é”™æˆ–æ…¢
    const dataResult = await dbQuery
      .orderBy('lessonNumber', 'asc')
      .skip(validOffset)
      .limit(validLimit)
      .get();

    const vocabularies = dataResult.data.map(formatVocabularyForList);

    return createResponse(true, {
      vocabularies,
      pagination: {
        total,
        limit: validLimit,
        offset: validOffset,
        hasMore: validOffset + validLimit < total,
      },
    }, 'è·å–è¯æ±‡åˆ—è¡¨æˆåŠŸ');

  } catch (error) {
    console.error('getVocabularyList error:', error);
    return createResponse(false, null, error.message, 'SERVER_ERROR');
  }
}

module.exports = getVocabularyList;
</file>

<file path="cloudbase/functions/learn-vocab/handlers/toggleSkipWord.js">
/**
 * åˆ’æ‰/æ¢å¤å•è¯å¤„ç†å™¨
 * 
 * å°†å•è¯ä»å¤ä¹ é˜Ÿåˆ—ä¸­ç§»é™¤æˆ–é‡æ–°åŠ å…¥
 * 
 * @action toggleSkipWord
 */

'use strict';

const { createResponse } = require('../utils/response');

/**
 * åˆ’æ‰æˆ–æ¢å¤å•è¯
 */
async function toggleSkipWord(db, params) {
  const { userId, vocabularyId, skipped } = params;

  // å‚æ•°éªŒè¯
  if (!userId || !vocabularyId || typeof skipped !== 'boolean') {
    return createResponse(false, null, 'ç¼ºå°‘å¿…å¡«å‚æ•°æˆ–å‚æ•°ç±»å‹é”™è¯¯', 'INVALID_PARAMS');
  }

  try {
    // éªŒè¯ç”¨æˆ·
    const userResult = await db.collection('users')
      .where({ userId })
      .get();

    if (!userResult.data || userResult.data.length === 0) {
      return createResponse(false, null, 'ç”¨æˆ·ä¸å­˜åœ¨', 'USER_NOT_FOUND');
    }

    // éªŒè¯è¯æ±‡
    const vocabResult = await db.collection('vocabulary')
      .where({ _id: vocabularyId })
      .get();

    if (!vocabResult.data || vocabResult.data.length === 0) {
      return createResponse(false, null, 'è¯æ±‡ä¸å­˜åœ¨', 'VOCABULARY_NOT_FOUND');
    }

    const now = new Date();

    // æŸ¥æ‰¾ç°æœ‰è¿›åº¦è®°å½•
    const existingProgress = await db.collection('user_vocabulary_progress')
      .where({ userId, vocabularyId })
      .limit(1)
      .get();

    if (existingProgress.data && existingProgress.data.length > 0) {
      // æ›´æ–°ç°æœ‰è®°å½•
      await db.collection('user_vocabulary_progress')
        .doc(existingProgress.data[0]._id)
        .update({
          skipped,
          updatedAt: now
        });
    } else {
      // åˆ›å»ºæ–°è®°å½•
      await db.collection('user_vocabulary_progress').add({
        userId,
        vocabularyId,
        mastery: null,
        skipped,
        lastReviewed: null,
        reviewCount: 0,
        intervalDays: 1,
        easinessFactor: 2.5,
        nextReviewDate: null,
        createdAt: now,
        updatedAt: now,
      });
    }

    const message = skipped ? 'å·²ä»å¤ä¹ é˜Ÿåˆ—ç§»é™¤' : 'å·²åŠ å…¥å¤ä¹ é˜Ÿåˆ—';

    return createResponse(true, {
      vocabularyId,
      skipped,
      message,
    }, skipped ? 'å•è¯å·²åˆ’æ‰' : 'å•è¯å·²æ¢å¤');

  } catch (error) {
    console.error('toggleSkipWord error:', error);
    return createResponse(false, null, error.message, 'SERVER_ERROR');
  }
}

module.exports = toggleSkipWord;
</file>

<file path="cloudbase/functions/learn-vocab/handlers/updateMastery.js">
/**
 * æ›´æ–°æŒæ¡çŠ¶æ€å¤„ç†å™¨
 * 
 * è®°å½•ç”¨æˆ·å¯¹å•è¯çš„æŒæ¡ç¨‹åº¦ï¼Œä½¿ç”¨ SM-2 ç®—æ³•è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´
 * 
 * @action updateMastery
 */

'use strict';


const { progressCollection } = require('../utils/database');
const {
  createResponse,
  successResponse,
  errorResponse,
  userNotFoundResponse,
  vocabularyNotFoundResponse
} = require('../utils/response');
const {
  COLLECTIONS,
  MasteryLevel,
  SM2_PARAMS
} = require('../utils/constants');

const { validateUser, validateVocabulary, isValidMastery } = require('../utils/validators');
const { calculateSM2Optimized, generateReviewTimeline } = require('../utils/sm2');

/**
 * æ›´æ–°å•è¯æŒæ¡çŠ¶æ€
 * 
 * ä¸šåŠ¡é€»è¾‘:
 * 1. éªŒè¯ç”¨æˆ·å’Œè¯æ±‡å­˜åœ¨
 * 2. éªŒè¯æŒæ¡ç¨‹åº¦æœ‰æ•ˆæ€§
 * 3. ä½¿ç”¨ SM-2 ç®—æ³•è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸ
 * 4. åˆ›å»ºæˆ–æ›´æ–°è¿›åº¦è®°å½•
 * 
 * @param {Object} params
 * @param {string} params.userId - ç”¨æˆ·ID
 * @param {string} params.vocabularyId - è¯æ±‡ID
 * @param {string} params.mastery - æŒæ¡ç¨‹åº¦: é™Œç”Ÿ/æ¨¡ç³Š/è®°å¾—
 */
async function updateMastery({ userId, vocabularyId, mastery }) {
  // éªŒè¯æŒæ¡ç¨‹åº¦
  if (!isValidMastery(mastery)) {
    return errorResponse(ErrorCodes.INVALID_MASTERY);
  }

  // éªŒè¯ç”¨æˆ·
  const user = await validateUser(userId);
  if (!user) {
    return userNotFoundResponse();
  }

  // éªŒè¯è¯æ±‡
  const vocabulary = await validateVocabulary(vocabularyId);
  if (!vocabulary) {
    return vocabularyNotFoundResponse();
  }

  // æŸ¥æ‰¾ç°æœ‰è¿›åº¦è®°å½•
  const { data: existingProgress } = await progressCollection
    .where({ userId, vocabularyId })
    .limit(1)
    .get();

  const now = new Date().toISOString();
  let progressData;
  let isNewRecord = false;
  let newReviewCount;

  if (existingProgress.length > 0) {
    // ========== æ›´æ–°ç°æœ‰è®°å½• ==========
    const current = existingProgress[0];

    const sm2Result = calculateSM2Optimized(
      mastery,
      current.intervalDays || 1,
      current.easinessFactor || SM2_PARAMS.INITIAL_EASINESS_FACTOR,
      current.reviewCount || 0
    );

    // è®¡ç®—æ–°çš„å¤ä¹ æ¬¡æ•°
    newReviewCount = sm2Result.shouldResetCount ? 1 : (current.reviewCount || 0) + 1;

    progressData = {
      mastery,
      lastReviewed: now,
      reviewCount: newReviewCount,
      intervalDays: sm2Result.nextInterval,
      easinessFactor: sm2Result.nextEasinessFactor,
      nextReviewDate: sm2Result.nextReviewDate,
      updatedAt: now,
    };

    await progressCollection.doc(current._id).update({
      data: progressData
    });

  } else {
    // ========== åˆ›å»ºæ–°è®°å½• ==========
    isNewRecord = true;
    newReviewCount = 1;

    const sm2Result = calculateSM2Optimized(
      mastery,
      1,
      SM2_PARAMS.INITIAL_EASINESS_FACTOR,
      0
    );

    progressData = {
      userId,
      vocabularyId,
      mastery,
      skipped: false,
      lastReviewed: now,
      reviewCount: 1,
      intervalDays: sm2Result.nextInterval,
      easinessFactor: sm2Result.nextEasinessFactor,
      nextReviewDate: sm2Result.nextReviewDate,
      createdAt: now,
      updatedAt: now,
    };

    await progressCollection.add(progressData);
  }

  return successResponse({
    vocabularyId,
    mastery,
    reviewCount: newReviewCount,
    nextReviewDate: progressData.nextReviewDate,
    intervalDays: progressData.intervalDays,
    easinessFactor: progressData.easinessFactor,
    isNewRecord,
    reviewTimeline: generateReviewTimeline(newReviewCount),
  }, 'æ›´æ–°æŒæ¡çŠ¶æ€æˆåŠŸ');
}

module.exports = updateMastery;
</file>

<file path="cloudbase/functions/learn-vocab/utils/memoryEngine.js">
/**
 * ç»Ÿä¸€è®°å¿†å¼•æ“æ ¸å¿ƒæ¨¡å—
 * æ”¯æŒå­—æ¯/å•è¯/å¥å­çš„ç»Ÿä¸€è®°å¿†ç®¡ç†
 * 
 * ä¿®å¤ï¼šwx-server-sdk ä¸æ”¯æŒ getOne()ï¼Œæ”¹ç”¨ get() + data[0]
 */

const { calculateSM2Optimized } = require('./sm2');

/**
 * åˆ›å»ºæ–°çš„è®°å¿†è®°å½•
 */
async function createMemoryRecord(db, userId, entityType, entityId, isLocked = false) {

    // éªŒè¯å‚æ•°
    if (!userId || !entityType || !entityId) {
        console.error('[createMemoryRecord] å‚æ•°ç¼ºå¤±:', { userId, entityType, entityId });
        throw new Error('userId, entityType, entityId éƒ½æ˜¯å¿…éœ€å‚æ•°');
    }

    const now = new Date();
    const nextReviewAt = isLocked ? null : new Date(now.getTime() + 24 * 60 * 60 * 1000).toISOString();

    const memoryRecord = {
        userId,
        entityType,
        entityId,
        masteryLevel: 0.0,
        reviewStage: 0,
        easinessFactor: 2.5,
        intervalDays: 1,
        lastReviewAt: null,
        nextReviewAt,
        correctCount: 0,
        wrongCount: 0,
        streakCorrect: 0,
        isLocked,
        createdAt: now.toISOString(),
        updatedAt: now.toISOString()
    };

    try {
        // å°è¯•æ’å…¥
        const result = await db.collection('memory_status').add(memoryRecord);

        console.log('[createMemoryRecord] åˆ›å»ºæˆåŠŸ:', { userId, entityType, entityId });

        return {
            _id: result._id,
            ...memoryRecord
        };
    } catch (error) {
        // å¦‚æœæ˜¯é‡å¤é”®é”™è¯¯ï¼ŒæŸ¥è¯¢å¹¶è¿”å›ç°æœ‰è®°å½•
        if (error.errCode === -502001 || error.message.includes('duplicate key')) {
            console.log('[createMemoryRecord] è®°å½•å·²å­˜åœ¨ï¼ŒæŸ¥è¯¢è¿”å›:', { userId, entityType, entityId });

            const existingResult = await db.collection('memory_status')
                .where({ userId, entityType, entityId })
                .get();

            if (existingResult.data && existingResult.data.length > 0) {
                return existingResult.data[0];
            }
        }

        // å…¶ä»–é”™è¯¯ç»§ç»­æŠ›å‡º
        console.error('[createMemoryRecord] åˆ›å»ºå¤±è´¥:', error);
        throw error;
    }
}

/**
 * è·å–æˆ–åˆ›å»ºè®°å¿†è®°å½•
 * ä¿®å¤ï¼šä½¿ç”¨ get() ä»£æ›¿ getOne()
 */
async function getOrCreateMemory(db, userId, entityType, entityId, isLocked = false) {
    // 1. å°è¯•æŸ¥è¯¢ç°æœ‰è®°å½•
    const existingMemory = await db.collection('memory_status')
        .where({
            userId,
            entityType,
            entityId
        })
        .get();

    // 2. å¦‚æœå­˜åœ¨,ç›´æ¥è¿”å›ç¬¬ä¸€æ¡
    if (existingMemory.data && existingMemory.data.length > 0) {
        return existingMemory.data[0];
    }

    // 3. ä¸å­˜åœ¨åˆ™åˆ›å»ºæ–°è®°å½•
    return await createMemoryRecord(db, userId, entityType, entityId, isLocked);
}

/**
 * æ›´æ–°è®°å¿†çŠ¶æ€(ç­”é¢˜åè°ƒç”¨)
 */
async function updateMemoryAfterReview(db, userId, entityType, entityId, quality) {
    console.log('ã€æµ‹è¯•ã€‘updateMemoryAfterReview è¢«è°ƒç”¨äº†ï¼', { userId, quality });
    console.log('=== [updateMemoryAfterReview] å¼€å§‹ ===');
    console.log('å‚æ•°:', JSON.stringify({ userId, entityType, entityId, quality }));

    try {
        // 1. è·å–å½“å‰è®°å¿†è®°å½•
        console.log('æ­¥éª¤1: è·å–è®°å¿†è®°å½•');
        const memory = await getOrCreateMemory(db, userId, entityType, entityId);
        console.log('è®°å¿†è®°å½•:', JSON.stringify(memory));

        // 2. æ˜ å°„è´¨é‡åˆ°SM-2è¯„åˆ†
        console.log('æ­¥éª¤2: æ˜ å°„è´¨é‡');
        const qualityMap = {
            'é™Œç”Ÿ': 1,
            'æ¨¡ç³Š': 3,
            'è®°å¾—': 5
        };
        const sm2Quality = qualityMap[quality] || 3;
        console.log('SM-2è´¨é‡:', sm2Quality);

        // 3. è®¡ç®—æ–°çš„SM-2å‚æ•°
        console.log('æ­¥éª¤3: è°ƒç”¨ calculateSM2Optimized');
        console.log('è°ƒç”¨å‚æ•°:', {
            quality,
            intervalDays: memory.intervalDays,
            easinessFactor: memory.easinessFactor,
            reviewStage: memory.reviewStage
        });

        const sm2Result = calculateSM2Optimized(
            quality,
            memory.intervalDays,
            memory.easinessFactor,
            memory.reviewStage
        );

        console.log('SM-2ç»“æœ:', JSON.stringify(sm2Result));

        // 4. æ›´æ–°æŒæ¡åº¦
        console.log('æ­¥éª¤4: è®¡ç®—æ–°æŒæ¡åº¦');
        let newMasteryLevel = memory.masteryLevel;
        if (quality === 'è®°å¾—') {
            newMasteryLevel = Math.min(1.0, memory.masteryLevel + 0.15);
        } else if (quality === 'æ¨¡ç³Š') {
            newMasteryLevel = Math.max(0.0, memory.masteryLevel + 0.05);
        } else {
            newMasteryLevel = Math.max(0.0, memory.masteryLevel - 0.2);
        }
        console.log('æ–°æŒæ¡åº¦:', newMasteryLevel);

        // 5. æ›´æ–°è¿èƒœå’Œè®¡æ•°
        console.log('æ­¥éª¤5: è®¡ç®—è¿èƒœ');
        const newStreakCorrect = quality === 'è®°å¾—' ? memory.streakCorrect + 1 : 0;
        const newCorrectCount = quality === 'è®°å¾—' ? memory.correctCount + 1 : memory.correctCount;
        const newWrongCount = quality === 'é™Œç”Ÿ' ? memory.wrongCount + 1 : memory.wrongCount;

        // 6. è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´
        console.log('æ­¥éª¤6: è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´');
        const now = new Date();
        const nextReviewAt = new Date(now.getTime() + sm2Result.interval * 24 * 60 * 60 * 1000);
        console.log('ä¸‹æ¬¡å¤ä¹ æ—¶é—´:', nextReviewAt);

        // 7. å‡†å¤‡æ›´æ–°æ•°æ®
        console.log('æ­¥éª¤7: å‡†å¤‡æ›´æ–°æ•°æ®åº“');
        const updateData = {
            masteryLevel: newMasteryLevel,
            reviewStage: sm2Result.repetitions,
            easinessFactor: sm2Result.easinessFactor,
            intervalDays: sm2Result.interval,
            lastReviewAt: now.toISOString(),
            nextReviewAt: nextReviewAt.toISOString(),
            correctCount: newCorrectCount,
            wrongCount: newWrongCount,
            streakCorrect: newStreakCorrect,
            updatedAt: now.toISOString()
        };

        console.log('æ›´æ–°æ•°æ®å¯¹è±¡:', JSON.stringify(updateData));

        // æ£€æŸ¥æ˜¯å¦æœ‰ undefined
        for (const [key, value] of Object.entries(updateData)) {
            if (value === undefined) {
                console.error(`âŒ å‘ç° undefined å€¼: ${key}`);
            }
        }

        // 8. æ‰§è¡Œæ›´æ–°
        console.log('æ­¥éª¤8: æ‰§è¡Œæ•°æ®åº“æ›´æ–°');
        await db.collection('memory_status')
            .where({
                userId,
                entityType,
                entityId
            })
            .update({
                data: updateData   // âœ… CloudBase å¿…é¡»è¿™æ ·å†™
            });

        console.log('âœ… æ›´æ–°æˆåŠŸ');

        return {
            entityId,
            entityType,
            masteryLevel: newMasteryLevel,
            reviewStage: sm2Result.repetitions,
            easinessFactor: sm2Result.easinessFactor,
            intervalDays: sm2Result.interval,
            nextReviewAt: nextReviewAt.toISOString(),
            correctCount: newCorrectCount,
            wrongCount: newWrongCount,
            streakCorrect: newStreakCorrect
        };

    } catch (error) {
        console.error('âŒ [updateMemoryAfterReview] é”™è¯¯:', error);
        console.error('é”™è¯¯å †æ ˆ:', error.stack);
        throw error;
    }
}

/**
 * è·å–ä»Šæ—¥å¾…å¤ä¹ çš„å®ä½“
 */
async function getTodayReviewEntities(db, userId, entityType, limit = 20) {
    const now = new Date();

    const result = await db.collection('memory_status')
        .where({
            userId,
            entityType,
            isLocked: false,
            nextReviewAt: db.command.lte(now)
        })
        .orderBy('nextReviewAt', 'asc')
        .limit(limit)
        .get();

    return result.data || [];
}

/**
 * æ£€æŸ¥å¹¶è§£é”ä¸‹ä¸€é˜¶æ®µå­¦ä¹ 
 */
// async function checkAndUnlockNextStage(db, userId) {

//   if (process.env.FORCE_UNLOCK === 'true') {
//     return {
//       allowed: true,
//       progress: 100,
//       stage: "all",
//       message: 'ã€è°ƒè¯•æ¨¡å¼ã€‘å¼ºåˆ¶è§£é”'
//     };
//   }

//   // ä¿®å¤ï¼šä½¿ç”¨ get() + data[0]
//   const progressResult = await db.collection('user_progress')
//     .where({ userId })
//     .get();

//   if (!progressResult.data || progressResult.data.length === 0) {
//     await initUserProgress(db, userId);
//     return {
//       unlocked: false,
//       stage: 'letter',
//       message: 'åˆå§‹åŒ–å­¦ä¹ è¿›åº¦æˆåŠŸ'
//     };
//   }

//   const progress = progressResult.data[0];

//   if (!progress.letterCompleted) {
//     const letterMemories = await db.collection('memory_status')
//       .where({
//         userId,
//         entityType: 'letter'
//       })
//       .get();

//     const totalLetters = 44;
//     const masteredLetters = letterMemories.data.filter(m => m.masteryLevel >= 0.7).length;
//     const letterProgress = masteredLetters / totalLetters;

//     if (letterProgress >= 0.95) {
//       await db.collection('user_progress').where({ userId }).update({
//         data: {
//           letterCompleted: true,
//           letterProgress: 1.0,
//           wordUnlocked: true,
//           currentStage: 'word',
//           updatedAt: new Date().toISOString()
//         }
//       });

//       await db.collection('memory_status')
//         .where({
//           userId,
//           entityType: 'word',
//           isLocked: true
//         })
//         .update({
//           data: {
//             isLocked: false,
//             nextReviewAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
//           }
//         });

//       return {
//         unlocked: true,
//         stage: 'word',
//         message: 'æ­å–œ!å­—æ¯å­¦ä¹ å®Œæˆ,å•è¯å­¦ä¹ å·²è§£é”!'
//       };
//     }

//     return {
//       unlocked: false,
//       stage: 'letter',
//       progress: letterProgress,
//       remaining: Math.ceil((0.95 - letterProgress) * totalLetters),
//       message: `è¿˜éœ€æŒæ¡ ${Math.ceil((0.95 - letterProgress) * totalLetters)} ä¸ªå­—æ¯`
//     };
//   }

//   return {
//     unlocked: false,
//     stage: progress.currentStage,
//     message: 'ç»§ç»­åŠ æ²¹!'
//   };
// }

/**
 * åˆå§‹åŒ–ç”¨æˆ·çš„å­¦ä¹ è¿›åº¦è®°å½•
 */
async function initUserProgress(db, userId) {
    const now = new Date();

    const progressRecord = {
        userId,
        letterCompleted: false,
        letterProgress: 0.0,
        wordUnlocked: false,
        wordProgress: 0.0,
        sentenceUnlocked: false,
        sentenceProgress: 0.0,
        articleUnlocked: false,
        currentStage: 'letter',
        totalStudyDays: 0,
        streakDays: 0,
        lastStudyDate: null,
        createdAt: now,
        updatedAt: now
    };

    await db.collection('user_progress').add(progressRecord);
    return progressRecord;
}

/**
 * æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™
 * ä¿®å¤ï¼šä½¿ç”¨ get() + data[0]
 */
async function checkModuleAccess(db, userId, moduleType) {

    // âœ…âœ…âœ…ã€è°ƒè¯•æ€»å¼€å…³ï¼šè·³è¿‡æ‰€æœ‰å­¦ä¹ é”ã€‘
    if (process.env.FORCE_UNLOCK === 'true') {
        console.warn('âš ï¸ FORCE_UNLOCK å·²å¼€å¯, å¼ºåˆ¶æ”¾è¡Œæ¨¡å—:', moduleType);
        return {
            allowed: true,
            progress: {
                letterCompleted: true,
                letterProgress: 1,
                wordUnlocked: true,
                sentenceUnlocked: true,
                articleUnlocked: true,
                currentStage: moduleType
            }
        };
    }

    const progressResult = await db.collection('user_progress')
        .where({ userId })
        .get();

    if (!progressResult.data || progressResult.data.length === 0) {
        return {
            allowed: false,
            errorCode: 'USER_PROGRESS_NOT_FOUND',
            message: 'ç”¨æˆ·å­¦ä¹ è¿›åº¦ä¸å­˜åœ¨,è¯·è”ç³»ç®¡ç†å‘˜'
        };
    }

    const progress = progressResult.data[0];

    // âœ… å­—æ¯æ¨¡å—æ°¸è¿œå…è®¸è®¿é—®
    if (moduleType === 'letter') {
        return {
            allowed: true,
            progress
        };
    }

    // âœ… å…¶ä»–æ‰€æœ‰æ¨¡å—åªä¾èµ– letterCompleted
    if (!progress.letterCompleted) {
        return {
            allowed: false,
            errorCode: 'MODULE_LOCKED',
            message: `è¯·å…ˆå®Œæˆå­—æ¯å­¦ä¹ ï¼ˆå½“å‰è¿›åº¦ï¼š${Math.round(progress.letterProgress * 100)}%ï¼‰`,
            progress
        };
    }

    // âœ… å­—æ¯å®Œæˆ â†’ å…¨éƒ¨æ¨¡å—æ”¾è¡Œ
    return {
        allowed: true,
        progress
    };
}

module.exports = {
    createMemoryRecord,
    getOrCreateMemory,
    updateMemoryAfterReview,
    getTodayReviewEntities,
    // checkAndUnlockNextStage,
    initUserProgress,
    checkModuleAccess
};
</file>

<file path="cloudbase/functions/learn-vocab/utils/sm2.js">
/**
 * SM-2 é—´éš”é‡å¤ç®—æ³•æ¨¡å—ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
 * 
 * åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–:
 * - æ—©æœŸå¤ä¹ é—´éš”æ›´å¯†é›†: 1â†’2â†’4â†’7â†’14 å¤©
 * - "æ¨¡ç³Š"çŠ¶æ€ç¼©çŸ­é—´éš”è€Œéç»´æŒä¸å˜
 * - "é™Œç”Ÿ"çŠ¶æ€é‡ç½®å¤ä¹ è¿›åº¦
 * 
 * ç®—æ³•è®ºæ–‡: https://www.supermemo.com/en/archives1990-2015/english/ol/sm2
 */

'use strict';

const { MasteryLevel, SM2_PARAMS, EARLY_INTERVALS } = require('./constants');

/**
 * å°†æŒæ¡ç¨‹åº¦æ˜ å°„åˆ° SM-2 Quality å€¼
 * 
 * SM-2 Quality å®šä¹‰:
 * 0 - å®Œå…¨ä¸è®°å¾—
 * 1 - é”™è¯¯å›ç­”ï¼Œä½†çœ‹åˆ°æ­£ç¡®ç­”æ¡ˆåæƒ³èµ·
 * 2 - é”™è¯¯å›ç­”ï¼Œæ­£ç¡®ç­”æ¡ˆçœ‹èµ·æ¥å¾ˆç†Ÿæ‚‰
 * 3 - æ­£ç¡®å›ç­”ï¼Œä½†å›°éš¾è¾ƒå¤§
 * 4 - æ­£ç¡®å›ç­”ï¼Œæœ‰äº›çŠ¹è±«
 * 5 - æ­£ç¡®å›ç­”ï¼Œæ¯«æ— å›°éš¾
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦
 * @returns {number} Qualityå€¼ (1-5)
 */
function masteryToQuality(mastery) {
    switch (mastery) {
        case MasteryLevel.UNFAMILIAR:
            return 1;  // å®Œå…¨ä¸è®°å¾—
        case MasteryLevel.FUZZY:
            return 3;  // æœ‰å°è±¡ä½†ä¸ç¡®å®š
        case MasteryLevel.REMEMBERED:
            return 5;  // å®Œå…¨è®°å¾—
        default:
            return 1;
    }
}

/**
 * è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸï¼ˆä¼˜åŒ–ç‰ˆ SM-2 ç®—æ³•ï¼‰
 * 
 * æ”¹è¿›ç‚¹:
 * 1. æ—©æœŸé˜¶æ®µï¼ˆå‰5æ¬¡ï¼‰ä½¿ç”¨å›ºå®šçš„æ¸è¿›é—´éš” [1,2,4,7,14]
 * 2. "æ¨¡ç³Š"æ—¶ç¼©çŸ­é—´éš”è€Œéç»´æŒä¸å˜
 * 3. "é™Œç”Ÿ"æ—¶å®Œå…¨é‡ç½®å¤ä¹ è¿›åº¦
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦: å¿˜è®°/æ¨¡ç³Š/è®¤è¯†
 * @param {number} currentInterval - å½“å‰å¤ä¹ é—´éš”ï¼ˆå¤©ï¼‰
 * @param {number} easinessFactor - ç®€æ˜“åº¦å› å­ï¼ˆ1.3-2.5+ï¼‰
 * @param {number} reviewCount - å·²å¤ä¹ æ¬¡æ•°
 * @returns {Object} ç®—æ³•è®¡ç®—ç»“æœ
 * 
 * @example
 * const result = calculateSM2Optimized('è®¤è¯†', 2, 2.5, 1);
 * // {
 * //   nextInterval: 4,
 * //   nextEasinessFactor: 2.6,
 * //   nextReviewDate: "2025-12-01T10:00:00Z",
 * //   shouldResetCount: false
 * // }
 * */
function calculateSM2Optimized(
    mastery,
    currentInterval = 1,
    easinessFactor = SM2_PARAMS.INITIAL_EASINESS_FACTOR,
    reviewCount = 0
) {
    let nextInterval = currentInterval;
    let nextEF = easinessFactor;
    let shouldResetCount = false;

    const quality = masteryToQuality(mastery);

    // ==================== æ ¸å¿ƒç®—æ³•é€»è¾‘ ====================

    if (quality < 3) {
        // ========== å¿˜è®°: å®Œå…¨é‡ç½® ==========
        // ç”¨æˆ·å®Œå…¨ä¸è®°å¾—ï¼Œéœ€è¦ä»å¤´å¼€å§‹å­¦ä¹ 
        nextInterval = 1;
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF - 0.2);
        shouldResetCount = true;

    } else if (quality === 3) {
        // ========== æ¨¡ç³Š: ç¼©çŸ­é—´éš”ï¼ŒåŠ å¼ºå¤ä¹  ==========
        // æ”¹è¿›: ä¸æ˜¯ç»´æŒä¸å˜ï¼Œè€Œæ˜¯ç¼©çŸ­20%
        nextInterval = Math.max(1, Math.round(currentInterval * SM2_PARAMS.FUZZY_MULTIPLIER));
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF - 0.1);

    } else {
        // ========== è®°å¾—: ä½¿ç”¨ä¼˜åŒ–çš„é—´éš”åºåˆ— ==========
        if (reviewCount < EARLY_INTERVALS.length) {
            // æ—©æœŸé˜¶æ®µ: ä½¿ç”¨é¢„å®šä¹‰çš„æ¸è¿›é—´éš”
            // è¿™æ˜¯å…³é”®æ”¹è¿›: 1â†’2â†’4â†’7â†’14 è€ŒéåŸç‰ˆçš„ 1â†’6
            nextInterval = EARLY_INTERVALS[reviewCount];
        } else {
            // åæœŸé˜¶æ®µ: ä½¿ç”¨ EF è®¡ç®—æŒ‡æ•°å¢é•¿
            nextInterval = Math.round(currentInterval * nextEF);
        }

        // æé«˜ç®€æ˜“åº¦ (æ ‡å‡† SM-2 å…¬å¼)
        nextEF = nextEF + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF);
    }

    // é™åˆ¶æœ€å¤§é—´éš”
    nextInterval = Math.min(nextInterval, SM2_PARAMS.MAX_INTERVAL_DAYS);

    // è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸ
    const nextReviewDate = new Date();
    nextReviewDate.setDate(nextReviewDate.getDate() + nextInterval);

    // è®¡ç®—æ–°çš„å¤ä¹ æ¬¡æ•°
    const newRepetitions = shouldResetCount ? 0 : reviewCount + 1;

    return {
        // === å…¼å®¹ memoryEngine.js çš„æ—§æ¥å£ ===
        interval: nextInterval,
        easinessFactor: parseFloat(nextEF.toFixed(2)),
        repetitions: newRepetitions,

        // === æ–°æ¥å£ï¼ˆä¿ç•™ä¾›æœªæ¥ä½¿ç”¨ï¼‰===
        nextInterval,
        nextEasinessFactor: parseFloat(nextEF.toFixed(2)),
        nextReviewDate: nextReviewDate.toISOString(),
        shouldResetCount,
    };
}

/**
 * ç”Ÿæˆé¢„è®¡å¤ä¹ æ—¶é—´çº¿
 * 
 * ç”¨äºå‰ç«¯å±•ç¤ºæœªæ¥çš„å¤ä¹ è®¡åˆ’
 * 
 * @param {number} currentReviewCount - å½“å‰å¤ä¹ æ¬¡æ•°
 * @param {number} maxItems - è¿”å›çš„æ—¶é—´çº¿é¡¹æ•° (é»˜è®¤5)
 * @returns {Array} æœªæ¥å¤ä¹ è®¡åˆ’
 * 
 * @example
 * generateReviewTimeline(2);
 * // [
 * //   { reviewNumber: 3, intervalDays: 4 },
 * //   { reviewNumber: 4, intervalDays: 7 },
 * //   { reviewNumber: 5, intervalDays: 14 },
 * //   ...
 * // ]
 */
function generateReviewTimeline(currentReviewCount, maxItems = 5) {
    const timeline = [];
    let interval = 1;
    let ef = SM2_PARAMS.INITIAL_EASINESS_FACTOR;

    for (let i = currentReviewCount; i < currentReviewCount + maxItems; i++) {
        if (i < EARLY_INTERVALS.length) {
            interval = EARLY_INTERVALS[i];
        } else {
            interval = Math.round(interval * ef);
        }
        interval = Math.min(interval, SM2_PARAMS.MAX_INTERVAL_DAYS);

        timeline.push({
            reviewNumber: i + 1,
            intervalDays: interval,
        });
    }

    return timeline;
}

/**
 * è·å–ä»Šå¤©çš„æ—¶é—´èŒƒå›´ (UTC)
 * 
 * @returns {Object} { startOfDay, endOfDay, timestamp }
 */
function getTodayRange() {
    const now = new Date();
    const startOfDay = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate(),
        0, 0, 0, 0
    ));
    const endOfDay = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate() + 1,
        0, 0, 0, 0
    ));

    return {
        startOfDay: startOfDay.toISOString(),
        endOfDay: endOfDay.toISOString(),
        timestamp: now.toISOString(),
    };
}

/**
 * è·å–ç®—æ³•ä¿¡æ¯ (ç”¨äºå‰ç«¯å±•ç¤º)
 * 
 * @returns {Object} ç®—æ³•å…ƒä¿¡æ¯
 */
function getAlgorithmInfo() {
    return {
        name: 'Optimized SM-2',
        version: '1.1.0',
        earlyIntervals: EARLY_INTERVALS,
        maxInterval: SM2_PARAMS.MAX_INTERVAL_DAYS,
        description: 'åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–çš„é—´éš”é‡å¤ç®—æ³•',
    };
}

module.exports = {
    calculateSM2Optimized,
    generateReviewTimeline,
    getTodayRange,
    getAlgorithmInfo,
    masteryToQuality,
};
</file>

<file path="cloudbase/functions/learn-vocab/utils/validators.js">
/**
 * å‚æ•°éªŒè¯æ¨¡å—
 * 
 * ç”¨æˆ·ã€è¯æ±‡éªŒè¯åŠé€šç”¨éªŒè¯å·¥å…·
 */

'use strict';

const { userCollection, vocabularyCollection } = require('./database');
const { MasteryLevel } = require('./constants');

/**
 * éªŒè¯ç”¨æˆ·æ˜¯å¦å­˜åœ¨
 * 
 * @param {string} userId - ç”¨æˆ·ID
 * @returns {Promise<Object|null>} ç”¨æˆ·å¯¹è±¡æˆ– null
 */
async function validateUser(userId) {
    if (!userId || typeof userId !== 'string') {
        return null;
    }

    try {
        const { data } = await userCollection
            .where({ userId })
            .limit(1)
            .get();

        return data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('[validateUser] Error:', error);
        return null;
    }
}

/**
 * éªŒè¯è¯æ±‡æ˜¯å¦å­˜åœ¨
 * 
 * @param {string} vocabularyId - è¯æ±‡ID
 * @returns {Promise<Object|null>} è¯æ±‡å¯¹è±¡æˆ– null
 */
async function validateVocabulary(vocabularyId) {
    if (!vocabularyId || typeof vocabularyId !== 'string') {
        return null;
    }

    try {
        const { data } = await vocabularyCollection
            .where({ vocabularyId })
            .limit(1)
            .get();

        return data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('[validateVocabulary] Error:', error);
        return null;
    }
}

/**
 * éªŒè¯æŒæ¡ç¨‹åº¦æ˜¯å¦æœ‰æ•ˆ
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦
 * @returns {boolean} æ˜¯å¦æœ‰æ•ˆ
 */
function isValidMastery(mastery) {
    const validValues = Object.values(MasteryLevel);
    return validValues.includes(mastery);
}

/**
 * éªŒè¯å¹¶è§„èŒƒåŒ–åˆ†é¡µå‚æ•°
 * 
 * @param {number} limit - é™åˆ¶æ•°é‡
 * @param {number} offset - åç§»é‡
 * @param {number} maxLimit - æœ€å¤§é™åˆ¶ (é»˜è®¤100)
 * @returns {Object} éªŒè¯åçš„åˆ†é¡µå‚æ•°
 */
function validatePagination(limit, offset, maxLimit = 100) {
    return {
        limit: Math.min(Math.max(1, parseInt(limit) || 20), maxLimit),
        offset: Math.max(0, parseInt(offset) || 0),
    };
}

/**
 * éªŒè¯å¿…å¡«å­—ç¬¦ä¸²å‚æ•°
 * 
 * @param {string} value - å‚æ•°å€¼
 * @param {string} name - å‚æ•°å (ç”¨äºé”™è¯¯æ¶ˆæ¯)
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateRequiredString(value, name) {
    if (!value || typeof value !== 'string' || value.trim() === '') {
        return {
            valid: false,
            error: `${name} æ˜¯å¿…å¡«å‚æ•°ä¸”ä¸èƒ½ä¸ºç©º`,
        };
    }
    return { valid: true };
}

/**
 * éªŒè¯å¸ƒå°”å‚æ•°
 * 
 * @param {any} value - å‚æ•°å€¼
 * @param {string} name - å‚æ•°å
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateBoolean(value, name) {
    if (typeof value !== 'boolean') {
        return {
            valid: false,
            error: `${name} å¿…é¡»æ˜¯å¸ƒå°”å€¼`,
        };
    }
    return { valid: true };
}
/**
 * é€šç”¨å‚æ•°éªŒè¯å‡½æ•°
 * 
 * @param {Object} params - éœ€è¦éªŒè¯çš„å‚æ•°å¯¹è±¡
 * @param {Array<string>} requiredFields - å¿…éœ€å­—æ®µåˆ—è¡¨
 * @returns {Object} { isValid: boolean, message?: string }
 */
function validateParams(params, requiredFields) {
    const missing = [];

    for (const field of requiredFields) {
        if (params[field] === undefined || params[field] === null || params[field] === '') {
            missing.push(field);
        }
    }

    if (missing.length > 0) {
        return {
            isValid: false,
            message: `ç¼ºå°‘å¿…å¡«å‚æ•°: ${missing.join(', ')}`
        };
    }

    return { isValid: true };
}

module.exports = {
    validateUser,
    validateVocabulary,
    isValidMastery,
    validatePagination,
    validateRequiredString,
    validateBoolean,
    validateParams,
};
</file>

<file path="cloudbase/functions/memory-engine/index.js">
/**
 * memory-engine äº‘å‡½æ•°
 * ç»Ÿä¸€è®°å¿†å¼•æ“æœåŠ¡
 * ç‰ˆæœ¬: 1.0.0
 * 
 * è§¦å‘æ–¹å¼: HTTP è§¦å‘å™¨
 */

const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.SYMBOL_CURRENT_ENV });
const db = cloud.database();

// ===== Handlers =====
const getTodayMemories = require('./handlers/getTodayMemories');
const submitMemoryResult = require('./handlers/submitMemoryResult');
const submitRoundEvaluation = require('./handlers/submitRoundEvaluation');
const checkModuleAccessHandler = require('./handlers/checkModuleAccess');
const getUserProgress = require('./handlers/getUserProgress');
const getAlphabetLessons = require('./handlers/getAlphabetLessons');

// ===== Utils =====
const { createResponse } = require('./utils/response');

/**
 * äº‘å‡½æ•°ä¸»å…¥å£
 */
exports.main = async (event, context) => {
    // ===== è§£æ HTTP è¯·æ±‚ =====
    let requestData = event;

    // HTTP è§¦å‘å™¨ï¼šbody å¯èƒ½æ˜¯å­—ç¬¦ä¸²æˆ–å¯¹è±¡
    if (event.body) {
        if (typeof event.body === 'string') {
            try {
                requestData = JSON.parse(event.body);
            } catch (e) {
                console.error('[memory-engine] JSON è§£æå¤±è´¥:', e.message);
                return createResponse(false, null, 'Invalid JSON in request body', 'INVALID_JSON');
            }
        } else if (typeof event.body === 'object') {
            requestData = event.body;
        }
    }

    const { action, data = {} } = requestData;

    console.log(`[memory-engine] Action: ${action}`, JSON.stringify(data));

    // éªŒè¯ action å‚æ•°
    if (!action) {
        return createResponse(
            false,
            null,
            'ç¼ºå°‘å¿…å¡«å‚æ•°: action',
            'MISSING_ACTION'
        );
    }

    try {
        /**
         * è·å–ä»Šæ—¥å­¦ä¹ å†…å®¹ (ç»Ÿä¸€æ¥å£)
         */
        if (action === 'getTodayMemories') {
            return await getTodayMemories(db, data);
        }

        /**
         * æäº¤å­¦ä¹ ç»“æœ (ç»Ÿä¸€æ¥å£)
         */
        if (action === 'submitMemoryResult') {
            return await submitMemoryResult(db, data);
        }

        /**
         * æäº¤ä¸‰è½®è¯„ä¼°ç»“æœï¼ˆå­—æ¯æ¨¡å—ï¼‰
         */
        if (action === 'submitRoundEvaluation') {
            return await submitRoundEvaluation(db, data);
        }

        /**
         * æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™
         */
        if (action === 'checkModuleAccess') {
            return await checkModuleAccessHandler(db, data);
        }

        /**
         * è·å–ç”¨æˆ·å­¦ä¹ è¿›åº¦
         */
        if (action === 'getUserProgress') {
            return await getUserProgress(db, data);
        }

        /**
         * è·å–å­—æ¯è¯¾ç¨‹åˆ—è¡¨ï¼ˆç”¨äºå‰ç«¯è¯¾ç¨‹æ€»è§ˆï¼‰
         */
        if (action === 'getAlphabetLessons') {
            return await getAlphabetLessons(db, data);
        }

        // ===== æœªçŸ¥Action =====
        const supportedActions = [
            'getTodayMemories',
            'submitMemoryResult',
            'submitRoundEvaluation',
            'checkModuleAccess',
            'getUserProgress',
            'getAlphabetLessons',
        ];

        return createResponse(
            false,
            { supportedActions },
            `æœªçŸ¥çš„æ“ä½œç±»å‹: ${action}`,
            'UNKNOWN_ACTION'
        );

    } catch (error) {
        console.error(`[memory-engine] äº‘å‡½æ•°é”™è¯¯:`, error);
        console.error('é”™è¯¯å †æ ˆ:', error.stack);

        return createResponse(
            false,
            null,
            error.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
            'SERVER_ERROR'
        );
    }
};
</file>

<file path="cloudbase/cloudbaserc.json">
{
  "envId": "cloud1-1gjcyrdd7ab927c6",
  "region": "ap-shanghai",
  "functionRoot": "./functions",
  "functions": [
    {
      "name": "user-register",
      "timeout": 15,
      "runtime": "Nodejs18.15",
      "handler": "index.main"
    },
    {
      "name": "user-login",
      "timeout": 15,
      "runtime": "Nodejs18.15",
      "handler": "index.main"
    },
    {
      "name": "user-reset-password",
      "timeout": 15,
      "runtime": "Nodejs18.15",
      "handler": "index.main"
    },
    {
      "name": "user-update-profile",
      "timeout": 15,
      "runtime": "Nodejs18.15",
      "handler": "index.main"
    },
    {
      "name": "learn-vocab",
      "timeout": 15,
      "runtime": "Nodejs18.15",
      "handler": "index.main",
      "installDependency": true
    },
    {
      "name": "memory-engine",
      "timeout": 20,
      "runtime": "Nodejs18.15",
      "handler": "index.main",
      "installDependency": true
    },
    {
      "name": "alphabet",
      "timeout": 20,
      "runtime": "Nodejs18.15",
      "handler": "index.main",
      "installDependency": true
    },
    {
      "name": "storage-download",
      "timeout": 20,
      "runtime": "Nodejs18.15",
      "handler": "index.main",
      "installDependency": true
    }
  ]
}
</file>

<file path="src/config/alphabet/lessonMetadata.config.ts">
// src/config/alphabet/lessonMetadata.config.ts

import type { LessonMetadata } from '@/src/entities/types/phonicsRule.types';

/**
 * 6è¯¾å…ƒæ•°æ®å®Œæ•´é…ç½®
 * 
 * å®šä¹‰æ¯è¯¾çš„å­—æ¯ç»„æˆã€æ‹¼è¯»è§„åˆ™å…³è”ã€é€šè¿‡ç‡è¦æ±‚ç­‰
 * 
 * @version 1.0.0
 * @see SEQUENCE_LESSONS
 */
export const LESSON_METADATA: Record<string, LessonMetadata> = {
  /**
   * Lesson 1: åŸºç¡€æ‹¼è¯»èƒ½åŠ›(5è¾…éŸ³+3å…ƒéŸ³)
   */
  lesson1: {
    lessonId: 'lesson1',
    title: 'ç¬¬ä¸€è¯¾:åŸºç¡€æ‹¼è¯»èƒ½åŠ›',
    description: 'æŒæ¡æœ€åŸºç¡€çš„ä¸­è¾…éŸ³å’Œå¸¸è§é•¿å…ƒéŸ³,å»ºç«‹CVæ‹¼è¯»æ¦‚å¿µ',
    consonants: ['à¸', 'à¸”', 'à¸•', 'à¸™', 'à¸¡'],
    vowels: ['à¸²', 'à¸µ', 'à¸¹','à¸µ'],
    tones: [],
    phonicsRuleId: 'rule_1_cv_structure',
    totalCount: 9,
    minPassRate: 0.95,
    miniReviewInterval: 3,
    order: 1,
  },

  /**
   * Lesson 2: å‰ç½®å…ƒéŸ³ç³»ç»Ÿ(6è¾…éŸ³+4å…ƒéŸ³)
   */
  lesson2: {
    lessonId: 'lesson2',
    title: 'ç¬¬äºŒè¯¾:å‰ç½®å…ƒéŸ³ç³»ç»Ÿ',
    description: 'å­¦ä¹ å‰ç½®å…ƒéŸ³(à¹€ à¹ à¹‚)å’Œæ›´å¤šé«˜é¢‘è¾…éŸ³',
    consonants: ['à¸š', 'à¸›', 'à¸£', 'à¸¥', 'à¸§', 'à¸¢'],
    vowels: ['à¹€', 'à¹', 'à¹‚', 'à¸­'],
    tones: [],
    phonicsRuleId: 'rule_2_leading_vowel',
    totalCount: 10,
    minPassRate: 0.90,
    miniReviewInterval: 3,
    order: 2,
  },

  /**
   * Lesson 3: å£°è°ƒå…¥é—¨+é€æ°”å¯¹æ¯”(5è¾…éŸ³+3å…ƒéŸ³+2å£°è°ƒ)
   */
  lesson3: {
    lessonId: 'lesson3',
    title: 'ç¬¬ä¸‰è¯¾:å£°è°ƒå…¥é—¨',
    description: 'æŒæ¡é€æ°”/ä¸é€æ°”å¯¹æ¯”,å¼•å…¥åŸºç¡€å£°è°ƒç³»ç»Ÿ',
    consonants: ['à¸‚', 'à¸–', 'à¸œ', 'à¸ª', 'à¸«'],
    vowels: ['à¸°', 'à¸¸', 'à¸¶'],
    tones: ['à¹ˆ', 'à¹‰'],
    phonicsRuleId: 'rule_3_tone_basics',
    totalCount: 10,
    minPassRate: 0.90,
    miniReviewInterval: 3,
    order: 3,
  },

  /**
   * Lesson 4: è¾…éŸ³ç±»ä¸å£°è°ƒè§„åˆ™(6è¾…éŸ³+4å…ƒéŸ³+2å£°è°ƒ)
   */
  lesson4: {
    lessonId: 'lesson4',
    title: 'ç¬¬å››è¯¾:è¾…éŸ³ç±»ä¸å£°è°ƒ',
    description: 'ç†è§£é«˜/ä¸­/ä½è¾…éŸ³å¯¹å£°è°ƒçš„å½±å“,æŒæ¡å®Œæ•´å£°è°ƒç³»ç»Ÿ',
    consonants: ['à¸„', 'à¸—', 'à¸', 'à¸Š', 'à¸ˆ', 'à¸‡'],
    vowels: ['à¹„', 'à¹ƒ', 'à¹€à¸­à¸²', 'à¸­à¸³'],
    tones: ['à¹Š', 'à¹‹'],
    phonicsRuleId: 'rule_4_consonant_class_tones',
    totalCount: 12,
    minPassRate: 0.85,
    miniReviewInterval: 3,
    order: 4,
  },

  /**
   * Lesson 5: å¤åˆå…ƒéŸ³ç³»ç»Ÿ(8è¾…éŸ³+6å…ƒéŸ³)
   */
  lesson5: {
    lessonId: 'lesson5',
    title: 'ç¬¬äº”è¯¾:å¤åˆå…ƒéŸ³ç³»ç»Ÿ',
    description: 'æŒæ¡ä¸‰åˆå…ƒéŸ³(à¹€à¸­à¸µà¸¢ à¹€à¸­à¸·à¸­ à¸­à¸±à¸§)ç­‰å¤æ‚å…ƒéŸ³ç»„åˆ',
    consonants: ['à¸‹', 'à¸‰', 'à¸', 'à¸Ÿ', 'à¸¨', 'à¸©', 'à¸®', 'à¸­'],
    vowels: ['à¹€à¸­à¸µà¸¢', 'à¹€à¸­à¸·à¸­', 'à¸­à¸±à¸§', 'à¹€à¸­à¸­', 'à¸·', 'à¸­'],
    tones: [],
    phonicsRuleId: 'rule_5_compound_vowels',
    totalCount: 14,
    minPassRate: 0.85,
    miniReviewInterval: 3,
    order: 5,
  },

  /**
   * Lesson 6: å®Œæ•´è¦†ç›–+ç‰¹æ®Šè§„åˆ™(14è¾…éŸ³+12å…ƒéŸ³)
   * è¯´æ˜:
   * - æ­¤è¯¾å…ƒéŸ³ç»„ç”¨äºè®­ç»ƒã€ŒçŸ­å…ƒéŸ³å˜å½¢ã€ä¸ Dead Syllable è§„åˆ™ï¼›
   * - å…¶ä¸­ 'à¸­à¸±à¸§' åœ¨è¿™é‡Œä»£è¡¨å®é™…æ‹¼å†™æ¨¡å¼ã€Œà¸±à¸§à¸°ã€(çŸ­ ua)ï¼Œ
   *   ç”±äº letters æ•°æ®é›†ä¸­ä¸å­˜åœ¨ç‹¬ç«‹å­—å½¢ã€Œà¸±à¸§à¸°ã€ï¼Œæ•…ç”¨ 'à¸­à¸±à¸§' ä½œä¸ºä»£è¡¨ç¬¦å·ã€‚
   */
  lesson6: {
    lessonId: 'lesson6',
    title: 'ç¬¬å…­è¯¾:å®Œæ•´è¦†ç›–(å¸¸ç”¨è¿›é˜¶)',
    description: 'è¡¥å……å¸¸ç”¨è¿›é˜¶è¾…éŸ³ä¸å¤åˆå…ƒéŸ³,æŒæ¡ç‰¹æ®Šè§„åˆ™(å¦‚ à¸« à¸™à¸³ ç­‰)',
    consonants: [
      // ä½è¾…éŸ³æ¸…éŸ³(æ¢µæ–‡å€Ÿè¯) + å¸¸ç”¨è¿›é˜¶è¾…éŸ³
      'à¸‘', 'à¸’', 'à¸“', 'à¸ ', 'à¸˜', 'à¸Œ', 'à¸', 'à¸¬', 'à¸', 'à¸', 'à¸',
    ],
    vowels: [
      // æ ¸å¿ƒå˜å½¢çŸ­å…ƒéŸ³ç»„
      'à¹‚à¸­à¸°', 'à¹€à¸­à¸°', 'à¹à¸­à¸°', 'à¹€à¸­à¸²à¸°', 'à¸­à¸±à¸§',
    ],
    tones: [],
    phonicsRuleId: 'rule_6_special_cases',
    totalCount: 16,
    minPassRate: 0.90,
    miniReviewInterval: 4,
    order: 6,
  },

  /**
   * Lesson 7: ç½•ç”¨/å¤ä½“å­—æ¯ä¸å¤æ‚å…ƒéŸ³
   * ä»…ä½œä¸ºè¡¥å……è¯¾ç¨‹,ä¸å‚ä¸å…¶ä»–æ¨¡å—è§£é”
   */
  lesson7: {
    lessonId: 'lesson7',
    title: 'ç¬¬ä¸ƒè¯¾:ç½•ç”¨å­—æ¯ä¸ç‰¹æ®Šå…ƒéŸ³',
    description: 'é›†ä¸­å­¦ä¹ ç°ä»£æ³°è¯­ä¸­è¾ƒå°‘ä½¿ç”¨çš„è¾…éŸ³ä¸å¤æ‚å…ƒéŸ³,ç”¨äºé˜…è¯»å¤æ–‡ä¸ç‰¹æ®Šä¸“æœ‰åè¯',
    consonants: [
      // å·²å¼ƒç”¨æˆ–æå°‘ä½¿ç”¨çš„è¾…éŸ³
      'à¸ƒ', 'à¸…',
    ],
    vowels: [
      // æ¢µæ–‡/å·´åˆ©å€Ÿè¯ä¸­çš„ç‰¹æ®Šå…ƒéŸ³
      'à¸¤', 'à¸¤à¹…', 'à¸¦', 'à¸¦à¹…',
    ],
    tones: [],
    phonicsRuleId: 'rule_6_special_cases',
    totalCount: 6,
    minPassRate: 0.80,
    miniReviewInterval: 4,
    order: 7,
  },
};

/**
 * æ ¹æ®è¯¾ç¨‹IDè·å–å…ƒæ•°æ®
 */
export function getLessonMetadata(lessonId: string): LessonMetadata | null {
  return LESSON_METADATA[lessonId] || null;
}

/**
 * è·å–æ‰€æœ‰è¯¾ç¨‹å…ƒæ•°æ®(æŒ‰é¡ºåº)
 */
export function getAllLessons(): LessonMetadata[] {
  return Object.values(LESSON_METADATA).sort((a, b) => a.order - b.order);
}

/**
 * æ ¹æ®å­—æ¯è·å–æ‰€å±è¯¾ç¨‹
 */
export function getLessonByLetter(thaiChar: string): LessonMetadata | null {
  for (const lesson of Object.values(LESSON_METADATA)) {
    const allLetters = [
      ...lesson.consonants,
      ...lesson.vowels,
      ...lesson.tones,
    ];
    
    if (allLetters.includes(thaiChar)) {
      return lesson;
    }
  }
  
  return null;
}

/**
 * è·å–è¯¾ç¨‹ç»Ÿè®¡
 */
export function getLessonStatistics() {
  const lessons = Object.values(LESSON_METADATA);
  
  return {
    totalLessons: lessons.length,
    totalConsonants: lessons.reduce((sum, l) => sum + l.consonants.length, 0),
    totalVowels: lessons.reduce((sum, l) => sum + l.vowels.length, 0),
    totalTones: lessons.reduce((sum, l) => sum + l.tones.length, 0),
    totalLetters: lessons.reduce((sum, l) => sum + l.totalCount, 0),
  };
}
</file>

<file path="src/entities/types/letter.types.ts">
// src/entities/types/letter.types.ts

/**
 * å­—æ¯ç±»å‹å®šä¹‰
 *
 * æ•°æ®æº: letters_final.enriched.json (80 ä¸ªæ³°è¯­å­—æ¯/å…ƒéŸ³/å£°è°ƒ)
 * æ›´æ–°æ—¥æœŸ: 2025-12-06
 *
 * è¯´æ˜: æ­¤æ¥å£å°½é‡è´´è¿‘æ•°æ®åº“ letters é›†åˆçš„å®é™…ç»“æ„ã€‚
 * - éƒ¨åˆ†å†å²å­—æ®µ (audioPath/learningLevel/strokeCount/createdAt/lessonNumber)
 *   åœ¨æœ€æ–°ç‰ˆæœ¬ä¸­å·²ä»æ•°æ®æºä¸­ç§»é™¤,å› æ­¤åœ¨ç±»å‹ä¸­ä¿ç•™ä¸ºå¯é€‰,ä»…ç”¨äºå…¼å®¹æ—§æ•°æ®ã€‚
 */

// ==================== åŸºç¡€ç±»å‹ ====================

/**
 * å­—æ¯ç±»å‹
 */
export type LetterType = 'consonant' | 'vowel' | 'tone';

/**
 * è¾…éŸ³ç±»åˆ« (ä»…è¾…éŸ³æœ‰æ•ˆ)
 */
export type ConsonantClass = 'mid' | 'high' | 'low';

/**
 * å­¦ä¹ çº§åˆ«
 */
export type LearningLevel = 'BEGINNER' | 'INTERMEDIATE' | 'ADVANCED';

/**
 * å­—æ¯ä¸»ç±»åˆ«
 */
export type LetterCategory = 'mid_consonant' | 'high_consonant' | 'low_consonant' | 'vowel' | 'tone';

// ==================== ä¸»è¦æ¥å£ ====================

/**
 * Letter - å®Œæ•´çš„å­—æ¯æ•°æ®ç»“æ„
 * 
 * â­ æ­¤æ¥å£åŒ…å«letters_final.jsonçš„æ‰€æœ‰å­—æ®µ
 * â­ å¯¹åº”æ•°æ®åº“lettersé›†åˆçš„æ–‡æ¡£ç»“æ„
 */
export interface Letter {
    // ===== åŸºç¡€å­—æ®µ (åŸæœ‰æ•°æ®åº“å­—æ®µ) =====
    _id: string;                    // å”¯ä¸€æ ‡è¯† (å¦‚: "TH_C_01")
    type: LetterType;               // ç±»å‹: consonant | vowel | tone
    thaiChar: string;               // æ³°æ–‡å­—ç¬¦ (å¦‚: "à¸")
    nameThai: string;               // æ³°æ–‡åç§° (å¦‚: "à¹„à¸à¹ˆ")
    nameEnglish: string;            // è‹±æ–‡åç§° (å¦‚: "ko kai")
    initialSound: string;           // é¦–éŸ³ (å¦‚: "k")
    finalSound: string;             // å°¾éŸ³ (å¦‚: "k")
    class: ConsonantClass | null;   // è¾…éŸ³ç±»åˆ« (ä»…è¾…éŸ³æœ‰æ•ˆ,å…ƒéŸ³/å£°è°ƒä¸ºnull)
    exampleWord: string;            // ä¾‹è¯ (å¦‚: "à¹„à¸à¹ˆ")
    exampleMeaning: string;         // ä¾‹è¯å«ä¹‰ (å¦‚: "é¸¡")

    // ä»¥ä¸‹ä¸ºå†å²å­—æ®µ,ç›®å‰æ•°æ®æºä¸­å·²ç§»é™¤,ä¿ç•™ä¸ºå¯é€‰ä»¥å…¼å®¹æ—§æ•°æ®
    audioPath?: string;             // æ—§ç‰ˆéŸ³é¢‘è·¯å¾„ (å¯èƒ½ä¸ºç©º,å»ºè®®ä½¿ç”¨fullSoundUrl)
    strokeCount?: number;           // ç¬”ç”»æ•° (é¢„ç•™å­—æ®µ,æš‚æœªä½¿ç”¨)
    learningLevel?: LearningLevel;  // å­¦ä¹ çº§åˆ«
    createdAt?: string;             // åˆ›å»ºæ—¥æœŸ (ISOæ ¼å¼)
    
    // ===== æ–°å¢å­—æ®µ (æ¥è‡ªletters.jsonåˆå¹¶) =====
    
    // è¯¾ç¨‹ä¸åˆ†ç±»
    lessonId?: string;              // ä¸»è¯¾ç¨‹ ID (å¦‚: "lesson1")
    lessonNumber?: number;          // æ—§è¯¾ç¨‹ç¼–å· (1-7), å·²åºŸå¼ƒ
    category: LetterCategory;       // ä¸»ç±»åˆ« (å¦‚: "mid_consonant", "high_consonant")
    subCategory: string;            // å­ç±»åˆ« (å¦‚: "lesson1_mid", "lesson4_high")
    
    // é”®ç›˜è¾“å…¥
    keyboardKey?: string;           // é”®ç›˜æŒ‰é”® (å¦‚: "d", "j") - å¯é€‰
    
    // å‘éŸ³ç³»ç»Ÿ (å¤šå±‚çº§éŸ³é¢‘)
    fullSound?: string;             // å®Œæ•´å‘éŸ³æ ‡è¯† (å¦‚: "consonant-ko-kai")
    fullSoundUrl?: string;          // â­ å®Œæ•´å‘éŸ³URL (ä¼˜å…ˆä½¿ç”¨)
    fullSoundFileId?: string;       // CloudBase å®Œæ•´å‘éŸ³ fileId (cloud://...)
    fullSoundLocalPath?: string;    // æœ¬åœ°ç¼“å­˜è·¯å¾„ï¼ˆfile://ï¼‰

    syllableSoundName?: string;     // éŸ³èŠ‚å‘éŸ³åç§° (å¦‚: "k")
    syllableSound?: string;         // éŸ³èŠ‚å‘éŸ³æ ‡è¯†
    syllableSoundUrl?: string;      // éŸ³èŠ‚å‘éŸ³URL (ç”¨äºéŸ³èŠ‚ç»ƒä¹ )
    syllableSoundFileId?: string;   // CloudBase éŸ³èŠ‚å‘éŸ³ fileId
    syllableSoundLocalPath?: string;// æœ¬åœ°ç¼“å­˜è·¯å¾„

    endSyllableSoundName?: string;  // å°¾éŸ³èŠ‚åç§°
    endSyllableSound?: string;      // å°¾éŸ³èŠ‚å‘éŸ³æ ‡è¯†
    endSyllableSoundUrl?: string;   // å°¾éŸ³èŠ‚å‘éŸ³URL (ç”¨äºè¾…éŸ³å°¾éŸ³ç»ƒä¹ )
    endSyllableSoundFileId?: string;// CloudBase å°¾éŸ³èŠ‚å‘éŸ³ fileId
    endSyllableSoundLocalPath?: string;// æœ¬åœ°ç¼“å­˜è·¯å¾„

    letterNamePronunciation?: string; // â­ å­—æ¯åç§°å‘éŸ³ (å¦‚: "kay`")
    letterPronunciationUrl?: string;  // å­—æ¯å‘éŸ³URL
    letterPronunciationFileId?: string; // CloudBase å­—æ¯å‘éŸ³ fileId
    letterPronunciationLocalPath?: string; // æœ¬åœ°ç¼“å­˜è·¯å¾„
    
    // å¤šåª’ä½“èµ„æº
    letterImageUrl?: string;        // å­—æ¯å›¾ç‰‡URL (é¢„ç•™)
    
    // æè¿°ä¿¡æ¯
    description?: string;           // é¢å¤–æè¿°ä¿¡æ¯ (å¯é€‰)

    // è¯¾ç¨‹ç¼–æ’ï¼ˆæ¥è‡ª letters_final.enriched.jsonï¼‰
    usageTag?: string;                     // ä½¿ç”¨æ ‡ç­¾: core / rare / supplement ç­‰
    lessonGroup?: string;                  // è¯¾ç¨‹ç»„åˆ«: core / supplement ç­‰
    curriculumLessonIds?: string[];        // æ‰€å±è¯¾ç¨‹ ID åˆ—è¡¨ï¼Œä¾‹å¦‚ ['lesson1', 'lesson3']
    curriculumLessonOrders?: number[];     // å„è¯¾ç¨‹å†…æ’åºåºå·
    primaryCurriculumLessonId?: string;    // ä¸»è¯¾ç¨‹ IDï¼Œä¾‹å¦‚ 'lesson1'
    primaryCurriculumLessonOrder?: number; // ä¸»è¯¾ç¨‹ä¸­çš„æ’åº
}

/**
 * LetterListItem - ç®€åŒ–ç‰ˆå­—æ¯æ•°æ® (ç”¨äºåˆ—è¡¨æ˜¾ç¤º)
 */
export interface LetterListItem {
    _id: string;
    thaiChar: string;
    nameThai: string;
    nameEnglish: string;
    type: LetterType;
    class: ConsonantClass | null;
    lessonId?: string;
    category: LetterCategory;
    isMastered?: boolean;           // å‰ç«¯æ·»åŠ : æ˜¯å¦å·²æŒæ¡
}

/**
 * LetterProgress - å­—æ¯å­¦ä¹ è¿›åº¦
 */
export interface LetterProgress {
    masteredCount: number;          // å·²æŒæ¡æ•°é‡
    totalCount: number;             // æ€»æ•°é‡ (80ä¸ª)
    accuracy: number;               // æ­£ç¡®ç‡ (0-100)
    masteredIds: string[];          // å·²æŒæ¡çš„å­—æ¯IDåˆ—è¡¨
}

/**
 * LetterStatistics - å­—æ¯ç»Ÿè®¡ä¿¡æ¯
 */
export interface LetterStatistics {
    total: number;
    consonants: number;
    vowels: number;
    tones: number;
    byLesson: {
        lesson1: number;
        lesson2: number;
        lesson3: number;
        lesson4: number;
        lesson5: number;
        lesson6: number;
        lesson7: number;
    };
    byClass: {
        mid: number;
        high: number;
        low: number;
    };
}

/**
 * LetterFilter - å­—æ¯æœç´¢/è¿‡æ»¤æ¡ä»¶
 */
export interface LetterFilter {
    type?: LetterType;
    lessonId?: string;
    class?: ConsonantClass;
    category?: LetterCategory;
    subCategory?: string;
    excludeIds?: string[];
}

// ==================== è¾…åŠ©ç±»å‹ ====================

/**
 * éŸ³é¢‘URLä¼˜å…ˆçº§ç±»å‹
 */
export type AudioUrlPriority = {
    primary: string | undefined;    // fullSoundUrl
    secondary: string | undefined;  // letterPronunciationUrl
    fallback: string;               // audioPath
};

/**
 * å­—æ¯æ˜¾ç¤ºä¿¡æ¯ (ç”¨äºUIç»„ä»¶)
 */
export interface LetterDisplayInfo {
    char: string;                   // æ³°æ–‡å­—ç¬¦
    name: string;                   // åç§° (ä¼˜å…ˆæ³°æ–‡)
    pronunciation: string;          // å‘éŸ³ (ä¼˜å…ˆletterNamePronunciation)
    example: string;                // å®Œæ•´ä¾‹è¯ (åŒ…å«ä¸­æ–‡)
    audioUrl: string;               // éŸ³é¢‘URL (å·²å¤„ç†ä¼˜å…ˆçº§)
    keyboardHint?: string;          // é”®ç›˜æç¤º
}
</file>

<file path="src/stores/vocabularyStore.ts">
// src/stores/vocabularyStore.ts

/**
 * å•è¯å­¦ä¹  Store
 * 
 * åŠŸèƒ½ï¼š
 * 1. ä»åç«¯è·å–ä»Šæ—¥å•è¯å­¦ä¹ ä»»åŠ¡
 * 2. ç®¡ç†å•è¯å­¦ä¹ ä¼šè¯æµç¨‹
 * 3. æäº¤å­¦ä¹ ç»“æœåˆ°åç«¯
 * 4. æœ¬åœ°è¿›åº¦è¿½è¸ª
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { apiClient } from '@/src/utils/apiClient';
import { API_ENDPOINTS } from '@/src/config/api.endpoints';
import { useUserStore } from './userStore';
import { useModuleAccessStore, type ModuleType } from './moduleAccessStore';
import type {
    Vocabulary,
    VocabularyLearningState,
    TodayVocabularyResponse,
    VocabularyProgress,
} from '@/src/entities/types/vocabulary.types';
import { LearningPhase } from '@/src/entities/enums/LearningPhase.enum';
import {
    QualityButton,
    QUALITY_SCORE_MAP,
    ATTEMPTS_INCREMENT_MAP,
} from '@/src/entities/enums/QualityScore.enum';

interface VocabularyStore {
    // ===== å­¦ä¹ ä¼šè¯çŠ¶æ€ =====
    phase: LearningPhase;
    reviewQueue: VocabularyLearningState[];
    currentVocabulary: VocabularyLearningState | null;
    currentCourseSource: string | null; // Added: Track current course source

    // ===== æœ¬åœ°è¿›åº¦ =====
    progress: VocabularyProgress;
    courseProgressMap: Record<string, VocabularyProgress>;

    // ===== å­¦ä¹ ä¼šè¯æ“ä½œ =====
    initSession: (userId: string) => Promise<void>;
    submitAnswer: (quality: QualityButton) => Promise<void>;
    moveToNext: () => void;
    finishSession: () => void;
    startCourse: (source: string, moduleType?: ModuleType) => Promise<void>; // Modified: Accept moduleType for access check

    // ===== æœ¬åœ°è¿›åº¦æ“ä½œ =====
    markAsMastered: (vocabularyId: string) => void;
    resetProgress: () => void;
}

const defaultProgress: VocabularyProgress = {
    masteredCount: 0,
    totalCount: 0,
    accuracy: 0,
    masteredIds: [],
};

export const useVocabularyStore = create<VocabularyStore>()(
    persist(
        (set, get) => ({
            // ===== åˆå§‹çŠ¶æ€ =====
            phase: LearningPhase.IDLE,
            reviewQueue: [],
            currentVocabulary: null,
            currentCourseSource: null, // Initial state
            progress: defaultProgress,
            courseProgressMap: {},

            // ===== åˆå§‹åŒ–å­¦ä¹ ä¼šè¯ =====
            initSession: async (userId: string) => {
                try {
                    console.log('ğŸ” å¼€å§‹è·å–ä»Šæ—¥å•è¯ï¼ŒuserId:', userId);

                    const { currentCourseSource } = get();
                    const endpoint = API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES;
                    const result = await apiClient.post<TodayVocabularyResponse>(
                        endpoint,
                        {
                            userId,
                            limit: 10,
                            source: currentCourseSource // Added: Filter by course source
                        }
                    );

                    console.log('ğŸ” API å“åº”:', result);

                    if (result.success && (result.data as any)?.items?.length > 0) {
                        const data = result.data as any;
                        const reviewQueue: VocabularyLearningState[] = data.items.map(
                            (item: any) => ({
                                vocabularyId: item._id,
                                thaiWord: item.entity.thaiWord,
                                pronunciation: item.entity.pronunciation,
                                meaning: item.entity.meaning,
                                exampleSentence: item.entity.exampleSentence,
                                audioPath: item.entity.audioPath,
                                currentAttempts: 0,
                                requiredAttempts: 3,
                                qualityHistory: [],
                                isCompleted: false,
                                timestamp: new Date().toISOString(),
                            })
                        );

                        set({
                            phase: LearningPhase.IDLE,
                            reviewQueue,
                            currentVocabulary: reviewQueue[0] || null,
                        });

                        console.log('âœ… æˆåŠŸåŠ è½½', reviewQueue.length, 'ä¸ªå•è¯');
                    } else {
                        // æ²¡æœ‰æ•°æ®æ—¶çš„å¤„ç†
                        console.log('â„¹ï¸ ä»Šæ—¥æ²¡æœ‰éœ€è¦å¤ä¹ çš„å•è¯');
                        set({
                            phase: LearningPhase.COMPLETED,
                            reviewQueue: [],
                            currentVocabulary: null,
                        });
                    }
                } catch (error) {
                    console.error('âŒ initSession error:', error);
                    // é™çº§å¤„ç†ï¼šæ˜¾ç¤ºé”™è¯¯çŠ¶æ€
                    set({
                        phase: LearningPhase.IDLE,
                        reviewQueue: [],
                        currentVocabulary: null,
                    });
                    throw error;
                }
            },

            // ===== å¼€å§‹è¯¾ç¨‹ =====
            startCourse: async (source: string, moduleType: ModuleType = 'word') => {
                // ğŸ”’ Strict Safety Net: éªŒè¯æ˜¯å¦æœ‰æƒé™è®¿é—®è¯¥æ¨¡å—
                const allowed = useModuleAccessStore.getState().checkAccessLocally(moduleType);
                if (!allowed) {
                    console.warn(`ğŸš« Access Denied: Module '${moduleType}' is locked. Cannot start course '${source}'.`);
                    return; // â›”ï¸ å¼ºåˆ¶ä¸­æ–­ï¼Œä¸æ‰§è¡Œä»»ä½•åˆ‡æ¢é€»è¾‘
                }

                const { currentCourseSource, progress, courseProgressMap } = get();

                // If switching to a different course, reset progress
                if (currentCourseSource !== source) {
                    console.log(`ğŸ”„ Switching course from ${currentCourseSource} to ${source}. Caching current progress.`);

                    const cachedProgress = courseProgressMap[source];
                    const updatedCache = currentCourseSource
                        ? { ...courseProgressMap, [currentCourseSource]: progress }
                        : { ...courseProgressMap };

                    // 1. Update local state
                    set({
                        courseProgressMap: updatedCache,
                        currentCourseSource: source,
                        progress: cachedProgress || defaultProgress,
                        reviewQueue: [],
                        currentVocabulary: null,
                        phase: LearningPhase.IDLE // Or START?
                    });

                    // 2. Reset remote progress (if applicable)
                    // Note: The requirement says "clear Basic Thai 1's progress". 
                    // Since we have a single 'wordProgress' in user_progress, we likely need to reset that.
                    // However, 'user_progress' seems to be managed by moduleAccessStore/userStore mostly.
                    // We might need an API call here to reset the backend progress for the user.
                    // For now, we'll assume the 'initSession' or a specific 'resetProgress' API call handles this.
                    // Let's call a reset endpoint if it exists, or just rely on local reset + future updates overwriting.

                    // Ideally call an API to reset wordProgress on backend
                    try {
                        const userId = useUserStore.getState().currentUser?.userId;
                        if (userId) {
                            // Assuming we reuse the progress update endpoint to set progress to 0
                            // Or if there's a specific reset endpoint. 
                            // Based on available endpoints, we might need to use PROGRESS.UPDATE
                            /*
                            await apiClient.post(API_ENDPOINTS.PROGRESS.UPDATE, {
                                userId,
                                wordProgress: 0,
                                wordUnlocked: false // Maybe?
                            });
                            */
                            // For now, just logging as the backend logic for "resetting" isn't fully exposed in the snippets.
                            // We will rely on the fact that we are starting fresh.
                        }
                    } catch (e) {
                        console.error("Failed to reset remote progress", e);
                    }
                } else {
                    console.log(`â–¶ï¸ Continuing course ${source}`);
                }
            },

            // ===== æäº¤ç­”æ¡ˆ =====
            submitAnswer: async (quality: QualityButton) => {
                const { currentVocabulary, reviewQueue } = get();
                if (!currentVocabulary) return;

                const qualityScore = QUALITY_SCORE_MAP[quality];
                const attemptsIncrement = ATTEMPTS_INCREMENT_MAP[quality];

                // æ›´æ–°å½“å‰å•è¯çŠ¶æ€
                const updatedVocabulary: VocabularyLearningState = {
                    ...currentVocabulary,
                    currentAttempts: currentVocabulary.currentAttempts + attemptsIncrement,
                    qualityHistory: [...currentVocabulary.qualityHistory, qualityScore],
                    timestamp: new Date().toISOString(),
                };

                // åˆ¤æ–­æ˜¯å¦å®Œæˆ
                if (updatedVocabulary.currentAttempts >= 3) {
                    updatedVocabulary.isCompleted = true;
                    updatedVocabulary.currentAttempts = 3;

                    // æ ‡è®°ä¸ºå·²æŒæ¡ï¼ˆæœ¬åœ°ï¼‰
                    get().markAsMastered(currentVocabulary.vocabularyId);

                    // æäº¤åˆ°åç«¯
                    const avgQuality = Math.round(
                        updatedVocabulary.qualityHistory.reduce((a, b) => a + b, 0) /
                        updatedVocabulary.qualityHistory.length
                    );

                    const endpoint = API_ENDPOINTS.MEMORY.SUBMIT_MEMORY_RESULT;
                    apiClient
                        .post(endpoint, {
                            userId: useUserStore.getState().currentUser?.userId,
                            vocabularyId: currentVocabulary.vocabularyId,
                            quality: avgQuality,
                        })
                        .then((result: any) => {
                            console.log('âœ… æäº¤ç»“æœæˆåŠŸ:', result);
                        })
                        .catch((err: any) => console.error('âŒ æäº¤å¤±è´¥:', err));
                }

                // æ›´æ–°é˜Ÿåˆ—
                const currentIndex = reviewQueue.findIndex(
                    (v) => v.vocabularyId === currentVocabulary.vocabularyId
                );
                const newQueue = [...reviewQueue];
                newQueue[currentIndex] = updatedVocabulary;

                set({ reviewQueue: newQueue });

                // è‡ªåŠ¨è·³è½¬
                get().moveToNext();
            },

            // ===== ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå•è¯ =====
            moveToNext: () => {
                const { reviewQueue } = get();
                const nextVocabulary = reviewQueue.find((v) => !v.isCompleted);

                if (nextVocabulary) {
                    set({ currentVocabulary: nextVocabulary });
                } else {
                    set({ phase: LearningPhase.COMPLETED });
                }
            },

            // ===== å®Œæˆä¼šè¯ =====
            finishSession: () => {
                set({ phase: LearningPhase.COMPLETED });
            },

            // ===== æ ‡è®°ä¸ºå·²æŒæ¡ =====
            markAsMastered: (vocabularyId: string) => {
                const { progress } = get();
                if (!progress.masteredIds.includes(vocabularyId)) {
                    const newMasteredIds = [...progress.masteredIds, vocabularyId];
                    set({
                        progress: {
                            ...progress,
                            masteredIds: newMasteredIds,
                            masteredCount: newMasteredIds.length,
                        },
                    });
                }
            },

            // ===== é‡ç½®è¿›åº¦ =====
            resetProgress: () => {
                set({ progress: defaultProgress });
            },
        }),
        {
            name: 'vocabulary-learning-storage',
            storage: createJSONStorage(() => AsyncStorage),
            // åªæŒä¹…åŒ–å…³é”®æ•°æ®
            partialize: (state) => ({
                progress: state.progress,
                currentCourseSource: state.currentCourseSource, // Persist current course
            }),
        }
    )
);
</file>

<file path="src/utils/apiClient.ts">
// src/utils/apiClient.ts

import {
  getApiBaseUrl,
  CURRENT_BACKEND,
  logBackendInfo,
} from '../config/backend.config';
import { getEndpoint, replacePathParams } from '../config/api.endpoints';
import type { EndpointMap } from '../config/api.endpoints';
import { API_TIMEOUT, ERROR_MESSAGES } from '../config/constants';
import type { ApiResponse } from '../entities/types/api.types';

interface RequestOptions {
  timeout?: number;
  headers?: Record<string, string>;
  pathParams?: Record<string, string>;  // è·¯å¾„å‚æ•°
}

// Cloud Function è°ƒç”¨å¯é€‰å‚æ•°
export interface CloudFunctionOptions {
  /**
   * äº‘å‡½æ•°çš„ HTTP è§¦å‘è·¯å¾„ï¼Œé»˜è®¤å€¼ä¸º '/learn-vocab'ã€‚
   * è‹¥é¡¹ç›®ä¸­å­˜åœ¨å…¶ä»–äº‘å‡½æ•°ï¼ˆå¦‚ '/memory-engine'ï¼‰ï¼Œè¯·åœ¨è°ƒç”¨æ—¶æ˜¾å¼ä¼ å…¥ã€‚
   */
  endpoint?: string | EndpointMap;
}

class ApiClient {
  private baseUrl: string;
  private authToken: string | null = null;

  constructor() {
    this.baseUrl = getApiBaseUrl();

    // æ‰“å°åç«¯ä¿¡æ¯ï¼ˆä»…å¼€å‘ç¯å¢ƒï¼‰
    logBackendInfo();
  }

  // ==================== Token ç®¡ç† ====================

  setAuthToken(token: string | null) {
    this.authToken = token;
    if (__DEV__) {
      console.log('ğŸ”‘ Token å·²è®¾ç½®:', token ? token.substring(0, 20) + '...' : 'null');
    }
  }

  getAuthToken(): string | null {
    return this.authToken;
  }

  // ==================== æ„å»ºå®Œæ•´ URL ====================

  private buildUrl(
    endpoint: string | EndpointMap,
    pathParams?: Record<string, string>
  ): string {
    let path: string;

    // å¦‚æœæ˜¯ç«¯ç‚¹æ˜ å°„å¯¹è±¡ï¼Œæ ¹æ®å½“å‰åç«¯é€‰æ‹©è·¯å¾„
    if (typeof endpoint === 'object') {
      path = getEndpoint(endpoint, CURRENT_BACKEND);
    } else {
      path = endpoint;
    }

    // æ›¿æ¢è·¯å¾„å‚æ•°ï¼ˆå¦‚ /api/courses/:idï¼‰
    if (pathParams) {
      path = replacePathParams(path, pathParams);
    }

    // æ‹¼æ¥å®Œæ•´ URL
    const fullUrl = `${this.baseUrl}${path}`;

    return fullUrl;
  }

  // ==================== é€šç”¨è¯·æ±‚æ–¹æ³• ====================

  private async request<T>(
    endpoint: string | EndpointMap,
    method: 'GET' | 'POST' | 'PUT' | 'DELETE',
    data?: any,
    options: RequestOptions = {}
  ): Promise<ApiResponse<T>> {
    const {
      timeout = API_TIMEOUT.DEFAULT,
      headers = {},
      pathParams,
    } = options;

    // æ„å»ºè¯·æ±‚å¤´
    const authToken = this.getAuthToken();
    const requestHeaders: Record<string, string> = {
      'Content-Type': 'application/json',
      ...headers,
    };

    // æ·»åŠ  Authorization å¤´
    if (authToken) {
      requestHeaders['Authorization'] = `Bearer ${authToken}`;
    }

    // æ„å»º URL
    const url = this.buildUrl(endpoint, pathParams);

    // è¶…æ—¶æ§åˆ¶
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
      if (__DEV__) {
        console.log(`ğŸ“¤ [${method}] ${url}`);
        if (data) console.log('ğŸ“¦ Request data:', data);
      }

      // å‘é€è¯·æ±‚
      const response = await fetch(url, {
        method,
        headers: requestHeaders,
        body: method !== 'GET' ? JSON.stringify(data) : undefined,
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (__DEV__) {
        console.log(`ğŸ“¥ Response status: ${response.status}`);
      }

      // è§£æå“åº”
      let responseData;
      try {
        responseData = await response.json();
      } catch (parseError) {
        console.error('âŒ è§£æå“åº”å¤±è´¥:', parseError);
        return {
          success: false,
          error: ERROR_MESSAGES.SERVER_ERROR,
          code: 'PARSE_ERROR',
        };
      }

      // æ£€æŸ¥ HTTP çŠ¶æ€ç 
      if (!response.ok) {
        // 401 Unauthorized - Token å¤±æ•ˆ
        if (response.status === 401) {
          return {
            success: false,
            error: responseData.error || ERROR_MESSAGES.TOKEN_EXPIRED,
            code: 'TOKEN_EXPIRED',
          };
        }

        // å…¶ä»–é”™è¯¯
        return {
          success: false,
          error: responseData.error || responseData.message || ERROR_MESSAGES.SERVER_ERROR,
          code: responseData.code || 'SERVER_ERROR',
        };
      }

      // è¿”å›æˆåŠŸå“åº”
      if (__DEV__) {
        console.log('âœ… Response data:', responseData);
      }

      return {
        success: true,
        data: responseData.data || responseData,
      };

    } catch (error: any) {
      clearTimeout(timeoutId);

      // è¶…æ—¶é”™è¯¯
      if (error.name === 'AbortError') {
        console.error('â±ï¸ è¯·æ±‚è¶…æ—¶');
        return {
          success: false,
          error: ERROR_MESSAGES.TIMEOUT_ERROR,
          code: 'TIMEOUT',
        };
      }

      // ç½‘ç»œé”™è¯¯
      if (!navigator.onLine) {
        console.error('ğŸ“¡ ç½‘ç»œæœªè¿æ¥');
        return {
          success: false,
          error: ERROR_MESSAGES.NETWORK_ERROR,
          code: 'NETWORK_ERROR',
        };
      }

      // å…¶ä»–é”™è¯¯
      console.error('âŒ è¯·æ±‚å¤±è´¥:', error);
      return {
        success: false,
        error: error.message || ERROR_MESSAGES.UNKNOWN_ERROR,
        code: 'UNKNOWN_ERROR',
      };
    }
  }

  // ==================== HTTP æ–¹æ³• ====================

  async get<T>(
    endpoint: string | EndpointMap,
    options?: RequestOptions
  ): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, 'GET', undefined, options);
  }

  async post<T>(
    endpoint: string | EndpointMap,
    data?: any,
    options?: RequestOptions
  ): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, 'POST', data, options);
  }

  async put<T>(
    endpoint: string | EndpointMap,
    data?: any,
    options?: RequestOptions
  ): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, 'PUT', data, options);
  }

  async delete<T>(
    endpoint: string | EndpointMap,
    options?: RequestOptions
  ): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, 'DELETE', undefined, options);
  }
}

// ==================== å¯¼å‡ºå•ä¾‹ ====================
export const apiClient = new ApiClient();

// ==================== Cloud Function é€‚é…å™¨ ====================

/**
 * é€šç”¨ CloudBase äº‘å‡½æ•°è°ƒç”¨å·¥å…·ï¼Œé€‚ç”¨äºæ‰€æœ‰åŸºäº `action` å‚æ•°çš„äº‘å‡½æ•°ã€‚
 *
 * è¯´æ˜ï¼ˆç»“åˆ V9 å¿«ç…§ï¼‰ï¼š
 * - å¯¹äºå¤š action äº‘å‡½æ•°ï¼ˆå¦‚ `/memory-engine`ã€`/learn-vocab`ï¼‰ï¼Œè¯·æ±‚ä½“ç»Ÿä¸€ä¸ºï¼š
 *   `{ action, data }`
 * - è¿”å›ç»“æ„ç»Ÿä¸€ä¸º `ApiResponse<T>`ï¼Œä¸ apiClient å…¶ä½™ HTTP è°ƒç”¨ä¿æŒä¸€è‡´ã€‚
 *
 * @param action   äº‘å‡½æ•°å†…éƒ¨ä¸šåŠ¡æ ‡è¯†ï¼Œä¾‹å¦‚ 'getTodayMemories'ã€'submitMemoryResult' ç­‰ã€‚
 * @param data     ä¸šåŠ¡è¯·æ±‚å‚æ•°å¯¹è±¡ï¼Œä¼šè¢«åŒ…è£…åœ¨ `{ action, data }` ä¸­å‘é€ã€‚
 * @param options  å¯é€‰é…ç½®ï¼Œå½“å‰æ”¯æŒè‡ªå®šä¹‰äº‘å‡½æ•°å…¥å£è·¯å¾„ï¼ˆé»˜è®¤ '/learn-vocab'ï¼‰ã€‚
 */
export async function callCloudFunction<T>(
  action: string,
  data: Record<string, any>,
  options?: CloudFunctionOptions
): Promise<ApiResponse<T>> {
  // é»˜è®¤ä½¿ç”¨ learn-vocab äº‘å‡½æ•°å…¥å£ï¼ˆä¸æ—§ cloudFunctionAdapter ä¿æŒå…¼å®¹ï¼‰
  const endpoint = options?.endpoint ?? '/learn-vocab';

  try {
    // ç»Ÿä¸€çš„è¯·æ±‚ä½“ç»“æ„ï¼š{ action, data }
    const response = await apiClient.post<T>(endpoint, {
      action,
      data,
    });

    // ç›´æ¥è¿”å›åç«¯çš„æ ‡å‡†ç»“æ„ï¼Œè°ƒç”¨æ–¹åªéœ€è¦åˆ¤æ–­ `success`
    return response;
  } catch (err: any) {
    // ç†è®ºä¸Š apiClient å·²ç»æ•è·å¤§éƒ¨åˆ†é”™è¯¯ï¼Œè¿™é‡Œæ˜¯å…œåº•é˜²æŠ¤
    console.error(`âŒ CloudFunction "${action}" è°ƒç”¨å¼‚å¸¸:`, err);

    return {
      success: false,
      error: err?.message ?? 'ç½‘ç»œè¯·æ±‚å¼‚å¸¸',
      code: err?.code ?? 'NETWORK_ERROR',
    };
  }
}
</file>

<file path="src/utils/lettersQuestionGenerator.ts">
// src/utils/lettersQuestionGenerator.ts

/**
 * Letters Question Generator
 *
 * å­—æ¯é¢˜ç›®ç”Ÿæˆå™¨ - Phase 2 é‡æ„ç‰ˆæœ¬
 * æŒ‰ç…§ alphabet-module-spec.md ç¬¬6ç« å’Œç»Ÿä¸€ Question Engine åè®®å®ç°
 *
 * å˜æ›´è¯´æ˜:
 * - ç§»é™¤äº† LETTER_NAME_TO_THAI å’Œ THAI_TO_LETTER_NAME é¢˜å‹
 * - ä½¿ç”¨æ–°çš„ AlphabetGameType æšä¸¾
 * - å‡½æ•°ç­¾åæ”¹ä¸º generateQuestion(queueItem, allLetters)
 * - æ·»åŠ  TONE_CALCULATION å’Œ PHONICS_MATH å ä½å®ç°
 */

import type { Letter } from '@/src/entities/types/letter.types';
import type {
  AlphabetQueueItem,
  AlphabetQuestion,
} from '@/src/entities/types/alphabet.types';
import { AlphabetGameType } from '@/src/entities/types/alphabetGameTypes';
import { generateLetterDistractors } from './lettersDistractorEngine';
import { getLetterAudioUrl } from './alphabet/audioHelper';

/**
 * ç”Ÿæˆå­—æ¯é¢˜ç›®
 *
 * @param queueItem - é˜Ÿåˆ—é¡¹,åŒ…å«ç›®æ ‡å­—æ¯å’Œé¢˜å‹ä¿¡æ¯
 * @param allLetters - æ‰€æœ‰å­—æ¯æ± ,ç”¨äºç”Ÿæˆå¹²æ‰°é¡¹
 * @returns ç”Ÿæˆçš„é¢˜ç›®å¯¹è±¡
 */
export function generateQuestion(
  queueItem: AlphabetQueueItem,
  allLetters: Letter[]
): AlphabetQuestion {
  const { letter, gameType } = queueItem;

  // ğŸ› P0-1 FIX: ç”Ÿæˆå¹²æ‰°é¡¹ (3ä¸ª) + é˜²å¾¡æ€§æ£€æŸ¥
  const distractorLetters =
    allLetters && allLetters.length > 1
      ? generateLetterDistractors({ pool: allLetters, correct: letter, count: 3 })
      : [];

  // ğŸ› P0-1 FIX: ç¡®ä¿æœ‰è¶³å¤Ÿçš„å¹²æ‰°é¡¹
  if (distractorLetters.length < 3) {
    console.warn('âš ï¸ å¹²æ‰°é¡¹ä¸è¶³ï¼', {
      expected: 3,
      actual: distractorLetters.length,
      poolSize: allLetters?.length || 0,
      letterId: letter._id,
      gameType
    });

    // å¦‚æœæ± å­å¤ªå°ï¼Œç”¨æ­£ç¡®å­—æ¯å¤åˆ¶å¡«å……ï¼ˆä¸´æ—¶æ–¹æ¡ˆï¼‰
    while (distractorLetters.length < 3) {
      distractorLetters.push({ ...letter, _id: `dummy-${distractorLetters.length}` });
    }
  }

  // æ ¹æ®é¢˜å‹ç”Ÿæˆé¢˜ç›®
  switch (gameType) {
    case AlphabetGameType.SOUND_TO_LETTER:
      return generateSoundToLetterQuestion(letter, distractorLetters);

    case AlphabetGameType.LETTER_TO_SOUND:
      return generateLetterToSoundQuestion(letter, distractorLetters);

    case AlphabetGameType.CONSONANT_CLASS:
      return generateConsonantClassQuestion(letter);

    case AlphabetGameType.INITIAL_SOUND:
      return generateInitialSoundQuestion(letter, distractorLetters);

    case AlphabetGameType.FINAL_SOUND:
      return generateFinalSoundQuestion(letter, distractorLetters);

    case AlphabetGameType.TONE_CALCULATION:
      return generateToneCalculationQuestion(letter);

    case AlphabetGameType.PHONICS_MATH:
      return generatePhonicsMathQuestion(letter);

    default:
      // STRICT MODE: Do not fallback to simple questions for unknown types.
      // If we get here, it means we requested a type that isn't handled.
      console.error('âŒ Unknown Game Type requested:', gameType);
      // We must return *something* to avoid crash, but let's log loudly.
      // Ideally this should trigger a "Content Error" state in UI.
      // For now, return a placeholder valid object but log error.
      // BUT for strict requirement: "ä¸å…è®¸ fallback ä¸ºç®€å•é¢˜". 
      // This implies if we asked for Unknown/Complex, we shouldn't get Simple.
      // But if the code asked for it, it's a bug in the engine.
      // The Engine asked for `CONSONANT_CLASS`, we are in case `CONSONANT_CLASS`.

      // If the case is handled, we are good.
      // The only risk is if `generateConsonantClassQuestion` fails?
      // It currently always returns a question (options are fixed).

      // So this default block is only for truly unknown enum values.
      throw new Error(`[Generator] Unsupported Game Type: ${gameType}`);
  }
}

// ===== å„é¢˜å‹çš„å…·ä½“å®ç° =====

/**
 * å¬éŸ³é€‰å­— - æ’­æ”¾å­—æ¯å‘éŸ³,é€‰æ‹©æ­£ç¡®çš„å­—æ¯
 */
function generateSoundToLetterQuestion(
  letter: Letter,
  distractors: Letter[]
): AlphabetQuestion {
  const options = shuffle([letter, ...distractors]);

  return {
    id: `sound-to-letter-${letter._id}-${Date.now()}`,
    gameType: AlphabetGameType.SOUND_TO_LETTER,
    targetLetter: letter,
    options,
    correctAnswer: letter.thaiChar,
    audioUrl: getLetterAudioUrl(letter, 'letter'),
  };
}

/**
 * çœ‹å­—é€‰éŸ³ - æ˜¾ç¤ºå­—æ¯,é€‰æ‹©æ­£ç¡®çš„å‘éŸ³
 */
function generateLetterToSoundQuestion(
  letter: Letter,
  distractors: Letter[]
): AlphabetQuestion {
  const options = shuffle([letter, ...distractors]);

  return {
    id: `letter-to-sound-${letter._id}-${Date.now()}`,
    gameType: AlphabetGameType.LETTER_TO_SOUND,
    targetLetter: letter,
    options,
    correctAnswer: letter.initialSound || letter.fullSoundUrl || letter._id,
    audioUrl: getLetterAudioUrl(letter, 'letter'),
  };
}

/**
 * è¾…éŸ³ç±»åˆ«åˆ¤æ–­ - åˆ¤æ–­å­—æ¯å±äºé«˜/ä¸­/ä½è¾…éŸ³
 */
function generateConsonantClassQuestion(letter: Letter): AlphabetQuestion {
  // å›ºå®šçš„ä¸‰ä¸ªé€‰é¡¹: é«˜è¾…éŸ³ã€ä¸­è¾…éŸ³ã€ä½è¾…éŸ³
  const classOptions: Letter[] = [
    { ...letter, thaiChar: 'é«˜è¾…éŸ³', class: 'high' } as Letter,
    { ...letter, thaiChar: 'ä¸­è¾…éŸ³', class: 'mid' } as Letter,
    { ...letter, thaiChar: 'ä½è¾…éŸ³', class: 'low' } as Letter,
  ];

  return {
    id: `consonant-class-${letter._id}-${Date.now()}`,
    gameType: AlphabetGameType.CONSONANT_CLASS,
    targetLetter: letter,
    options: classOptions,
    correctAnswer: mapClassToLabel(letter.class || 'low'),
    audioUrl: getLetterAudioUrl(letter, 'letter'),
  };
}

/**
 * é¦–éŸ³åˆ¤æ–­ - åˆ¤æ–­å­—æ¯çš„é¦–è¾…éŸ³å‘éŸ³
 */
function generateInitialSoundQuestion(
  letter: Letter,
  distractors: Letter[]
): AlphabetQuestion {
  const options = shuffle([letter, ...distractors]);

  return {
    id: `initial-sound-${letter._id}-${Date.now()}`,
    gameType: AlphabetGameType.INITIAL_SOUND,
    targetLetter: letter,
    options,
    correctAnswer: letter.initialSound,
    audioUrl: getLetterAudioUrl(letter, 'letter'),
  };
}

/**
 * å°¾éŸ³åˆ¤æ–­ - åˆ¤æ–­å­—æ¯ä½œä¸ºå°¾éŸ³æ—¶çš„å‘éŸ³
 */
function generateFinalSoundQuestion(
  letter: Letter,
  distractors: Letter[]
): AlphabetQuestion {
  const options = shuffle([letter, ...distractors]);

  return {
    id: `final-sound-${letter._id}-${Date.now()}`,
    gameType: AlphabetGameType.FINAL_SOUND,
    targetLetter: letter,
    options,
    correctAnswer: letter.finalSound || letter.initialSound,
    audioUrl: getLetterAudioUrl(letter, 'letter'),
  };
}

/**
 * å£°è°ƒè®¡ç®— - å ä½å®ç°
 *
 * TODO: åœ¨åç»­è¿­ä»£ä¸­å®ç°å®Œæ•´çš„å£°è°ƒè®¡ç®—é€»è¾‘
 * éœ€è¦è€ƒè™‘: è¾…éŸ³ç±»åˆ« + å…ƒéŸ³é•¿çŸ­ + å£°è°ƒç¬¦å· â†’ æœ€ç»ˆå£°è°ƒ
 */
function generateToneCalculationQuestion(letter: Letter): AlphabetQuestion {
  // å ä½å®ç°: è¿”å›ä¸€ä¸ªç®€å•çš„å›ºå®šé¢˜ç›®
  const placeholderOptions: Letter[] = [
    { ...letter, thaiChar: 'ç¬¬1å£°(å¹³å£°)' } as Letter,
    { ...letter, thaiChar: 'ç¬¬2å£°(ä½å£°)' } as Letter,
    { ...letter, thaiChar: 'ç¬¬3å£°(é™å£°)' } as Letter,
  ];

  return {
    id: `tone-calculation-${letter._id}-${Date.now()}`,
    gameType: AlphabetGameType.TONE_CALCULATION,
    targetLetter: letter,
    options: placeholderOptions,
    correctAnswer: 'ç¬¬1å£°(å¹³å£°)', // å ä½ç­”æ¡ˆ
    audioUrl: getLetterAudioUrl(letter, 'letter'),
  };
}

/**
 * æ‹¼è¯»æ•°å­¦ - å ä½å®ç°
 *
 * TODO: åœ¨åç»­è¿­ä»£ä¸­å®ç°å®Œæ•´çš„æ‹¼è¯»é€»è¾‘
 * éœ€è¦è€ƒè™‘: è¾…éŸ³ + å…ƒéŸ³çš„ç»„åˆå‘éŸ³
 */
function generatePhonicsMathQuestion(letter: Letter): AlphabetQuestion {
  // å ä½å®ç°: è¿”å›ä¸€ä¸ªç®€å•çš„æ‹¼è¯»é¢˜
  const syllable = `${letter.thaiChar}à¸²`; // è¾…éŸ³ + é•¿å…ƒéŸ³ à¸²
  const placeholderOptions: Letter[] = [
    { ...letter, thaiChar: syllable } as Letter,
    { ...letter, thaiChar: `${letter.thaiChar}à¸´` } as Letter,
    { ...letter, thaiChar: `${letter.thaiChar}à¸¸` } as Letter,
  ];

  return {
    id: `phonics-math-${letter._id}-${Date.now()}`,
    gameType: AlphabetGameType.PHONICS_MATH,
    targetLetter: letter,
    options: placeholderOptions,
    correctAnswer: syllable, // å ä½ç­”æ¡ˆ
    audioUrl: getLetterAudioUrl(letter, 'syllable'),
  };
}

// ===== è¾…åŠ©å‡½æ•° =====

/**
 * éšæœºæ‰“ä¹±æ•°ç»„
 */
function shuffle<T>(arr: T[]): T[] {
  return [...arr].sort(() => Math.random() - 0.5);
}

/**
 * å°†è¾…éŸ³ç±»åˆ«æ˜ å°„ä¸ºä¸­æ–‡æ ‡ç­¾
 */
function mapClassToLabel(cls: string): string {
  if (cls === 'mid') return 'ä¸­è¾…éŸ³';
  if (cls === 'high') return 'é«˜è¾…éŸ³';
  return 'ä½è¾…éŸ³';
}

// ===== å‘åå…¼å®¹çš„å¯¼å‡º =====

/**
 * @deprecated è¯·ä½¿ç”¨æ–°çš„ generateQuestion å‡½æ•°
 *
 * ä¸ºäº†å‘åå…¼å®¹,ä¿ç•™æ—§çš„å‡½æ•°ç­¾å
 * ä¼šåœ¨åç»­ç‰ˆæœ¬ä¸­ç§»é™¤
 */
export function generateAlphabetQuestion(
  letter: Letter,
  pool: Letter[],
  preferredType?: any // ä½¿ç”¨ any é¿å…å¯¼å…¥æ—§çš„ QuestionType
): any {
  // å°†æ—§çš„è°ƒç”¨è½¬æ¢ä¸ºæ–°çš„æ ¼å¼
  const queueItem: AlphabetQueueItem = {
    letterId: letter._id,
    gameType: AlphabetGameType.SOUND_TO_LETTER, // é»˜è®¤ä½¿ç”¨å¬éŸ³é€‰å­—
    letter,
  };

  return generateQuestion(queueItem, pool);
}
</file>

<file path="app/(tabs)/profile.tsx">
// app/(tabs)/profile.tsx
import React from 'react';
import { View, Text, Pressable, ScrollView, StyleSheet, Switch, Alert } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { useTranslation } from 'react-i18next';
import { Settings, Award, LogOut, ChevronRight } from 'lucide-react-native';
import Animated, { FadeInDown } from 'react-native-reanimated';
import { LanguageSwitcher } from '@/src/components/common/LanguageSwitcher';
import { useModuleAccessStore } from '@/src/stores/moduleAccessStore';
import { useUserStore } from '@/src/stores/userStore';
import { useLearningStore } from '@/src/stores/learningStore';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

export default function ProfileScreen() {
  const { t } = useTranslation();
  const router = useRouter();
  const { currentUser, logout } = useUserStore();
  const { progress } = useLearningStore();
  const { userProgress } = useModuleAccessStore();

  const [dailyReminder, setDailyReminder] = React.useState(true);

  const updateDailyLimit = (limit: number) => {
    // Update local store
    useModuleAccessStore.setState(state => ({
      userProgress: state.userProgress ? { ...state.userProgress, dailyLimit: limit } : null
    }));
    // In a real app, I should also call an API to save this setting specifically, 
    // but the requirement says "unless user clicks...". 
    // The backend getTodayMemories updates it if passed.
    // So if I update it here locally, the next time they learn, it will use this new limit?
    // No, getTodayMemories uses the stored limit if param is not passed.
    // If I want to persist this change *without* starting a session, I need an API.
    // However, for now, I will just update the local store so that when they go to Learning, 
    // the Learning screen picks up this new limit and sends it to initSession, which updates the backend.
  };

  const handleLogout = () => {
    Alert.alert(
      t('auth.logout'),
      'Are you sure you want to logout?',
      [
        { text: t('common.cancel'), style: 'cancel' },
        {
          text: t('common.confirm'),
          style: 'destructive',
          onPress: () => {
            logout();
            router.replace('/(auth)/login');
          },
        },
      ]
    );
  };

  const achievements = [
    {
      id: 'streak7',
      icon: 'ğŸ”¥',
      label: t('profile.achievementBadges.streak7'),
      unlocked: (progress?.streakDays || 0) >= 7,
    },
    {
      id: 'master',
      icon: 'ğŸ—£ï¸',
      label: t('profile.achievementBadges.master'),
      unlocked: false,
    },
    {
      id: 'vocab100',
      icon: 'ğŸ“š',
      label: t('profile.achievementBadges.vocab100'),
      unlocked: false,
    },
  ];

  return (
    <SafeAreaView edges={['top']} style={styles.safeArea}>
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        {/* Header */}
        <View style={styles.header}>
          <Text style={styles.headerTitle}>{t('profile.title')}</Text>
          <Pressable style={styles.settingsButton}>
            <Settings size={24} color={Colors.ink} />
          </Pressable>
        </View>

        {/* Profile Card */}
        <Animated.View entering={FadeInDown.delay(100).duration(500)} style={styles.profileCard}>
          <View style={styles.avatarContainer}>
            <View style={styles.avatar}>
              <Text style={styles.avatarText}>L</Text>
            </View>
          </View>
          <Text style={styles.displayName}>{currentUser?.displayName || 'Liang JianYu'}</Text>
          <Text style={styles.subtitle}>ä¿¡æ¯æŠ€æœ¯ Â· ç¡•å£«åœ¨è¯»</Text>
        </Animated.View>

        {/* Achievements Section */}
        <Animated.View entering={FadeInDown.delay(200).duration(500)} style={styles.section}>
          <View style={styles.sectionHeader}>
            <Award size={20} color={Colors.ink} />
            <Text style={styles.sectionTitle}>{t('profile.achievements')}</Text>
          </View>

          <View style={styles.achievementsContainer}>
            <View style={styles.achievementsGrid}>
              {achievements.map((achievement, index) => (
                <View
                  key={achievement.id}
                  style={[
                    styles.achievementBadge,
                    !achievement.unlocked && styles.achievementBadgeLocked,
                  ]}
                >
                  <View style={styles.achievementIcon}>
                    <Text style={styles.achievementEmoji}>{achievement.icon}</Text>
                  </View>
                  <Text style={styles.achievementLabel}>{achievement.label}</Text>
                </View>
              ))}
            </View>
          </View>
        </Animated.View>

        {/* Settings Section */}
        <Animated.View entering={FadeInDown.delay(300).duration(500)} style={styles.section}>
          <Text style={styles.sectionTitle}>{t('profile.settings')}</Text>

          <View style={styles.settingsCard}>
            {/* Daily Reminder */}
            <View style={styles.settingItem}>
              <Text style={styles.settingLabel}>{t('profile.dailyReminder')}</Text>
              <Switch
                value={dailyReminder}
                onValueChange={setDailyReminder}
                trackColor={{ false: Colors.sand, true: Colors.ink }}
                thumbColor={Colors.white}
              />
            </View>

            {/* Daily Learning Limit */}
            <View style={styles.divider} />
            <Pressable
              style={styles.settingItem}
              onPress={() => {
                // Simple selection for now
                Alert.alert(
                  t('profile.dailyLimit', 'æ¯æ—¥å­¦ä¹ æ•°é‡'),
                  t('profile.selectLimit', 'è¯·é€‰æ‹©æ¯æ—¥å­¦ä¹ æ•°é‡'),
                  [
                    { text: '10', onPress: () => updateDailyLimit(10) },
                    { text: '20', onPress: () => updateDailyLimit(20) },
                    { text: '50', onPress: () => updateDailyLimit(50) },
                    { text: t('common.cancel'), style: 'cancel' }
                  ]
                );
              }}
            >
              <Text style={styles.settingLabel}>{t('profile.dailyLimit', 'æ¯æ—¥å­¦ä¹ æ•°é‡')}</Text>
              <View style={styles.settingRight}>
                <Text style={styles.settingValue}>{userProgress?.dailyLimit || 20}</Text>
                <ChevronRight size={20} color={Colors.taupe} />
              </View>
            </Pressable>

            {/* TTS Engine */}
            <View style={styles.divider} />
            <Pressable style={styles.settingItem}>
              <Text style={styles.settingLabel}>{t('profile.ttsEngine')}</Text>
              <View style={styles.settingRight}>
                <Text style={styles.settingValue}>Tencent TTS</Text>
                <ChevronRight size={20} color={Colors.taupe} />
              </View>
            </Pressable>

            {/* Language Switcher */}
            <View style={styles.divider} />
            <View style={styles.languageSection}>
              <LanguageSwitcher variant="full" />
            </View>
          </View>
        </Animated.View>

        {/* Logout Button */}
        <Animated.View entering={FadeInDown.delay(400).duration(500)}>
          <Pressable style={styles.logoutButton} onPress={handleLogout}>
            <LogOut size={16} color="#DC2626" />
            <Text style={styles.logoutText}>{t('auth.logout')}</Text>
          </Pressable>
        </Animated.View>

        <View style={{ height: 40 }} />
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: Colors.paper,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    paddingBottom: 120,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 24,
    paddingTop: 16,
    paddingBottom: 24,
  },
  headerTitle: {
    fontFamily: Typography.playfairBold,
    fontSize: 28,
    fontWeight: '700',
    color: Colors.ink,
  },
  settingsButton: {
    width: 40,
    height: 40,
    alignItems: 'center',
    justifyContent: 'center',
  },
  profileCard: {
    alignItems: 'center',
    paddingVertical: 24,
    marginHorizontal: 24,
    marginBottom: 32,
  },
  avatarContainer: {
    marginBottom: 16,
  },
  avatar: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: Colors.sand,
    alignItems: 'center',
    justifyContent: 'center',
  },
  avatarText: {
    fontFamily: Typography.playfairBold,
    fontSize: 36,
    fontWeight: '700',
    color: Colors.ink,
  },
  displayName: {
    fontFamily: Typography.playfairRegular,
    fontSize: 24,
    color: Colors.ink,
    marginBottom: 4,
  },
  subtitle: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  section: {
    marginHorizontal: 24,
    marginBottom: 32,
  },
  sectionHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    marginBottom: 16,
  },
  sectionTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 18,
    fontWeight: '700',
    color: Colors.ink,
  },
  achievementsContainer: {
    backgroundColor: Colors.white,
    borderRadius: 24,
    borderWidth: 1,
    borderColor: Colors.sand,
    padding: 24,
  },
  achievementsGrid: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  achievementBadge: {
    alignItems: 'center',
    opacity: 1,
  },
  achievementBadgeLocked: {
    opacity: 0.5,
  },
  achievementIcon: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: Colors.paper,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 8,
  },
  achievementEmoji: {
    fontSize: 24,
  },
  achievementLabel: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 12,
    fontWeight: '600',
    color: Colors.ink,
    textAlign: 'center',
  },
  settingsCard: {
    backgroundColor: Colors.white,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: Colors.sand,
    padding: 16,
  },
  settingItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 12,
  },
  settingLabel: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.ink,
  },
  settingRight: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  settingValue: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  divider: {
    height: 1,
    backgroundColor: 'rgba(229, 226, 219, 0.5)',
    marginVertical: 4,
  },
  languageSection: {
    paddingTop: 16,
  },
  logoutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    marginHorizontal: 24,
    paddingVertical: 16,
    borderRadius: 16,
    backgroundColor: Colors.white,
    borderWidth: 1,
    borderColor: '#FEE2E2',
  },
  logoutText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    fontWeight: '500',
    color: '#DC2626',
  },
});
</file>

<file path="app/alphabet/test.tsx">
import React, { use, useEffect, useState } from 'react';
import { View, Text, ScrollView, Pressable, ActivityIndicator, StyleSheet, Alert } from 'react-native';
import { useRouter } from 'expo-router';
import { SafeAreaView } from 'react-native-safe-area-context';
import { callCloudFunction } from '@/src/utils/apiClient';
import { useModuleAccessStore } from '@/src/stores/moduleAccessStore';
import { useUserStore } from '@/src/stores/userStore';
import { API_ENDPOINTS } from '@/src/config/api.endpoints';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { useTranslation } from 'react-i18next';
import { generateQuestion } from '@/src/utils/lettersQuestionGenerator';
import { AlphabetGameType } from '@/src/entities/types/alphabetGameTypes';
import { Letter } from '@/src/entities/types/letter.types';
import { AlphabetQuestion } from '@/src/entities/types/alphabet.types';
import { Audio } from 'expo-av';
import { TextStyle } from 'react-native';
import { getLetterAudioUrl } from '@/src/utils/alphabet/audioHelper';
import * as FileSystem from 'expo-file-system/legacy';


// ------------------------------------------------------------------
// Types
// ------------------------------------------------------------------


interface UserAnswer {
    questionId: string;
    answer: string;
}

interface TestResponse {
    questions: AlphabetQuestion[];
}

interface SubmitResponse {
    passed: boolean;
    score?: number;
}

// ------------------------------------------------------------------
// Pure Helper: Test Generator
// ------------------------------------------------------------------

/**
 * çº¯å‡½æ•°ï¼šæ ¹æ®å­—æ¯æ± ç”Ÿæˆ 20 é“æµ‹è¯•é¢˜
 * 
 * é€»è¾‘ï¼š
 * 1. æ‰“ä¹±å­—æ¯æ± 
 * 2. ç¡®ä¿å‡‘å¤Ÿ 20 ä¸ªé¢˜ç›®æº (ä¸è¶³åˆ™å¾ªç¯è¡¥å……)
 * 3. è½¬æ¢ä¸º UI å±•ç¤ºç”¨çš„ TestQuestion æ ¼å¼
 */

export function generateTestQuestions(allLetters: Letter[]): AlphabetQuestion[] {
    // é˜²å¾¡æ€§ç¼–ç¨‹ï¼šå¦‚æœæ²¡æœ‰å­—æ¯æˆ–å…¶ä»–å¼‚å¸¸ï¼Œè¿”å›ç©ºæ•°ç»„
    if (!allLetters || allLetters.length === 0) return [];
    // TODO 1: åˆ›å»ºå‰¯æœ¬å¹¶æ´—ç‰Œ (Shuffle)
    const pool = [...allLetters].sort(() => Math.random() - 0.5);
    // TODO 2: æˆªå–æˆ–å¾ªç¯è¡¥é½åˆ° 20 ä¸ª (Target Letters)
    const TARGET_COUNT = 20;
    const targetLetters: Letter[] = [];
    let i = 0;
    while (targetLetters.length < TARGET_COUNT) {
        // å–æ¨¡è¿ç®—ï¼šå³ä½¿ i è¶…è¿‡ pool.lengthï¼Œä¹Ÿèƒ½å¾ªç¯å›åˆ°å¼€å¤´å–å€¼
        targetLetters.push(pool[i % pool.length]);
        i++;
    }
    // TODO 3: Generate Questions & Map to UI Model
    return targetLetters.map((letter, index) => {
        const queueItem = {
            letter,
            letterId: letter._id,
            gameType: Math.random() > 0.5
                ? AlphabetGameType.SOUND_TO_LETTER
                : AlphabetGameType.LETTER_TO_SOUND
        }
        // æç¤ºï¼šè°ƒç”¨ generateQuestion(queueItem, allLetters)
        const algoQuestion = generateQuestion(queueItem, allLetters);

        return {
            ...algoQuestion,
            id: `${algoQuestion.id}-${index}`
        };
    }
    )
}

// ------------------------------------------------------------------
// Component: Alphabet Test Page
// ------------------------------------------------------------------
export default function AlphabetTestScreen() {
    const router = useRouter();
    const { t } = useTranslation();

    // State
    const [loading, setLoading] = useState(true);
    const [submitting, setSubmitting] = useState(false);
    const [questions, setQuestions] = useState<AlphabetQuestion[]>([]);
    const [answers, setAnswers] = useState<Record<string, string>>({});
    const [sound, setSound] = useState<Audio.Sound | null>(null);

    // ç®€åŒ–çš„éŸ³é¢‘æ’­æ”¾ï¼ˆå‚è€ƒ AlphabetReviewViewï¼‰
    const playAudio = async (audioUrl: string) => {
        try {
            // åœæ­¢å¹¶å¸è½½ä¹‹å‰çš„éŸ³é¢‘
            if (sound) {
                try {
                    await sound.stopAsync();
                    await sound.unloadAsync();
                } catch (e) {
                    // å¿½ç•¥æ¸…ç†é”™è¯¯
                }
            }

            // ç›´æ¥åŠ è½½å¹¶æ’­æ”¾
            const { sound: newSound } = await Audio.Sound.createAsync(
                { uri: audioUrl },
                { shouldPlay: true }
            );

            setSound(newSound);
        } catch (error) {
            console.error('Failed to play audio:', error);
        }
    };

    //æ¸…ç†éŸ³é¢‘
    useEffect(() => {
        return () => {
            if (sound) {
                sound.unloadAsync();
            }
        };
    }, [sound]);

    // ğŸµ åå°éŸ³é¢‘é¢„ä¸‹è½½ï¼ˆå‚è€ƒ alphabetStoreï¼‰
    const toHttpUrl = (path?: string | null): string => {
        if (!path) return '';
        if (path.startsWith('http://') || path.startsWith('https://')) {
            return path;
        }
        let finalPath = path;
        if (!/\.mp3($|\?)/.test(finalPath)) {
            finalPath = `${finalPath}.mp3`;
        }
        return `https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/${finalPath}`;
    };

    const predownloadAudio = async (letters: Letter[]) => {
        try {
            const cacheDir = `${FileSystem.cacheDirectory}alphabet-audio/`;
            const dirInfo = await FileSystem.getInfoAsync(cacheDir);
            if (!dirInfo.exists) {
                await FileSystem.makeDirectoryAsync(cacheDir, { intermediates: true });
            }

            const updatedLetters = new Map<string, Letter>();

            for (const letter of letters) {
                const updatedLetter = { ...letter };

                // ä¸‹è½½æ‰€æœ‰éŸ³é¢‘å­—æ®µ
                const fields: Array<{ key: keyof Letter; localKey: keyof Letter }> = [
                    { key: 'fullSoundUrl', localKey: 'fullSoundLocalPath' },
                    { key: 'syllableSoundUrl', localKey: 'syllableSoundLocalPath' },
                    { key: 'letterPronunciationUrl', localKey: 'letterPronunciationLocalPath' },
                ];

                for (const field of fields) {
                    const url = letter[field.key] as string | undefined;
                    if (!url) continue;

                    const httpUrl = toHttpUrl(url);
                    if (!httpUrl) continue;

                    const fileName = encodeURIComponent(httpUrl);
                    const localPath = `${cacheDir}${fileName}`;

                    try {
                        const info = await FileSystem.getInfoAsync(localPath);
                        if (!info.exists) {
                            await FileSystem.downloadAsync(httpUrl, localPath);
                        }
                        (updatedLetter as any)[field.localKey] = localPath;
                    } catch (err) {
                        console.warn(`Failed to download ${httpUrl}:`, err);
                    }
                }

                updatedLetters.set(letter._id, updatedLetter);
            }

            // æ›´æ–° questions ä¸­çš„ Letter å¯¹è±¡
            setQuestions(prevQuestions =>
                prevQuestions.map(q => ({
                    ...q,
                    targetLetter: updatedLetters.get(q.targetLetter._id) || q.targetLetter,
                    options: q.options?.map(opt =>
                        updatedLetters.get(opt._id) || opt
                    )
                }))
            );

            console.log('âœ… Audio predownload completed');
        } catch (error) {
            console.error('Failed to predownload audio:', error);
        }
    };

    // 1ï¸âƒ£ Fetch Test Data on Mount
    useEffect(() => {
        fetchTest();
    }, []);

    const fetchTest = async () => {
        try {
            setLoading(true);
            // ğŸ†• è°ƒç”¨æ–°çš„ getAllLetters æ¥å£è·å–å­—æ¯æ± 
            const result = await callCloudFunction<{ letters: Letter[] }>(
                'getAllLetters',
                {},
                { endpoint: API_ENDPOINTS.ALPHABET.GET_TEST }
            );

            if (result.success && result.data?.letters) {
                // ğŸ†• ä½¿ç”¨ç”Ÿæˆå™¨å‡½æ•°åœ¨å‰ç«¯ç”Ÿæˆ 20 é“é¢˜
                const generatedQuestions = generateTestQuestions(result.data.letters);
                setQuestions(generatedQuestions);

                // ğŸµ åå°å¼‚æ­¥ä¸‹è½½éŸ³é¢‘ï¼ˆä¸é˜»å¡é¡µé¢æ˜¾ç¤ºï¼‰
                (async () => {
                    if (result.data?.letters) {
                        await predownloadAudio(result.data.letters);
                    }
                })();
            } else {
                Alert.alert('Error', 'Failed to load letters.');
            }
        } catch (error) {
            console.error('Fetch test error:', error);
            Alert.alert('Error', 'An error occurred while loading the test.');
        } finally {
            setLoading(false);
        }
    };

    // 2ï¸âƒ£ Handle Answer Selection
    const selectAnswer = (questionId: string, option: string) => {
        setAnswers(prev => ({
            ...prev,
            [questionId]: option
        }));
    };

    // 3ï¸âƒ£ Submit Test
    const handleSubmit = async () => {
        // Basic Validation
        if (Object.keys(answers).length < questions.length) {
            Alert.alert('Incomplete', 'Please answer all questions before submitting.');
            return;
        }

        try {
            setSubmitting(true);

            // ğŸ› è°ƒè¯•ï¼šæ‰“å°æ‰€æœ‰ç­”æ¡ˆå’Œæ­£ç¡®ç­”æ¡ˆ
            console.log('=== åˆ¤åˆ†è°ƒè¯• ===');
            questions.forEach((q, idx) => {
                const userAnswer = answers[q.id];
                // LETTER_TO_SOUND: æ¯”è¾ƒ option._id ä¸ targetLetter._id
                const correctAnswer = q.gameType === AlphabetGameType.LETTER_TO_SOUND
                    ? q.targetLetter._id
                    : q.correctAnswer;
                const isCorrect = userAnswer === correctAnswer;
                console.log(`Q${idx + 1} [${q.gameType}]:`, {
                    userAnswer,
                    correctAnswer,
                    isCorrect,
                    targetLetter: q.targetLetter.thaiChar
                });
            });

            // æœ¬åœ°åˆ¤åˆ†
            const correctCount = questions.filter(q => {
                const userAnswer = answers[q.id];
                // LETTER_TO_SOUND: æ¯”è¾ƒ option._id ä¸ targetLetter._id
                if (q.gameType === AlphabetGameType.LETTER_TO_SOUND) {
                    return userAnswer === q.targetLetter._id;
                }
                // SOUND_TO_LETTER: æ¯”è¾ƒ thaiChar ä¸ correctAnswer
                return userAnswer === q.correctAnswer;
            }).length;
            const passed = correctCount >= 17;

            console.log(`åˆ¤åˆ†ç»“æœï¼š ${correctCount}/20, é€šè¿‡ï¼š ${passed}`);
            //å¦‚æœæ²¡é€šè¿‡ï¼Œç›´æ¥æç¤ºå¤±è´¥ï¼Œä¸è°ƒç”¨åç«¯
            if (!passed) {
                Alert.alert(
                    'Test Failed',
                    `You got ${correctCount}/20 correct. You need at least 17 to pass.`,
                    [{ text: 'Try again' }]
                )
                setSubmitting(false);
                return;     //æå‰è¿”å›ï¼Œä¸æ‰§è¡Œåç»­ç½‘ç»œè¯·æ±‚
            }

            // è°ƒç”¨åç«¯äº‘å‡½æ•°ï¼šæäº¤ç­”æ¡ˆ
            const userId = useUserStore.getState().currentUser?.userId;

            if (!userId) {
                Alert.alert('Error', 'User not logged in');
                setSubmitting(false);
                return;
            }

            const result = await callCloudFunction<SubmitResponse>(
                'submitLetterTest',
                { userId, passed: true },
                { endpoint: API_ENDPOINTS.ALPHABET.SUBMIT_TEST }
            );

            if (result.success) {
                // ğŸ‰ Test Passed
                Alert.alert(
                    'Congratulations!',
                    'You have passed the test. All modules are now unlocked.',
                    [{
                        text: 'Got it',
                        onPress: async () => {
                            await useModuleAccessStore.getState().getUserProgress();
                            router.replace('/courses');
                        }
                    }]
                )

            } else {
                Alert.alert('Error', result.error || 'Submission failed.');
            }
        } catch (error) {
            console.error('Submit test error:', error);
            Alert.alert('Error', 'An error occurred while submitting the test.');
        } finally {
            setSubmitting(false);
        }
    };

    // ------------------------------------------------------------------
    // Render
    // ------------------------------------------------------------------
    if (loading) {
        return (
            <View style={styles.centerContainer}>
                <ActivityIndicator size="large" color={Colors.thaiGold} />
                <Text style={styles.loadingText}>Loading Test...</Text>
            </View>
        );
    }

    return (
        <SafeAreaView edges={['top', 'bottom']} style={styles.container}>
            <ThaiPatternBackground opacity={0.1} />

            {/* Header */}
            <View style={styles.header}>
                <Text style={styles.title}>Alphabet Test</Text>
                <Text style={styles.subtitle}>Pass this test to unlock all courses immediately.</Text>
            </View>

            {/* Questions List */}
            <ScrollView style={styles.scrollView} contentContainerStyle={styles.scrollContent}>
                {questions.map((q, index) => (
                    <View key={q.id} style={styles.questionCard}>
                        {/* é¢˜å· */}
                        <Text style={styles.questionNumber}>Question {index + 1}/20</Text>
                        {/* ğŸ†• æ ¹æ®é¢˜å‹æ˜¾ç¤ºä¸åŒå†…å®¹ */}
                        {q.gameType === AlphabetGameType.SOUND_TO_LETTER ? (
                            // å¬éŸ³é€‰å­—ï¼šæ˜¾ç¤ºæ’­æ”¾æŒ‰é’®
                            <View style={styles.audioQuestionContainer}>
                                <Text style={styles.questionText}>
                                    Which letter matches this sound?
                                </Text>
                                <Pressable
                                    style={styles.playButton}
                                    onPress={() => {
                                        const audioUrl = getLetterAudioUrl(q.targetLetter, 'letter');
                                        if (audioUrl) {
                                            playAudio(audioUrl);
                                        }
                                    }}
                                >
                                    <Text style={styles.playButtonText}>ğŸ”Š Play Sound</Text>
                                </Pressable>
                            </View>
                        ) : (
                            // çœ‹å­—é€‰éŸ³ï¼šæ˜¾ç¤ºæ³°æ–‡å­—æ¯
                            <View style={styles.letterQuestionContainer}>
                                <Text style={styles.questionText}>
                                    Which sound matches this letter?
                                </Text>
                                <Text style={styles.targetLetter}>
                                    {q.targetLetter.thaiChar}
                                </Text>
                            </View>
                        )}
                        {/* ğŸ†• é€‰é¡¹æ¸²æŸ“ */}
                        <View style={styles.optionsContainer}>
                            {q.options?.map((option, optIndex) => {
                                // ğŸ› ä¿®å¤ï¼šä½¿ç”¨å”¯ä¸€æ ‡è¯†ç¬¦é¿å…å¤šé€‰
                                // LETTER_TO_SOUND: ä½¿ç”¨ option._idï¼ˆå”¯ä¸€ï¼‰
                                // SOUND_TO_LETTER: ä½¿ç”¨ option.thaiChar
                                const comparisonValue = q.gameType === AlphabetGameType.LETTER_TO_SOUND
                                    ? option._id
                                    : option.thaiChar;
                                const isSelected = answers[q.id] === comparisonValue;

                                // SOUND_TO_LETTER: æ˜¾ç¤ºæ³°æ–‡å­—ç¬¦
                                if (q.gameType === AlphabetGameType.SOUND_TO_LETTER) {
                                    return (
                                        <Pressable
                                            key={option._id}
                                            style={[styles.optionButton, isSelected && styles.optionSelected]}
                                            onPress={() => selectAnswer(q.id, option.thaiChar)}
                                        >
                                            <View style={[styles.radioCircle, isSelected && styles.radioSelected]} />
                                            <Text style={[styles.optionText, isSelected && styles.optionTextSelected]}>
                                                {option.thaiChar}
                                            </Text>
                                        </Pressable>
                                    );
                                }

                                // LETTER_TO_SOUND: æ˜¾ç¤ºæ’­æ”¾æŒ‰é’®
                                return (
                                    <Pressable
                                        key={option._id}
                                        style={[styles.audioOptionButton, isSelected && styles.audioOptionSelected]}
                                        onPress={() => {
                                            // ä½¿ç”¨ audioHelper è·å–æ­£ç¡®çš„éŸ³é¢‘è·¯å¾„
                                            const audioUrl = getLetterAudioUrl(option, 'letter');

                                            // æ’­æ”¾éŸ³é¢‘
                                            if (audioUrl) {
                                                playAudio(audioUrl);
                                            }

                                            // ğŸ› ä¿®å¤ï¼šä½¿ç”¨å”¯ä¸€çš„ option._id é¿å…å¤šé€‰
                                            selectAnswer(q.id, option._id);
                                        }}
                                    >
                                        <View style={[styles.radioCircle, isSelected && styles.radioSelected]} />
                                        <View style={styles.audioOptionContent}>
                                            <Text style={styles.audioOptionLabel}>é€‰é¡¹ {optIndex + 1}</Text>
                                            <Text style={styles.audioOptionIcon}>ğŸ”Š</Text>
                                        </View>
                                    </Pressable>
                                );
                            })}
                        </View>
                    </View>
                ))}

                {/* Submit Button */}
                <Pressable
                    style={[
                        styles.submitButton,
                        (submitting || Object.keys(answers).length < questions.length) && styles.submitDisabled
                    ]}
                    onPress={handleSubmit}
                    disabled={submitting}
                >
                    {submitting ? (
                        <ActivityIndicator color={Colors.white} />
                    ) : (
                        <Text style={styles.submitButtonText}>Submit Test</Text>
                    )}
                </Pressable>
            </ScrollView>
        </SafeAreaView>
    );
}

// ------------------------------------------------------------------
// Styles
// ------------------------------------------------------------------
const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: Colors.paper,
    },
    centerContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: Colors.paper,
    },
    loadingText: {
        marginTop: 12,
        fontFamily: Typography.notoSerifRegular,
        color: Colors.taupe,
    },
    header: {
        padding: 24,
        backgroundColor: Colors.white,
        borderBottomWidth: 1,
        borderBottomColor: Colors.sand,
    },
    title: {
        fontFamily: Typography.playfairBold,
        fontSize: 24,
        color: Colors.ink,
        marginBottom: 8,
    },
    subtitle: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.taupe,
    },
    scrollView: {
        flex: 1,
    },
    scrollContent: {
        padding: 24,
        gap: 24,
    },
    audioQuestionContainer: {
        alignItems: 'center',
        marginBottom: 16,
    },
    letterQuestionContainer: {
        alignItems: 'center',
        marginBottom: 16,
    },
    targetLetter: {
        fontSize: 48,
        fontFamily: Typography.notoSerifBold,
        color: Colors.ink,
        marginTop: 12,
    },
    playButton: {
        backgroundColor: Colors.thaiGold,
        paddingVertical: 12,
        paddingHorizontal: 24,
        borderRadius: 8,
        marginTop: 12,
    },
    playButtonText: {
        fontSize: 16,
        fontFamily: Typography.notoSerifBold,
        color: Colors.white,
    },
    questionNumber: {
        fontSize: 12,
        fontFamily: Typography.notoSerifRegular,
        color: Colors.taupe,
        marginBottom: 8,
    },
    audioOptionButton: {
        flexDirection: 'row',
        alignItems: 'center',
        padding: 12,
        borderRadius: 8,
        borderWidth: 1,
        borderColor: '#E0E0E0',
        backgroundColor: '#FAFAFA',
    },
    audioOptionSelected: {
        borderColor: Colors.thaiGold,
        backgroundColor: '#FFF9E6',
    },
    audioOptionContent: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        flex: 1,
    },
    audioOptionLabel: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.ink,
    },
    audioOptionIcon: {
        fontSize: 20,
    },
    questionCard: {
        backgroundColor: Colors.white,
        borderRadius: 16,
        padding: 16,
        borderWidth: 1,
        borderColor: Colors.sand,
    },
    questionText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.ink,
        marginBottom: 16,
    },
    optionsContainer: {
        gap: 12,
    },
    optionButton: {
        flexDirection: 'row',
        alignItems: 'center',
        padding: 12,
        borderRadius: 8,
        borderWidth: 1,
        borderColor: '#E0E0E0',
        backgroundColor: '#FAFAFA',
    },
    optionSelected: {
        borderColor: Colors.thaiGold,
        backgroundColor: '#FFF9E6', // Light gold bg
    },
    radioCircle: {
        width: 20,
        height: 20,
        borderRadius: 10,
        borderWidth: 2,
        borderColor: Colors.taupe,
        marginRight: 12,
    },
    radioSelected: {
        borderColor: Colors.thaiGold,
        backgroundColor: Colors.thaiGold,
    },
    optionText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.ink,
    },
    optionTextSelected: {
        color: Colors.ink, // Keep ink for readability, or change if needed
        fontWeight: '600',
    },
    submitButton: {
        backgroundColor: Colors.ink,
        paddingVertical: 16,
        borderRadius: 12,
        alignItems: 'center',
        justifyContent: 'center',
        marginTop: 12,
        marginBottom: 48,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.1,
        shadowRadius: 8,
        elevation: 4,
    },
    submitDisabled: {
        backgroundColor: '#A0A0A0',
        shadowOpacity: 0,
        elevation: 0,
    },
    submitButtonText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.white,
        letterSpacing: 1,
    },
});
</file>

<file path="cloudbase/functions/learn-vocab/handlers/getReviewStatistics.js">
/**
 * è·å–å¤ä¹ ç»Ÿè®¡å¤„ç†å™¨
 * 
 * è¿”å›ç”¨æˆ·çš„å­¦ä¹ è¿›åº¦ç»Ÿè®¡æ•°æ®
 * 
 * @action getReviewStatistics
 */

'use strict';

const { createResponse } = require('../utils/response');
const {
  MasteryLevel,
  EARLY_INTERVALS,
  DAILY_LEARNING_CONFIG
} = require('../utils/constants');

/**
 * è®¡ç®—è¿ç»­å­¦ä¹ å¤©æ•°
 */
async function calculateStreak(db, userId) {
  const recentProgress = await db.collection('user_vocabulary_progress')
    .where({ userId })
    .orderBy('lastReviewed', 'desc')
    .limit(100)
    .get();

  if (!recentProgress.data || recentProgress.data.length === 0) {
    return 0;
  }

  const reviewDates = new Set();
  recentProgress.data.forEach(p => {
    if (p.lastReviewed) {
      const dateStr = new Date(p.lastReviewed).toISOString().split('T')[0];
      reviewDates.add(dateStr);
    }
  });

  let streak = 0;
  const checkDate = new Date();

  for (let i = 0; i < 365; i++) {
    const dateStr = checkDate.toISOString().split('T')[0];
    if (reviewDates.has(dateStr)) {
      streak++;
      checkDate.setDate(checkDate.getDate() - 1);
    } else if (i === 0) {
      checkDate.setDate(checkDate.getDate() - 1);
    } else {
      break;
    }
  }

  return streak;
}

/**
 * è·å–å¤ä¹ è¿›åº¦ç»Ÿè®¡
 */
async function getReviewStatistics(db, params) {
  const { userId } = params;

  if (!userId) {
    return createResponse(false, null, 'ç¼ºå°‘ç”¨æˆ·ID', 'INVALID_PARAMS');
  }

  try {
    // éªŒè¯ç”¨æˆ·
    const userResult = await db.collection('users')
      .where({ userId })
      .get();

    if (!userResult.data || userResult.data.length === 0) {
      return createResponse(false, null, 'ç”¨æˆ·ä¸å­˜åœ¨', 'USER_NOT_FOUND');
    }

    const now = new Date();
    const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const endOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);

    // è·å–ç”¨æˆ·æ‰€æœ‰è¿›åº¦è®°å½•
    const allProgress = await db.collection('user_vocabulary_progress')
      .where({ userId })
      .get();

    // ç»Ÿè®¡åˆ†æ
    let todayReviewedCount = 0;
    let totalLearned = 0;
    let skippedCount = 0;
    const masteryDistribution = {
      [MasteryLevel.UNFAMILIAR]: 0,
      [MasteryLevel.FUZZY]: 0,
      [MasteryLevel.REMEMBERED]: 0,
    };

    const dueForReviewNow = [];

    (allProgress.data || []).forEach(progress => {
      if (progress.lastReviewed &&
        new Date(progress.lastReviewed) >= startOfDay &&
        new Date(progress.lastReviewed) < endOfDay) {
        todayReviewedCount++;
      }

      if (progress.skipped) {
        skippedCount++;
        return;
      }

      if (progress.mastery && masteryDistribution.hasOwnProperty(progress.mastery)) {
        masteryDistribution[progress.mastery]++;
        totalLearned++;
      }

      if (progress.nextReviewDate && new Date(progress.nextReviewDate) <= now) {
        dueForReviewNow.push(progress);
      }
    });

    // è·å–è¯æ±‡æ€»æ•°
    const totalVocabResult = await db.collection('vocabulary').count();
    const totalVocabulary = totalVocabResult.total || 0;

    // è®¡ç®—æŒæ¡ç‡
    const masteryRate = totalLearned > 0
      ? ((masteryDistribution[MasteryLevel.REMEMBERED] / totalLearned) * 100).toFixed(1)
      : 0;

    // è·å–ä¸‹ä¸€ä¸ªå»ºè®®å¤ä¹ çš„å•è¯
    let nextRecommendedWord = null;
    if (dueForReviewNow.length > 0) {
      const priorityOrder = {
        [MasteryLevel.UNFAMILIAR]: 0,
        [MasteryLevel.FUZZY]: 1,
        [MasteryLevel.REMEMBERED]: 2,
      };

      dueForReviewNow.sort((a, b) => {
        return (priorityOrder[a.mastery] ?? 3) - (priorityOrder[b.mastery] ?? 3);
      });

      const nextProgress = dueForReviewNow[0];
      const vocabResult = await db.collection('vocabulary')
        .where({ _id: nextProgress.vocabularyId })
        .limit(1)
        .get();

      if (vocabResult.data && vocabResult.data.length > 0) {
        const vocab = vocabResult.data[0];
        nextRecommendedWord = {
          vocabularyId: vocab._id,
          thaiWord: vocab.thaiWord,
          meaning: vocab.meaning,
          mastery: nextProgress.mastery,
          lastReviewed: nextProgress.lastReviewed,
          reviewCount: nextProgress.reviewCount,
        };
      }
    }

    // è®¡ç®—è¿ç»­å­¦ä¹ å¤©æ•°
    const streakDays = await calculateStreak(db, userId);

    // è®¡ç®—å¹³å‡å¤ä¹ æ¬¡æ•°
    const avgReviewCount = totalLearned > 0
      ? ((allProgress.data || []).reduce((sum, p) => sum + (p.reviewCount || 0), 0) / totalLearned).toFixed(1)
      : 0;

    return createResponse(true, {
      today: {
        reviewed: todayReviewedCount,
        remaining: dueForReviewNow.length,
        target: DAILY_LEARNING_CONFIG.TOTAL_WORDS_LIMIT,
      },
      overall: {
        totalLearned,
        totalVocabulary,
        progressPercentage: totalVocabulary > 0 ? ((totalLearned / totalVocabulary) * 100).toFixed(1) : 0,
        skipped: skippedCount,
        avgReviewCount: parseFloat(avgReviewCount),
      },
      masteryDistribution,
      masteryRate: parseFloat(masteryRate),
      nextRecommendedWord,
      streakDays,
    }, 'è·å–ç»Ÿè®¡æ•°æ®æˆåŠŸ');

  } catch (error) {
    console.error('getReviewStatistics error:', error);
    return createResponse(false, null, error.message, 'SERVER_ERROR');
  }
}

module.exports = getReviewStatistics;
</file>

<file path="cloudbase/functions/learn-vocab/handlers/getSkippedWords.js">
/**
 * è·å–å·²åˆ’æ‰å•è¯å¤„ç†å™¨
 * @action getSkippedWords
 */
'use strict';

const { createResponse } = require('../utils/response');

/**
 * æ ¼å¼åŒ–è¯æ±‡ä¸ºåˆ—è¡¨é¡¹
 */
function formatVocabularyForList(vocab) {
  return {
    vocabularyId: vocab.vocabularyId || vocab._id, // å…¼å®¹å­—æ®µå
    thaiWord: vocab.thaiWord,
    meaning: vocab.meaning,
    pronunciation: vocab.pronunciation,
    audioPath: vocab.audioPath,
    partOfSpeech: vocab.partOfSpeech,
    level: vocab.level,
    lessonNumber: vocab.lessonNumber,
  };
}

/**
 * è·å–å·²åˆ’æ‰çš„å•è¯åˆ—è¡¨
 * @param {Object} db - æ•°æ®åº“å®ä¾‹ (ç”± index.js ä¼ å…¥)
 * @param {Object} params - è¯·æ±‚å‚æ•°
 * @param {string} params.userId - ç”¨æˆ·ID
 * @param {number} params.limit - è¿”å›æ•°é‡
 * @param {number} params.offset - åˆ†é¡µåç§»
 */
async function getSkippedWords(db, params) {
  // 1. è§£æ„å‚æ•° (æ³¨æ„ï¼šè¿™é‡Œ params æ˜¯ç¬¬äºŒä¸ªå‚æ•°)
  const { userId, limit = 20, offset = 0 } = params;

  if (!userId) {
    return createResponse(false, null, 'ç¼ºå°‘ç”¨æˆ·ID', 'INVALID_PARAMS');
  }

  try {
    // 2. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å®Œæˆå­—æ¯å­¦ä¹ 
    const { checkModuleAccess } = require('../utils/memoryEngine');
    const accessResult = await checkModuleAccess(db, userId, 'word');

    if (!accessResult.allowed) {
      return createResponse(false, null, accessResult.message, accessResult.errorCode);
    }

    // 3. è·å–å·²åˆ’æ‰å•è¯æ€»æ•°
    const countResult = await db.collection('user_vocabulary_progress')
      .where({ userId, skipped: true })
      .count();
    const total = countResult.total;

    // 4. æŸ¥è¯¢åˆ†é¡µè¿›åº¦
    const skippedProgressResult = await db.collection('user_vocabulary_progress')
      .where({ userId, skipped: true })
      .skip(offset)
      .limit(limit)
      .get();

    const skippedProgress = skippedProgressResult.data || [];

    if (skippedProgress.length === 0) {
      return createResponse(true, {
        words: [],
        pagination: { total, limit, offset, hasMore: false }
      }, 'æ²¡æœ‰å·²åˆ’æ‰çš„å•è¯');
    }

    // 5. è·å–å¯¹åº”çš„è¯æ±‡è¯¦æƒ…
    const vocabIds = skippedProgress.map(p => p.vocabularyId);

    // æ³¨æ„ï¼šè¿™é‡Œä½¿ç”¨å®é™…å­˜åœ¨çš„ vocabulary é›†åˆï¼ˆä¸»é”®ä¸º _idï¼‰
    const vocabResult = await db.collection('vocabulary')
      .where({
        // å‡è®¾ vocabularyId å­—æ®µå­˜å‚¨çš„æ˜¯è¯æ±‡çš„ _id
        _id: db.command.in(vocabIds)
      })
      .get();

    const vocabMap = new Map(vocabResult.data.map(v => [v._id, v]));

    // 6. ç»„è£…æ•°æ®
    const words = skippedProgress.map(progress => {
      const vocab = vocabMap.get(progress.vocabularyId);
      if (!vocab) return null;

      return {
        ...formatVocabularyForList(vocab),
        skippedAt: progress.updatedAt,
      };
    }).filter(Boolean);

    return createResponse(true, {
      words,
      pagination: {
        total,
        limit,
        offset,
        hasMore: offset + limit < total,
      }
    }, 'è·å–å·²åˆ’æ‰å•è¯æˆåŠŸ');

  } catch (error) {
    console.error('getSkippedWords error:', error);
    return createResponse(false, null, `æœåŠ¡å™¨å†…éƒ¨é”™è¯¯: ${error.message}`, 'SERVER_ERROR');
  }
}

module.exports = getSkippedWords;
</file>

<file path="cloudbase/functions/learn-vocab/index.js">
/**
 * learn-vocab äº‘å‡½æ•° - ç»Ÿä¸€è®°å¿†å¼•æ“ç‰ˆæœ¬
 * æ”¯æŒå­—æ¯/å•è¯/å¥å­çš„ç»Ÿä¸€å­¦ä¹ ç®¡ç†
 * ç‰ˆæœ¬: 2.0.0 (UME - Unified Memory Engine)
 * 
 * è§¦å‘æ–¹å¼: HTTP è§¦å‘å™¨
 */

const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.SYMBOL_CURRENT_ENV });
const db = cloud.database();

// ===== åŸæœ‰handlers (ä¿ç•™) =====
const getTodayWords = require('./handlers/getTodayWords');
const updateMastery = require('./handlers/updateMastery');
const toggleSkipWord = require('./handlers/toggleSkipWord');
const getVocabularyDetail = require('./handlers/getVocabularyDetail');
const getReviewStatistics = require('./handlers/getReviewStatistics');
const getVocabularyList = require('./handlers/getVocabularyList');
const getSkippedWords = require('./handlers/getSkippedWords');

// ===== æ–°å¢handlers (ç»Ÿä¸€è®°å¿†å¼•æ“) =====
// (å·²è¿ç§»è‡³ memory-engine äº‘å‡½æ•°)

// ===== å·¥å…·å‡½æ•° =====
const { createResponse } = require('./utils/response');

/**
 * äº‘å‡½æ•°ä¸»å…¥å£
 * æ”¯æŒ HTTP è§¦å‘å™¨è°ƒç”¨
 * 
 * @param {Object} event - è¯·æ±‚äº‹ä»¶
 * @param {Object} context - ä¸Šä¸‹æ–‡
 */
exports.main = async (event, context) => {
  // ===== è§£æ HTTP è¯·æ±‚ =====
  let requestData = event;

  // HTTP è§¦å‘å™¨ï¼šbody å¯èƒ½æ˜¯å­—ç¬¦ä¸²æˆ–å¯¹è±¡
  if (event.body) {
    if (typeof event.body === 'string') {
      try {
        requestData = JSON.parse(event.body);
      } catch (e) {
        console.error('[learn-vocab] JSON è§£æå¤±è´¥:', e.message);
        return createResponse(false, null, 'Invalid JSON in request body', 'INVALID_JSON');
      }
    } else if (typeof event.body === 'object') {
      requestData = event.body;
    }
  }

  const { action, data = {} } = requestData;

  console.log(`[learn-vocab] Action: ${action}`, JSON.stringify(data));

  // éªŒè¯ action å‚æ•°
  if (!action) {
    return createResponse(
      false,
      null,
      'ç¼ºå°‘å¿…å¡«å‚æ•°: action',
      'MISSING_ACTION'
    );
  }

  try {
    // ===== åŸæœ‰APIè·¯ç”± (7ä¸ª) =====
    if (action === 'getTodayWords') {
      return await getTodayWords(db, data);
    }

    if (action === 'updateMastery') {
      return await updateMastery(data);
    }

    if (action === 'toggleSkipWord') {
      return await toggleSkipWord(db, data);
    }

    if (action === 'getVocabularyDetail') {
      return await getVocabularyDetail(db, data);
    }

    if (action === 'getReviewStatistics') {
      return await getReviewStatistics(db, data);
    }

    if (action === 'getVocabularyList') {
      return await getVocabularyList(db, data);
    }

    if (action === 'getSkippedWords') {
      return await getSkippedWords(db, data);
    }

    // ===== å·²è¿ç§»è‡³ memory-engine çš„è·¯ç”± =====
    if (['getTodayMemories', 'submitMemoryResult', 'checkModuleAccess', 'getUserProgress'].includes(action)) {
      return createResponse(
        false,
        null,
        `Action '${action}' has been moved to 'memory-engine' cloud function. Please update your client.`,
        'MOVED_PERMANENTLY'
      );
    }

    // ===== æœªçŸ¥Action =====
    const supportedActions = [
      'getTodayWords',
      'updateMastery',
      'toggleSkipWord',
      'getVocabularyDetail',
      'getReviewStatistics',
      'getVocabularyList',
      'getSkippedWords'
    ];

    return createResponse(
      false,
      { supportedActions },
      `æœªçŸ¥çš„æ“ä½œç±»å‹: ${action}`,
      'UNKNOWN_ACTION'
    );

  } catch (error) {
    console.error(`[learn-vocab] äº‘å‡½æ•°é”™è¯¯:`, error);
    console.error('é”™è¯¯å †æ ˆ:', error.stack);

    return createResponse(
      false,
      null,
      error.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      'SERVER_ERROR'
    );
  }
};
</file>

<file path="cloudbase/functions/memory-engine/handlers/checkModuleAccess.js">
/**
 * æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™
 * Action: checkModuleAccess
 */

const { checkModuleAccess } = require('../utils/memoryEngine');
const { validateParams } = require('../utils/validators');
const { createResponse } = require('../utils/response');

async function checkModuleAccessHandler(db, params) {

  const devForceUnlock = process.env.FORCE_UNLOCK === 'true';
  console.log('ğŸ”§ FORCE_UNLOCK å½“å‰å€¼:', process.env.FORCE_UNLOCK, '=>', devForceUnlock);
  if (devForceUnlock) {
    return createResponse(true, {
      allowed: true,
      moduleType: params.moduleType,
      progress: 100
    }, 'ã€å¼€å‘æ¨¡å¼ã€‘æ¨¡å—å·²å¼ºåˆ¶æ”¾è¡Œ');
  }

  // ================== ä»¥ä¸‹ä¸ºæ­£å¼ç”Ÿäº§é€»è¾‘ ==================

  // 1ï¸âƒ£ å‚æ•°éªŒè¯
  const validation = validateParams(params, ['userId', 'moduleType']);
  if (!validation.isValid) {
    return createResponse(false, null, validation.message, 'INVALID_PARAMS');
  }

  const { userId, moduleType } = params;

  // 2ï¸âƒ£ éªŒè¯ moduleType åˆæ³•æ€§
  const validModules = ['letter', 'word', 'sentence', 'article'];
  if (!validModules.includes(moduleType)) {
    return createResponse(
      false,
      null,
      `æ— æ•ˆçš„æ¨¡å—ç±»å‹: ${moduleType}`,
      'INVALID_MODULE_TYPE'
    );
  }

  try {
    // 3ï¸âƒ£ æ­£å¼æ ¡éªŒæ¨¡å—æƒé™
    const accessResult = await checkModuleAccess(db, userId, moduleType);

    if (!accessResult.allowed) {
      return createResponse(false, accessResult, accessResult.message, accessResult.errorCode);
    }

    // 4ï¸âƒ£ å…è®¸è®¿é—®
    return createResponse(true, {
      allowed: true,
      moduleType,
      progress: accessResult.progress
    }, 'æ¨¡å—å·²è§£é”,å¯ä»¥è®¿é—®');

  } catch (error) {
    console.error('checkModuleAccess é”™è¯¯:', error);
    return createResponse(false, null, error.message || 'æœåŠ¡å™¨é”™è¯¯', 'SERVER_ERROR');
  }
}

module.exports = checkModuleAccessHandler;
</file>

<file path="cloudbase/functions/memory-engine/handlers/submitMemoryResult.js">
/**
 * æäº¤å­¦ä¹ ç»“æœï¼ˆæ”¯æŒå•æ¡ + æ‰¹é‡ï¼‰
 * 
 * æ”¯æŒä¸¤ç§è¯·æ±‚æ ¼å¼ï¼š
 * 1ï¼‰æ—§ç‰ˆå•æ¡ï¼š
 * {
 *   userId,
 *   entityType,
 *   entityId,
 *   quality
 * }
 * 
 * 2ï¼‰æ–°ç‰ˆæ‰¹é‡ï¼š
 * {
 *   userId,
 *   results: [
 *     { entityType, entityId, quality },
 *     ...
 *   ]
 * }
 */

'use strict';

const { createResponse } = require('../utils/response');
const { updateMemoryAfterReview } = require('../utils/memoryEngine');

const MAX_RESULTS = 30;
const BATCH_SIZE = 5;

/**
 * @param {Object} db     - cloud.database()
 * @param {Object} params - è¯·æ±‚å‚æ•°ï¼ˆæ¥è‡ª index.js ä¸­çš„ dataï¼‰
 */
async function submitMemoryResult(db, params) {
  const start = Date.now();
  const {
    userId,
    entityType,
    entityId,
    quality,
    results
  } = params || {};

  // 1. åŸºæœ¬æ ¡éªŒï¼šå¿…é¡»æœ‰ userId
  if (!userId) {
    return createResponse(
      false,
      null,
      'ç¼ºå°‘å¿…å¡«å‚æ•°: userId',
      'INVALID_PARAMS'
    );
  }

  // 2. è§„èŒƒåŒ–ä¸ºç»Ÿä¸€çš„æ•°ç»„æ ¼å¼ items[]
  let items = [];

  // 2.1 æ–°ç‰ˆï¼šdata.results æ˜¯æ•°ç»„
  if (Array.isArray(results) && results.length > 0) {
    if (results.length > MAX_RESULTS) {
      return createResponse(
        false,
        null,
        `å•æ¬¡æœ€å¤šæäº¤ ${MAX_RESULTS} æ¡ç»“æœï¼Œè¯·åˆ†æ‰¹æäº¤`,
        'RESULTS_TOO_MANY'
      );
    }
    items = results.map((r) => ({
      entityType: r.entityType,
      entityId: r.entityId,
      quality: r.quality
    }));
  }
  // 2.2 å…¼å®¹æ—§ç‰ˆï¼šå•æ¡å‚æ•°
  else if (entityType && entityId && quality) {
    items = [{ entityType, entityId, quality }];
  } else {
    // ä¸¤ç§æ ¼å¼éƒ½ä¸æ»¡è¶³
    return createResponse(
      false,
      null,
      'ç¼ºå°‘å¿…å¡«å‚æ•°: entityType, entityId, quality æˆ– results[]',
      'INVALID_PARAMS'
    );
  }

  try {
    const updatedMemories = [];

    // 3. åˆ†æ‰¹å¹¶å‘æ›´æ–°è®°å¿†çŠ¶æ€ï¼ˆé˜²æ­¢è¶…æ—¶ï¼‰
    for (let i = 0; i < items.length; i += BATCH_SIZE) {
      const batch = items.slice(i, i + BATCH_SIZE);

      const batchResults = await Promise.all(
        batch.map(async (item) => {
          const { entityType, entityId, quality } = item;

          // é˜²å¾¡æ€§æ ¡éªŒï¼Œé¿å… results é‡Œæ··å…¥ç©ºå¯¹è±¡
          if (!entityType || !entityId || !quality) return null;

          const memoryState = await updateMemoryAfterReview(
            db,
            userId,
            entityType,
            entityId,
            quality
          );

          return {
            entityType,
            entityId,
            quality,
            memoryState
          };
        })
      );

      batchResults
        .filter(Boolean)
        .forEach((res) => updatedMemories.push(res));
    }

    if (updatedMemories.length === 0) {
      return createResponse(
        false,
        null,
        'results ä¸­æ²¡æœ‰æœ‰æ•ˆçš„è®°å½•',
        'INVALID_PARAMS'
      );
    }

    // 4. è¿”å›ç»Ÿä¸€ç»“æ„
    const response = createResponse(
      true,
      { updatedMemories },
      'æäº¤å­¦ä¹ ç»“æœæˆåŠŸ'
    );
    console.log('[FunctionCost] submitMemoryResult', Date.now() - start, 'ms');
    return response;

  } catch (error) {
    console.error('[submitMemoryResult] error:', error);
    console.log('[FunctionCost] submitMemoryResult', Date.now() - start, 'ms');

    return createResponse(
      false,
      null,
      error.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      'SERVER_ERROR'
    );
  }
}

module.exports = submitMemoryResult;
</file>

<file path="src/entities/types/alphabet.types.ts">
// src/entities/types/alphabet.types.ts

/**
 * å­—æ¯å­¦ä¹ ç›¸å…³ç±»å‹
 * 
 * è¯´æ˜: æ­¤æ–‡ä»¶å®šä¹‰å­—æ¯å­¦ä¹ ä¼šè¯(Session)ç›¸å…³çš„ç±»å‹
 * ä¸è¦ä¸letter.types.tsé‡å¤å®šä¹‰LetteråŸºç¡€ç»“æ„
 */

import type { Letter } from './letter.types';

// ==================== å­¦ä¹ ä¼šè¯ç›¸å…³ ====================

/**
 * AlphabetLearningState - å­—æ¯å­¦ä¹ çŠ¶æ€
 *
 * ç”¨äºå­¦ä¹ ä¼šè¯ä¸­è¿½è¸ªå•ä¸ªå­—æ¯çš„å­¦ä¹ è¿›åº¦
 */
export interface AlphabetLearningState {
    // åŸºç¡€ä¿¡æ¯
    alphabetId: string;             // å­—æ¯ID (å¯¹åº”Letter._id)
    thaiChar: string;               // æ³°æ–‡å­—ç¬¦
    category: string;               // ç±»åˆ«
    pronunciation: string;          // å‘éŸ³
    example: string;                // ä¾‹è¯ (å·²åŒ…å«ä¸­æ–‡)
    audioPath: string;              // éŸ³é¢‘URL

    // å­¦ä¹ è¿›åº¦
    currentAttempts: number;        // å½“å‰å°è¯•æ¬¡æ•°
    requiredAttempts: number;       // éœ€è¦è¾¾åˆ°çš„æ¬¡æ•° (é»˜è®¤3)
    qualityHistory: number[];       // è´¨é‡è¯„åˆ†å†å² (1-5)
    isCompleted: boolean;           // æ˜¯å¦å®Œæˆ
    timestamp: string;              // æœ€åæ›´æ–°æ—¶é—´ (ISOæ ¼å¼)

    // åç«¯è®°å¿†çŠ¶æ€ (å¯é€‰,æ¥è‡ªåç«¯getTodayMemories)
    memoryState?: MemoryStatus;

    // â­ æ–°å¢: ä¿ç•™å®Œæ•´Letterå¯¹è±¡,æ–¹ä¾¿è®¿é—®æ‰€æœ‰å­—æ®µ
    letterData?: Letter;
}

// ==================== Phase 2 ç»Ÿä¸€é¢˜å‹åè®® ====================

import type { AlphabetGameType } from '@/src/entities/types/alphabetGameTypes';

/**
 * AlphabetQueueItem - é¢˜ç›®é˜Ÿåˆ—é¡¹
 *
 * ç”¨äº Question Engine çš„ç»Ÿä¸€é˜Ÿåˆ—é¡¹åè®®
 * åŒ…å«å­—æ¯ä¿¡æ¯å’Œé¢˜å‹ä¿¡æ¯
 */
export interface AlphabetQueueItem {
    /** å­—æ¯ID */
    letterId: string;

    /** é¢˜å‹ */
    gameType: AlphabetGameType;

    /** å®Œæ•´çš„å­—æ¯å¯¹è±¡,ä¾›é¢˜ç›®ç”Ÿæˆå™¨ä½¿ç”¨ */
    letter: Letter;
}

/**
 * AlphabetQuestion - ç»Ÿä¸€é¢˜ç›®åè®®
 *
 * ç”± lettersQuestionGenerator ç”Ÿæˆçš„æ ‡å‡†é¢˜ç›®ç»“æ„
 */
export interface AlphabetQuestion {
    /** é¢˜ç›®ID (å¯ç”¨äºè¿½è¸ª) */
    id: string;

    /** é¢˜å‹ */
    gameType: AlphabetGameType;

    /** ç›®æ ‡å­—æ¯ (æ­£ç¡®ç­”æ¡ˆå¯¹åº”çš„å­—æ¯å¯¹è±¡) */
    targetLetter: Letter;

    /** é€‰é¡¹ (é€‰æ‹©é¢˜ä½¿ç”¨,æ‹¼å†™é¢˜å¯ä¸ºç©º) */
    options?: Letter[];

    /** æ­£ç¡®ç­”æ¡ˆ (å­—æ¯çš„ thaiChar æˆ–å…¶ä»–å±æ€§å€¼) */
    correctAnswer: string;

    /** éŸ³é¢‘URL (å¦‚æœé¢˜ç›®éœ€è¦æ’­æ”¾éŸ³é¢‘) */
    audioUrl?: string;
}

/**
 * MemoryStatus - åç«¯è®°å¿†çŠ¶æ€
 * 
 * æ¥è‡ªç»Ÿä¸€è®°å¿†å¼•æ“çš„è®°å¿†çŠ¶æ€
 */
export interface MemoryStatus {
    easinessFactor: number;         // éš¾åº¦å› å­ (1.3-2.5)
    interval: number;               // å¤ä¹ é—´éš”(å¤©)
    repetitions: number;            // é‡å¤æ¬¡æ•°
    nextReviewDate: string;         // ä¸‹æ¬¡å¤ä¹ æ—¥æœŸ (ISOæ ¼å¼)
    lastReviewDate?: string;        // æœ€åå¤ä¹ æ—¥æœŸ
}

/**
 * UnlockInfo - è§£é”ä¿¡æ¯
 * 
 * ç”¨äºç»Ÿä¸€è®°å¿†å¼•æ“çš„è§£é”ç³»ç»Ÿ
 */
export interface UnlockInfo {
    letterProgress: number;         // å­—æ¯å­¦ä¹ è¿›åº¦ (0-1 æ¯”ä¾‹å€¼)
    wordUnlocked: boolean;          // æ˜¯å¦è§£é”å•è¯å­¦ä¹ 
    unlocked?: boolean;             // æ˜¯å¦åˆšåˆšè§£é” (ç”¨äºå¼¹çª—æç¤º)
}

/**
 * TodayLettersResponse - ä»Šæ—¥å­—æ¯å­¦ä¹ å“åº”
 * 
 * åç«¯getTodayMemoriesè¿”å›çš„æ•°æ®ç»“æ„
 */
export interface TodayLettersResponse {
    items: Array<{
        entityId: string;           // å­—æ¯ID
        memoryState: MemoryStatus;
    }>;
    unlockInfo: UnlockInfo;
}

/**
 * SubmitLetterResultRequest - æäº¤å­—æ¯å­¦ä¹ ç»“æœ
 * 
 * æäº¤åˆ°åç«¯è®°å¿†å¼•æ“çš„æ•°æ®ç»“æ„
 */
export interface SubmitLetterResultRequest {
    userId: string;
    entityType: 'letter';
    entityId: string;
    quality: number;                // 1-5çš„è´¨é‡è¯„åˆ†
}

/**
 * SubmitLetterResultResponse - æäº¤ç»“æœå“åº”
 */
export interface SubmitLetterResultResponse {
    success: boolean;
    data?: {
        nextReviewDate: string;
        interval: number;
        repetitions: number;
        unlockInfo?: UnlockInfo;
    };
    message?: string;
    errorCode?: string;
}

// ==================== æµ‹è¯•ç›¸å…³ ====================

/**
 * AlphabetTest - å­—æ¯æµ‹è¯•æ•°æ®
 */
export interface AlphabetTest {
    testId: string;
    userId: string;
    questions: AlphabetTestQuestion[];
    totalQuestions: number;
    passingScore: number;           // åŠæ ¼åˆ†æ•° (é»˜è®¤80)
    createdAt: string;
}

/**
 * AlphabetTestQuestion - æµ‹è¯•é¢˜ç›®
 */
export interface AlphabetTestQuestion {
    questionId: string;
    type: 'recognition' | 'pronunciation' | 'writing';
    letterId: string;
    thaiChar: string;
    options?: string[];             // é€‰é¡¹ (é€‰æ‹©é¢˜)
    correctAnswer: string;
}

/**
 * AlphabetTestResult - æµ‹è¯•ç»“æœ
 */
export interface AlphabetTestResult {
    testId: string;
    userId: string;
    score: number;                  // å¾—åˆ† (0-100)
    correctCount: number;
    totalQuestions: number;
    passed: boolean;                // æ˜¯å¦é€šè¿‡
    answers: Array<{
        questionId: string;
        userAnswer: string;
        correctAnswer: string;
        isCorrect: boolean;
    }>;
    unlocked?: boolean;             // æ˜¯å¦è§£é”äº†ä¸‹ä¸€æ¨¡å—
    completedAt: string;
}

// ==================== å­¦ä¹ ä¼šè¯æ§åˆ¶ ====================

/**
 * LearningSessionState - å­¦ä¹ ä¼šè¯çŠ¶æ€
 * 
 * ç”¨äºAlphabetStoreç®¡ç†æ•´ä¸ªå­¦ä¹ æµç¨‹
 */
export interface LearningSessionState {
    phase: LearningPhase;
    reviewQueue: AlphabetLearningState[];
    currentAlphabet: AlphabetLearningState | null;
    completedCount: number;
    totalCount: number;
}

/**
 * LearningPhase - å­¦ä¹ é˜¶æ®µæšä¸¾
 */
export enum LearningPhase {
    IDLE = 'IDLE',                  // ç©ºé—²
    LOADING = 'LOADING',            // åŠ è½½ä¸­
    REVIEW = 'REVIEW',              // å¤ä¹ ä¸­
    TEST_PROMPT = 'TEST_PROMPT',    // æµ‹è¯•æç¤º
    TESTING = 'TESTING',            // æµ‹è¯•ä¸­
    TEST_RESULT = 'TEST_RESULT',    // æµ‹è¯•ç»“æœ
    COMPLETED = 'COMPLETED'         // å®Œæˆ
}

/**
 * QualityScore - è´¨é‡è¯„åˆ†æ˜ å°„
 */
export enum QualityButton {
    AGAIN = 'AGAIN',                // å®Œå…¨å¿˜è®°
    HARD = 'HARD',                  // å›°éš¾
    GOOD = 'GOOD',                  // è‰¯å¥½
    EASY = 'EASY'                   // ç®€å•
}

/**
 * è´¨é‡è¯„åˆ†æ˜ å°„è¡¨
 */
export const QUALITY_SCORE_MAP: Record<QualityButton, number> = {
    [QualityButton.AGAIN]: 1,
    [QualityButton.HARD]: 3,
    [QualityButton.GOOD]: 4,
    [QualityButton.EASY]: 5,
};

/**
 * å°è¯•æ¬¡æ•°å¢é‡æ˜ å°„è¡¨
 */
export const ATTEMPTS_INCREMENT_MAP: Record<QualityButton, number> = {
    [QualityButton.AGAIN]: 0,       // ä¸å¢åŠ 
    [QualityButton.HARD]: 1,        // +1
    [QualityButton.GOOD]: 1,        // +1
    [QualityButton.EASY]: 2,        // +2 (è·³è¿‡ä¸€æ¬¡)
};

// ==================== Phase 2 é”™é¢˜ç»Ÿè®¡ ====================

/**
 * RoundErrorSummary - è½®æ¬¡é”™é¢˜ç»Ÿè®¡
 *
 * ç”¨äºåœ¨ Round ç»“æœé¡µå±•ç¤ºé”™è¯¯æœ€å¤šçš„å­—æ¯
 */
export interface RoundErrorSummary {
    /** å­—æ¯ID */
    letterId: string;

    /** å®Œæ•´çš„å­—æ¯å¯¹è±¡ */
    letter: Letter;

    /** é”™è¯¯æ¬¡æ•° */
    wrongCount: number;

    /** æ€»å°è¯•æ¬¡æ•° */
    totalAttempts: number;

    /** é”™è¯¯ç‡ (wrongCount / totalAttempts) */
    errorRate?: number;
}
</file>

<file path="app.json">
{
  "expo": {
    "name": "ThaiLearningApp",
    "slug": "ThaiLearningApp",
    "scheme": "thailearningapp",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "newArchEnabled": false,
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.asherlliang.ThaiLearningApp"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "edgeToEdgeEnabled": true,
      "predictiveBackGestureEnabled": false,
      "package": "com.asherlliang.ThaiLearningApp"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      "expo-localization",
      "expo-font"
    ]
  }
}
</file>

<file path="cloudbase/functions/learn-vocab/handlers/getTodayWords.js">
/**
 * è·å–ä»Šæ—¥å•è¯å¤„ç†å™¨
 * 
 * è¿”å›ç”¨æˆ·ä»Šæ—¥éœ€è¦å­¦ä¹ /å¤ä¹ çš„å•è¯åˆ—è¡¨
 * 
 * @action getTodayWords
 */

'use strict';

const { createResponse } = require('../utils/response');
const {
  COLLECTIONS,
  MasteryLevel,
  SM2_PARAMS,
  EARLY_INTERVALS,
  DAILY_LEARNING_CONFIG
} = require('../utils/constants');

const MAX_DAILY_WORDS = 200; // é™é…æ¨¡å¼ç¡¬ä¸Šé™ï¼Œé˜²æ­¢ 3s è¶…æ—¶

/**
 * æ ¼å¼åŒ–è¯æ±‡ä¸ºåˆ—è¡¨é¡¹ (ç²¾ç®€ç‰ˆ)
 */
function formatVocabularyForList(vocab) {
  return {
    vocabularyId: vocab._id || vocab.vocabularyId,
    thaiWord: vocab.thaiWord,
    meaning: vocab.meaning,
    pronunciation: vocab.pronunciation,
    audioPath: vocab.audioPath,
    partOfSpeech: vocab.partOfSpeech,
    level: vocab.level,
    lessonNumber: vocab.lessonNumber,
  };
}

/**
 * è·å–ä»Šæ—¥å•è¯åˆ—è¡¨
 * 
 * ä¸šåŠ¡é€»è¾‘:
 * 1. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å®Œæˆå­—æ¯å­¦ä¹ 
 * 2. è·å–ç”¨æˆ·æ‰€æœ‰æœªåˆ’æ‰çš„è¿›åº¦è®°å½•
 * 3. ç­›é€‰ä»Šæ—¥éœ€å¤ä¹ çš„å•è¯å’Œæ–°è¯
 * 4. æŒ‰ä¼˜å…ˆçº§æ’åº: é™Œç”Ÿ > æ¨¡ç³Š > è®°å¾— > æ–°è¯
 * 5. åº”ç”¨åˆ†é¡µè¿”å›
 */
async function getTodayWords(db, params) {
  const start = Date.now();
  const { userId, limit = 30, offset = 0, level = null } = params;
  const safeLimit = Math.max(1, Math.min(limit, MAX_DAILY_WORDS));

  // éªŒè¯å‚æ•°
  if (!userId) {
    return createResponse(false, null, 'ç¼ºå°‘ç”¨æˆ·ID', 'INVALID_PARAMS');
  }

  try {
    // ===== Step 1: æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨ =====
    const userResult = await db.collection('users')
      .where({ userId })
      .get();

    if (!userResult.data || userResult.data.length === 0) {
      return createResponse(false, null, 'ç”¨æˆ·ä¸å­˜åœ¨', 'USER_NOT_FOUND');
    }

    // ===== Step 2: æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å®Œæˆå­—æ¯å­¦ä¹ ï¼ˆæƒé™æ£€æŸ¥ï¼‰=====
    const { checkModuleAccess } = require('../utils/memoryEngine');
    const accessResult = await checkModuleAccess(db, userId, 'word');

    if (!accessResult.allowed) {
      return createResponse(
        false,
        null,
        accessResult.message,
        accessResult.errorCode
      );
    }

    // ===== Step 3: è·å–ç”¨æˆ·æ‰€æœ‰æœªåˆ’æ‰çš„è¿›åº¦è®°å½• =====
    const allProgressResult = await db.collection('user_vocabulary_progress')
      .where({
        userId,
        skipped: db.command.neq(true)
      })
      .get();

    const allProgress = allProgressResult.data || [];

    // ===== Step 4: åˆ†ç¦»éœ€è¦å¤ä¹ çš„è¯å’Œå·²å­¦ä¹ çš„è¯ =====
    const dueForReview = [];
    const learnedVocabIds = new Set();
    const now = new Date();

    allProgress.forEach(progress => {
      learnedVocabIds.add(progress.vocabularyId);

      // æ£€æŸ¥æ˜¯å¦ä»Šæ—¥éœ€è¦å¤ä¹ 
      if (progress.nextReviewDate && new Date(progress.nextReviewDate) <= now) {
        dueForReview.push(progress);
      }
    });

    // ===== Step 5: è·å–æ–°è¯ (ç”¨æˆ·ä»æœªå­¦è¿‡çš„è¯æ±‡) =====
    const maxNewWords = (DAILY_LEARNING_CONFIG && DAILY_LEARNING_CONFIG.MAX_NEW_WORDS) || 10;

    let newWordsQuery = db.collection('vocabulary');

    if (learnedVocabIds.size > 0) {
      newWordsQuery = newWordsQuery.where({
        _id: db.command.nin([...learnedVocabIds])
      });
    }

    if (level) {
      newWordsQuery = newWordsQuery.where({ level });
    }

  const newVocabsResult = await newWordsQuery
    .orderBy('lessonNumber', 'asc')
    .limit(Math.min(maxNewWords, MAX_DAILY_WORDS))
    .get();

    const newVocabularies = newVocabsResult.data || [];

    // ===== Step 6: æŒ‰ä¼˜å…ˆçº§æ’åºå¤ä¹ è¯ (é™Œç”Ÿ > æ¨¡ç³Š > è®°å¾—) =====
    const priorityOrder = {
      [MasteryLevel.UNFAMILIAR]: 0,
      [MasteryLevel.FUZZY]: 1,
      [MasteryLevel.REMEMBERED]: 2,
    };

    dueForReview.sort((a, b) => {
      return (priorityOrder[a.mastery] ?? 3) - (priorityOrder[b.mastery] ?? 3);
    });

    // ===== Step 7: ç»„åˆä»Šæ—¥å•è¯åˆ—è¡¨ =====
    const todayList = [];

    // æ·»åŠ éœ€è¦å¤ä¹ çš„è¯
    if (dueForReview.length > 0) {
      const reviewVocabIds = dueForReview.map(p => p.vocabularyId);
      const reviewVocabsResult = await db.collection('vocabulary')
        .where({ _id: db.command.in(reviewVocabIds) })
        .get();

      const vocabMap = new Map(
        (reviewVocabsResult.data || []).map(v => [v._id, v])
      );

      dueForReview.forEach(progress => {
        const vocab = vocabMap.get(progress.vocabularyId);
        if (vocab) {
          todayList.push({
            ...formatVocabularyForList(vocab),
            learningStatus: {
              mastery: progress.mastery,
              reviewCount: progress.reviewCount,
              lastReviewed: progress.lastReviewed,
              nextReviewDate: progress.nextReviewDate,
              intervalDays: progress.intervalDays,
              isReview: true,
              isNew: false,
            },
          });
        }
      });
    }

    // æ·»åŠ æ–°è¯
    newVocabularies.forEach(vocab => {
      todayList.push({
        ...formatVocabularyForList(vocab),
        learningStatus: {
          mastery: null,
          reviewCount: 0,
          lastReviewed: null,
          nextReviewDate: null,
          intervalDays: 0,
          isReview: false,
          isNew: true,
        },
      });
    });

    // ===== Step 8: åº”ç”¨åˆ†é¡µ =====
    const totalCount = todayList.length;
    const validOffset = Math.max(0, offset);
    const validLimit = Math.max(1, Math.min(safeLimit, 100));

    const paginatedList = todayList.slice(validOffset, validOffset + validLimit);

    const response = createResponse(true, {
      words: paginatedList,
      pagination: {
        total: totalCount,
        limit: validLimit,
        offset: validOffset,
        hasMore: validOffset + validLimit < totalCount,
      },
      summary: {
        reviewCount: dueForReview.length,
        newCount: newVocabularies.length,
        totalToday: totalCount,
      },
    }, 'è·å–ä»Šæ—¥å•è¯æˆåŠŸ');
    console.log('[FunctionCost] getTodayWords', Date.now() - start, 'ms');
    return response;

  } catch (error) {
    console.error('getTodayWords error:', error);
    console.log('[FunctionCost] getTodayWords', Date.now() - start, 'ms');
    return createResponse(false, null, error.message || 'æœåŠ¡å™¨é”™è¯¯', 'SERVER_ERROR');
  }
}

module.exports = getTodayWords;
</file>

<file path="cloudbase/functions/memory-engine/utils/memoryEngine.js">
/**
 * ç»Ÿä¸€è®°å¿†å¼•æ“æ ¸å¿ƒæ¨¡å—
 * æ”¯æŒå­—æ¯/å•è¯/å¥å­çš„ç»Ÿä¸€è®°å¿†ç®¡ç†
 * 
 * ä¿®å¤ï¼šwx-server-sdk ä¸æ”¯æŒ getOne()ï¼Œæ”¹ç”¨ get() + data[0]
 */

const { calculateSM2Optimized } = require('./sm2');

/**
 * åˆ›å»ºæ–°çš„è®°å¿†è®°å½•
 */
async function createMemoryRecord(db, userId, entityType, entityId, isLocked = false) {

    // éªŒè¯å‚æ•°
    if (!userId || !entityType || !entityId) {
        console.error('[createMemoryRecord] å‚æ•°ç¼ºå¤±:', { userId, entityType, entityId });
        throw new Error('userId, entityType, entityId éƒ½æ˜¯å¿…éœ€å‚æ•°');
    }

    const now = new Date();
    const nextReviewAt = isLocked ? null : new Date(now.getTime() + 24 * 60 * 60 * 1000).toISOString();

    const memoryRecord = {
        userId,
        entityType,
        entityId,
        masteryLevel: 0.0,
        reviewStage: 0,
        easinessFactor: 2.5,
        intervalDays: 1,
        lastReviewAt: null,
        nextReviewAt,
        correctCount: 0,
        wrongCount: 0,
        streakCorrect: 0,
        isLocked,
        createdAt: now.toISOString(),
        updatedAt: now.toISOString()
    };

    try {
        // å°è¯•æ’å…¥
        const result = await db.collection('memory_status').add(memoryRecord);

        console.log('[createMemoryRecord] åˆ›å»ºæˆåŠŸ:', { userId, entityType, entityId });

        return {
            _id: result._id,
            ...memoryRecord
        };
    } catch (error) {
        // å¦‚æœæ˜¯é‡å¤é”®é”™è¯¯ï¼ŒæŸ¥è¯¢å¹¶è¿”å›ç°æœ‰è®°å½•
        if (error.errCode === -502001 || error.message.includes('duplicate key')) {
            console.log('[createMemoryRecord] è®°å½•å·²å­˜åœ¨ï¼ŒæŸ¥è¯¢è¿”å›:', { userId, entityType, entityId });

            const existingResult = await db.collection('memory_status')
                .where({ userId, entityType, entityId })
                .get();

            if (existingResult.data && existingResult.data.length > 0) {
                return existingResult.data[0];
            }
        }

        // å…¶ä»–é”™è¯¯ç»§ç»­æŠ›å‡º
        console.error('[createMemoryRecord] åˆ›å»ºå¤±è´¥:', error);
        throw error;
    }
}

/**
 * è·å–æˆ–åˆ›å»ºè®°å¿†è®°å½•
 * ä¿®å¤ï¼šä½¿ç”¨ get() ä»£æ›¿ getOne()
 */
async function getOrCreateMemory(db, userId, entityType, entityId, isLocked = false) {
    // 1. å°è¯•æŸ¥è¯¢ç°æœ‰è®°å½•
    const existingMemory = await db.collection('memory_status')
        .where({
            userId,
            entityType,
            entityId
        })
        .get();

    // 2. å¦‚æœå­˜åœ¨,ç›´æ¥è¿”å›ç¬¬ä¸€æ¡
    if (existingMemory.data && existingMemory.data.length > 0) {
        return existingMemory.data[0];
    }

    // 3. ä¸å­˜åœ¨åˆ™åˆ›å»ºæ–°è®°å½•
    return await createMemoryRecord(db, userId, entityType, entityId, isLocked);
}

/**
 * æ›´æ–°è®°å¿†çŠ¶æ€(ç­”é¢˜åè°ƒç”¨)
 */
async function updateMemoryAfterReview(db, userId, entityType, entityId, quality) {
    console.log('ã€æµ‹è¯•ã€‘updateMemoryAfterReview è¢«è°ƒç”¨äº†ï¼', { userId, quality });
    console.log('=== [updateMemoryAfterReview] å¼€å§‹ ===');
    console.log('å‚æ•°:', JSON.stringify({ userId, entityType, entityId, quality }));

    try {
        // 1. è·å–å½“å‰è®°å¿†è®°å½•
        console.log('æ­¥éª¤1: è·å–è®°å¿†è®°å½•');
        const memory = await getOrCreateMemory(db, userId, entityType, entityId);
        console.log('è®°å¿†è®°å½•:', JSON.stringify(memory));

        // 2. æ˜ å°„è´¨é‡åˆ°SM-2è¯„åˆ†
        console.log('æ­¥éª¤2: æ˜ å°„è´¨é‡');
        const qualityMap = {
            'é™Œç”Ÿ': 1,
            'æ¨¡ç³Š': 3,
            'è®°å¾—': 5
        };
        const sm2Quality = qualityMap[quality] || 3;
        console.log('SM-2è´¨é‡:', sm2Quality);

        // 3. è®¡ç®—æ–°çš„SM-2å‚æ•°
        console.log('æ­¥éª¤3: è°ƒç”¨ calculateSM2Optimized');
        console.log('è°ƒç”¨å‚æ•°:', {
            quality,
            intervalDays: memory.intervalDays,
            easinessFactor: memory.easinessFactor,
            reviewStage: memory.reviewStage
        });

        const sm2Result = calculateSM2Optimized(
            quality,
            memory.intervalDays,
            memory.easinessFactor,
            memory.reviewStage
        );

        console.log('SM-2ç»“æœ:', JSON.stringify(sm2Result));

        // 4. æ›´æ–°æŒæ¡åº¦
        console.log('æ­¥éª¤4: è®¡ç®—æ–°æŒæ¡åº¦');
        let newMasteryLevel = memory.masteryLevel;
        if (quality === 'è®°å¾—') {
            newMasteryLevel = Math.min(1.0, memory.masteryLevel + 0.15);
        } else if (quality === 'æ¨¡ç³Š') {
            newMasteryLevel = Math.max(0.0, memory.masteryLevel + 0.05);
        } else {
            newMasteryLevel = Math.max(0.0, memory.masteryLevel - 0.2);
        }
        console.log('æ–°æŒæ¡åº¦:', newMasteryLevel);

        // 5. æ›´æ–°è¿èƒœå’Œè®¡æ•°
        console.log('æ­¥éª¤5: è®¡ç®—è¿èƒœ');
        const newStreakCorrect = quality === 'è®°å¾—' ? memory.streakCorrect + 1 : 0;
        const newCorrectCount = quality === 'è®°å¾—' ? memory.correctCount + 1 : memory.correctCount;
        const newWrongCount = quality === 'é™Œç”Ÿ' ? memory.wrongCount + 1 : memory.wrongCount;

        // 6. è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´
        console.log('æ­¥éª¤6: è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´');
        const now = new Date();
        const nextReviewAt = new Date(now.getTime() + sm2Result.interval * 24 * 60 * 60 * 1000);
        console.log('ä¸‹æ¬¡å¤ä¹ æ—¶é—´:', nextReviewAt);

        // 7. å‡†å¤‡æ›´æ–°æ•°æ®
        console.log('æ­¥éª¤7: å‡†å¤‡æ›´æ–°æ•°æ®åº“');
        const updateData = {
            masteryLevel: newMasteryLevel,
            reviewStage: sm2Result.repetitions,
            easinessFactor: sm2Result.easinessFactor,
            intervalDays: sm2Result.interval,
            lastReviewAt: now.toISOString(),
            nextReviewAt: nextReviewAt.toISOString(),
            correctCount: newCorrectCount,
            wrongCount: newWrongCount,
            streakCorrect: newStreakCorrect,
            updatedAt: now.toISOString()
        };

        console.log('æ›´æ–°æ•°æ®å¯¹è±¡:', JSON.stringify(updateData));

        // æ£€æŸ¥æ˜¯å¦æœ‰ undefined
        for (const [key, value] of Object.entries(updateData)) {
            if (value === undefined) {
                console.error(`âŒ å‘ç° undefined å€¼: ${key}`);
            }
        }

        // 8. æ‰§è¡Œæ›´æ–°
        console.log('æ­¥éª¤8: æ‰§è¡Œæ•°æ®åº“æ›´æ–°');
        await db.collection('memory_status')
            .where({
                userId,
                entityType,
                entityId
            })
            .update({
                data: updateData   // âœ… CloudBase å¿…é¡»è¿™æ ·å†™
            });

        console.log('âœ… æ›´æ–°æˆåŠŸ');

        return {
            entityId,
            entityType,
            masteryLevel: newMasteryLevel,
            reviewStage: sm2Result.repetitions,
            easinessFactor: sm2Result.easinessFactor,
            intervalDays: sm2Result.interval,
            nextReviewAt: nextReviewAt.toISOString(),
            correctCount: newCorrectCount,
            wrongCount: newWrongCount,
            streakCorrect: newStreakCorrect
        };

    } catch (error) {
        console.error('âŒ [updateMemoryAfterReview] é”™è¯¯:', error);
        console.error('é”™è¯¯å †æ ˆ:', error.stack);
        throw error;
    }
}

/**
 * è·å–ä»Šæ—¥å¾…å¤ä¹ çš„å®ä½“
 */
async function getTodayReviewEntities(db, userId, entityType, limit = 20) {
    const now = new Date();

    const result = await db.collection('memory_status')
        .where({
            userId,
            entityType,
            isLocked: false,
            nextReviewAt: db.command.lte(now)
        })
        .orderBy('nextReviewAt', 'asc')
        .limit(limit)
        .get();

    return result.data || [];
}

/**
 * æ£€æŸ¥å¹¶è§£é”ä¸‹ä¸€é˜¶æ®µå­¦ä¹ 
 */
// async function checkAndUnlockNextStage(db, userId) {

//   if (process.env.FORCE_UNLOCK === 'true') {
//     return {
//       allowed: true,
//       progress: 100,
//       stage: "all",
//       message: 'ã€è°ƒè¯•æ¨¡å¼ã€‘å¼ºåˆ¶è§£é”'
//     };
//   }

//   // ä¿®å¤ï¼šä½¿ç”¨ get() + data[0]
//   const progressResult = await db.collection('user_progress')
//     .where({ userId })
//     .get();

//   if (!progressResult.data || progressResult.data.length === 0) {
//     await initUserProgress(db, userId);
//     return {
//       unlocked: false,
//       stage: 'letter',
//       message: 'åˆå§‹åŒ–å­¦ä¹ è¿›åº¦æˆåŠŸ'
//     };
//   }

//   const progress = progressResult.data[0];

//   if (!progress.letterCompleted) {
//     const letterMemories = await db.collection('memory_status')
//       .where({
//         userId,
//         entityType: 'letter'
//       })
//       .get();

//     const totalLetters = 44;
//     const masteredLetters = letterMemories.data.filter(m => m.masteryLevel >= 0.7).length;
//     const letterProgress = masteredLetters / totalLetters;

//     if (letterProgress >= 0.95) {
//       await db.collection('user_progress').where({ userId }).update({
//         data: {
//           letterCompleted: true,
//           letterProgress: 1.0,
//           wordUnlocked: true,
//           currentStage: 'word',
//           updatedAt: new Date().toISOString()
//         }
//       });

//       await db.collection('memory_status')
//         .where({
//           userId,
//           entityType: 'word',
//           isLocked: true
//         })
//         .update({
//           data: {
//             isLocked: false,
//             nextReviewAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
//           }
//         });

//       return {
//         unlocked: true,
//         stage: 'word',
//         message: 'æ­å–œ!å­—æ¯å­¦ä¹ å®Œæˆ,å•è¯å­¦ä¹ å·²è§£é”!'
//       };
//     }

//     return {
//       unlocked: false,
//       stage: 'letter',
//       progress: letterProgress,
//       remaining: Math.ceil((0.95 - letterProgress) * totalLetters),
//       message: `è¿˜éœ€æŒæ¡ ${Math.ceil((0.95 - letterProgress) * totalLetters)} ä¸ªå­—æ¯`
//     };
//   }

//   return {
//     unlocked: false,
//     stage: progress.currentStage,
//     message: 'ç»§ç»­åŠ æ²¹!'
//   };
// }

/**
 * åˆå§‹åŒ–ç”¨æˆ·çš„å­¦ä¹ è¿›åº¦è®°å½•
 */
async function initUserProgress(db, userId) {
    const now = new Date();

    const progressRecord = {
        userId,
        letterCompleted: false,
        letterProgress: 0.0,
        wordUnlocked: false,
        wordProgress: 0.0,
        sentenceUnlocked: false,
        sentenceProgress: 0.0,
        articleUnlocked: false,
        currentStage: 'letter',
        totalStudyDays: 0,
        streakDays: 0,
        lastStudyDate: null,
        createdAt: now,
        updatedAt: now
    };

    await db.collection('user_progress').add(progressRecord);
    return progressRecord;
}

/**
 * æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™
 * ä¿®å¤ï¼šä½¿ç”¨ get() + data[0]
 */
async function checkModuleAccess(db, userId, moduleType) {
    const forceUnlock = process.env.FORCE_UNLOCK === 'true';

    // ç‰¹æ®Šå¤„ç†ï¼šå¼€å‘é˜¶æ®µçš„æœ¬åœ°æµ‹è¯•ç”¨æˆ·
    // å‰ç«¯åœ¨æœªç™»å½•æƒ…å†µä¸‹ä¼šä½¿ç”¨ userId = 'test-user' è¿›å…¥å­—æ¯æ¨¡å—ï¼Œ
    // æ­¤æ—¶ CloudBase ä¸­å¹¶ä¸å­˜åœ¨å¯¹åº”çš„ user / user_progress è®°å½•ï¼Œ
    // å¦‚æœç›´æ¥è®¿é—®æ•°æ®åº“ä¼šè§¦å‘å„ç§çº¦æŸé”™è¯¯ï¼ˆä¾‹å¦‚å”¯ä¸€ç´¢å¼•ï¼‰ã€‚
    //
    // è¿™é‡Œç›´æ¥æ”¾è¡Œè¯¥ç”¨æˆ·ï¼Œå¹¶è¿”å›ä¸€ä¸ªæœ€å°åŒ–çš„è¿›åº¦å¯¹è±¡ï¼Œä»…ç”¨äºæœ¬åœ°è°ƒè¯•ã€‚
    if (userId === 'test-user') {
        console.warn('â„¹ï¸ checkModuleAccess: ä½¿ç”¨å¼€å‘æµ‹è¯•ç”¨æˆ· test-user, ç›´æ¥æ”¾è¡Œæ¨¡å—:', moduleType);
        const progress = {
            userId,
            letterCompleted: false,
            letterProgress: 0,
            wordUnlocked: false,
            wordProgress: 0,
            sentenceUnlocked: false,
            sentenceProgress: 0,
            articleUnlocked: false,
            articleProgress: 0,
            currentStage: moduleType,
        };
        return {
            allowed: true,
            progress,
        };
    }

    // 1. è·å–ç”¨æˆ·è¿›åº¦è®°å½•
    const progressResult = await db.collection('user_progress')
        .where({ userId })
        .limit(1)
        .get();

    if (!progressResult.data || progressResult.data.length === 0) {
        // æ²¡æœ‰è¿›åº¦è®°å½•ï¼š
        // - å¦‚æœå¼€å¯ FORCE_UNLOCKï¼Œä»ç„¶æ”¾è¡Œå¹¶è¿”å›ä¸€ä¸ªé»˜è®¤è¿›åº¦å¯¹è±¡ï¼›
        // - å¦‚æœæ˜¯å­—æ¯æ¨¡å—ï¼Œåˆ™è‡ªåŠ¨åˆå§‹åŒ– user_progress åæ”¾è¡Œï¼›
        // - å…¶ä»–æ¨¡å—ä¿æŒåŸæœ‰è¡Œä¸ºï¼ˆæ‹’ç»è®¿é—®ï¼‰ã€‚
        if (forceUnlock) {
            console.warn('âš ï¸ FORCE_UNLOCK å·²å¼€å¯, ä½†æœªæ‰¾åˆ° user_progress è®°å½•, ä½¿ç”¨é»˜è®¤è¿›åº¦:', moduleType);
            const progress = {
                userId,
                letterCompleted: true,
                letterProgress: 1,
                wordUnlocked: true,
                wordProgress: 1,
                sentenceUnlocked: true,
                sentenceProgress: 1,
                articleUnlocked: true,
                articleProgress: 1,
                currentStage: moduleType,
            };
            return {
                allowed: true,
                progress,
            };
        }

        // å­—æ¯æ¨¡å—ï¼šè‡ªåŠ¨åˆå§‹åŒ–è¿›åº¦è®°å½•ï¼Œé¿å…ç¬¬ä¸€æ¬¡è¿›å…¥å­—æ¯æ¨¡å—å°±è¢«æ‹’ç»
        if (moduleType === 'letter') {
            console.warn('â„¹ï¸ æœªæ‰¾åˆ° user_progress è®°å½•, ä¸ºå­—æ¯æ¨¡å—è‡ªåŠ¨åˆå§‹åŒ–è¿›åº¦:', userId);
            const progress = await initUserProgress(db, userId);
            return {
                allowed: true,
                progress,
            };
        }

        // éå­—æ¯æ¨¡å—ï¼šä»ç„¶è¦æ±‚å…ˆæœ‰è¿›åº¦è®°å½•
        return {
            allowed: false,
            errorCode: 'USER_PROGRESS_NOT_FOUND',
            message: 'ç”¨æˆ·å­¦ä¹ è¿›åº¦ä¸å­˜åœ¨,è¯·è”ç³»ç®¡ç†å‘˜',
        };
    }

    const progress = progressResult.data[0];
    const letterProgress = typeof progress.letterProgress === 'number'
        ? progress.letterProgress
        : 0;

    // 2. è°ƒè¯•æ€»å¼€å…³ï¼šä¸€é”®è§£é”æ‰€æœ‰æ¨¡å—
    if (forceUnlock) {
        console.warn('âš ï¸ FORCE_UNLOCK å·²å¼€å¯, å¼ºåˆ¶æ”¾è¡Œæ¨¡å—:', moduleType);
        return {
            allowed: true,
            progress: {
                ...progress,
                letterCompleted: true,
                letterProgress: 1,
                wordUnlocked: true,
                sentenceUnlocked: true,
                articleUnlocked: true,
                currentStage: moduleType,
            },
        };
    }

    // 3. å­—æ¯æ¨¡å—æ°¸è¿œå…è®¸è®¿é—®
    if (moduleType === 'letter') {
        return {
            allowed: true,
            progress,
        };
    }

    // 4. å…¶ä»–æ¨¡å—ï¼šç»Ÿä¸€ä½¿ç”¨ã€ŒäºŒé€‰ä¸€ã€è§„åˆ™
    // - letterCompleted === true
    // - æˆ– letterProgress >= 0.8 (å³ 80%)
    const finishedByTest = !!progress.letterCompleted;
    const finishedByProgress = letterProgress >= 0.8;

    if (!finishedByTest && !finishedByProgress) {
        return {
            allowed: false,
            errorCode: 'MODULE_LOCKED',
            message: `è¯·å…ˆå®Œæˆå­—æ¯å­¦ä¹ ï¼ˆå½“å‰è¿›åº¦ï¼š${Math.round(letterProgress * 100)}%ï¼‰`,
            progress,
        };
    }

    return {
        allowed: true,
        progress,
    };
}

module.exports = {
    createMemoryRecord,
    getOrCreateMemory,
    updateMemoryAfterReview,
    getTodayReviewEntities,
    // checkAndUnlockNextStage,
    initUserProgress,
    checkModuleAccess
};
</file>

<file path="cloudbase/functions/user-register/index.js">
const cloud = require('wx-server-sdk');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();
const _ = db.command;

//JWT Secret
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';
const JWT_EXPIRES_IN = '7d'; // 7 days

exports.main = async (event, context) => {
  // Parse request body if coming from HTTP trigger
  let requestData = event;
  if (typeof event.body === 'string') {
    try {
      requestData = JSON.parse(event.body);
    } catch (e) {
      return {
        success: false,
        message: 'Invalid JSON in request body',
        code: 'INVALID_JSON'
      };
    }
  } else if (event.body && typeof event.body === 'object') {
    requestData = event.body;
  }

  const { email, password, displayName, role = 'LEARNER' } = requestData;

  // Validate required fields
  if (!email || !password || !displayName) {
    return {
      success: false,
      message: 'Missing required fields: email, password, displayName',
      code: 'MISSING_FIELDS'
    };
  }

  try {
    // Check if email already exists 
    const existingUser = await db.collection('users').where({
      email: email.toLowerCase()
    }).count();

    if (existingUser.count > 0) {
      return {
        success: false,
        message: 'é‚®ç®±å·²å­˜åœ¨ \n Email already exists',
        code: 'EMAIL_EXISTS'
      };
    }

    // ===== Hash password =====
    const salt = await bcrypt.genSalt(10);
    const passwordHash = await bcrypt.hash(password, salt);

    // åˆ›å»ºæ–°ç”¨æˆ·
    const userId = `u_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const registrationDate = new Date().toISOString();
    const userDoc = {
      userId,
      email: email.toLowerCase(),
      passwordHash,
      displayName,
      role,
      registrationDate,
      lastLogin: registrationDate,
      isActive: true,
      preferences: {
        language: 'zh',
        notificationsEnabled: true
      }
    };
    // ===== Save to database =====
    await db.collection('users').add({
      data: userDoc
    });

    // åˆå§‹åŒ–ç”¨æˆ·æ•´ä½“å­¦ä¹ è¿›åº¦ (ç»Ÿä¸€è¿›åº¦è¡¨)
    await db.collection('user_progress').add({
      data: {
        userId,
        letterCompleted: false,
        debugSkipLetter: false,
        letterProgress: 0.0,
        wordProgress: 0.0,
        sentenceProgress: 0.0,
        totalStudyDays: 0,
        streakDays: 0,
        lastStudyDate: null,
        createdAt: registrationDate,
        updatedAt: registrationDate
      }
    });

    // åˆå§‹åŒ–å­—æ¯æ¨¡å—ä¸“ç”¨è¿›åº¦è¡¨
    // è¯´æ˜:
    // - letterProgress: 0â€“1 ä¹‹é—´çš„å°æ•°, 0.8 ä»£è¡¨ 80%
    // - letterCompleted: ä¸‰è½®å…¨éƒ¨å®Œæˆåç”±è®°å¿†å¼•æ“æ›´æ–°ä¸º true
    // - completedLessons: å·²å®Œæˆçš„å­—æ¯è¯¾ç¨‹IDåˆ—è¡¨ (ä¾‹å¦‚: ["alphabet-lesson1"])
    // - masteredLetterCount: å·²æŒæ¡çš„å­—æ¯æ•°é‡
    // - totalLetterCount: å­—æ¯æ€»æ•° (å½“å‰çº¦ 80, é¢„ç•™ç»™æœªæ¥æ‰©å±•)
    await db.collection('user_alphabet_progress').add({
      data: {
        userId,
        letterProgress: 0.0,
        letterCompleted: false,
        completedLessons: [],
        masteredLetterCount: 0,
        totalLetterCount: 80,
        currentRound: 1,          // ğŸ”¥ æ–°å¢ï¼šé»˜è®¤ä»ç¬¬1è½®å¼€å§‹
        roundHistory: [],         // ğŸ”¥ æ–°å¢ï¼šè½®æ¬¡å†å²è®°å½•
        createdAt: registrationDate,
        updatedAt: registrationDate,
      }
    });

    // ===== Generate JWT token =====
    const token = jwt.sign(
      {
        userId,
        email: email.toLowerCase(),
        role
      },
      JWT_SECRET,
      { expiresIn: JWT_EXPIRES_IN }
    );
    // ===== Return user data (exclude password hash) =====
    const { passwordHash: _, ...userResponse } = userDoc;

    return {
      success: true,
      data: {
        user: userResponse,
        token,
        expiresIn: 604800 // 7 days in seconds
      }
    };

  } catch (error) {
    console.error('æ³¨å†Œå¤±è´¥:', error);
    return {
      success: false,
      message: 'æ³¨å†Œå¤±è´¥: ' + error.message
    };
  }
};
</file>

<file path="src/components/learning/alphabet/AlphabetLearningView.tsx">
// src/components/learning/alphabet/AlphabetLearningView.tsx

import React, { memo, useCallback, useRef, useEffect, useState } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  ScrollView,
  Platform,
} from 'react-native';
import { Audio } from 'expo-av';
import { Volume2, Play } from 'lucide-react-native';

import type { AlphabetLearningState } from '@/src/stores/alphabetStore';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

interface AlphabetLearningViewProps {
  alphabet: AlphabetLearningState;
  onNext: () => void;
  onBack?: () => void;
}

export const AlphabetLearningView = memo(function AlphabetLearningView({
  alphabet,
  onNext,
  onBack,
}: AlphabetLearningViewProps) {
  const soundRef = useRef<Audio.Sound | null>(null);
  const audioModeConfiguredRef = useRef(false);
  const autoPlayCounter = useRef(0);
  const [isPlaying, setIsPlaying] = useState(false);

  const letter = alphabet.letter;
  const lessonOrder = letter.primaryCurriculumLessonOrder;

  const thaiChar = letter.thaiChar;
  const nameEnglish = letter.nameEnglish;

  const syllableSoundName = letter.syllableSoundName;

  const initialSound = letter.initialSound;
  const finalSound = letter.finalSound;

  const exampleWord = letter.exampleWord;
  const exampleMeaning = letter.exampleMeaning;
  const syllableSoundUrl = letter.syllableSoundUrl;
  const endSyllableSoundUrl = letter.endSyllableSoundUrl;

  const fullSoundLocalPath = letter.fullSoundLocalPath;
  const coreSyllableLocalPath = letter.syllableSoundLocalPath;
  const endSyllableSoundLocalPath = letter.endSyllableSoundLocalPath;
  const exampleWordLocalPath = letter.letterPronunciationLocalPath;

  // --- Audio Logic ---

  const resolveAudioPath = useCallback(
    (primary?: string | null) => {
      //  relaxes strict file:// check, allowing any valid path string
      if (primary && primary.length > 0) return primary;
      if (alphabet.audioUrl && alphabet.audioUrl.length > 0)
        return alphabet.audioUrl;
      return null;
    },
    [alphabet.audioUrl]
  );


  const playLocalAudio = useCallback(async (localPath?: string | null) => {
    // Relaxes check: allow any string path
    if (!localPath) return;


    try {
      setIsPlaying(true);
      if (!audioModeConfiguredRef.current) {
        await Audio.setAudioModeAsync({
          allowsRecordingIOS: false,
          playsInSilentModeIOS: true,
          staysActiveInBackground: false,
          shouldDuckAndroid: true,
          playThroughEarpieceAndroid: false,
        });
        audioModeConfiguredRef.current = true;
      }

      if (soundRef.current) {
        await soundRef.current.unloadAsync().catch(() => { });
        soundRef.current = null;
      }

      const { sound } = await Audio.Sound.createAsync(
        { uri: localPath },
        { shouldPlay: true }
      );
      soundRef.current = sound;

      sound.setOnPlaybackStatusUpdate((status) => {
        if (status.isLoaded && status.didJustFinish) {
          setIsPlaying(false);
        }
      });
    } catch (e) {
      console.warn('âŒ Playback failed:', e);
      setIsPlaying(false);
    }
  }, []);

  const handlePlayFullLetter = useCallback(() => {
    const path = resolveAudioPath(fullSoundLocalPath);
    void playLocalAudio(path);
  }, [fullSoundLocalPath, resolveAudioPath, playLocalAudio]);

  const handlePlayCoreSyllable = useCallback(() => {
    const path = resolveAudioPath(coreSyllableLocalPath);
    void playLocalAudio(path);
  }, [coreSyllableLocalPath, resolveAudioPath, playLocalAudio]);

  const handlePlayEndSyllable = useCallback(() => {
    const path = resolveAudioPath(
      endSyllableSoundLocalPath || coreSyllableLocalPath
    );
    void playLocalAudio(path);
  }, [endSyllableSoundLocalPath, coreSyllableLocalPath, resolveAudioPath, playLocalAudio]);

  // Position Sound Handlers
  const handlePlayInitialSound = useCallback(() => {
    // Priority: Local Cache -> Remote Specific URL -> (resolveAudioPath Fallback to Full)
    const path = resolveAudioPath(coreSyllableLocalPath || syllableSoundUrl);
    void playLocalAudio(path);
  }, [coreSyllableLocalPath, syllableSoundUrl, resolveAudioPath, playLocalAudio]);

  const handlePlayFinalSound = useCallback(() => {
    // Priority: Local Final -> Remote Final -> Local Syllable -> Remote Syllable
    const path = resolveAudioPath(
      endSyllableSoundLocalPath || endSyllableSoundUrl || coreSyllableLocalPath || syllableSoundUrl
    );
    void playLocalAudio(path);
  }, [endSyllableSoundLocalPath, endSyllableSoundUrl, coreSyllableLocalPath, syllableSoundUrl, resolveAudioPath, playLocalAudio]);

  const handlePlayExampleWord = useCallback(() => {
    const path = resolveAudioPath(
      exampleWordLocalPath || fullSoundLocalPath || coreSyllableLocalPath
    );
    void playLocalAudio(path);
  }, [exampleWordLocalPath, fullSoundLocalPath, coreSyllableLocalPath, resolveAudioPath, playLocalAudio]);


  // --- Auto-Play Logic (2 times) ---

  useEffect(() => {
    // Reset counter on letter change
    autoPlayCounter.current = 0;

    const playTwice = async () => {
      const path = resolveAudioPath(fullSoundLocalPath);
      if (!path) return;

      // First play
      await playLocalAudio(path);

      // Wait a bit before second play
      setTimeout(async () => {
        // Check if still mounted/same letter context basically (ref check)
        if (autoPlayCounter.current < 2) {
          await playLocalAudio(path);
          autoPlayCounter.current = 2; // Mark done
        }
      }, 1500); // 1.5s delay
    };

    void playTwice();

    return () => {
      if (soundRef.current) {
        soundRef.current.unloadAsync().catch(() => { });
      }
    };
  }, [letter._id, resolveAudioPath, fullSoundLocalPath, playLocalAudio]);


  // --- Render ---

  return (
    <ScrollView
      style={styles.container}
      contentContainerStyle={styles.contentContainer}
      showsVerticalScrollIndicator={false}
    >
      {/* Top Header Label */}
      <View style={styles.header}>
        <Text style={styles.headerText}>
          {lessonOrder ? `Lesson ${lessonOrder} Â· ` : ''}Learning Letter
        </Text>
      </View>

      {/* Hero Card */}
      <View style={styles.heroCard}>
        <View style={styles.heroInner}>
          <Text style={styles.thaiChar}>{thaiChar}</Text>
          {nameEnglish && <Text style={styles.englishName}>{nameEnglish}</Text>}

          <TouchableOpacity
            style={[styles.mainPlayButton, isPlaying && styles.buttonActive]}
            onPress={handlePlayFullLetter}
            disabled={!resolveAudioPath(fullSoundLocalPath)}
          >
            <Volume2 size={24} color={Colors.white} />
            <Text style={styles.mainPlayText}>Play Full Sound</Text>
          </TouchableOpacity>
        </View>
      </View>

      {/* Details Card */}
      <View style={styles.detailsCard}>

        {/* Row 1: Syllable Sound */}
        <View style={styles.detailRow}>
          <View style={styles.detailLabelContainer}>
            <View style={styles.iconCircle}>
              <Text style={styles.iconText}>ğŸ”Š</Text>
            </View>
            <Text style={styles.detailLabel}>Core Sound</Text>
          </View>
          <TouchableOpacity
            style={styles.detailAction}
            onPress={handlePlayCoreSyllable}
            disabled={!resolveAudioPath(coreSyllableLocalPath)}
          >
            <Text style={styles.detailValue}>/{syllableSoundName || '-'}/</Text>
            <Play size={16} color={Colors.thaiGold} fill={Colors.thaiGold} />
          </TouchableOpacity>
        </View>

        <View style={styles.divider} />

        {/* Row 2: Initial / Final */}
        <View style={styles.detailRow}>
          <View style={styles.detailLabelContainer}>
            <View style={styles.iconCircle}>
              <Text style={styles.iconText}>ğŸ§©</Text>
            </View>
            <Text style={styles.detailLabel}>Position</Text>
          </View>
          <View style={styles.positionContainer}>
            <TouchableOpacity
              style={styles.positionBlock}
              onPress={handlePlayInitialSound}
              disabled={!resolveAudioPath(coreSyllableLocalPath || syllableSoundUrl)}
            >
              <Text style={styles.positionLabel}>Initial</Text>
              <View style={styles.positionValueRow}>
                <Text style={styles.positionValue}>/{initialSound || '-'}/</Text>
                <Play size={12} color={Colors.thaiGold} fill={Colors.thaiGold} style={{ marginLeft: 4 }} />
              </View>
            </TouchableOpacity>

            <View style={styles.verticalDivider} />

            <TouchableOpacity
              style={styles.positionBlock}
              onPress={handlePlayFinalSound}
              disabled={!resolveAudioPath(endSyllableSoundLocalPath || endSyllableSoundUrl || coreSyllableLocalPath || syllableSoundUrl)}
            >
              <Text style={styles.positionLabel}>Final</Text>
              <View style={styles.positionValueRow}>
                <Text style={styles.positionValue}>/{finalSound || '-'}/</Text>
                <Play size={12} color={Colors.thaiGold} fill={Colors.thaiGold} style={{ marginLeft: 4 }} />
              </View>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.divider} />

        {/* Row 3: Example Word */}
        <View style={styles.detailRow}>
          <View style={styles.detailLabelContainer}>
            <View style={styles.iconCircle}>
              <Text style={styles.iconText}>ğŸ“Œ</Text>
            </View>
            <Text style={styles.detailLabel}>Example</Text>
          </View>
          <TouchableOpacity
            style={styles.detailAction}
            onPress={handlePlayExampleWord}
            disabled={!resolveAudioPath(exampleWordLocalPath || fullSoundLocalPath)}
          >
            <View style={{ alignItems: 'flex-end' }}>
              <Text style={styles.exampleWord}>{exampleWord || '-'}</Text>
              {exampleMeaning && <Text style={styles.exampleMeaning}>{exampleMeaning}</Text>}
            </View>
            <Play size={16} color={Colors.thaiGold} fill={Colors.thaiGold} />
          </TouchableOpacity>
        </View>

      </View>

      {/* Footer Navigation */}
      <View style={styles.footer}>
        <TouchableOpacity style={styles.continueButton} onPress={onNext}>
          <Text style={styles.continueText}>Continue</Text>
        </TouchableOpacity>
      </View>

    </ScrollView>
  );
});

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F8F9FA',
  },
  contentContainer: {
    padding: 24,
    paddingBottom: 48,
  },
  header: {
    alignItems: 'center',
    marginBottom: 24,
    marginTop: 8,
  },
  headerText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
    letterSpacing: 1,
    textTransform: 'uppercase',
  },
  heroCard: {
    backgroundColor: Colors.white,
    borderRadius: 24,
    padding: 32,
    alignItems: 'center',
    marginBottom: 24,
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 8 },
        shadowOpacity: 0.08,
        shadowRadius: 16,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  heroInner: {
    alignItems: 'center',
    width: '100%',
  },
  thaiChar: {
    fontFamily: Typography.playfairBold,
    fontSize: 96,
    color: Colors.ink,
    lineHeight: 110,
    marginBottom: 8,
  },
  englishName: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 18,
    color: Colors.taupe,
    marginBottom: 24,
  },
  mainPlayButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.thaiGold,
    paddingVertical: 14,
    paddingHorizontal: 32,
    borderRadius: 100,
    gap: 8,
    width: '100%',
    justifyContent: 'center',
  },
  buttonActive: {
    opacity: 0.8,
    transform: [{ scale: 0.98 }]
  },
  mainPlayText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
  },
  detailsCard: {
    backgroundColor: Colors.white,
    borderRadius: 20,
    padding: 24,
    marginBottom: 32,
    borderWidth: 1,
    borderColor: '#EFEFEF',
  },
  detailRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 12,
  },
  divider: {
    height: 1,
    backgroundColor: '#F0F0F0',
    marginVertical: 4,
  },
  detailLabelContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  iconCircle: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: '#F9FAFB',
    justifyContent: 'center',
    alignItems: 'center',
  },
  iconText: {
    fontSize: 16,
  },
  detailLabel: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 15,
    color: Colors.ink,
  },
  detailAction: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    backgroundColor: '#FFFCF5', // Light gold bg
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: 'rgba(212, 175, 55, 0.2)',
  },
  detailValue: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.ink,
  },
  positionContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 16,
  },
  positionBlock: {
    alignItems: 'center',
  },
  positionLabel: {
    fontSize: 10,
    color: Colors.taupe,
    textTransform: 'uppercase',
    marginBottom: 2,
    fontFamily: Typography.notoSerifRegular,
  },
  positionValue: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 15,
    color: Colors.ink,
  },
  verticalDivider: {
    width: 1,
    height: 24,
    backgroundColor: '#E0E0E0',
  },
  exampleWord: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.ink,
  },
  exampleMeaning: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 12,
    color: Colors.taupe,
  },
  positionValueRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },

  footer: {
    alignItems: 'center',
  },
  continueButton: {
    width: '100%',
    backgroundColor: Colors.ink,
    paddingVertical: 16,
    borderRadius: 16,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  continueText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
  },
});
</file>

<file path=".gitignore">
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
.kotlin/
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

# generated native folders
/ios
/android

# environment variables
.env

# Local reference data (do not commit)
assets/courses/
assets/data/

# docs
docs/Document/
docs/OLD/
/Rule
# Environment variables
.env.local
</file>

<file path="README.md">
# ğŸ‡¹ğŸ‡­ ThaiLearningApp - æ³°è¯­å­¦ä¹ åº”ç”¨
âš ï¸ AI Development Rules

This project is governed by CLAUDE.md.
All AI-assisted changes must comply with it.

<div align="center">

![Version](https://img.shields.io/badge/version-1.0.0-blue.svg)
![React Native](https://img.shields.io/badge/React%20Native-0.76.9-61dafb.svg)
![Expo](https://img.shields.io/badge/Expo-~52.0.38-000020.svg)
![TypeScript](https://img.shields.io/badge/TypeScript-5.1.3-3178c6.svg)
![License](https://img.shields.io/badge/license-MIT-green.svg)

ä¸€æ¬¾ä¼˜é›…çš„æ³°è¯­å­¦ä¹ åº”ç”¨ï¼Œé‡‡ç”¨é—´éš”é‡å¤ç®—æ³•ï¼Œæä¾›æ²‰æµ¸å¼çš„å­¦ä¹ ä½“éªŒã€‚

[åŠŸèƒ½ç‰¹æ€§](#-åŠŸèƒ½ç‰¹æ€§) â€¢ [æŠ€æœ¯æ ˆ](#-æŠ€æœ¯æ ˆ) â€¢ [å¿«é€Ÿå¼€å§‹](#-å¿«é€Ÿå¼€å§‹) â€¢ [é¡¹ç›®ç»“æ„](#-é¡¹ç›®ç»“æ„) â€¢ [å¼€å‘æŒ‡å—](#-å¼€å‘æŒ‡å—)

</div>

---

## ğŸ“¸ åº”ç”¨æˆªå›¾

<div align="center">
  <img src="./docs/screenshots/home.png" width="250" alt="é¦–é¡µ" />
  <img src="./docs/screenshots/learning.png" width="250" alt="å­¦ä¹ é¡µé¢" />
  <img src="./docs/screenshots/review.png" width="250" alt="å¤ä¹ é¡µé¢" />
</div>

## âœ¨ åŠŸèƒ½ç‰¹æ€§

### ğŸ¯ æ ¸å¿ƒåŠŸèƒ½
- **ç»Ÿä¸€å­¦ä¹ ä¼šè¯**: å¤ä¹ æ—§è¯ + å­¦ä¹ æ–°è¯çš„å®Œæ•´å­¦ä¹ æµç¨‹
- **é—´éš”é‡å¤ç®—æ³•**: åŸºäºè®°å¿†æ›²çº¿çš„æ™ºèƒ½å¤ä¹ ç³»ç»Ÿï¼ˆæ¯ä¸ªå•è¯é‡å¤3æ¬¡ï¼‰
- **ä¸‰çº§è¯„ä¼°ç³»ç»Ÿ**: è®¤è¯†/æ¨¡ç³Š/å¿˜è®°äº† - ç²¾å‡†è®°å½•å­¦ä¹ çŠ¶æ€
- **è·³è¿‡å¤ä¹ **: çµæ´»çš„å­¦ä¹ èŠ‚å¥æ§åˆ¶

### ğŸŒ å›½é™…åŒ–æ”¯æŒ
- **å¤šè¯­è¨€ç•Œé¢**: å®Œæ•´æ”¯æŒä¸­æ–‡/English
- **è‡ªåŠ¨è¯­è¨€æ£€æµ‹**: æ ¹æ®è®¾å¤‡è¯­è¨€è‡ªåŠ¨åˆ‡æ¢
- **æŒä¹…åŒ–åå¥½**: è®°ä½ç”¨æˆ·çš„è¯­è¨€é€‰æ‹©

### ğŸ¨ UI/UX è®¾è®¡
- **æ³°å›½é£æ ¼ä¸»é¢˜**: é‡‘è‰² (#D4AF37) + å¢¨è‰² (#1A1A1A) ä¼˜é›…é…è‰²
- **æ¨¡ç³Šé®ç½©æ•ˆæœ**: æ¸è¿›å¼ä¿¡æ¯å±•ç¤ºï¼Œå¢å¼ºå­¦ä¹ ä½“éªŒ
- **æµç•…åŠ¨ç”»**: ä½¿ç”¨ `expo-blur` å’Œ `react-native-reanimated`
- **å“åº”å¼å¸ƒå±€**: é€‚é…å„ç§å±å¹•å°ºå¯¸

### ğŸ“š å­¦ä¹ åŠŸèƒ½
- **æ–°è¯å­¦ä¹ **: 
  - ä¸‰ä¸ªæ ‡ç­¾é¡µï¼šåŸºç¡€é‡Šä¹‰ã€ä¾‹å¥ç¤ºä¾‹ã€ç”¨æ³•è¯¦è§£
  - éŸ³é¢‘å‘éŸ³æŒ‰é’®ï¼ˆå‡†å¤‡æ¥å…¥ï¼‰
  - æ¸è¿›å¼å†…å®¹å±•ç¤º
- **å•è¯å¤ä¹ **:
  - ä¸Šä¸‹æ–‡ä¾‹å¥å±•ç¤º
  - ä¸‰æŒ‰é’®å¿«é€Ÿè¯„ä¼°
  - å³æ—¶åé¦ˆ

### ğŸ“Š è¿›åº¦è¿½è¸ª
- å­¦ä¹ å¤©æ•°ç»Ÿè®¡
- å­¦ä¹ æ—¶é•¿è®°å½•
- æŒæ¡å•è¯æ•°é‡
- è¿ç»­æ‰“å¡å¤©æ•°

## ğŸ›  æŠ€æœ¯æ ˆ

### å‰ç«¯æ¡†æ¶
- **React Native** 0.76.9 - è·¨å¹³å°ç§»åŠ¨åº”ç”¨æ¡†æ¶
- **Expo** ~52.0.38 - å¼€å‘å·¥å…·é“¾
- **Expo Router** ~4.0.20 - æ–‡ä»¶ç³»ç»Ÿè·¯ç”±
- **TypeScript** 5.1.3 - ç±»å‹å®‰å…¨

### UI ç»„ä»¶
- **expo-blur** - æ¨¡ç³Šæ•ˆæœ
- **lucide-react-native** - å›¾æ ‡åº“
- **react-native-svg** - SVG æ”¯æŒ
- **expo-linear-gradient** - æ¸å˜æ•ˆæœ

### çŠ¶æ€ç®¡ç† & æ•°æ®
- **Zustand** 5.0.8 - è½»é‡çº§çŠ¶æ€ç®¡ç†
- **i18next** 25.6.3 - å›½é™…åŒ–
- **react-i18next** 16.3.4 - React å›½é™…åŒ–ç»‘å®š
- **AsyncStorage** - æœ¬åœ°å­˜å‚¨

### å­—ä½“
- **Playfair Display** - è‹±æ–‡æ ‡é¢˜
- **Noto Serif SC** - ä¸­æ–‡æ­£æ–‡
- **Sarabun** - æ³°æ–‡ä¸“ç”¨

### åç«¯å‡†å¤‡
- **Tencent CloudBase** - äº‘å¼€å‘å¹³å°ï¼ˆå‡†å¤‡æ¥å…¥ï¼‰
- **Axios** - HTTP å®¢æˆ·ç«¯

## ğŸš€ å¿«é€Ÿå¼€å§‹

### ç¯å¢ƒè¦æ±‚
- Node.js >= 18.x
- npm æˆ– yarn
- iOS Simulator (macOS) æˆ– Android Emulator

### å®‰è£…æ­¥éª¤

1. **å…‹éš†ä»“åº“**
```bash
git clone https://github.com/yourusername/ThaiLearningApp.git
cd ThaiLearningApp
```

2. **å®‰è£…ä¾èµ–**
```bash
npm install
```

3. **å¯åŠ¨å¼€å‘æœåŠ¡å™¨**
```bash
npm start
```

4. **è¿è¡Œåº”ç”¨**
```bash
# iOS
npm run ios

# Android
npm run android

# Web
npm run web
```

### ç¯å¢ƒå˜é‡é…ç½®

åˆ›å»º `.env` æ–‡ä»¶ï¼š
```env
EXPO_PUBLIC_CLOUDBASE_ENV_ID=your_cloudbase_env_id
EXPO_PUBLIC_API_BASE_URL=your_api_base_url
```

## ğŸ“ é¡¹ç›®ç»“æ„

```
ThaiLearningApp/
â”œâ”€â”€ app/                          # Expo Router é¡µé¢
â”‚   â”œâ”€â”€ (auth)/                   # è®¤è¯æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ login.tsx
â”‚   â”‚   â”œâ”€â”€ register.tsx
â”‚   â”‚   â””â”€â”€ forgot-password.tsx
â”‚   â”œâ”€â”€ (tabs)/                   # ä¸»å¯¼èˆª
â”‚   â”‚   â”œâ”€â”€ index.tsx             # é¦–é¡µ
â”‚   â”‚   â”œâ”€â”€ courses.tsx           # è¯¾ç¨‹åˆ—è¡¨
â”‚   â”‚   â””â”€â”€ profile.tsx           # ä¸ªäººä¸­å¿ƒ
â”‚   â”œâ”€â”€ learning/                 # å­¦ä¹ æ¨¡å—
â”‚   â”‚   â””â”€â”€ index.tsx             # ç»Ÿä¸€å­¦ä¹ ä¼šè¯
â”‚   â””â”€â”€ _layout.tsx               # æ ¹å¸ƒå±€
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/               # ç»„ä»¶åº“
â”‚   â”‚   â”œâ”€â”€ common/               # é€šç”¨ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ learning/             # å­¦ä¹ ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ NewWordView.tsx   # æ–°è¯å­¦ä¹ 
â”‚   â”‚   â”‚   â””â”€â”€ ReviewWordView.tsx # å¤ä¹ è§†å›¾
â”‚   â”‚   â”œâ”€â”€ progress/             # è¿›åº¦ç»„ä»¶
â”‚   â”‚   â””â”€â”€ pronunciation/        # å‘éŸ³ç»„ä»¶
â”‚   â”œâ”€â”€ constants/                # å¸¸é‡å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ colors.ts             # é¢œè‰²ç³»ç»Ÿ
â”‚   â”‚   â””â”€â”€ typography.ts         # å­—ä½“ç³»ç»Ÿ
â”‚   â”œâ”€â”€ i18n/                     # å›½é™…åŒ–
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ locales/
â”‚   â”‚       â”œâ”€â”€ zh.ts             # ä¸­æ–‡
â”‚   â”‚       â””â”€â”€ en.ts             # è‹±æ–‡
â”‚   â”œâ”€â”€ stores/                   # Zustand çŠ¶æ€
â”‚   â”‚   â”œâ”€â”€ authStore.ts
â”‚   â”‚   â”œâ”€â”€ languageStore.ts
â”‚   â”‚   â””â”€â”€ learningStore.ts
â”‚   â”œâ”€â”€ entities/                 # ç±»å‹å®šä¹‰
â”‚   â””â”€â”€ utils/                    # å·¥å…·å‡½æ•°
â”œâ”€â”€ cloudbase/                    # äº‘å¼€å‘
â”‚   â””â”€â”€ functions/                # äº‘å‡½æ•°
â”œâ”€â”€ docs/                         # æ–‡æ¡£
â”‚   â”œâ”€â”€ project-snapshot-v5.md    # é¡¹ç›®å¿«ç…§
â”‚   â””â”€â”€ screenshots/              # æˆªå›¾
â””â”€â”€ assets/                       # é™æ€èµ„æº
```

## ğŸ¨ è®¾è®¡ç³»ç»Ÿ

### é¢œè‰²è§„èŒƒ
```typescript
Colors = {
  paper: '#FAF9F6',      // èƒŒæ™¯è‰²
  ink: '#1A1A1A',        // ä¸»æ–‡æœ¬
  sand: '#E5E2DB',       // è¾¹æ¡†
  taupe: '#8E8B82',      // æ¬¡è¦æ–‡æœ¬
  thaiGold: '#D4AF37',   // å¼ºè°ƒè‰²
  accent: '#B8956A',     // è¾…åŠ©è‰²
}
```

### å­—ä½“è§„èŒƒ
- **æ ‡é¢˜**: Playfair Display (è‹±æ–‡) / Noto Serif SC (ä¸­æ–‡)
- **æ­£æ–‡**: Noto Serif SC
- **æ³°æ–‡**: Sarabun

### ç»„ä»¶è§„èŒƒ
è¯¦è§ [é¡¹ç›®å¿«ç…§ v5](./docs/project-snapshot-v5.md)

## ğŸ’» å¼€å‘æŒ‡å—

### æ·»åŠ æ–°é¡µé¢
ä½¿ç”¨ Expo Router æ–‡ä»¶ç³»ç»Ÿè·¯ç”±ï¼š
```bash
# åˆ›å»ºæ–°é¡µé¢
touch app/new-page.tsx
```

### æ·»åŠ æ–°ç»„ä»¶
```bash
# åˆ›å»ºç»„ä»¶
touch src/components/MyComponent.tsx
```

### å›½é™…åŒ–
1. åœ¨ `src/i18n/locales/zh.ts` å’Œ `en.ts` æ·»åŠ ç¿»è¯‘é”®
2. åœ¨ç»„ä»¶ä¸­ä½¿ç”¨ï¼š
```tsx
import { useTranslation } from 'react-i18next';

const MyComponent = () => {
  const { t } = useTranslation();
  return <Text>{t('myKey')}</Text>;
};
```

### çŠ¶æ€ç®¡ç†
ä½¿ç”¨ Zustandï¼š
```tsx
import { create } from 'zustand';

const useMyStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}));
```

## ï¿½ åç«¯æ¥å…¥

### æ•°æ®ç»“æ„

#### å•è¯ (Word)
```typescript
interface WordData {
  id: string;
  thai: string;           // æ³°æ–‡
  phonetic: string;       // ç½—é©¬éŸ³
  type: string;           // è¯æ€§
  meaning: string;        // é‡Šä¹‰
  definitions: {
    basic: string;
    examples: { thai: string; meaning: string }[];
    usage: { /* ... */ };
  };
}
```

### API æ¥å£

#### è·å–å­¦ä¹ é˜Ÿåˆ—
```typescript
GET /api/learning/queue
Response: {
  reviewWords: WordData[];
  newWords: WordData[];
}
```

#### æäº¤å­¦ä¹ ç»“æœ
```typescript
POST /api/learning/submit
Body: {
  wordId: string;
  quality: 'know' | 'unsure' | 'forgot';
  timestamp: number;
}
```

è¯¦ç»†åç«¯æ¥å…¥æŒ‡å—è¯·å‚è€ƒ [é¡¹ç›®å¿«ç…§ v5](./docs/project-snapshot-v5.md#åç«¯æ¥å…¥æŒ‡å—)

## ğŸ“ å¼€å‘è§„èŒƒ

### ä»£ç é£æ ¼
- ä½¿ç”¨ TypeScript ä¸¥æ ¼æ¨¡å¼
- ç»„ä»¶ä½¿ç”¨å‡½æ•°å¼ç»„ä»¶ + Hooks
- æ ·å¼ä½¿ç”¨ StyleSheet.create()
- æ‰€æœ‰ç”¨æˆ·å¯è§æ–‡æœ¬å¿…é¡»å›½é™…åŒ–

### å‘½åè§„èŒƒ
- ç»„ä»¶æ–‡ä»¶: `PascalCase.tsx`
- å·¥å…·æ–‡ä»¶: `camelCase.ts`
- å¸¸é‡æ–‡ä»¶: `camelCase.ts`
- æ ·å¼å: `camelCase`

### Git æäº¤è§„èŒƒ
```
feat: æ–°åŠŸèƒ½
fix: ä¿®å¤bug
docs: æ–‡æ¡£æ›´æ–°
style: ä»£ç æ ¼å¼è°ƒæ•´
refactor: é‡æ„
test: æµ‹è¯•ç›¸å…³
chore: æ„å»º/å·¥å…·é“¾ç›¸å…³
```

## ğŸ—º è·¯çº¿å›¾

### v1.1 (è®¡åˆ’ä¸­)
- [ ] æ¥å…¥çœŸå®åç«¯ API
- [ ] å®ç°éŸ³é¢‘æ’­æ”¾åŠŸèƒ½
- [ ] æ·»åŠ å­¦ä¹ ç»Ÿè®¡å›¾è¡¨
- [ ] å®ç°ç¦»çº¿ç¼“å­˜

### v1.2 (è®¡åˆ’ä¸­)
- [ ] å®ç° SM-2 é—´éš”é‡å¤ç®—æ³•
- [ ] æ·»åŠ å•è¯æ”¶è—åŠŸèƒ½
- [ ] å®ç°å­¦ä¹ æé†’é€šçŸ¥
- [ ] æ·»åŠ ç¤¾äº¤åˆ†äº«åŠŸèƒ½

### v2.0 (è§„åˆ’ä¸­)
- [ ] AI è¯­éŸ³è¯„æµ‹
- [ ] ä¸ªæ€§åŒ–å­¦ä¹ è·¯å¾„
- [ ] ç¤¾åŒºäº’åŠ¨åŠŸèƒ½
- [ ] æ¸¸æˆåŒ–å­¦ä¹ 

## ğŸ¤ è´¡çŒ®æŒ‡å—

æ¬¢è¿è´¡çŒ®ä»£ç ï¼è¯·éµå¾ªä»¥ä¸‹æ­¥éª¤ï¼š

1. Fork æœ¬ä»“åº“
2. åˆ›å»ºç‰¹æ€§åˆ†æ”¯ (`git checkout -b feature/AmazingFeature`)
3. æäº¤æ›´æ”¹ (`git commit -m 'feat: Add some AmazingFeature'`)
4. æ¨é€åˆ°åˆ†æ”¯ (`git push origin feature/AmazingFeature`)
5. å¼€å¯ Pull Request

## ğŸ“„ è®¸å¯è¯

æœ¬é¡¹ç›®é‡‡ç”¨ MIT è®¸å¯è¯ - è¯¦è§ [LICENSE](LICENSE) æ–‡ä»¶

## ğŸ‘¥ å›¢é˜Ÿ

- **å¼€å‘è€…**: Liang Jianyu
- **è®¾è®¡**: ThaiLearningApp Team

## ğŸ“§ è”ç³»æ–¹å¼

- é¡¹ç›®ä¸»é¡µ: [GitHub](https://github.com/yourusername/ThaiLearningApp)
- é—®é¢˜åé¦ˆ: [Issues](https://github.com/yourusername/ThaiLearningApp/issues)

## ğŸ™ è‡´è°¢

- [Expo](https://expo.dev/) - ä¼˜ç§€çš„å¼€å‘å·¥å…·é“¾
- [React Native](https://reactnative.dev/) - å¼ºå¤§çš„è·¨å¹³å°æ¡†æ¶
- [Lucide Icons](https://lucide.dev/) - ç²¾ç¾çš„å›¾æ ‡åº“
- æ‰€æœ‰è´¡çŒ®è€…å’Œæ”¯æŒè€…

---

<div align="center">

**[â¬† å›åˆ°é¡¶éƒ¨](#-thailearningapp---æ³°è¯­å­¦ä¹ åº”ç”¨)**

Made with â¤ï¸ by ThaiLearningApp Team

</div>
</file>

<file path="tsconfig.json">
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "jsx": "react-native",
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path="app/(tabs)/_layout.tsx">
// app/(tabs)/_layout.tsx
import { Tabs } from 'expo-router';
import { View, Text, Pressable, Platform, StyleSheet } from 'react-native';
import { Home, BookOpen, User } from 'lucide-react-native';
import { BlurView } from 'expo-blur';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

interface TabButtonProps {
  icon: React.ComponentType<any>;
  label: string;
  isActive: boolean;
  onPress: () => void;
}

function TabButton({ icon: Icon, label, isActive, onPress }: TabButtonProps) {
  return (
    <Pressable onPress={onPress} style={styles.tabButton}>
      <Icon
        size={22}
        strokeWidth={isActive ? 2 : 1.5}
        color={isActive ? Colors.ink : Colors.taupe}
      />
      <Text
        style={[
          styles.tabLabel,
          {
            color: isActive ? Colors.ink : Colors.taupe,
            fontFamily: Typography.notoSerifRegular,
          }
        ]}
      >
        {label}
      </Text>
    </Pressable>
  );
}

interface CustomTabBarProps {
  state: any;
  descriptors: any;
  navigation: any;
}

function CustomTabBar({ state, navigation }: CustomTabBarProps) {

  const insets = useSafeAreaInsets();

  return (
    <View
      style={[
        styles.tabBarContainer,
        {
          height: 64 + insets.bottom,
          paddingBottom: insets.bottom,
        }
      ]}
    >
      {Platform.OS === 'ios' && (
        <BlurView
          intensity={80}
          tint="light"
          style={StyleSheet.absoluteFill}
        />
      )}

      <View style={styles.tabBarContent}>
        {/* Left: Learn */}
        <TabButton
          icon={BookOpen}
          label="å­¦ä¹ "
          isActive={state.index === 1}
          onPress={() => navigation.navigate('courses')}
        />

        {/* Center: Home (Protruding) */}
        <View style={[styles.centerButtonContainer]}>
          <Pressable
            onPress={() => navigation.navigate('index')}
            style={[
              styles.centerButton,
              {
                backgroundColor: state.index === 0 ? Colors.ink : Colors.white,
              }
            ]}
          >
            <Home
              size={40}
              strokeWidth={2}
              color={state.index === 0 ? Colors.white : Colors.taupe}

            />
          </Pressable>
        </View>

        {/* Right: Profile */}
        <TabButton
          icon={User}
          label="æˆ‘çš„"
          isActive={state.index === 2}
          onPress={() => navigation.navigate('profile')}
        />
      </View>
    </View>
  );
}

export default function TabsLayout() {
  return (
    <Tabs
      screenOptions={{
        headerShown: false,
      }}
      tabBar={(props) => <CustomTabBar {...props} />}
    >
      <Tabs.Screen name="index" />
      <Tabs.Screen name="courses" />
      {/* profile è·¯ç”±ç”±æ–‡ä»¶ç³»ç»Ÿè‡ªåŠ¨åˆ›å»ºï¼Œæ— éœ€æ‰‹åŠ¨å£°æ˜ */}
    </Tabs>
  );
}

const styles = StyleSheet.create({
  tabBarContainer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    borderTopWidth: 1,
    borderTopColor: Colors.sand,
    backgroundColor: Platform.OS === 'ios' ? 'transparent' : Colors.white,
  },
  tabBarContent: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 48,
  },
  tabButton: {
    flexDirection: 'column',
    alignItems: 'center',
    gap: 4,
  },
  tabLabel: {
    fontSize: 10,
    fontWeight: '500',
    letterSpacing: 1.5,
  },
  centerButtonContainer: {
    position: 'absolute',
    left: '60%',
    marginLeft: -42,
  },
  centerButton: {
    width: 90,
    height: 90,
    borderRadius: 45,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 4,
    borderColor: Colors.paper,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 8,
  },
});
</file>

<file path="app/alphabet/index.tsx">
// app/alphabet/index.tsx
// å­—æ¯è¯¾ç¨‹æ€»è§ˆé¡µï¼ˆè¯¾ç¨‹å…¥å£ â†’ Lesson 1~5ï¼‰

import React, { useEffect, useState, useRef, useMemo, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  Pressable,
  ActivityIndicator,
  Modal,
  Animated,
  Dimensions,
  TouchableWithoutFeedback
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { ArrowLeft, X, BookOpen, ChevronRight } from 'lucide-react-native';

import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { getAllLessons } from '@/src/config/alphabet/lessonMetadata.config';
import type { LessonMetadata } from '@/src/entities/types/phonicsRule.types';
import { callCloudFunction } from '@/src/utils/apiClient';
import { API_ENDPOINTS } from '@/src/config/api.endpoints';
import { useModuleAccessStore } from '@/src/stores/moduleAccessStore';

const { height: SCREEN_HEIGHT } = Dimensions.get('window');

interface LessonCardProps {
  id: string;
  title: string;
  description: string;
  letterKeys: string[];
  lessonData: LessonMetadata; // Store full metadata for drawer
  isCurrent: boolean;
  progress?: {
    completed: number;
    total: number;
  };
}

// --- Drawer Component ---

interface LessonDrawerProps {
  visible: boolean;
  lesson: LessonCardProps | null;
  onClose: () => void;
  onStart: () => void;
  unlocked: boolean;
}

const LessonDrawer = ({ visible, lesson, onClose, onStart, unlocked }: LessonDrawerProps) => {
  const slideAnim = useRef(new Animated.Value(SCREEN_HEIGHT)).current;
  const fadeAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (visible) {
      Animated.parallel([
        Animated.timing(slideAnim, {
          toValue: 0,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      Animated.parallel([
        Animated.timing(slideAnim, {
          toValue: SCREEN_HEIGHT,
          duration: 250,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 0,
          duration: 250,
          useNativeDriver: true,
        }),
      ]).start();
    }
  }, [visible, slideAnim, fadeAnim]);

  if (!lesson) return null;

  const { lessonData } = lesson;
  const allLetters = [
    ...lessonData.consonants,
    ...lessonData.vowels,
    ...lessonData.tones
  ];

  return (
    <Modal transparent visible={visible} onRequestClose={onClose}>
      <View style={drawerStyles.overlay}>
        <TouchableWithoutFeedback onPress={onClose}>
          <Animated.View style={[drawerStyles.backdrop, { opacity: fadeAnim }]} />
        </TouchableWithoutFeedback>

        <Animated.View
          style={[
            drawerStyles.sheet,
            { transform: [{ translateY: slideAnim }] }
          ]}
        >
          <View style={drawerStyles.handle} />

          {/* Header */}
          <View style={drawerStyles.header}>
            <View style={{ flex: 1 }}>
              <Text style={drawerStyles.title}>{lesson.title}</Text>
              <Text style={drawerStyles.subtitle}>Expected time: 15 mins</Text>
            </View>
            <Pressable onPress={onClose} style={drawerStyles.closeButton}>
              <X size={24} color={Colors.taupe} />
            </Pressable>
          </View>

          <ScrollView contentContainerStyle={drawerStyles.content}>
            <Text style={drawerStyles.sectionTitle}>Description</Text>
            <Text style={drawerStyles.description}>{lesson.description}</Text>

            <Text style={drawerStyles.sectionTitle}>Content Preview ({allLetters.length} items)</Text>
            <View style={drawerStyles.grid}>
              {allLetters.map((char, index) => (
                <View key={index} style={drawerStyles.gridItem}>
                  <Text style={drawerStyles.gridChar}>{char}</Text>
                </View>
              ))}
            </View>
          </ScrollView>

          {/* Footer Action */}
          <View style={drawerStyles.footer}>
            <Pressable
              style={[drawerStyles.startButton, !unlocked && drawerStyles.disabledBtn]}
              onPress={onStart}
              disabled={!unlocked}
            >
              <Text style={drawerStyles.startButtonText}>
                {unlocked ? 'Start Learning' : 'Locked'}
              </Text>
              {unlocked && <ChevronRight size={20} color={Colors.white} />}
            </Pressable>
          </View>
        </Animated.View>
      </View>
    </Modal>
  );
};

// --- Main Screen ---

export default function AlphabetCoursesScreen() {
  const router = useRouter();

  const [lessons, setLessons] = useState<LessonCardProps[]>([]);
  const [loading, setLoading] = useState<boolean>(true);

  // Drawer State
  const [selectedLesson, setSelectedLesson] = useState<LessonCardProps | null>(null);
  const [drawerVisible, setDrawerVisible] = useState(false);

  // ğŸ”¥ TODO-07: ä½¿ç”¨ moduleAccessStore è¯»å–å·²å®Œæˆè¯¾ç¨‹åˆ—è¡¨
  const { userProgress, getUserProgress } = useModuleAccessStore();
  const completedLessons = userProgress?.completedAlphabetLessons ?? [];

  // ğŸ”¥ TODO-07: ç¡®ä¿è¿›å…¥é¡µé¢æ—¶åŠ è½½ç”¨æˆ·è¿›åº¦
  useEffect(() => {
    getUserProgress();
  }, [getUserProgress]);

  useEffect(() => {
    let mounted = true;

    const mapLessons = (list: LessonMetadata[]): LessonCardProps[] =>
      list.map((lesson) => {
        const letterKeys = [
          ...lesson.consonants,
          ...lesson.vowels,
          ...lesson.tones,
        ];

        return {
          id: lesson.lessonId,
          title: lesson.title,
          description: lesson.description,
          letterKeys,
          lessonData: lesson,
          isCurrent: false,
          progress: {
            completed: 0,
            total: lesson.totalCount,
          },
        };
      });

    (async () => {
      try {
        const res = await callCloudFunction<{ lessons: LessonMetadata[] }>(
          'getAlphabetLessons',
          {},
          {
            endpoint: API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase,
          },
        );

        const list: LessonMetadata[] =
          (res.success && res.data?.lessons) || getAllLessons();

        if (!mounted) return;
        setLessons(mapLessons(list));
      } catch {
        if (!mounted) return;
        setLessons(mapLessons(getAllLessons()));
      } finally {
        if (mounted) setLoading(false);
      }
    })();

    return () => {
      mounted = false;
    };
  }, []);

  // ğŸ”¥ TODO-07: è¿›åº¦ç™¾åˆ†æ¯”åŸºäºå·²å®Œæˆè¯¾ç¨‹æ•°,è€Œéå­—æ¯æ•°
  const totalLessons = lessons.length;
  const overallProgressPercent =
    totalLessons > 0
      ? Math.min(100, Math.round((completedLessons.length / totalLessons) * 100))
      : 0;

  const handleCardPress = (lesson: LessonCardProps) => {
    setSelectedLesson(lesson);
    setDrawerVisible(true);
  };

  const handleStartLesson = (lessonId: string) => {
    setDrawerVisible(false);
    router.push(`/alphabet/${lessonId}`);
  };

  // ğŸ”¥ TODO-07: è¯¾ç¨‹è§£é”é€»è¾‘åªä¾èµ– completedAlphabetLessons
  // è§„åˆ™: lesson1 æ°¸è¿œè§£é”, lessonN éœ€è¦ lesson(N-1) å·²å®Œæˆ
  const isLessonUnlocked = useCallback((lessonIndex: number): boolean => {
    if (lessonIndex === 0) return true; // lesson1 æ°¸è¿œè§£é”
    const prevLessonId = lessons[lessonIndex - 1]?.id;
    return prevLessonId ? completedLessons.includes(prevLessonId) : false;
  }, [lessons, completedLessons]);

  // Helper to check unlocked status for modal
  const isSelectedUnlocked = useMemo(() => {
    if (!selectedLesson) return false;
    const index = lessons.findIndex(l => l.id === selectedLesson.id);
    if (index === -1) return false;
    return isLessonUnlocked(index);
  }, [selectedLesson, lessons, isLessonUnlocked]);


  return (
    <SafeAreaView edges={['top', 'bottom']} style={styles.container}>

      <View style={styles.backRow}>
        <Pressable onPress={() => router.back()} style={styles.backButton}>
          <ArrowLeft size={24} color={Colors.taupe} />
          <Text style={styles.backText}>Back</Text>
        </Pressable>
      </View>

      <View style={styles.headerContainer}>
        <Text style={styles.headerTitle}>Alphabet Course</Text>
        <Text style={styles.headerSubtitle}>
          {lessons.length} Lessons Â· {overallProgressPercent}% Completed
        </Text>
      </View>

      {loading ? (
        <View style={{ flex: 1, justifyContent: 'center' }}>
          <ActivityIndicator size="large" color={Colors.thaiGold} />
        </View>
      ) : (
        <View style={{ flex: 1 }}>
          <ScrollView style={styles.scroll} contentContainerStyle={styles.inner}>
            <ThaiPatternBackground opacity={0.12} />

            {lessons.map((lesson, index) => {
              // ğŸ”¥ TODO-07: è§£é”é€»è¾‘ç»Ÿä¸€ä¸º completedAlphabetLessons
              const unlocked = isLessonUnlocked(index);

              // ğŸ”¥ TODO-07: "å½“å‰è¯¾ç¨‹" = ç¬¬ä¸€ä¸ªå·²è§£é”ä½†æœªå®Œæˆçš„è¯¾ç¨‹
              const isCompleted = completedLessons.includes(lesson.id);
              const isCurrent = unlocked && !isCompleted;

              return (
                <Pressable
                  key={lesson.id}
                  style={[styles.card, isCurrent && styles.activeCard]}
                  onPress={() => handleCardPress(lesson)}
                >
                  <View style={styles.cardPressable}>
                    <View style={styles.info}>
                      <View style={styles.cardHeader}>
                        <Text style={styles.title} numberOfLines={1}>
                          {lesson.title}
                        </Text>
                        {isCurrent && (
                          <View style={styles.currentBadge}>
                            <Text style={styles.currentBadgeText}>Current</Text>
                          </View>
                        )}
                      </View>

                      <Text style={styles.description} numberOfLines={2}>
                        {lesson.description}
                      </Text>

                      <View style={styles.footer}>
                        <View style={styles.metaColumn}>
                          <Text style={styles.lessonMeta}>
                            {lesson.letterKeys.length} letters
                          </Text>
                        </View>

                        {/* Start Learning Button - Direct Access */}
                        <Pressable
                          disabled={!unlocked}
                          style={[
                            styles.startBtn,
                            isCurrent && styles.activeStartBtn,
                            !unlocked && styles.disabledStartBtn,
                          ]}
                          // Stop propagation to prevent opening drawer when clicking Start directly
                          onPress={(e) => {
                            e.stopPropagation();
                            router.push(`/alphabet/${lesson.id}`);
                          }}
                        >
                          <Text
                            style={[
                              styles.startBtnText,
                              isCurrent && styles.activeStartBtnText,
                            ]}
                          >
                            {unlocked ? 'Start' : 'Locked'}
                          </Text>
                        </Pressable>
                      </View>
                    </View>
                  </View>
                </Pressable>
              );
            })}

            <View style={{ height: 100 }} />
          </ScrollView>

          {/* Fixed Footer for Test Entry */}
          <View style={styles.footerContainer}>
            <Pressable
              style={({ pressed }) => [
                styles.unlockAllBtn,
                pressed && { opacity: 0.9, transform: [{ scale: 0.98 }] }
              ]}
              onPress={() => router.push('/alphabet/test')}
            >
              <Text style={styles.unlockAllText}>
                Take Test to Unlock All
              </Text>
            </Pressable>
          </View>
        </View>
      )}

      {/* Detail Drawer */}
      <LessonDrawer
        visible={drawerVisible}
        lesson={selectedLesson}
        unlocked={isSelectedUnlocked}
        onClose={() => setDrawerVisible(false)}
        onStart={() => selectedLesson && handleStartLesson(selectedLesson.id)}
      />

    </SafeAreaView >
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.paper,
  },
  headerContainer: {
    alignItems: "center",
    marginBottom: 8,
  },
  scroll: {
    flex: 1,
  },
  inner: {
    paddingHorizontal: 24,
    paddingVertical: 16,
    gap: 16,
    paddingBottom: 48,
  },
  backRow: {
    width: '100%',
    paddingHorizontal: 16,
    paddingVertical: 8,
    alignItems: 'flex-start',
  },
  backButton: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 8,
    borderRadius: 8,
  },
  backText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.taupe,
    marginLeft: 4,
  },
  headerTitle: {
    fontFamily: Typography.playfairBold,
    fontSize: 28,
    color: Colors.ink,
    marginBottom: 4,
  },
  headerSubtitle: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  card: {
    flexDirection: 'row',
    backgroundColor: Colors.white,
    borderRadius: 16,
    overflow: 'hidden',
    borderWidth: 1,
    borderColor: '#EFEFEF',
    minHeight: 120,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 8,
    elevation: 3,
  },
  activeCard: {
    borderColor: Colors.thaiGold,
    borderWidth: 1.5,
    backgroundColor: '#FFFCF5',
  },
  cardPressable: {
    flex: 1,
    flexDirection: 'row',
  },
  info: {
    flex: 1,
    padding: 16,
    justifyContent: 'space-between',
    gap: 8,
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    gap: 8,
  },
  title: {
    flex: 1,
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.ink,
  },
  currentBadge: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    backgroundColor: 'rgba(212, 175, 55, 0.1)',
    borderRadius: 4,
  },
  currentBadgeText: {
    fontSize: 10,
    color: Colors.thaiGold,
    fontFamily: Typography.notoSerifBold,
    textTransform: 'uppercase',
  },
  description: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 13,
    color: Colors.taupe,
    lineHeight: 18,
  },
  lessonMeta: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 12,
    color: Colors.taupe,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 8,
  },
  metaColumn: {
    flex: 1,
  },
  startBtn: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: Colors.ink,
    borderRadius: 20,
  },
  activeStartBtn: {
    backgroundColor: Colors.thaiGold,
  },
  startBtnText: {
    fontSize: 12,
    color: Colors.white,
    fontFamily: Typography.notoSerifBold,
  },
  activeStartBtnText: {
    color: Colors.white,
  },
  disabledStartBtn: {
    backgroundColor: '#E0E0E0',
  },
  // Footer Button Styles
  footerContainer: {
    padding: 24,
    paddingBottom: 34, // Extra padding for safe area
    backgroundColor: Colors.white,
    borderTopWidth: 1,
    borderTopColor: Colors.sand,
  },
  unlockAllBtn: {
    width: '100%',
    backgroundColor: Colors.ink,
    paddingVertical: 16,
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 12,
    elevation: 8,
  },
  unlockAllText: {
    fontFamily: Typography.playfairBold,
    fontSize: 16,
    color: Colors.white,
    letterSpacing: 0.5,
  },
});

const drawerStyles = StyleSheet.create({
  overlay: {
    flex: 1,
    justifyContent: 'flex-end',
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  backdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'black',
  },
  sheet: {
    backgroundColor: Colors.paper,
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    maxHeight: '80%',
    minHeight: '50%',
    paddingBottom: 34,
  },
  handle: {
    width: 40,
    height: 4,
    backgroundColor: '#E0E0E0',
    borderRadius: 2,
    alignSelf: 'center',
    marginTop: 12,
    marginBottom: 8,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    paddingHorizontal: 24,
    paddingTop: 16,
    paddingBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#F0F0F0',
  },
  title: {
    fontFamily: Typography.playfairBold,
    fontSize: 24,
    color: Colors.ink,
    marginBottom: 4,
  },
  subtitle: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  closeButton: {
    padding: 4,
  },
  content: {
    padding: 24,
  },
  sectionTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.ink,
    marginBottom: 12,
    marginTop: 8,
  },
  description: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 15,
    color: Colors.taupe,
    lineHeight: 22,
    marginBottom: 24,
  },
  grid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 12,
  },
  gridItem: {
    width: 48,
    height: 48,
    borderRadius: 12,
    backgroundColor: Colors.white,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#EFEFEF',
  },
  gridChar: {
    fontFamily: Typography.playfairBold,
    fontSize: 20,
    color: Colors.ink,
  },
  footer: {
    padding: 24,
    borderTopWidth: 1,
    borderTopColor: '#F0F0F0',
  },
  startButton: {
    backgroundColor: Colors.thaiGold,
    borderRadius: 16,
    paddingVertical: 16,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    gap: 8,
    shadowColor: Colors.thaiGold,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 4,
  },
  startButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 18,
    color: Colors.white,
  },
  disabledBtn: {
    backgroundColor: '#E0E0E0',
    shadowOpacity: 0,
  }
});
</file>

<file path="app/_layout.tsx">
import { Stack, useRouter, useSegments, useRootNavigationState } from 'expo-router';
import { useEffect, useRef } from 'react';
import { useFonts } from 'expo-font';
import * as SplashScreen from 'expo-splash-screen';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { useUserStore } from '@/src/stores/userStore';
import { useModuleAccessStore } from '@/src/stores/moduleAccessStore';
import '../global.css';
import { useState } from 'react';

// Prevent the splash screen from auto-hiding before asset loading
SplashScreen.preventAutoHideAsync();

export default function RootLayout() {
  const segments = useSegments();
  const router = useRouter();
  const navigationState = useRootNavigationState();
  const { isAuthenticated } = useUserStore();
  const { checkAccess, getUserProgress } = useModuleAccessStore();
  const [navReady, setNavReady] = useState(false);
  const didInitDevAccessRef = useRef(false);

  const [fontsLoaded, fontError] = useFonts({
    // Font loading temporarily disabled - font files not found
  });

  useEffect(() => {
    if (fontsLoaded || fontError) {
      SplashScreen.hideAsync();
    }
  }, [fontsLoaded, fontError]);

  useEffect(() => {
    const ready =
      !!navigationState?.key &&
      Array.isArray((navigationState as any)?.routes) &&
      (navigationState as any).routes.length > 0;
    if (ready) {
      setNavReady(true);
    }
  }, [navigationState?.key, (navigationState as any)?.routes?.length]);

  useEffect(() => {
    // ç­‰å¾…æ ¹å¯¼èˆªå®Œæ•´æŒ‚è½½ï¼ˆkey å­˜åœ¨ä¸” routes éç©ºï¼‰åå†åšè·³è½¬ï¼Œé¿å…â€œæœªæŒ‚è½½å…ˆå¯¼èˆªâ€å´©æºƒ
    if (!navReady) return;
    if (!fontsLoaded && !fontError) return;
    const inAuthGroup = segments[0] === '(auth)';

    if (!isAuthenticated && !inAuthGroup) {
      router.replace('/(auth)/login');
    } else if (isAuthenticated && inAuthGroup) {
      router.replace('/(tabs)');
    }
  }, [isAuthenticated, segments, fontsLoaded, fontError, navReady, router]);

  useEffect(() => {
    if (!__DEV__) return;
    if (!isAuthenticated) return;
    if (didInitDevAccessRef.current) return;
    didInitDevAccessRef.current = true;

    (async () => {
      try {
        await getUserProgress();
        await checkAccess('word');
      } catch (error) {
        console.warn('âš ï¸ Dev access warmup failed:', error);
      }
    })();
  }, [isAuthenticated, checkAccess, getUserProgress]);

  if (!fontsLoaded && !fontError) {
    return null;
  }

  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <Stack screenOptions={{ headerShown: false }}>
        <Stack.Screen name="(auth)" />
        <Stack.Screen name="(tabs)" />
        <Stack.Screen
          name="review-modal"
          options={{
            presentation: 'fullScreenModal',
            animation: 'slide_from_bottom',
          }}
        />
      </Stack>
    </GestureHandlerRootView>
  );
}
</file>

<file path="src/components/learning/alphabet/AlphabetLearningEngineView.tsx">
// src/components/learning/alphabet/AlphabetLearningEngineView.tsx

import React from 'react';
import { View, ActivityIndicator, Text, SafeAreaView, TouchableOpacity } from 'react-native';
import { ChevronLeft } from 'lucide-react-native';

import { AlphabetLearningView } from '@/src/components/learning/alphabet/AlphabetLearningView';
import { AlphabetReviewView } from '@/src/components/learning/alphabet/AlphabetReviewView';
import { PhonicsRuleCard } from '@/src/components/learning/alphabet/PhonicsRuleCard';
import { SessionRecoveryCard } from '@/src/components/learning/alphabet/SessionRecoveryCard';
import { AlphabetCompletionView } from '@/src/components/learning/alphabet/AlphabetCompletionView';
import { RoundCompletionView } from '@/src/components/learning/alphabet/RoundCompletionView';
import type { AlphabetQueueItem } from '@/src/stores/alphabetStore';

import type { Phase } from '@/src/hooks/useAlphabetLearningEngine';
import type { QuestionType } from '@/src/entities/enums/QuestionType.enum';
import type { Letter } from '@/src/entities/types/letter.types';
import type {
  PhonicsRule,
  RoundEvaluationState,
} from '@/src/entities/types/phonicsRule.types';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

interface AlphabetLearningEngineViewProps {
  phase: Phase;
  initialized: boolean;
  currentRound: number;
  roundEvaluation?: RoundEvaluationState;
  currentItem: AlphabetQueueItem | null;
  currentQuestionType: QuestionType | null;
  letterPool?: Letter[];
  onAnswer: (isCorrect: boolean, questionType: QuestionType) => void;
  onNext: () => void;
  // REMOVED: onStartNextRound (Manual start happens in Lesson Page now)
  onBack?: () => void;
  phonicsRule?: PhonicsRule | null;
  showPhonicsRuleCard?: boolean;
  onCompletePhonicsRule?: () => void;

  // Recovery
  pendingRecoverySession?: any;
  resolveRecovery?: (choice: 'continue' | 'restart') => void;

  // New props for Observability
  queueIndex?: number;
  totalQueue?: number;

  onSkipYesterdayReview?: () => void;
}

// Helper to get friendly phase name
const getPhaseLabel = (phase: Phase) => {
  switch (phase) {
    case 'new-learning': return 'New Letters';
    case 'mini-review': return 'Quick Review';
    case 'final-review': return 'Final Review';
    case 'error-review': return 'Fix Mistakes';
    // ğŸ”¥ TODO-03: ç»Ÿä¸€ä½¿ç”¨ 'previous-review'
    case 'previous-review': return 'Warm Up';
    case 'round-completed': return 'Round Done';
    case 'finished': return 'Finished';
    default: return phase;
  }
};

function RoundHeader({
  currentRound,
  phase,
  queueIndex,
  totalQueue,
  onBack,
  onSkipYesterdayReview
}: {
  currentRound: number;
  phase: Phase;
  queueIndex?: number;
  totalQueue?: number;
  onBack?: () => void;
  onSkipYesterdayReview?: () => void;
}) {
  return (
    <View
      style={{
        paddingHorizontal: 16,
        paddingTop: 12,
        paddingBottom: 4,
        flexDirection: 'column',
        justifyContent: 'center',
        alignItems: 'center',
      }}
    >
      <View style={{ flexDirection: 'row', justifyContent: 'space-between', width: '100%', alignItems: 'center' }}>
        {/* Left: Back Button or Spacer */}
        <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>
          {onBack && (
            <TouchableOpacity onPress={onBack} hitSlop={12}>
              <ChevronLeft size={24} color={Colors.taupe} />
            </TouchableOpacity>
          )}
          <Text
            style={{
              fontFamily: Typography.notoSerifRegular,
              fontSize: 14,
              color: Colors.taupe,
            }}
          >
            Round {currentRound} / 3
          </Text>
        </View>

        {/* Visible Phase Label */}
        <View style={{
          backgroundColor: '#F0F0F0',
          paddingHorizontal: 8,
          paddingVertical: 4,
          borderRadius: 4
        }}>
          <Text style={{
            fontFamily: Typography.notoSerifBold,
            fontSize: 12,
            color: Colors.ink
          }}>
            {getPhaseLabel(phase)}
          </Text>
        </View>

        {/* Skip/Bury Button for previous-review */}
        {phase === 'previous-review' && onSkipYesterdayReview && (
          <TouchableOpacity
            style={{
              marginLeft: 8,
              paddingHorizontal: 12,
              paddingVertical: 4,
              backgroundColor: '#FFF0F0',
              borderRadius: 4,
              borderWidth: 1,
              borderColor: '#FFD0D0'
            }}
            onPress={onSkipYesterdayReview}
          >
            <Text style={{
              fontSize: 12,
              color: '#D00000',
              fontWeight: '600'
            }}>
              Skip (Bury)
            </Text>
          </TouchableOpacity>
        )}
      </View>
    </View>
  );
}



export function AlphabetLearningEngineView({
  phase,
  initialized,
  currentRound,
  roundEvaluation,
  currentItem,
  currentQuestionType,
  letterPool,
  onAnswer,
  onNext,
  // onStartNextRound, // Removed
  onBack,
  phonicsRule,
  showPhonicsRuleCard,
  onCompletePhonicsRule,
  onSkipYesterdayReview,
  pendingRecoverySession,
  resolveRecovery,

  queueIndex,
  totalQueue,
}: AlphabetLearningEngineViewProps) {

  // åŠ è½½çŠ¶æ€
  if (!initialized || !currentItem) {
    return (
      <SafeAreaView style={{ flex: 1, justifyContent: 'center' }}>
        <ActivityIndicator size="large" />
      </SafeAreaView>
    );
  }

  if (phase === 'finished') {
    return (
      <AlphabetCompletionView
        roundEvaluation={roundEvaluation}
        onFinish={onBack || (() => { })} // Fallback to no-op if onBack missing, but it handles router.back
      />
    );
  }

  if (phase === 'round-completed') {
    return (
      <RoundCompletionView
        roundNumber={currentRound}
        onFinish={onBack || (() => { console.warn('No Back Handler'); })}
      />
    );
  }

  const source = (currentItem as any)?.source;
  // ğŸ”¥ TODO-03: ç»Ÿä¸€ä½¿ç”¨ 'new-learning'
  const isNewLetter = source === 'new-learning';

  const hasValidRule = !!(phonicsRule && phonicsRule.title && phonicsRule.content?.length > 0);

  const shouldShowPhonicsRule =
    isNewLetter &&
    showPhonicsRuleCard &&
    hasValidRule &&
    onCompletePhonicsRule;

  const renderMainView = () => {

    if (shouldShowPhonicsRule) {
      return <PhonicsRuleCard rule={phonicsRule} onComplete={onCompletePhonicsRule} />;
    }

    if (!isNewLetter) {
      // Use currentQuestionType provided by engine, fallback to SoundToLetter if null
      return (
        <AlphabetReviewView
          alphabet={currentItem}
          letterPool={letterPool}
          preferredType={currentQuestionType ?? undefined}
          onAnswer={onAnswer}
          onNext={onNext}
          onBack={onBack}
        />
      );
    }

    return <AlphabetLearningView alphabet={currentItem} onNext={onNext} onBack={onBack} />;
  };

  return (
    <SafeAreaView style={{ flex: 1 }}>


      {/* ä¼˜å…ˆæ˜¾ç¤ºæ¢å¤å¼¹çª— */}
      {pendingRecoverySession && resolveRecovery && (
        <SessionRecoveryCard
          onContinue={() => resolveRecovery('continue')}
          onRestart={() => resolveRecovery('restart')}
        />
      )}

      <RoundHeader currentRound={currentRound} phase={phase} queueIndex={queueIndex} totalQueue={totalQueue} onSkipYesterdayReview={onSkipYesterdayReview} />

      {renderMainView()}
    </SafeAreaView>
  );
}
</file>

<file path="app/(auth)/login.tsx">
// app/(auth)/login.tsx
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, Pressable, StyleSheet, KeyboardAvoidingView, Platform, Alert } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { useTranslation } from 'react-i18next';
import Animated, { FadeInDown } from 'react-native-reanimated';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { LanguageSwitcher } from '@/src/components/common/LanguageSwitcher';
import { useUserStore } from '@/src/stores/userStore';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

export default function LoginScreen() {
  const { t } = useTranslation();
  const router = useRouter();
  const { login, isLoading, error, clearError } = useUserStore();

  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  // Clear error when component unmounts
  useEffect(() => {
    return () => {
      clearError();
    };
  }, []);

  // Show error alert if error changes
  useEffect(() => {
    if (error) {
      Alert.alert(t('common.error'), error);
    }
  }, [error]);

  const handleLogin = async () => {
    // Basic validation
    if (!email || !password) {
      Alert.alert(t('common.error'), 'Please fill in all fields');
      return;
    }

    // Email format validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      Alert.alert(t('common.error'), 'Please enter a valid email address');
      return;
    }

    // Call login action
    const success = await login({ email, password });

    if (success) {
      // Navigate to main app
      router.replace('/(tabs)');
    }
    // Error is handled by useEffect above
  };
  const handleForgotPassword = () => {
    router.push('/(auth)/forgot-password');
  };

  return (
    <SafeAreaView style={styles.container}>
      <ThaiPatternBackground opacity={0.08} />

      {/* Language Switcher */}
      <View style={styles.languageSwitcherContainer}>
        <LanguageSwitcher />
      </View>

      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <View style={styles.content}>
          {/* Logo & Title */}
          <Animated.View entering={FadeInDown.delay(100).duration(500)} style={styles.headerSection}>
            <Text style={styles.logo}>à¸Šà¸²</Text>
            <Text style={styles.title}>Thai Learning</Text>
            <Text style={styles.subtitle}>{t('auth.login')}</Text>
          </Animated.View>

          {/* Login Form */}
          <Animated.View entering={FadeInDown.delay(200).duration(500)} style={styles.formSection}>
            <View style={styles.inputContainer}>
              <Text style={styles.label}>{t('auth.email')}</Text>
              <TextInput
                style={styles.input}
                placeholder={t('auth.emailPlaceholder')}
                placeholderTextColor={Colors.taupe}
                value={email}
                onChangeText={setEmail}
                keyboardType="email-address"
                autoCapitalize="none"
                autoCorrect={false}
              />
            </View>

            <View style={styles.inputContainer}>
              <Text style={styles.label}>{t('auth.password')}</Text>
              <TextInput
                style={styles.input}
                placeholder={t('auth.passwordPlaceholder')}
                placeholderTextColor={Colors.taupe}
                value={password}
                onChangeText={setPassword}
                secureTextEntry
                autoCapitalize="none"
              />
            </View>

            <Pressable
              style={styles.forgotPassword}
              onPress={handleForgotPassword}
            >
              <Text style={styles.forgotPasswordText}>{t('auth.forgotPassword')}</Text>
            </Pressable>

            <Pressable
              style={[styles.loginButton, isLoading && styles.loginButtonDisabled]}
              onPress={handleLogin}
              disabled={isLoading}
            >
              <Text style={styles.loginButtonText}>
                {isLoading ? t('auth.logining') : t('auth.loginButton')}
              </Text>
            </Pressable>

            <View style={styles.registerSection}>
              <Text style={styles.registerText}>{t('auth.noAccount')}</Text>
              <Pressable onPress={() => router.push('/(auth)/register')}>
                <Text style={styles.registerLink}>{t('auth.register')}</Text>
              </Pressable>
            </View>
          </Animated.View>
        </View>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.paper,
  },
  languageSwitcherContainer: {
    position: 'absolute',
    top: 60,
    right: 24,
    zIndex: 10,
  },
  keyboardView: {
    flex: 1,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    paddingHorizontal: 32,
  },
  headerSection: {
    alignItems: 'center',
    marginBottom: 48,
  },
  logo: {
    fontFamily: Typography.sarabunBold,
    fontSize: 72,
    color: Colors.thaiGold,
    marginBottom: 8,
  },
  title: {
    fontFamily: Typography.playfairBold,
    fontSize: 28,
    color: Colors.ink,
    marginBottom: 4,
  },
  subtitle: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.taupe,
  },
  formSection: {
    width: '100%',
  },
  inputContainer: {
    marginBottom: 20,
  },
  label: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.ink,
    marginBottom: 8,
  },
  input: {
    fontFamily: Typography.notoSerifRegular,
    height: 56,
    backgroundColor: Colors.white,
    borderWidth: 1,
    borderColor: Colors.sand,
    borderRadius: 16,
    paddingHorizontal: 20,
    fontSize: 16,
    color: Colors.ink,
  },
  forgotPassword: {
    alignSelf: 'flex-end',
    marginBottom: 24,
  },
  forgotPasswordText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.thaiGold,
  },
  loginButton: {
    height: 56,
    backgroundColor: Colors.ink,
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  loginButtonDisabled: {
    opacity: 0.6,
  },
  loginButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
    fontWeight: '600',
  },
  registerSection: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 24,
    gap: 8,
  },
  registerText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  registerLink: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    color: Colors.thaiGold,
    fontWeight: '600',
  },
});
</file>

<file path="app/learning/index.tsx">
import React, { useEffect, useState } from 'react';
import { useTranslation } from 'react-i18next';
import { View, Text, StyleSheet, Pressable, Alert } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter, useLocalSearchParams } from 'expo-router';
import { X } from 'lucide-react-native';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { NewWordView, WordData } from '@/src/components/learning/NewWordView';
import { ReviewWordView } from '@/src/components/learning/ReviewWordView';
import { AlphabetLearningView } from '@/src/components/learning/alphabet/AlphabetLearningView';
import { AlphabetReviewView } from '@/src/components/learning/alphabet/AlphabetReviewView';
import { useVocabularyStore } from '@/src/stores/vocabularyStore';
import { useLearningPreferenceStore } from '@/src/stores/learningPreferenceStore';
import { useAlphabetStore } from '@/src/stores/alphabetStore';
import { LearningPhase } from '@/src/entities/enums/LearningPhase.enum';
import { useUserStore } from '@/src/stores/userStore';


// --- Mock Data ---

const MOCK_OLD_WORDS: WordData[] = [
    {
        id: 'old1',
        thai: 'à¸à¸´à¸™',
        phonetic: 'Kin',
        type: 'åŠ¨è¯',
        meaning: 'åƒ',
        definitions: {
            basic: 'åƒï¼Œé£Ÿç”¨',
            examples: [
                { thai: 'à¸à¸´à¸™à¸‚à¹‰à¸²à¸§à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡', meaning: 'åƒé¥­äº†å—ï¼Ÿ' },
                { thai: 'à¸Šà¸­à¸šà¸à¸´à¸™à¹€à¸œà¹‡à¸”', meaning: 'å–œæ¬¢åƒè¾£' }
            ],
            usage: {
                grammar: [],
                diff: 'æ— ',
                mistakes: 'å£è¯­å¸¸ç”¨ï¼Œæ­£å¼åœºåˆå¯ç”¨ à¸£à¸±à¸šà¸›à¸£à¸°à¸—à¸²à¸™',
                similar: 'à¸—à¸²à¸™ (æ›´ç¤¼è²Œ)'
            }
        }
    },
    {
        id: 'old2',
        thai: 'à¸™à¸­à¸™',
        phonetic: 'Non',
        type: 'åŠ¨è¯',
        meaning: 'ç¡',
        definitions: {
            basic: 'ç¡è§‰ï¼Œèºº',
            examples: [
                { thai: 'à¸™à¸­à¸™à¸«à¸¥à¸±à¸šà¸à¸±à¸™à¸”à¸µ', meaning: 'ç¡ä¸ªå¥½è§‰ (æ™šå®‰)' },
                { thai: 'à¸‚à¸µà¹‰à¹€à¸à¸µà¸¢à¸ˆà¸™à¸­à¸™à¸•à¸·à¹ˆà¸™à¸ªà¸²à¸¢', meaning: 'æ‡’å¾—ç¡æ‡’è§‰' }
            ],
            usage: {
                grammar: [],
                diff: 'æ— ',
                mistakes: 'æ— ',
                similar: 'à¸«à¸¥à¸±à¸š (ç¡ç€)'
            }
        }
    },
    {
        id: 'old3',
        thai: 'à¹„à¸›',
        phonetic: 'Pai',
        type: 'åŠ¨è¯',
        meaning: 'å»',
        definitions: {
            basic: 'å»ï¼Œå¾€ï¼Œç¦»å¼€',
            examples: [
                { thai: 'à¹„à¸›à¹„à¸«à¸™', meaning: 'å»å“ªé‡Œï¼Ÿ' },
                { thai: 'à¹„à¸›à¸—à¸³à¸‡à¸²à¸™', meaning: 'å»å·¥ä½œ' }
            ],
            usage: {
                grammar: [],
                diff: 'å¯ä½œè¶‹å‘è¡¥è¯­',
                mistakes: 'æ— ',
                similar: 'æ— '
            }
        }
    },
    {
        id: 'old4',
        thai: 'à¸¡à¸²',
        phonetic: 'Ma',
        type: 'åŠ¨è¯',
        meaning: 'æ¥',
        definitions: {
            basic: 'æ¥ï¼Œæ¥åˆ°',
            examples: [
                { thai: 'à¸¡à¸²à¸ˆà¸²à¸à¹„à¸«à¸™', meaning: 'æ¥è‡ªå“ªé‡Œï¼Ÿ' },
                { thai: 'à¸¡à¸²à¸™à¸µà¹ˆ', meaning: 'æ¥è¿™é‡Œ' }
            ],
            usage: {
                grammar: [],
                diff: 'å¯ä½œè¶‹å‘è¡¥è¯­',
                mistakes: 'æ— ',
                similar: 'æ— '
            }
        }
    },
    {
        id: 'old5',
        thai: 'à¸£à¸±à¸',
        phonetic: 'Rak',
        type: 'åŠ¨è¯',
        meaning: 'çˆ±',
        definitions: {
            basic: 'çˆ±ï¼Œå–œçˆ±',
            examples: [
                { thai: 'à¸‰à¸±à¸™à¸£à¸±à¸à¸„à¸¸à¸“', meaning: 'æˆ‘çˆ±ä½ ' },
                { thai: 'à¸£à¸±à¸à¸Šà¸²à¸•à¸´', meaning: 'çˆ±å›½' }
            ],
            usage: {
                grammar: [],
                diff: 'æ— ',
                mistakes: 'æ— ',
                similar: 'à¸Šà¸­à¸š (å–œæ¬¢)'
            }
        }
    }
];

const MOCK_NEW_WORDS: WordData[] = [
    {
        id: 'new1',
        thai: 'à¸—à¸³à¸‡à¸²à¸™',
        phonetic: 'Tham Ngan',
        type: 'åŠ¨è¯',
        meaning: 'å·¥ä½œ',
        definitions: {
            basic: 'å·¥ä½œï¼Œå¹²æ´»',
            examples: [
                { thai: 'à¸§à¸±à¸™à¸™à¸µà¹‰à¸—à¸³à¸‡à¸²à¸™à¹„à¸«à¸¡', meaning: 'ä»Šå¤©å·¥ä½œå—ï¼Ÿ' },
                { thai: 'à¸—à¸³à¸‡à¸²à¸™à¸«à¸™à¸±à¸', meaning: 'å·¥ä½œåŠªåŠ›/è¾›è‹¦' }
            ],
            usage: {
                grammar: [],
                diff: 'æ— ',
                mistakes: 'æ— ',
                similar: 'à¸‡à¸²à¸™ (åè¯: å·¥ä½œ)'
            }
        }
    },
    {
        id: 'new2',
        thai: 'à¹€à¸£à¸µà¸¢à¸™',
        phonetic: 'Rian',
        type: 'åŠ¨è¯',
        meaning: 'å­¦ä¹ ',
        definitions: {
            basic: 'å­¦ä¹ ï¼Œè¯»ä¹¦',
            examples: [
                { thai: 'à¹€à¸£à¸µà¸¢à¸™à¸ à¸²à¸©à¸²à¹„à¸—à¸¢', meaning: 'å­¦æ³°è¯­' },
                { thai: 'à¹„à¸›à¹‚à¸£à¸‡à¹€à¸£à¸µà¸¢à¸™', meaning: 'å»å­¦æ ¡' }
            ],
            usage: {
                grammar: [],
                diff: 'ä¾§é‡äºåœ¨å­¦æ ¡å­¦ä¹ æˆ–ä¸Šè¯¾',
                mistakes: 'è‡ªå­¦é€šå¸¸ç”¨ à¸¨à¸¶à¸à¸©à¸²',
                similar: 'à¸¨à¸¶à¸à¸©à¸² (ç ”ç©¶/è¿›ä¿®)'
            }
        }
    },
    {
        id: 'new3',
        thai: 'à¹€à¸¥à¹ˆà¸™',
        phonetic: 'Len',
        type: 'åŠ¨è¯',
        meaning: 'ç©',
        definitions: {
            basic: 'ç©ï¼Œæ¸¸æˆï¼Œæ¼”å¥',
            examples: [
                { thai: 'à¹€à¸¥à¹ˆà¸™à¹€à¸à¸¡', meaning: 'ç©æ¸¸æˆ' },
                { thai: 'à¸à¸¹à¸”à¹€à¸¥à¹ˆà¸™', meaning: 'å¼€ç©ç¬‘ (è¯´ç©)' }
            ],
            usage: {
                grammar: [],
                diff: 'èŒƒå›´å¾ˆå¹¿ï¼Œå¯æŒ‡ç©è€ã€æ¼”å¥ä¹å™¨ã€å¼€ç©ç¬‘ç­‰',
                mistakes: 'æ— ',
                similar: 'à¹€à¸—à¸µà¹ˆà¸¢à¸§ (å»ç©/æ—…æ¸¸)'
            }
        }
    },
    {
        id: 'new4',
        thai: 'à¸à¸¹à¸”',
        phonetic: 'Phut',
        type: 'åŠ¨è¯',
        meaning: 'è¯´',
        definitions: {
            basic: 'è¯´ï¼Œè®²',
            examples: [
                { thai: 'à¸à¸¹à¸”à¸ à¸²à¸©à¸²à¹„à¸—à¸¢à¹„à¸”à¹‰à¹„à¸«à¸¡', meaning: 'ä¼šè¯´æ³°è¯­å—ï¼Ÿ' },
                { thai: 'à¸à¸¹à¸”à¸Šà¹‰à¸²à¹† à¸«à¸™à¹ˆà¸­à¸¢', meaning: 'è¯·è¯´æ…¢ä¸€ç‚¹' }
            ],
            usage: {
                grammar: [],
                diff: 'ä¾§é‡äºè¯´è¯çš„åŠ¨ä½œ',
                mistakes: 'æ— ',
                similar: 'à¸šà¸­à¸ (å‘Šè¯‰)'
            }
        }
    },
    {
        id: 'new5',
        thai: 'à¸­à¹ˆà¸²à¸™',
        phonetic: 'Aan',
        type: 'åŠ¨è¯',
        meaning: 'è¯»',
        definitions: {
            basic: 'é˜…è¯»ï¼Œå¿µ',
            examples: [
                { thai: 'à¸­à¹ˆà¸²à¸™à¸«à¸™à¸±à¸‡à¸ªà¸·à¸­', meaning: 'è¯»ä¹¦' },
                { thai: 'à¸­à¹ˆà¸²à¸™à¸­à¸­à¸à¹€à¸ªà¸µà¸¢à¸‡', meaning: 'æœ—è¯»' }
            ],
            usage: {
                grammar: [],
                diff: 'æ— ',
                mistakes: 'æ— ',
                similar: 'à¸¨à¸¶à¸à¸©à¸² (å­¦ä¹ /ç ”ç©¶)'
            }
        }
    }
];

// --- Types ---

type SessionMode = 'REVIEW' | 'LEARN_NEW';
// ä¸åç«¯ä¿æŒä¸€è‡´ï¼Œå­—æ¯æ¨¡å—ä½¿ç”¨ 'letter'
type ModuleVariant = 'letter' | 'word';

interface QueueItem {
    word: WordData;
    type: 'review' | 'new';
    repetitionsLeft: number;
}

export default function LearningSession() {
    const params = useLocalSearchParams();
    const moduleParam = typeof params.module === 'string' ? params.module : 'word';
    const moduleType: ModuleVariant = moduleParam === 'letter' ? 'letter' : 'word';
    const courseSource = typeof params.source === 'string' ? params.source : undefined;
    const { startCourse, currentCourseSource } = useVocabularyStore();

    useEffect(() => {
        if (!courseSource) return;

        // â­ 1. å­—æ¯æ¨¡å—ï¼šä¸åœ¨è¿™é‡Œè‡ªåŠ¨ startCourse
        if (moduleType === 'letter') {
            return;
        }

        // â­ 2. åªæœ‰å½“å½“å‰æ²¡æœ‰è¯¾ç¨‹æ—¶ï¼Œæ‰åˆå§‹åŒ–ä¸€æ¬¡
        if (!currentCourseSource) {
            startCourse(courseSource);
        }
    }, [moduleType, courseSource, currentCourseSource, startCourse]);

    if (moduleType === 'letter') {
        return <AlphabetSession />;
    }

    return <WordSession />;
}

function WordSession() {
    const { t } = useTranslation();
    const router = useRouter();
    const [queue, setQueue] = useState<QueueItem[]>([]);
    const [currentIndex, setCurrentIndex] = useState(0);
    const [mode, setMode] = useState<SessionMode>('REVIEW');
    const [isSessionComplete, setIsSessionComplete] = useState(false);
    const { dailyLimits } = useLearningPreferenceStore();

    // Initialize Session
    useEffect(() => {
        const dailyLimit = dailyLimits.word || 20;
        const reviewCap = Math.min(MOCK_OLD_WORDS.length, Math.max(1, Math.floor(dailyLimit / 2)));
        const limitedReview = MOCK_OLD_WORDS.slice(0, reviewCap);

        const remaining = Math.max(1, dailyLimit - limitedReview.length);
        const limitedNew = MOCK_NEW_WORDS.slice(0, Math.min(MOCK_NEW_WORDS.length, remaining));

        const reviewItems: QueueItem[] = limitedReview.map(w => ({
            word: w,
            type: 'review',
            repetitionsLeft: 3,
        }));

        const newItems: QueueItem[] = limitedNew.map(w => ({
            word: w,
            type: 'new',
            repetitionsLeft: 3,
        }));

        setQueue([...reviewItems, ...newItems]);
    }, [dailyLimits.word]);

    const currentItem = queue[currentIndex];

    // Determine current mode based on item type
    useEffect(() => {
        if (currentItem) {
            if (currentItem.type === 'review' && mode !== 'REVIEW') {
                setMode('REVIEW');
            } else if (currentItem.type === 'new' && mode !== 'LEARN_NEW') {
                setMode('LEARN_NEW');
            }
        }
    }, [currentItem, mode]);

    const handleNext = () => {
        if (!currentItem) return;

        const nextQueue = [...queue];
        const currentQueueItem = nextQueue[currentIndex];

        // Decrease repetitions
        currentQueueItem.repetitionsLeft -= 1;

        if (currentQueueItem.repetitionsLeft > 0) {
            nextQueue.push({ ...currentQueueItem });
        }

        if (currentIndex < nextQueue.length - 1) {
            setQueue(nextQueue);
            setCurrentIndex(prev => prev + 1);
        } else {
            setIsSessionComplete(true);
        }
    };

    const handleSkipReview = () => {
        const newQueue = queue.filter(item => item.type === 'new');

        if (newQueue.length === 0) {
            Alert.alert(t('learning.noNewWordsTitle'), t('learning.noNewWordsMessage'));
            router.back();
            return;
        }

        setQueue(newQueue);
        setCurrentIndex(0);
        setMode('LEARN_NEW');
    };

    const handleClose = () => {
        Alert.alert(
            t('learning.endSessionTitle'),
            t('learning.endSessionMessage'),
            [
                { text: t('common.cancel'), style: "cancel" },
                { text: t('learning.quit'), style: "destructive", onPress: () => router.back() }
            ]
        );
    };

    if (isSessionComplete) {
        return (
            <SafeAreaView style={styles.container}>
                <View style={styles.completeContainer}>
                    <Text style={styles.completeTitle}>{t('learning.sessionComplete')}</Text>
                    <Pressable style={styles.completeButton} onPress={() => router.back()}>
                        <Text style={styles.completeButtonText}>{t('learning.backToHome')}</Text>
                    </Pressable>
                </View>
            </SafeAreaView>
        );
    }

    if (!currentItem) {
        return (
            <SafeAreaView style={styles.container}>
                <Text>{t('common.loading')}</Text>
            </SafeAreaView>
        );
    }

    const progress = Math.round(((currentIndex) / queue.length) * 100);

    return (
        <SafeAreaView edges={['top', 'bottom']} style={styles.container}>
            <ThaiPatternBackground opacity={0.05} />

            {/* Header */}
            <View style={styles.header}>
                <Pressable onPress={handleClose} style={styles.closeButton}>
                    <X size={24} color={Colors.taupe} />
                </Pressable>

                <View style={styles.progressBarContainer}>
                    <View style={[styles.progressBarFill, { width: `${progress}%` }]} />
                </View>

                {mode === 'REVIEW' ? (
                    <Pressable onPress={handleSkipReview}>
                        <Text style={styles.skipText}>{t('learning.skipReview')}</Text>
                    </Pressable>
                ) : (
                    <View style={{ width: 60 }} />
                )}
            </View>

            {/* Main Content */}
            <View style={styles.content}>
                {currentItem.type === 'review' ? (
                    <ReviewWordView
                        key={`${currentItem.word.id}-review-${currentIndex}`}
                        word={currentItem.word}
                        onAnswer={(quality) => {
                            console.log(`Answered ${quality} for ${currentItem.word.thai}`);
                        }}
                        onNext={handleNext}
                    />
                ) : (
                    <NewWordView
                        key={`${currentItem.word.id}-new-${currentIndex}`}
                        word={currentItem.word}
                        onNext={handleNext}
                    />
                )}
            </View>
        </SafeAreaView>
    );
}

function AlphabetSession() {
    const { t } = useTranslation();
    const router = useRouter();
    const { currentUser } = useUserStore();
    const { dailyLimits } = useLearningPreferenceStore();
    const [hasViewedIntro, setHasViewedIntro] = useState(false);
    const [sessionStarted, setSessionStarted] = useState(false);

    const {
        phase,
        isLoading,
        initializeSession,
        submitResult,
        reset,
        completedCount,
        totalCount,
        currentItem,
    } = useAlphabetStore();

    const currentAlphabet = currentItem;

    useEffect(() => {
        setHasViewedIntro(false);
    }, [currentAlphabet?.alphabetId]);

    useEffect(() => {
        const start = async () => {
            if (sessionStarted || isLoading) return;
            const userId = currentUser?.userId || 'user_123';
            await initializeSession(userId, {
              limit: dailyLimits.letter || 30,
            });
            setSessionStarted(true);
        };

        start();
    }, [sessionStarted, isLoading, initializeSession, currentUser?.userId, dailyLimits.letter]);

    const handleClose = () => {
        Alert.alert(
            t('learning.endSessionTitle', 'ç»“æŸå­¦ä¹ ?'),
            t('learning.endSessionMessage', 'å½“å‰è¿›åº¦å°†ä¸ä¼šä¿å­˜'),
            [
                { text: t('common.cancel', 'å–æ¶ˆ'), style: "cancel" },
                {
                    text: t('learning.quit', 'é€€å‡º'),
                    style: "destructive",
                    onPress: () => {
                        reset();
                        router.back();
                    }
                }
            ]
        );
    };

    if (isLoading && !sessionStarted) {
        return (
            <SafeAreaView style={styles.container}>
                <View style={styles.centerContent}>
                    <Text>{t('common.loading', 'åŠ è½½ä¸­...')}</Text>
                </View>
            </SafeAreaView>
        );
    }

    if (phase === LearningPhase.COMPLETED) {
        return (
            <SafeAreaView style={styles.container}>
                <View style={styles.centerContent}>
                    <Text style={styles.completeTitle}>{t('learning.sessionComplete', 'ä»Šæ—¥å­¦ä¹ å®Œæˆ!')}</Text>
                    <Pressable style={styles.completeButton} onPress={() => router.back()}>
                        <Text style={styles.completeButtonText}>{t('learning.backToHome', 'è¿”å›é¦–é¡µ')}</Text>
                    </Pressable>
                </View>
            </SafeAreaView>
        );
    }

    if (!currentAlphabet) {
        return (
            <SafeAreaView style={styles.container}>
                <View style={styles.centerContent}>
                    <Text>{t('common.loading', 'åŠ è½½ä¸­...')}</Text>
                </View>
            </SafeAreaView>
        );
    }

    const isNew = !currentAlphabet.memoryState || currentAlphabet.memoryState.isNew;
    const showIntro = isNew && !hasViewedIntro && currentAlphabet.currentAttempts === 0;
    const progress = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;

    return (
        <SafeAreaView edges={['top', 'bottom']} style={styles.container}>
            <ThaiPatternBackground opacity={0.05} />

            <View style={styles.header}>
                <Pressable onPress={handleClose} style={styles.closeButton}>
                    <X size={24} color={Colors.taupe} />
                </Pressable>

                <View style={styles.progressBarContainer}>
                    <View style={[styles.progressBarFill, { width: `${progress}%` }]} />
                </View>

                <View style={{ width: 60 }} />
            </View>

            <View style={styles.content}>
                {showIntro ? (
                    <AlphabetLearningView
                        alphabet={currentAlphabet}
                        onNext={() => setHasViewedIntro(true)}
                    />
                ) : (
                    <AlphabetReviewViewWrapper
                        key={currentAlphabet.alphabetId}
                        alphabet={currentAlphabet}
                        onSubmit={(quality) => {
                            const userId = currentUser?.userId || 'user_123';
                            submitResult(userId, quality);
                        }}
                    />
                )}
            </View>
        </SafeAreaView>
    );
}

function AlphabetReviewViewWrapper({ alphabet, onSubmit }: { alphabet: any, onSubmit: (q: any) => void }) {
    const [quality, setQuality] = useState<any>(null);

    return (
        <AlphabetReviewView
            alphabet={alphabet}
            onAnswer={(q) => setQuality(q)}
            onNext={() => {
                if (quality) onSubmit(quality);
            }}
        />
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: Colors.paper,
    },
    header: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        paddingHorizontal: 16,
        paddingVertical: 12,
        borderBottomWidth: 1,
        borderBottomColor: 'rgba(0,0,0,0.05)',
    },
    closeButton: {
        padding: 8,
    },
    progressBarContainer: {
        flex: 1,
        height: 6,
        backgroundColor: 'rgba(229, 226, 219, 0.5)',
        borderRadius: 3,
        marginHorizontal: 16,
        overflow: 'hidden',
    },
    progressBarFill: {
        height: '100%',
        backgroundColor: Colors.thaiGold,
        borderRadius: 3,
    },
    content: {
        flex: 1,
    },
    completeContainer: {
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
    },
    completeTitle: {
        fontFamily: Typography.playfairBold,
        fontSize: 24,
        color: Colors.ink,
        marginBottom: 24,
    },
    completeButton: {
        backgroundColor: Colors.ink,
        paddingHorizontal: 32,
        paddingVertical: 16,
        borderRadius: 12,
    },
    completeButtonText: {
        color: Colors.white,
        fontFamily: Typography.notoSerifBold,
    },
    centerContent: {
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
    },
    skipText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.taupe,
    },
});
</file>

<file path="cloudbase/functions/memory-engine/handlers/getUserProgress.js">
/**
 * è·å–ç”¨æˆ·å­¦ä¹ è¿›åº¦
 * Action: getUserProgress
 */
'use strict';

const { createResponse } = require('../utils/response');

/**
 * @param {Object} db - æ•°æ®åº“å®ä¾‹
 * @param {Object} params - è¯·æ±‚å‚æ•°
 */
async function getUserProgress(db, params) {
  const { userId } = params;

  // ğŸ” è°ƒè¯•æ—¥å¿—ï¼šæ‰“å°æ”¶åˆ°çš„ userId
  console.log('ğŸ“¥ [getUserProgress] æ”¶åˆ°è¯·æ±‚ï¼ŒuserId:', userId);

  if (!userId) {
    return createResponse(false, null, 'Missing userId', 'INVALID_PARAMS');
  }

  try {
    // 2. è·å–ç”¨æˆ·è¿›åº¦è®°å½•
    // âŒ ä¿®æ­£: ä¸è¦ç”¨ getOne(), ç”¨ limit(1).get()
    const progressResult = await db.collection('user_progress')
      .where({ userId })
      .limit(1)
      .get();

    if (!progressResult.data || progressResult.data.length === 0) {
      return createResponse(false, null, 'ç”¨æˆ·è¿›åº¦è®°å½•ä¸å­˜åœ¨', 'USER_PROGRESS_NOT_FOUND');
    }

    const progress = progressResult.data[0];

    // ğŸ”¥ è·å–å­—æ¯æ¨¡å—ä¸“å±è¿›åº¦ï¼ˆåŒ…å« currentRoundï¼‰
    let alphabetProgress = null;
    if (params.entityType === 'letter') {
      const alphabetProgressResult = await db.collection('user_alphabet_progress')
        .where({ userId })
        .limit(1)
        .get();

      console.log('ğŸ“Š [getUserProgress] alphabetProgressResult:', {
        found: alphabetProgressResult.data?.length > 0,
        data: alphabetProgressResult.data?.[0]
      });

      if (alphabetProgressResult.data && alphabetProgressResult.data.length > 0) {
        alphabetProgress = alphabetProgressResult.data[0];
        console.log('ğŸ“Š [getUserProgress] alphabetProgress.currentRound:', alphabetProgress.currentRound);
      } else {
        console.log('âš ï¸ [getUserProgress] No alphabet progress found for user:', userId);
      }
    }

    // 3. ç»Ÿè®¡å„æ¨¡å—å­¦ä¹ æ•°æ®
    // æ³¨æ„: å¦‚æœæ•°æ®é‡å¾ˆå¤§ï¼Œcount() æ¯” get() æ›´é«˜æ•ˆ
    const letterCountResult = await db.collection('memory_status')
      .where({ userId, entityType: 'letter' })
      .count();

    const letterMasteredResult = await db.collection('memory_status')
      .where({ userId, entityType: 'letter', masteryLevel: db.command.gte(0.7) })
      .count();

    const wordCountResult = await db.collection('memory_status')
      .where({ userId, entityType: 'word' })
      .count();

    const wordMasteredResult = await db.collection('memory_status')
      .where({ userId, entityType: 'word', masteryLevel: db.command.gte(0.7) })
      .count();

    // 4. ç»„è£…
    const result = {
      ...progress,
      // ğŸ”¥ åˆå¹¶å­—æ¯æ¨¡å—ä¸“å±å­—æ®µï¼ˆcurrentRound, completedLessons, roundHistoryï¼‰
      ...(alphabetProgress ? {
        currentRound: alphabetProgress.currentRound,
        completedLessons: alphabetProgress.completedLessons || [],  // ğŸ”¥ æ–°å¢å­—æ®µ
        roundHistory: alphabetProgress.roundHistory || []  // ğŸ”¥ P0-A: è¡¥å…… roundHistory
      } : {}),
      statistics: {
        letter: {
          total: 44,
          learned: letterCountResult.total,
          mastered: letterMasteredResult.total,
          progress: letterCountResult.total > 0 ? (letterMasteredResult.total / 44).toFixed(2) : 0
        },
        word: {
          total: 3500,
          learned: wordCountResult.total,
          mastered: wordMasteredResult.total,
          progress: wordCountResult.total > 0 ? (wordMasteredResult.total / 3500).toFixed(2) : 0
        }
      },
      unlockStatus: {
        letter: true,
        word: progress.wordUnlocked,
        sentence: progress.sentenceUnlocked,
        article: progress.articleUnlocked
      }
    };

    console.log('ğŸ“Š [getUserProgress] roundHistory returned:', (alphabetProgress?.roundHistory || []).length);

    // ä¸å‰ç«¯çº¦å®šï¼šdata.progress ä¸ºè¿›åº¦å¯¹è±¡
    return createResponse(true, { progress: result }, 'è·å–ç”¨æˆ·è¿›åº¦æˆåŠŸ');

  } catch (error) {
    console.error('getUserProgress error:', error);
    return createResponse(false, null, error.message, 'SERVER_ERROR');
  }
}

module.exports = getUserProgress;
</file>

<file path="src/components/courses/AlphabetCourseCard.tsx">
// src/components/courses/AlphabetCourseCard.tsx
import React from 'react';
import { View, Text, StyleSheet, Pressable, Image, ImageSourcePropType } from 'react-native';
import { useRouter } from 'expo-router';
import { useTranslation } from 'react-i18next';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

interface AlphabetCourseCardProps {
  course: {
    id: string;
    source: string;
    title: string;
    description: string;
    level: string;
    imageSource: ImageSourcePropType;
    lessons: number;
  };
  isCurrent: boolean;
  progress?: {
    completed: number;
    total: number;
  };
  onStart: () => void;
}

export function AlphabetCourseCard({ course, isCurrent, progress, onStart }: AlphabetCourseCardProps) {
  const router = useRouter();
  const { t } = useTranslation();

  const progressPercent = (() => {
    if (!progress) {
      return null;
    }
    const completed = progress.completed || 0;
    const total = progress.total || 44; // Default total if not provided
    if (total === 0) {
      return 0; // Or null, depending on desired behavior for 0 total
    }
    return Math.min(100, Math.round((completed / total) * 100));
  })();

  return (
    <View style={[styles.card, isCurrent && styles.activeCard]}>
      <Pressable style={styles.cardPressable} onPress={onStart}>
        <Image source={course.imageSource} style={styles.image} />
        <View style={styles.info}>
          <View style={styles.header}>
            <Text style={styles.title} numberOfLines={1}>
              {course.title}
            </Text>
            <View style={styles.levelBadge}>
              <Text style={styles.levelText}>{course.level}</Text>
            </View>
          </View>

          <Text style={styles.description} numberOfLines={2}>
            {course.description}
          </Text>

          <View style={styles.footer}>
            <View style={styles.metaColumn}>
              {progressPercent !== null ? (
                <>
                  <View style={styles.progressBar}>
                    <View style={[styles.progressFill, { width: `${progressPercent}%` }]} />
                  </View>
                  <Text style={styles.metaText}>
                    {progress?.completed}/{progress?.total} ({progressPercent}%)
                  </Text>
                </>
              ) : (
                <Text style={styles.metaText}>{course.lessons} è¯¾æ—¶</Text>
              )}
            </View>

            {/* Start Learning æŒ‰é’® */}
            <Pressable
              style={[styles.startBtn, isCurrent && styles.activeStartBtn]}
              onPress={(e) => {
                e.stopPropagation();
                onStart();
              }}
            >
              <Text style={[styles.startBtnText, isCurrent && styles.activeStartBtnText]}>
                {isCurrent ? t('courses.continue', 'ç»§ç»­å­¦ä¹ ') : t('courses.startBtnText', 'å¼€å§‹å­¦ä¹ ')}
              </Text>
            </Pressable>
          </View>
        </View>
      </Pressable>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    flexDirection: 'row',
    backgroundColor: Colors.white,
    borderRadius: 16,
    overflow: 'hidden',
    borderWidth: 1,
    borderColor: Colors.sand,
    height: 136,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.05,
    shadowRadius: 8,
    elevation: 3,
  },
  activeCard: {
    borderColor: Colors.thaiGold,
    borderWidth: 2,
    backgroundColor: '#FFFCF5',
  },
  cardPressable: {
    flex: 1,
    flexDirection: 'row',
  },
  image: {
    width: 110,
    height: '100%',
    resizeMode: 'cover',
  },
  info: {
    flex: 1,
    padding: 12,
    justifyContent: 'space-between',
    gap: 8,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    gap: 8,
  },
  title: {
    flex: 1,
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.ink,
  },
  levelBadge: {
    paddingHorizontal: 6,
    paddingVertical: 2,
    backgroundColor: 'rgba(212, 175, 55, 0.1)',
    borderRadius: 4,
    borderWidth: 1,
    borderColor: 'rgba(212, 175, 55, 0.3)',
  },
  levelText: {
    fontSize: 10,
    color: Colors.thaiGold,
    fontFamily: Typography.notoSerifRegular,
  },
  description: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 12,
    color: Colors.taupe,
    lineHeight: 16,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    gap: 12,
  },
  metaColumn: {
    flex: 1,
    gap: 6,
  },
  metaText: {
    fontSize: 11,
    color: Colors.taupe,
    fontFamily: Typography.notoSerifRegular,
  },
  progressBar: {
    height: 6,
    backgroundColor: '#F0F0F0',
    borderRadius: 3,
    overflow: 'hidden',
  },
  progressFill: {
    height: '100%',
    backgroundColor: Colors.thaiGold,
    borderRadius: 3,
  },
  startBtn: {
    paddingHorizontal: 14,
    paddingVertical: 10,
    backgroundColor: Colors.ink,
    borderRadius: 12,
  },
  activeStartBtn: {
    backgroundColor: Colors.thaiGold,
  },
  startBtnText: {
    fontSize: 12,
    color: Colors.white,
    fontFamily: Typography.notoSerifRegular,
  },
  activeStartBtnText: {
    color: Colors.white,
    fontWeight: '600',
  },
});
</file>

<file path="src/components/learning/alphabet/AlphabetReviewView.tsx">
// src/components/learning/alphabet/AlphabetReviewView.tsx

import React, { useState, useCallback, useRef, useEffect } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
  Animated,
  Vibration,
  Platform,
} from 'react-native';
import { Audio } from 'expo-av';
import { Volume2, Check, X, AudioLines } from 'lucide-react-native';

import type { AlphabetLearningState } from '@/src/stores/alphabetStore';
import type { Letter } from '@/src/entities/types/letter.types';
import type { AlphabetQueueItem, AlphabetQuestion } from '@/src/entities/types/alphabet.types';

// Use strict new types
import { AlphabetGameType, ALPHABET_GAME_TYPE_LABELS } from '@/src/entities/types/alphabetGameTypes';
import { generateQuestion } from '@/src/utils/lettersQuestionGenerator';
import { getLetterAudioUrl } from '@/src/utils/alphabet/audioHelper';
// Legacy type for prop compatibility (mapped internally)
import { QuestionType } from '@/src/entities/enums/QuestionType.enum';

import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

type AnswerState = 'idle' | 'correct' | 'wrong' | 'locked';

interface AlphabetReviewViewProps {
  alphabet: AlphabetLearningState;
  letterPool?: Letter[];
  preferredType?: QuestionType; // Legacy prop
  onAnswer: (isCorrect: boolean, questionType: any) => void;
  onNext: () => void;
  onBack?: () => void;
}

export function AlphabetReviewView({
  alphabet,
  letterPool,
  preferredType,
  onAnswer,
  onNext,
  onBack,
}: AlphabetReviewViewProps) {
  const [answerState, setAnswerState] = useState<AnswerState>('idle');
  // use index to track selection to avoid duplicate value issues
  const [selectedOptionIndex, setSelectedOptionIndex] = useState<number | null>(null);
  const [isPlaying, setIsPlaying] = useState(false);

  const soundRef = useRef<Audio.Sound | null>(null);
  const shakeX = useRef(new Animated.Value(0)).current;
  const wrongResetTimer = useRef<ReturnType<typeof setTimeout> | null>(null);
  const correctLockTimer = useRef<ReturnType<typeof setTimeout> | null>(null);

  const pool = letterPool || [];

  // --- 1. Question Generation & Type Mapping ---

  const mapLegacyType = (legacyType?: QuestionType): AlphabetGameType => {
    switch (legacyType) {
      case QuestionType.SOUND_TO_LETTER: return AlphabetGameType.SOUND_TO_LETTER;
      case QuestionType.LETTER_TO_SOUND: return AlphabetGameType.LETTER_TO_SOUND;
      case QuestionType.CLASS_CHOICE: return AlphabetGameType.CONSONANT_CLASS;
      case QuestionType.FINAL_CONSONANT: return AlphabetGameType.FINAL_SOUND;
      case QuestionType.SYLLABLE: return AlphabetGameType.SOUND_TO_LETTER;
      case QuestionType.ASPIRATED_CONTRAST: return AlphabetGameType.SOUND_TO_LETTER;
      case QuestionType.TONE_PERCEPTION: return AlphabetGameType.TONE_CALCULATION;
      case QuestionType.INITIAL_SOUND: return AlphabetGameType.INITIAL_SOUND;
      default: return AlphabetGameType.SOUND_TO_LETTER;
    }
  };

  const createQuestion = (): AlphabetQuestion => {
    const queueItem: AlphabetQueueItem = {
      letterId: alphabet.alphabetId,
      letter: alphabet.letter,
      gameType: mapLegacyType(preferredType),
    };
    return generateQuestion(queueItem, pool);
  };

  const [question, setQuestion] = useState<AlphabetQuestion>(createQuestion);
  const questionKey = question.id;

  // Debug Log
  useEffect(() => {
    // CONSONANT_CLASS has 3 options. Others usually 4.
    const minOptions = question.gameType === AlphabetGameType.CONSONANT_CLASS ? 3 : 4;
    // TONE_CALCULATION / PHONICS_MATH placeholders might also have fewer?
    // Let's safe guard.
    if (!question?.options || question.options.length < minOptions) {
      console.warn('âš ï¸ Options count low:', question?.options?.length || 0, 'Type:', question.gameType);
    }
  }, [question]);

  useEffect(() => {
    setQuestion(createQuestion());
    resetForNewQuestion();
  }, [alphabet.alphabetId, preferredType]);


  // --- 2. Audio Logic ---

  /* 
   * Stop audio safely handling potential race conditions
   * (e.g. concurrent calls where soundRef.current becomes null) 
   */
  const stopAudio = useCallback(async () => {
    const sound = soundRef.current;
    if (!sound) return;

    // Immediately detach ref to prevent other calls from accessing this instance
    soundRef.current = null;

    try {
      await sound.stopAsync().catch(() => { });
      await sound.unloadAsync().catch(() => { });
    } catch (ignore) {
      // Ignore errors during cleanup
    }
  }, []);

  const playAudio = useCallback(
    async (uri?: string | null) => {
      if (!uri) return;

      try {
        setIsPlaying(true);
        await stopAudio();
        const { sound } = await Audio.Sound.createAsync(
          { uri },
          { shouldPlay: true }
        );

        soundRef.current = sound;
        sound.setOnPlaybackStatusUpdate((status) => {
          if (status.isLoaded && status.didJustFinish) {
            setIsPlaying(false);
          }
        });
      } catch (error) {
        console.warn('[AlphabetReview] Playback failed:', error);
        setIsPlaying(false);
      }
    },
    [stopAudio]
  );

  useEffect(() => {
    resetForNewQuestion();

    const shouldAutoPlay = [
      AlphabetGameType.SOUND_TO_LETTER,
      AlphabetGameType.INITIAL_SOUND,
      AlphabetGameType.FINAL_SOUND
    ].includes(question.gameType);

    if (shouldAutoPlay && question.audioUrl) {
      void playAudio(question.audioUrl);
    }

    return () => {
      if (wrongResetTimer.current) clearTimeout(wrongResetTimer.current);
      if (correctLockTimer.current) clearTimeout(correctLockTimer.current);
      void stopAudio();
    };
  }, [questionKey]);


  // --- 3. Interaction Logic ---

  const resetForNewQuestion = useCallback(() => {
    setAnswerState('idle');
    setSelectedOptionIndex(null);
    shakeX.setValue(0);
    if (wrongResetTimer.current) clearTimeout(wrongResetTimer.current);
    if (correctLockTimer.current) clearTimeout(correctLockTimer.current);
  }, [shakeX]);

  const runShake = useCallback(() => {
    shakeX.setValue(0);
    Animated.sequence([
      Animated.timing(shakeX, { toValue: -10, duration: 40, useNativeDriver: true }),
      Animated.timing(shakeX, { toValue: 10, duration: 40, useNativeDriver: true }),
      Animated.timing(shakeX, { toValue: -6, duration: 40, useNativeDriver: true }),
      Animated.timing(shakeX, { toValue: 6, duration: 40, useNativeDriver: true }),
      Animated.timing(shakeX, { toValue: 0, duration: 40, useNativeDriver: true }),
    ]).start();
  }, [shakeX]);

  // MOVED checkAnswer UP to resolve hoisting error
  const checkAnswer = useCallback((optionValue: string, index: number) => {
    const isCorrect = optionValue === question.correctAnswer;
    setSelectedOptionIndex(index);

    if (isCorrect) {
      setAnswerState('correct');
      onAnswer(true, question.gameType);

      // Play success sound unless it's LetterToSound (where we already played)
      if (question.audioUrl && (question.gameType !== AlphabetGameType.LETTER_TO_SOUND)) {
        void playAudio(question.audioUrl);
      }

      correctLockTimer.current = setTimeout(() => {
        setAnswerState('locked');
      }, 500);
    } else {
      setAnswerState('wrong');
      onAnswer(false, question.gameType);
      runShake();
      Vibration.vibrate(50);

      wrongResetTimer.current = setTimeout(() => {
        setAnswerState('idle');
        setSelectedOptionIndex(null);
      }, 800);
    }
  }, [question, onAnswer, runShake, playAudio]);

  const handleOptionSelect = useCallback(
    (optionValue: string, index: number) => {
      if (answerState !== 'idle') return;

      const isAudioQuestion = question.gameType === AlphabetGameType.LETTER_TO_SOUND;

      if (isAudioQuestion) {
        // Play First Logic
        const targetLetter = question?.options?.[index];

        if (targetLetter) {
          const url = targetLetter.letterPronunciationUrl || targetLetter.fullSoundUrl || targetLetter.audioPath;
          if (url) {
            void playAudio(url);
          }
        }

        setSelectedOptionIndex(index);
        // Do NOT submit yet
        return;
      }

      // Default Immediate Feedback
      checkAnswer(optionValue, index);
    },
    [answerState, question, checkAnswer, playAudio]
  );

  const handleConfirmAnswer = useCallback(() => {
    if (selectedOptionIndex !== null && question.options) {
      // Get value from index
      const selectedItem = question.options[selectedOptionIndex];
      let val: string | undefined;

      switch (question.gameType) {
        case AlphabetGameType.LETTER_TO_SOUND:
          val = selectedItem.initialSound || selectedItem.fullSoundUrl || selectedItem._id;
          break;
        case AlphabetGameType.INITIAL_SOUND:
          val = selectedItem.initialSound;
          break;
        case AlphabetGameType.FINAL_SOUND:
          val = selectedItem.finalSound || selectedItem.initialSound;
          break;
        default:
          val = selectedItem.thaiChar;
      }

      if (val) checkAnswer(val, selectedOptionIndex);
    }
  }, [selectedOptionIndex, question, checkAnswer]);

  const handleNextQuestion = useCallback(() => {
    if (answerState !== 'locked') return;
    resetForNewQuestion();
    void stopAudio();
    onNext();
  }, [answerState, resetForNewQuestion, stopAudio, onNext]);


  // --- 4. Render Helpers ---

  const renderQuestionHeader = () => {
    const title = ALPHABET_GAME_TYPE_LABELS[question.gameType] || 'Review';
    let instruction = 'Select the correct answer';

    switch (question.gameType) {
      case AlphabetGameType.SOUND_TO_LETTER: instruction = 'Listen and choose the letter'; break;
      case AlphabetGameType.LETTER_TO_SOUND: instruction = 'Match the pronunciation'; break;
      case AlphabetGameType.CONSONANT_CLASS: instruction = 'Select the consonant class'; break;
      case AlphabetGameType.INITIAL_SOUND: instruction = 'Identify the initial sound'; break;
      case AlphabetGameType.FINAL_SOUND: instruction = 'Identify the final sound'; break;
      default: break;
    }

    return (
      <View style={styles.header}>
        <Text style={styles.headerTitle}>{title}</Text>
        <Text style={styles.headerInstruction}>{instruction}</Text>
      </View>
    );
  };

  const renderAudioButton = () => {
    // For Letter-to-Sound, the user must read the letter. Providing central audio defeats the visual recognition task.
    if (!question.audioUrl || question.gameType === AlphabetGameType.LETTER_TO_SOUND) return null;
    return (
      <TouchableOpacity
        style={[styles.audioButton, isPlaying && styles.audioButtonActive]}
        onPress={() => playAudio(question.audioUrl)}
      >
        <Volume2 size={32} color={Colors.white} />
      </TouchableOpacity>
    );
  };

  const renderStem = () => {
    if (question.gameType === AlphabetGameType.LETTER_TO_SOUND ||
      question.gameType === AlphabetGameType.CONSONANT_CLASS) {
      return (
        <View style={styles.stemContainer}>
          <Text style={styles.stemLetter}>{question.targetLetter.thaiChar}</Text>
        </View>
      );
    }
    return null;
  };

  const renderOptions = () => {
    const options = question.options || [];
    const minOptions = question.gameType === AlphabetGameType.CONSONANT_CLASS ? 3 : 4;

    if (!options || options.length < minOptions) {
      return (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>é¢˜ç›®é€‰é¡¹åŠ è½½å¤±è´¥</Text>
          <TouchableOpacity
            style={styles.retryButton}
            onPress={() => {
              setQuestion(createQuestion());
              resetForNewQuestion();
            }}
          >
            <Text style={styles.retryButtonText}>é‡æ–°ç”Ÿæˆé¢˜ç›®</Text>
          </TouchableOpacity>
        </View>
      );
    }

    return (
      <Animated.View
        style={[
          styles.optionsGrid,
          { transform: [{ translateX: shakeX }] }
        ]}
      >
        {options.map((optLetter, index) => {
          let displayValue = '';
          let comparisonValue = '';

          switch (question.gameType) {
            case AlphabetGameType.SOUND_TO_LETTER:
              displayValue = optLetter.thaiChar;
              comparisonValue = optLetter.thaiChar;
              break;
            case AlphabetGameType.LETTER_TO_SOUND:
              displayValue = `/${optLetter.initialSound || '...'} /`;
              comparisonValue = optLetter.initialSound || optLetter.fullSoundUrl || optLetter._id;
              break;
            case AlphabetGameType.INITIAL_SOUND:
              displayValue = `/${optLetter.initialSound}/`;
              comparisonValue = optLetter.initialSound;
              break;
            case AlphabetGameType.FINAL_SOUND:
              displayValue = `/${optLetter.finalSound || optLetter.initialSound}/`;
              comparisonValue = optLetter.finalSound || optLetter.initialSound;
              break;
            default:
              displayValue = optLetter.thaiChar;
              comparisonValue = optLetter.thaiChar;
          }

          const isSelected = selectedOptionIndex === index;
          const isCorrect = (answerState === 'correct' || answerState === 'locked') && comparisonValue === question.correctAnswer;
          const isWrong = answerState === 'wrong' && isSelected && comparisonValue !== question.correctAnswer;
          const isDimmed = (answerState === 'correct' || answerState === 'locked') && !isCorrect;

          return (
            <TouchableOpacity
              key={`${index}-${comparisonValue}`}
              style={[
                styles.optionCard,
                isSelected && styles.optionSelected,
                isCorrect && styles.optionCorrect,
                isWrong && styles.optionWrong,
                isDimmed && styles.optionDimmed,
              ]}
              onPress={() => {
                if (question.gameType === AlphabetGameType.LETTER_TO_SOUND) {
                  // Get normalized audio URL using helper
                  const url = getLetterAudioUrl(optLetter);

                  if (url) {
                    console.log('ğŸ”Š Playing Option Sound');
                    void playAudio(url);
                  } else {
                    console.warn('âš ï¸ No audio URL found for option:', optLetter.thaiChar);
                  }

                  handleOptionSelect(comparisonValue, index);
                } else {
                  handleOptionSelect(comparisonValue, index);
                }
              }}
              disabled={answerState !== 'idle' && answerState !== 'locked'}
            >
              {question.gameType === AlphabetGameType.LETTER_TO_SOUND ? (
                // Use AudioLines for "Voice Wave" style
                <View style={{ paddingBottom: 26 }}>
                  <AudioLines size={32} color={isSelected ? Colors.thaiGold : Colors.taupe} />
                </View>
              ) : (
                <Text
                  style={[
                    styles.optionText,
                    isCorrect && styles.optionTextCorrect,
                    isWrong && styles.optionTextWrong
                  ]}
                  adjustsFontSizeToFit
                  numberOfLines={1}
                >
                  {displayValue}
                </Text>
              )}

              <View style={styles.iconContainer}>
                {isCorrect && <Check size={20} color="#2A9D8F" />}
                {isWrong && <X size={20} color="#E63946" />}
              </View>
            </TouchableOpacity>
          );
        })}
      </Animated.View>
    );
  };

  return (
    <View style={styles.container}>
      {renderQuestionHeader()}

      <View style={styles.content}>
        {renderStem()}
        {renderAudioButton()}
        {renderOptions()}
      </View>

      <View style={styles.bottomArea}>
        {/* Confirm Button for Audio Questions */}
        {(question.gameType === AlphabetGameType.LETTER_TO_SOUND) && answerState === 'idle' && selectedOptionIndex !== null && (
          <TouchableOpacity style={styles.nextButton} onPress={handleConfirmAnswer}>
            <Text style={styles.nextButtonText}>Check Answer</Text>
          </TouchableOpacity>
        )}

        {answerState === 'locked' && (
          <TouchableOpacity style={styles.nextButton} onPress={handleNextQuestion}>
            <Text style={styles.nextButtonText}>Next Question â†’</Text>
          </TouchableOpacity>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 24,
    backgroundColor: Colors.paper,
  },
  header: {
    alignItems: 'center',
    marginBottom: 32,
  },
  headerTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.thaiGold,
    textTransform: 'uppercase',
    letterSpacing: 1,
    marginBottom: 8,
  },
  headerInstruction: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 18,
    color: Colors.ink,
    textAlign: 'center',
  },
  content: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'flex-start',
    paddingTop: 40,
  },
  stemContainer: {
    marginBottom: 32,
  },
  stemLetter: {
    fontFamily: Typography.playfairBold,
    fontSize: 88,
    color: Colors.ink,
  },
  audioButton: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: Colors.thaiGold,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 60,
    shadowColor: Colors.thaiGold,
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.3,
    shadowRadius: 16,
    elevation: 8,
  },
  audioButtonActive: {
    transform: [{ scale: 0.95 }],
    opacity: 0.9,
  },
  optionsGrid: {
    width: '100%',
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 16,
    justifyContent: 'center',
  },
  optionCard: {
    width: '47%',
    aspectRatio: 1.4,
    backgroundColor: Colors.white,
    borderRadius: 16,
    borderWidth: 2,
    borderColor: '#EFEFEF',
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.05,
        shadowRadius: 4,
      },
      android: { elevation: 2 }
    })
  },
  optionSelected: {
    borderColor: Colors.thaiGold,
    backgroundColor: '#FFFCF5',
  },
  optionCorrect: {
    borderColor: '#2A9D8F',
    backgroundColor: '#E8F5F3',
  },
  optionWrong: {
    borderColor: '#E63946',
    backgroundColor: '#FFE8EA',
  },
  optionDimmed: {
    opacity: 0.3,
  },
  optionText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 42,
    color: Colors.ink,
    textAlign: 'center',
    textAlignVertical: 'center',
    includeFontPadding: false,
    paddingBottom: 24, // Visual fix: Add bottom buffer to counteract font's top whitespace
  },
  optionTextCorrect: {
    color: '#2A9D8F',
  },
  optionTextWrong: {
    color: '#E63946',
  },
  iconContainer: {
    position: 'absolute',
    right: 8,
    top: 8,
  },
  bottomArea: {
    height: 80,
    justifyContent: 'center',
    alignItems: 'center',
  },
  nextButton: {
    backgroundColor: Colors.ink,
    paddingHorizontal: 32,
    paddingVertical: 14,
    borderRadius: 100,
    flexDirection: 'row',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 4,
  },
  nextButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
  },
  errorContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 32,
  },
  errorText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 18,
    color: '#E63946',
    marginBottom: 8,
    textAlign: 'center',
  },
  errorSubText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
    marginBottom: 24,
    textAlign: 'center',
  },
  retryButton: {
    backgroundColor: Colors.thaiGold,
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  retryButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    color: Colors.white,
  },
});
</file>

<file path="src/config/api.endpoints.ts">
// src/config/api.endpoints.ts

/*
 * API ç«¯ç‚¹é…ç½®
 *
 * ä½œç”¨ï¼š
 * 1. ç»Ÿä¸€ç®¡ç†æ‰€æœ‰ API è·¯å¾„ï¼Œæ”¯æŒå¤šåç«¯åˆ‡æ¢
 * 2. æ˜¾å¼æ ‡è®°â€œCloudBase å®é™…å­˜åœ¨çš„äº‘å‡½æ•°â€å’Œâ€œä»…å ä½/ä»… Java åç«¯å¯ç”¨â€çš„ç«¯ç‚¹
 *
 * å½“å‰ CloudBase å·²éƒ¨ç½²çš„å‡½æ•°ï¼ˆæ¥è‡ª cloudbase/cloudbaserc.jsonï¼‰ï¼š
 * - user-register
 * - user-login
 * - user-reset-password
 * - user-update-profile
 * - learn-vocab          ï¼ˆå¤š actionï¼šè¯æ±‡å­¦ä¹  / æ¨¡å—è§£é” ç­‰ï¼‰
 * - memory-engine        ï¼ˆå¤š actionï¼šgetTodayMemories / submitMemoryResult / submitRoundEvaluation ç­‰ï¼‰
 * - alphabet             ï¼ˆå­—æ¯æµ‹è¯•ç­‰å•ç‹¬åŠŸèƒ½ï¼‰
 *
 * é™¤ä¸Šè¿°äº‘å‡½æ•°åä»¥å¤–çš„ cloudbase å­—æ®µï¼Œå‡è§†ä¸ºâ€œæœªå®ç°çš„äº‘å‡½æ•°åç§°å ä½â€ï¼Œ
 * ç›®å‰å‰ç«¯ä»£ç ä¸åº”è°ƒç”¨è¿™äº›å ä½ç«¯ç‚¹ã€‚
 */

// ==================== åç«¯ç±»å‹å®šä¹‰ ====================
export type BackendType = 'cloudbase' | 'java';

// ==================== ç«¯ç‚¹æ˜ å°„æ¥å£ ====================
export interface EndpointMap {
  cloudbase: string;  // CloudBase äº‘å‡½æ•°å
  java: string;       // Java Spring Boot è·¯å¾„
}

// ==================== è®¤è¯ API ====================
export const AUTH_ENDPOINTS = {
  // ç”¨æˆ·ç™»å½•
  // âœ… CloudBase: å·²å®ç° user-login äº‘å‡½æ•°
  LOGIN: {
    cloudbase: '/user-login',
    java: '/api/auth/login'
  } as EndpointMap, /*
                    as EndpointMap è¡¨ç¤ºç±»å‹æ–­è¨€
                    ä½œç”¨æ˜¯å‘Šè¯‰TypeScriptç¼–è¯‘å™¨ï¼Œè¿™ä¸ªå¯¹è±¡çš„ç±»å‹æ˜¯EndpointMap
                    */

  // ç”¨æˆ·æ³¨å†Œ
  // âœ… CloudBase: å·²å®ç° user-register äº‘å‡½æ•°
  REGISTER: {
    cloudbase: '/user-register',
    java: '/api/auth/register'
  } as EndpointMap,

  // é‡ç½®å¯†ç 
  // âœ… CloudBase: å·²å®ç° user-reset-password äº‘å‡½æ•°
  RESET_PASSWORD: {
    cloudbase: '/user-reset-password',
    java: '/api/auth/reset-password'
  } as EndpointMap,

  // æ›´æ–°ä¸ªäººèµ„æ–™
  // âœ… CloudBase: å·²å®ç° user-update-profile äº‘å‡½æ•°
  UPDATE_PROFILE: {
    cloudbase: '/user-update-profile',
    java: '/api/user/profile'
  } as EndpointMap,

  // ç™»å‡º
  // âš ï¸ CloudBase: ç›®å‰æ²¡æœ‰ user-logout äº‘å‡½æ•°ï¼Œå‰ç«¯ä»…æœ¬åœ°ç™»å‡ºï¼Œä¸ä¼šè°ƒç”¨è¯¥ cloudbase ç«¯ç‚¹
  LOGOUT: {
    cloudbase: '/user-logout',
    java: '/api/auth/logout'
  } as EndpointMap,
};

// ==================== è¯¾ç¨‹ç®¡ç† API ====================
// âš ï¸ è¯´æ˜ï¼š
// - ä¸‹åˆ— cloudbase å­—æ®µï¼ˆ/course-get-*ï¼‰ç›®å‰æ²¡æœ‰å¯¹åº”çš„äº‘å‡½æ•°ï¼Œä»…ä½œä¸ºæœªæ¥æ‰©å±•çš„å ä½ã€‚
// - å¦‚éœ€åœ¨ CloudBase ä¸Šå®ç°è¯¾ç¨‹ç®¡ç†ï¼Œè¯·æ–°å¢å¯¹åº”äº‘å‡½æ•°åï¼Œå†æ­£å¼å¯ç”¨è¿™äº›ç«¯ç‚¹ã€‚
export const COURSE_ENDPOINTS = {
  // è·å–æ‰€æœ‰è¯¾ç¨‹
  GET_ALL: {
    cloudbase: '/course-get-all',
    java: '/api/courses'
  } as EndpointMap,

  // è·å–è¯¾ç¨‹è¯¦æƒ…
  GET_DETAIL: {
    cloudbase: '/course-get-detail',
    java: '/api/courses/:id'
  } as EndpointMap,

  // è·å–è¯¾ç¨‹å†…å®¹
  GET_CONTENT: {
    cloudbase: '/course-get-content',
    java: '/api/courses/:id/content'
  } as EndpointMap,
};

// ==================== å­¦ä¹ åŠŸèƒ½ API ====================
// âš ï¸ è¯´æ˜ï¼š
// - ä¸‹åˆ— cloudbase å­—æ®µï¼ˆ/learning-*ï¼‰ç›®å‰æ²¡æœ‰å¯¹åº”çš„äº‘å‡½æ•°ï¼Œä»…ä½œä¸ºå ä½ï¼›
// - å½“å‰å®é™…çš„å­—æ¯ / å•è¯å­¦ä¹ ç»Ÿä¸€èµ° memory-engine / learn-vocab å¤š action äº‘å‡½æ•°ã€‚
export const LEARNING_ENDPOINTS = {
  // è·å–å­—æ¯è¡¨
  GET_ALPHABETS: {
    cloudbase: '/learning-get-alphabets',
    java: '/api/learning/alphabets'
  } as EndpointMap,

  // è·å–è¯æ±‡
  GET_VOCABULARY: {
    cloudbase: '/learning-get-vocabulary',
    java: '/api/learning/vocabulary'
  } as EndpointMap,

  // è·å–å¥å­
  GET_SENTENCES: {
    cloudbase: '/learning-get-sentences',
    java: '/api/learning/sentences'
  } as EndpointMap,

  // è·å–æ–‡ç« 
  GET_ARTICLES: {
    cloudbase: '/learning-get-articles',
    java: '/api/learning/articles'
  } as EndpointMap,

  // è®°å½•å­¦ä¹ å®Œæˆ
  RECORD_COMPLETION: {
    cloudbase: '/learning-record-completion',
    java: '/api/learning/record'
  } as EndpointMap,
};

// ==================== å‘éŸ³è¯„ä¼° API ====================
// âš ï¸ è¯´æ˜ï¼š
// - ä¸‹åˆ— cloudbase å­—æ®µï¼ˆ/pronunciation-*ï¼‰ç›®å‰æ²¡æœ‰å¯¹åº”äº‘å‡½æ•°ï¼Œä»… Java ç«¯æˆ–æœªæ¥æ‰©å±•ä½¿ç”¨ã€‚
export const PRONUNCIATION_ENDPOINTS = {
  // å‘éŸ³è¯„ä¼°
  ASSESS: {
    cloudbase: '/pronunciation-assess',
    java: '/api/pronunciation/assess'
  } as EndpointMap,

  // è·å–è¯„ä¼°å†å²
  GET_HISTORY: {
    cloudbase: '/pronunciation-get-history',
    java: '/api/pronunciation/history'
  } as EndpointMap,
};

// ==================== è¿›åº¦ç®¡ç† API ====================
// âš ï¸ è¯´æ˜ï¼š
// - ä¸‹åˆ— cloudbase å­—æ®µï¼ˆ/progress-*ï¼‰ç›®å‰æ²¡æœ‰å¯¹åº”äº‘å‡½æ•°ï¼›
// - è¿›åº¦ç›¸å…³é€»è¾‘æš‚ç”± memory-engine / learn-vocab å†…éƒ¨æ›´æ–° user_progressã€‚
export const PROGRESS_ENDPOINTS = {
  // è·å–è¿›åº¦
  GET: {
    cloudbase: '/progress-get',
    java: '/api/progress'
  } as EndpointMap,

  // æ›´æ–°è¿›åº¦
  UPDATE: {
    cloudbase: '/progress-update',
    java: '/api/progress'
  } as EndpointMap,

  // è·å–ç»Ÿè®¡æ•°æ®
  GET_STATISTICS: {
    cloudbase: '/progress-get-statistics',
    java: '/api/progress/statistics'
  } as EndpointMap,
};

// ==================== å¤ä¹ ç³»ç»Ÿ API ====================
// âš ï¸ è¯´æ˜ï¼š
// - ä¸‹åˆ— cloudbase å­—æ®µï¼ˆ/review-*ï¼‰ç›®å‰æ²¡æœ‰å¯¹åº”äº‘å‡½æ•°ï¼Œä»…ä½œä¸ºæœªæ¥å¤ä¹ ä¸­å¿ƒåŒ–æœåŠ¡çš„å ä½ã€‚
export const REVIEW_ENDPOINTS = {
  // è·å–åˆ°æœŸå¤ä¹ 
  GET_DUE: {
    cloudbase: '/review-get-due',
    java: '/api/reviews/due'
  } as EndpointMap,

  // æ›´æ–°å¤ä¹ è®°å½•
  UPDATE: {
    cloudbase: '/review-update',
    java: '/api/reviews/:id'
  } as EndpointMap,

  // è·å–å¤ä¹ å†å²
  GET_HISTORY: {
    cloudbase: '/review-get-history',
    java: '/api/reviews/history'
  } as EndpointMap,
};

// ==================== æ±‡æ€»æ‰€æœ‰ç«¯ç‚¹ ====================


// ==================== è¾…åŠ©å‡½æ•°ï¼šè·å–ç«¯ç‚¹ ====================
export function getEndpoint(
  endpoint: EndpointMap,
  backendType: BackendType
): string {
  return endpoint[backendType];
}

// ==================== è¾…åŠ©å‡½æ•°ï¼šæ›¿æ¢è·¯å¾„å‚æ•° ====================
/**
 * æ›¿æ¢è·¯å¾„ä¸­çš„å‚æ•°
 * 
 * @example
 * replacePathParams('/api/courses/:id', { id: '123' })
 * // è¿”å›: '/api/courses/123'
 */
export function replacePathParams(
  path: string,
  params: Record<string, string>
): string {
  let result = path;

  for (const [key, value] of Object.entries(params)) {
    result = result.replace(`:${key}`, value);
    result = result.replace(`{${key}}`, value);
  }

  return result;
}
// === å­—æ¯å­¦ä¹  API ===
// ==================== å­—æ¯å­¦ä¹  API ====================
// âš ï¸ è¯´æ˜ï¼š
// - å½“å‰å­—æ¯å­¦ä¹ ä¸»æµç¨‹èµ° memory-engine + getTodayMemoriesã€‚
// - è¿™é‡Œçš„ /vocabulary-get-* äº‘å‡½æ•°ååœ¨ CloudBase ä¸­å¹¶ä¸å­˜åœ¨ï¼Œä»…ä¸ºæœ€æ—©ç‰ˆæœ¬è®¾è®¡çš„å ä½ã€‚
// - ä¸å­—æ¯æµ‹è¯•ç›¸å…³çš„å®é™…äº‘å‡½æ•°ä¸º `alphabet`ï¼ˆå¤š actionï¼‰ï¼Œåç»­å¦‚éœ€å¯¹æ¥å¯åœ¨æ­¤é‡æ–°æ˜ å°„ã€‚
export const ALPHABET_ENDPOINTS = {
  GET_TODAY: {
    cloudbase: '/vocabulary-get-today-alphabets',
    java: '/api/vocabulary/alphabets/today'
  } as EndpointMap,

  SUBMIT_RESULT: {
    cloudbase: '/vocabulary-submit-alphabet-result',
    java: '/api/vocabulary/alphabets/result'
  } as EndpointMap,

  GET_TEST: {
    cloudbase: '/alphabet',  // âœ… ä¿®å¤ï¼šæ·»åŠ å‰å¯¼æ–œæ 
    java: '/api/vocabulary/alphabets/test'
  } as EndpointMap,

  SUBMIT_TEST: {
    cloudbase: '/alphabet',  // âœ… ä¿®å¤ï¼šæ·»åŠ å‰å¯¼æ–œæ 
    java: '/api/vocabulary/alphabets/test/submit'
  } as EndpointMap,
};

// ==================== æ¨¡å—æƒé™ API ====================
export const MODULE_ENDPOINTS = {
  // âœ… CloudBase: ä½¿ç”¨ learn-vocab å¤š action äº‘å‡½æ•°ï¼ˆCHECK_ACCESSï¼‰
  CHECK_ACCESS: {
    cloudbase: '/learn-vocab',
    java: '/api/modules/access'
  } as EndpointMap,
  // ğŸ”¥ ä¿®å¤: GET_USER_PROGRESS å·²è¿ç§»åˆ° memory-engine
  GET_USER_PROGRESS: {
    cloudbase: '/memory-engine',
    java: '/api/modules/progress'
  } as EndpointMap,
};

// ==================== å•è¯å­¦ä¹  API ====================
export const VOCABULARY_ENDPOINTS = {
  // âœ… CloudBase: ä½¿ç”¨ learn-vocab å¤š action äº‘å‡½æ•°ï¼ˆgetTodayWords / updateMastery / getVocabularyList ç­‰ï¼‰
  GET_TODAY_WORDS: {
    cloudbase: '/learn-vocab',
    java: '/api/vocabulary/today'
  } as EndpointMap,
  UPDATE_MASTERY: {
    cloudbase: '/learn-vocab',
    java: '/api/vocabulary/mastery'
  } as EndpointMap,
  GET_VOCABULARY_LIST: {
    cloudbase: '/learn-vocab',
    java: '/api/vocabulary/list'
  } as EndpointMap,
  TOGGLE_SKIP_WORD: {
    cloudbase: '/learn-vocab',
    java: '/api/vocabulary/skip'
  } as EndpointMap,
  GET_SKIPPED_WORDS: {
    cloudbase: '/learn-vocab',
    java: '/api/vocabulary/skipped'
  } as EndpointMap,
  GET_VOCABULARY_DETAIL: {
    cloudbase: '/learn-vocab',
    java: '/api/vocabulary/:id'
  } as EndpointMap,
  GET_REVIEW_STATISTICS: {
    cloudbase: '/learn-vocab',
    java: '/api/vocabulary/statistics'
  } as EndpointMap,
};

// ==================== ç»Ÿä¸€è®°å¿†å¼•æ“ API ====================
export const MEMORY_ENDPOINTS = {
  // âœ… CloudBase: ä½¿ç”¨ memory-engine å¤š action äº‘å‡½æ•°
  GET_TODAY_MEMORIES: {
    cloudbase: '/memory-engine',  // äº‘å‡½æ•°å
    java: '/api/memory/today'
  } as EndpointMap,
  SUBMIT_MEMORY_RESULT: {
    cloudbase: '/memory-engine',
    java: '/api/memory/result'
  } as EndpointMap,
  SUBMIT_ROUND_EVALUATION: {
    cloudbase: '/memory-engine',
    java: '/api/memory/round-evaluation'
  } as EndpointMap,
};

// ==================== ä¸‹è½½äº‘å­˜å‚¨ API ====================
export const STORAGE_ENDPOINTS = {
  GET_DOWNLOAD_URL: {
    cloudbase: '/storage-download',
    java: '/api/storage/get-download-url', // é¢„ç•™
  } as EndpointMap,
  BATCH_GET_DOWNLOAD_URLS: {
    cloudbase: '/storage-download',
    java: '/api/storage/batch-get-download-urls',
  } as EndpointMap,
};

// ==================== æ±‡æ€»æ‰€æœ‰ç«¯ç‚¹ ====================
export const API_ENDPOINTS = {
  AUTH: AUTH_ENDPOINTS,
  COURSE: COURSE_ENDPOINTS,
  LEARNING: LEARNING_ENDPOINTS,
  PRONUNCIATION: PRONUNCIATION_ENDPOINTS,
  PROGRESS: PROGRESS_ENDPOINTS,
  REVIEW: REVIEW_ENDPOINTS,
  ALPHABET: ALPHABET_ENDPOINTS,
  VOCABULARY: VOCABULARY_ENDPOINTS,
  MODULE: MODULE_ENDPOINTS,
  MEMORY: MEMORY_ENDPOINTS,
  STORAGE: STORAGE_ENDPOINTS,
};
</file>

<file path="src/i18n/locales/en.ts">
// src/i18n/locales/en.ts
export default {
  common: {
    confirm: 'Confirm',
    cancel: 'Cancel',
    save: 'Save',
    delete: 'Delete',
    edit: 'Edit',
    loading: 'Loading...',
    error: 'Error',
    success: 'Success',
  },
  auth: {
    title: 'ThaiEasy',
    login: 'Login',
    register: 'Register',
    logout: 'Logout',
    email: 'Email',
    password: 'Password',
    emailPlaceholder: 'Enter your email',
    passwordPlaceholder: 'Enter your password',
    confirmPassword: 'Confirm Password',
    confirmPasswordPlaceholder: 'Re-enter your password',
    displayName: 'Display Name',
    displayNamePlaceholder: 'Enter your display name',
    loginButton: 'Login',
    registerButton: 'Register',
    forgotPassword: 'Forgot password?',
    noAccount: "Don't have an account?",
    hasAccount: 'Already have an account?',
    loginSuccess: 'Login successful',
    loginFailed: 'Login failed',
    alreadyHaveAccount: 'Already have an account?',
    logining: 'logining'
  },
  tabs: {
    home: 'Home',
    learn: 'Learn',
    courses: 'Courses',
    profile: 'Profile',
  },
  profile: {
    title: 'Profile',
    editProfile: 'Edit Profile',
    achievements: 'Achievements',
    settings: 'Settings',
    completedAlphabets: 'Alphabets Learned',
    completedVocabulary: 'Vocabulary Learned',
    completedSentences: 'Sentences Learned',
    completedArticles: 'Articles Read',
    totalScore: 'Total Score',
    studyTime: 'Study Time',
    streakDays: 'Streak Days',
    hours: 'hrs',
    days: 'days',
    selectLanguage: 'Select Language',
    chinese: 'ä¸­æ–‡',
    english: 'English',
    dailyReminder: 'Daily Reminder',
    ttsEngine: 'TTS Engine',
    achievementBadges: {
      streak7: '7-Day Streak',
      master: 'Tone Master',
      vocab100: 'Vocab 100',
    },
  },
  home: {
    greeting: 'Hello',
    todayProgress: "Today's learning goal completed",
    currentCourse: 'Current Course',
    recentMastered: 'Recently Mastered',
    mastered: 'Mastered',
    reviewDue: 'Reviews Due',
    streak: 'Current Streak',
    hoursThisWeek: 'Hours this week',
  },
  courses: {
    title: 'Choose a book, boy',
    subtitle: 'Start your Thai language journey',
    searchPlaceholder: 'Search courses...',
    startBtnText: 'Start Learning',
  },
  learning: {
    basicDefinition: 'Basic Definition',
    exampleSentences: 'Examples',
    usageDetails: 'Usage Details',
    grammarExamples: 'Grammar Examples:',
    diffWithChinese: 'Diff with Chinese:',
    commonMistakes: 'Common Mistakes:',
    similarWordsDiff: 'Similar Words:',
    viewDefinition: 'View Definition',
    nextEnter: 'Next (Enter)',
    next: 'Next',
    forgot: 'Forgot',
    unsure: 'Unsure',
    know: 'Know',
    skipReview: 'Skip Review',
    sessionComplete: 'Session Complete!',
    backToHome: 'Back to Home',
    noNewWordsTitle: 'No New Words',
    noNewWordsMessage: 'You have finished all new words!',
    endSessionTitle: 'End Session?',
    endSessionMessage: 'Are you sure you want to quit?',
    quit: 'Quit',
  },
  modules: {
    alphabet: 'Alphabet',
    word: 'Vocabulary',
    sentence: 'Sentences',
    article: 'Articles',
  },
  moduleAccess: {
    locked: 'Module Locked',
    lockedMessage: '{{module}} module is not yet unlocked',
    requirement: 'Unlock Requirement',
    prerequisite: {
      word: 'Complete alphabet learning and reach 95% progress',
      sentence: 'Complete vocabulary learning and reach 80% progress',
      article: 'Complete sentence learning and reach 80% progress',
    },
    currentProgress: 'Current Progress',
    remainingProgress: '{{remaining}}% remaining',
    progressComplete: 'Progress complete!',
    goBack: 'Go Back',
    noProgress: 'Please start learning first',
    unknownModule: 'Unknown module',
  },
  alphabet: {
    title: 'Thai Alphabet Learning',
    level: 'Basic',
    description: 'Learn 44 consonants and 32 vowels,æŒæ¡ standard pronunciation',
    continue: 'Continue Learning',
    start: 'Start Learning',
  },
  alphabetTest: {
    title: 'Alphabet Test',
    description: 'Test your alphabet knowledge',
    start: 'Start Test',
    submit: 'Submit',
    score: 'Score',
    passed: 'Pass',
    failed: 'Fail',
    retry: 'Retry',
    backToHome: 'Back to Home',
  }
};
</file>

<file path="src/i18n/locales/zh.ts">
// src/i18n/locales/zh.ts
export default {
  common: {
    confirm: 'ç¡®è®¤',
    cancel: 'å–æ¶ˆ',
    save: 'ä¿å­˜',
    delete: 'åˆ é™¤',
    edit: 'ç¼–è¾‘',
    loading: 'åŠ è½½ä¸­...',
    error: 'é”™è¯¯',
    success: 'æˆåŠŸ',
  },
  auth: {
    title: 'æ³°Easy',
    login: 'ç™»å½•',
    register: 'æ³¨å†Œ',
    logout: 'é€€å‡ºç™»å½•',
    email: 'é‚®ç®±',
    password: 'å¯†ç ',
    emailPlaceholder: 'è¯·è¾“å…¥é‚®ç®±',
    passwordPlaceholder: 'è¯·è¾“å…¥å¯†ç ',
    confirmPassword: 'ç¡®è®¤å¯†ç ',
    confirmPasswordPlaceholder: 'è¯·å†æ¬¡è¾“å…¥å¯†ç ',
    displayName: 'æ˜µç§°',
    displayNamePlaceholder: 'è¯·è¾“å…¥æ˜µç§°',
    loginButton: 'ç™»å½•',
    registerButton: 'æ³¨å†Œ',
    forgotPassword: 'å¿˜è®°å¯†ç ï¼Ÿ',
    noAccount: 'è¿˜æ²¡æœ‰è´¦å·ï¼Ÿ',
    hasAccount: 'å·²æœ‰è´¦å·ï¼Ÿ',
    loginSuccess: 'ç™»å½•æˆåŠŸ',
    loginFailed: 'ç™»å½•å¤±è´¥',
    alreadyHaveAccount: 'å·²æœ‰è´¦å·ï¼Ÿ',
    logining: 'ç™»å½•ä¸­'
  },
  tabs: {
    home: 'é¦–é¡µ',
    learn: 'å­¦ä¹ ',
    courses: 'è¯¾ç¨‹',
    profile: 'æˆ‘çš„',
  },
  profile: {
    title: 'ä¸ªäººä¸­å¿ƒ',
    editProfile: 'ç¼–è¾‘èµ„æ–™',
    achievements: 'å­¦ä¹ æˆå°±',
    settings: 'è®¾ç½®',
    completedAlphabets: 'å·²å­¦å­—æ¯',
    completedVocabulary: 'å·²å­¦è¯æ±‡',
    completedSentences: 'å·²å­¦å¥å­',
    completedArticles: 'å·²è¯»æ–‡ç« ',
    totalScore: 'æ€»åˆ†',
    studyTime: 'å­¦ä¹ æ—¶é•¿',
    streakDays: 'è¿ç»­å¤©æ•°',
    hours: 'å°æ—¶',
    days: 'å¤©',
    selectLanguage: 'é€‰æ‹©è¯­è¨€',
    chinese: 'ä¸­æ–‡',
    english: 'English',
    dailyReminder: 'æ¯æ—¥æé†’',
    ttsEngine: 'éŸ³é¢‘åé¦ˆå¼•æ“',
    achievementBadges: {
      streak7: '7å¤©è¿èƒœ',
      master: 'å£°è°ƒå¤§å¸ˆ',
      vocab100: 'è¯æ±‡100',
    },
  },
  home: {
    greeting: 'àºªàº°àºšàº²àºàº”àºµ',
    todayProgress: 'ä»Šæ—¥å­¦ä¹ ç›®æ ‡å·²å®Œæˆ',
    currentCourse: 'å½“å‰è¯¾ç¨‹',
    recentMastered: 'æœ€è¿‘æŒæ¡',
    mastered: 'å·²æŒæ¡',
    reviewDue: 'å¾…å¤ä¹ å†…å®¹',
    streak: 'è¿ç»­æ‰“å¡',
    hoursThisWeek: 'æœ¬å‘¨å°æ—¶æ•°',
  },
  courses: {
    title: 'é€‰æ‹©ä¸€æœ¬å§å°‘å¹´',
    subtitle: 'å¼€å¯ä½ çš„æ³°è¯­å­¦ä¹ ä¹‹æ—…',
    searchPlaceholder: 'æœç´¢è¯¾ç¨‹...',
    startBtnText: 'å¼€å§‹å­¦ä¹ ',
  },
  learning: {
    basicDefinition: 'åŸºç¡€é‡Šä¹‰',
    exampleSentences: 'ä¾‹å¥ç¤ºä¾‹',
    usageDetails: 'ç”¨æ³•è¯¦è§£',
    grammarExamples: 'è¯­æ³•ç¤ºä¾‹:',
    diffWithChinese: 'ä¸ä¸­æ–‡å·®å¼‚:',
    commonMistakes: 'å¸¸è§é”™è¯¯:',
    similarWordsDiff: 'ç›¸ä¼¼è¯æ±‡åŒºåˆ«:',
    viewDefinition: 'æŸ¥çœ‹é‡Šä¹‰',
    nextEnter: 'ä¸‹ä¸€ä¸ª (Enter)',
    next: 'ä¸‹ä¸€ä¸ª',
    forgot: 'å¿˜è®°äº†',
    unsure: 'æ¨¡ç³Š',
    know: 'è®¤è¯†',
    skipReview: 'è·³è¿‡å¤ä¹ ',
    sessionComplete: 'å­¦ä¹ å®Œæˆï¼',
    backToHome: 'è¿”å›é¦–é¡µ',
    noNewWordsTitle: 'æ²¡æœ‰æ–°å•è¯',
    noNewWordsMessage: 'ä½ å·²ç»å­¦å®Œäº†æ‰€æœ‰æ–°å•è¯ï¼',
    endSessionTitle: 'ç»“æŸå­¦ä¹ ï¼Ÿ',
    endSessionMessage: 'ç¡®å®šè¦é€€å‡ºå—ï¼Ÿ',
    quit: 'é€€å‡º',
  },
  modules: {
    alphabet: 'å­—æ¯å­¦ä¹ ',
    word: 'å•è¯å­¦ä¹ ',
    sentence: 'å¥å­å­¦ä¹ ',
    article: 'æ–‡ç« é˜…è¯»',
  },
  moduleAccess: {
    locked: 'æ¨¡å—å·²é”å®š',
    lockedMessage: '{{module}}æ¨¡å—æš‚æœªè§£é”',
    requirement: 'è§£é”è¦æ±‚',
    prerequisite: {
      word: 'å®Œæˆå­—æ¯å­¦ä¹ å¹¶è¾¾åˆ° 95% è¿›åº¦',
      sentence: 'å®Œæˆå•è¯å­¦ä¹ å¹¶è¾¾åˆ° 80% è¿›åº¦',
      article: 'å®Œæˆå¥å­å­¦ä¹ å¹¶è¾¾åˆ° 80% è¿›åº¦',
    },
    currentProgress: 'å½“å‰è¿›åº¦',
    remainingProgress: 'è¿˜éœ€å®Œæˆ {{remaining}}%',
    progressComplete: 'è¿›åº¦å·²è¾¾æ ‡ï¼',
    goBack: 'è¿”å›',
    noProgress: 'è¯·å…ˆå¼€å§‹å­¦ä¹ ',
    unknownModule: 'æœªçŸ¥æ¨¡å—',
  },
  alphabet: {
    title: 'æ³°è¯­å­—æ¯å­¦ä¹ ',
    level: 'åŸºç¡€',
    description: 'å­¦ä¹ 44ä¸ªè¾…éŸ³å’Œ32ä¸ªå…ƒéŸ³ï¼ŒæŒæ¡æ ‡å‡†å‘éŸ³',
    continue: 'ç»§ç»­å­¦ä¹ ',
    start: 'å¼€å§‹å­¦ä¹ ',
  },
  alphabetTest: {
    title: 'å­—æ¯æµ‹è¯•',
    description: 'æµ‹è¯•ä½ çš„å­—æ¯æŒæ¡æƒ…å†µ',
    start: 'å¼€å§‹æµ‹è¯•',
    submit: 'æäº¤',
    score: 'å¾—åˆ†',
    passed: 'é€šè¿‡',
    failed: 'æœªé€šè¿‡',
    retry: 'é‡æ–°æµ‹è¯•',
    backToHome: 'è¿”å›é¦–é¡µ',
  }
};
</file>

<file path="src/stores/userStore.ts">
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { apiClient } from '../utils/apiClient';
import { API_ENDPOINTS } from '../config/api.endpoints';
import type {
  LoginRequest,
  RegisterRequest,
  ResetPasswordRequest,
  LoginResponse,
  RegisterResponse,
  ResetPasswordResponse
} from '../entities/types/api.types';
import type { User } from '../entities/types/entities';

// Type definitions


interface UserState {
  // State
  currentUser: User | null;
  isAuthenticated: boolean;
  authToken: string | null;
  isLoading: boolean;
  error: string | null;

  // Actions
  register: (data: RegisterRequest) => Promise<boolean>;
  login: (data: LoginRequest) => Promise<boolean>;
  logout: () => void;
  requestPasswordReset: (data: ResetPasswordRequest) => Promise<boolean>;
  updateProfile: (data: { displayName?: string; avatar?: string }) => Promise<boolean>;
  setUser: (user: User, token: string) => void;
  checkAuth: () => boolean;
  clearError: () => void;
}

const validateEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

const validatePassword = (password: string): { valid: boolean; error?: string } => {
  if (password.length < 6) {
    return { valid: false, error: 'Password must be at least 6 characters' };
  }
  // å¯ä»¥æ·»åŠ æ›´å¤šè§„åˆ™
  return { valid: true };
};

// ==================== Store ====================

export const useUserStore = create<UserState>()(
  persist(
    (set, get) => ({
      // ==================== åˆå§‹çŠ¶æ€ ====================
      currentUser: null,
      isAuthenticated: false,
      authToken: null,
      isLoading: false,
      error: null,

      // ==================== æ³¨å†Œ ====================
      /**
       * Register a new user
       * 
       * Flow:
       * 1. Set loading state
       * 2. Call API
       * 3. If success: save user + token, set authenticated
       * 4. If fail: save error message
       * 
       * @param data Registration data (email, password, displayName)
       * @returns Success status
       */
      register: async (data: RegisterRequest) => {

        if (!validateEmail(data.email)) {
          set({ error: 'Invalid email format' });
          return false;
        }

        const passwordValidation = validatePassword(data.password);
        if (!passwordValidation.valid) {
          set({ error: passwordValidation.error });
          return false;
        }

        if (!data.displayName.trim()) {
          set({ error: 'Display name is required' });
          return false;
        }

        set({ isLoading: true, error: null });

        try {
          const response = await apiClient.post<RegisterResponse>(
            API_ENDPOINTS.AUTH.REGISTER,
            {
              email: data.email.toLowerCase().trim(),
              password: data.password,
              displayName: data.displayName,
            });

          if (response.success && response.data) {
            const { user, token } = response.data;

            // Save token to apiClient for future requests
            apiClient.setAuthToken(token);

            // Update store state
            set({
              currentUser: user as User,
              authToken: token,
              isAuthenticated: true,
              isLoading: false,
              error: null,
            });

            // ğŸ” è°ƒè¯•æ—¥å¿—ï¼šæ³¨å†ŒæˆåŠŸåæ‰“å° userId
            console.log('âœ… [æ³¨å†ŒæˆåŠŸ] currentUser.userId:', user.userId);

            return true;

          } else {
            set({
              error: response.error || 'æ³¨å†Œå¤±è´¥',
              isLoading: false,
            });
            return false;
          }
        } catch (error: any) {
          set({
            error: error.message || 'æ³¨å†Œå¤±è´¥',
            isLoading: false,
          });
          return false;
        }
      },

      // ==================== ç™»å½• ====================
      /**
       * Authenticate user
       * 
       * Flow:
       * 1. Set loading state
       * 2. Call API
       * 3. If success: save user + token, set authenticated
       * 4. If fail: save error message
       * 
       * @param email User email
       * @param password User password
       * @returns Success status
       */
      login: async (data: LoginRequest) => {

        if (!validateEmail(data.email)) {
          set({ error: 'Invalid email format' });
          return false;
        }

        const passwordValidation = validatePassword(data.password);
        if (!passwordValidation.valid) {
          set({ error: passwordValidation.error });
          return false;
        }

        set({ isLoading: true, error: null });

        try {
          const response = await apiClient.post<LoginResponse>(API_ENDPOINTS.AUTH.LOGIN, {
            email: data.email.toLowerCase().trim(),
            password: data.password,
          });

          if (response.success && response.data) {
            const { user, token } = response.data;

            // Save token to apiClient for future requests
            apiClient.setAuthToken(token);

            // Update store state
            set({
              currentUser: user as User,
              authToken: token,
              isAuthenticated: true,
              isLoading: false,
              error: null,
            });

            // ğŸ” è°ƒè¯•æ—¥å¿—ï¼šç™»å½•æˆåŠŸåæ‰“å° userId
            console.log('âœ… [ç™»å½•æˆåŠŸ] currentUser.userId:', user.userId);

            return true;
          } else {
            set({
              error: response.error || 'Login failed',
              isLoading: false,
            });
            return false;
          }
        } catch (error: any) {
          set({
            error: error.message || 'Login failed',
            isLoading: false,
          });
          return false;
        }
      },

      // ==================== ç™»å‡º ====================
      /**
       * Logout current user
       * 
       * Flow:
       * 1. Clear apiClient token
       * 2. Clear store state
       * 3. Clear AsyncStorage (via persist middleware)
       */
      logout: () => {
        // Clear token from apiClient
        apiClient.setAuthToken(null);

        // Clear store state
        set({
          currentUser: null,
          authToken: null,
          isAuthenticated: false,
          error: null,
        });
      },

      // ==================== é‡ç½®å¯†ç  ====================
      /**
       * Request password reset email
       * 
       * @param email User email
       * @returns Success status
       */
      requestPasswordReset: async (data: ResetPasswordRequest) => {
        if (!validateEmail(data.email)) {
          set({ error: 'Invalid email format', isLoading: false });
          return false;
        }

        set({ isLoading: true, error: null });

        try {
          const response = await apiClient.post<ResetPasswordResponse>(
            API_ENDPOINTS.AUTH.RESET_PASSWORD,
            { email: data.email.toLowerCase().trim() }
          );

          if (response.success) {
            set({ isLoading: false, error: null });
            return true;
          } else {
            set({
              error: response.error || 'Password reset failed',
              isLoading: false,
            });
            return false;
          }
        } catch (error: any) {
          set({
            error: error.message || 'Password reset failed',
            isLoading: false,
          });
          return false;
        }
      },

      // ==================== æ›´æ–°ä¸ªäººèµ„æ–™ ====================
      /**
       * Update user profile
       * 
       * @param data Profile data to update
       * @returns Success status
       */
      updateProfile: async (data: { displayName?: string; avatar?: string }) => {
        const currentUser = get().currentUser;
        if (!currentUser) {
          set({ error: 'No user logged in' });
          return false;
        }

        set({ isLoading: true, error: null });

        try {
          const response = await apiClient.put<{ user: User }>(
            API_ENDPOINTS.AUTH.UPDATE_PROFILE,
            {
              userId: currentUser.userId,
              ...data,
            });

          if (response.success && response.data) {
            set({
              currentUser: {
                ...currentUser,
                ...(data.displayName && { displayName: data.displayName }),
                ...(data.avatar && { avatar: data.avatar }),
              },
              isLoading: false,
              error: null,
            });
            return true;
          } else {
            set({
              error: response.error || 'Profile update failed',
              isLoading: false,
            });
            return false;
          }
        } catch (error: any) {
          set({
            error: error.message || 'Profile update failed',
            isLoading: false,
          });
          return false;
        }
      },

      // ===== Set User (Direct) =====
      /**
       * Directly set user and token
       * Used for: OAuth flows, token refresh
       * 
       * @param user User object
       * @param token Auth token
       */
      setUser: (user: User, token: string) => {
        apiClient.setAuthToken(token);

        set({
          currentUser: user,
          authToken: token,
          isAuthenticated: true,
          error: null,
        });
      },

      // ===== Check Auth Status =====
      /**
       * Check if user is authenticated
       * 
       * @returns Authentication status
       */
      checkAuth: () => {
        const state = get();
        return state.isAuthenticated && state.authToken !== null;
      },

      // ===== Clear Error =====
      /**
       * Clear error message
       */
      clearError: () => {
        set({ error: null });
      },
    }),
    {
      name: 'user-storage', // AsyncStorage key
      storage: createJSONStorage(() => AsyncStorage),

      // Restore auth token to apiClient on rehydration
      onRehydrateStorage: () => {
        return (state) => {
          if (state?.authToken) {
            apiClient.setAuthToken(state.authToken);
          }
        };
      },
    }
  )
);
</file>

<file path="app/alphabet/[lessonId].tsx">
// app/alphabet/lesson/[lessonId].tsx

import { useLocalSearchParams, useRouter } from 'expo-router';
import React, { useEffect, useMemo, useState } from 'react';
import { View, Text, ActivityIndicator, StyleSheet, Pressable } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { ArrowLeft, Lock } from 'lucide-react-native'; // Assuming Lock icon exists or use fallback

import { useAlphabetLearningEngine } from '@/src/hooks/useAlphabetLearningEngine';
import { AlphabetLearningEngineView } from '@/src/components/learning/alphabet/AlphabetLearningEngineView';
import { useModuleAccessStore } from '@/src/stores/moduleAccessStore';
import { getLessonMetadata, getAllLessons } from '@/src/config/alphabet/lessonMetadata.config';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';

export default function AlphabetLessonFlow() {
  const { lessonId } = useLocalSearchParams<{ lessonId: string }>();
  const router = useRouter();

  // Access Control & Progress
  const { userProgress, getUserProgress } = useModuleAccessStore();
  const [isCheckingAccess, setIsCheckingAccess] = useState(true);

  useEffect(() => {
    let mounted = true;
    (async () => {
      await getUserProgress();
      if (mounted) setIsCheckingAccess(false);
    })();
    return () => { mounted = false; };
  }, [getUserProgress]);

  // Unlock Logic
  const isUnlocked = useMemo(() => {
    if (!lessonId) return false;
    // Always load progress before deciding (unless lesson1, but let's be consistent)
    if (isCheckingAccess && !userProgress) return false;

    const currentMetadata = getLessonMetadata(lessonId);
    if (!currentMetadata) return false; // Invalid lesson ID

    // Rule 1: Lesson 1 always unlocked
    if (currentMetadata.order === 1) return true;

    // Rule 2: Lesson N requires Lesson N-1 completed
    const allLessons = getAllLessons();
    const prevLesson = allLessons.find(l => l.order === currentMetadata.order - 1);

    // Safety: If no prev lesson found (logic error?), default to locked or unlocked? 
    // Strict default: Locked.
    if (!prevLesson) return false;

    const completed = userProgress?.completedAlphabetLessons ?? [];
    return completed.includes(prevLesson.lessonId);
  }, [lessonId, userProgress, isCheckingAccess]);


  // Engine Hook - Only initialize if unlocked to prevent side effects
  // We conditionally call the hook? No, hooks must be unconditional.
  // But we can prevent it from doing work by passing a null or invalid ID if locked,
  // OR we rely on the component returning early before `useAlphabetLearningEngine` has side effects that matter.
  // Actually, `useAlphabetLearningEngine` has `initializeSession` in `useEffect`. 
  // We MUST prevent that useEffect if locked.
  // Easy way: pass `null` or `undefined` as lessonId to the hook if locked, but hook expects string.
  // Better way: The hook takes `lessonId`. If we pass a dummy or keep it as is, it's fine 
  // AS LONG AS we don't render the view that triggers start.
  // BUT the hook starts auto-initialization. 
  // Let's modify the hook call to key off `isUnlocked`.

  // Wait, I cannot conditionally call a hook. I must call it.
  // I will pass `isUnlocked ? lessonId : ''` to the hook? 
  // If I access `app/alphabet/lessonX`, lessonId is 'lessonX'.
  // If I early return NOT in the component body but RENDER a different component, the hook still runs.

  // Strict requirement: "ç‚¹å‡»ä¸å¾—è§¦å‘å¯¼èˆª / åˆå§‹åŒ– session" => "ä¸å…è®¸è§¦å‘å­¦ä¹ å¼•æ“".
  // If the hook runs `initializeSession`, it touches the backend.
  // I should check `isUnlocked` BEFORE calling the hook? No, I can't.

  // Solution: I will split the component? 
  // Or I can just verify that `useAlphabetLearningEngine` doesn't explode if I don't use the result?
  // It DOES `initializeSession`.

  // Best approach: A Guard Wrapper Component.
  // The default export will be the Guard. 
  // If unlocked, it renders the Engine Component (which calls the hook).

  if (isCheckingAccess) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: Colors.paper }}>
        <ActivityIndicator size="large" color={Colors.thaiGold} />
      </View>
    );
  }

  if (!isUnlocked) {
    return (
      <SafeAreaView style={styles.lockedContainer}>
        <ThaiPatternBackground opacity={0.1} />
        <View style={styles.lockedContent}>
          <Lock size={64} color={Colors.taupe} style={{ marginBottom: 24 }} />
          <Text style={styles.lockedTitle}>Lesson Locked</Text>
          <Text style={styles.lockedText}>
            Please complete the previous lesson to unlock this content.
          </Text>
          <Pressable onPress={() => router.replace('/alphabet')} style={styles.backButton}>
            <ArrowLeft size={20} color={Colors.white} />
            <Text style={styles.backButtonText}>Back to Courses</Text>
          </Pressable>
        </View>
      </SafeAreaView>
    );
  }

  // Only render the Engine (and trigger the hook) if verified unlocked
  return <AuthenticatedLessonFlow lessonId={lessonId!} />;
}

// Inner component that actually invokes the engine hook
function AuthenticatedLessonFlow({ lessonId }: { lessonId: string }) {
  const router = useRouter();

  const {
    phase,
    initialized,
    currentRound,
    roundEvaluation,
    currentItem,
    currentQuestionType,
    letterPool,
    onAnswer,
    onNext,
    phonicsRule,
    showPhonicsRuleCard,
    onCompletePhonicsRule,
    pendingRecoverySession,
    resolveRecovery,
    onFinishRound,
    onSkipYesterdayReview,
  } = useAlphabetLearningEngine(lessonId);

  const handleBack = async () => {
    // ğŸ”¥ åœ¨ç¦»å¼€é¡µé¢å‰æ¸…é™¤ session
    await onFinishRound();
    router.back();
  };

  return (
    <AlphabetLearningEngineView
      phase={phase}
      initialized={initialized}
      currentRound={currentRound}
      roundEvaluation={roundEvaluation}
      currentItem={currentItem}
      currentQuestionType={currentQuestionType}
      letterPool={letterPool}
      onAnswer={onAnswer}
      onNext={onNext}
      onBack={handleBack}
      phonicsRule={phonicsRule}
      showPhonicsRuleCard={showPhonicsRuleCard}
      onCompletePhonicsRule={onCompletePhonicsRule}
      pendingRecoverySession={pendingRecoverySession}
      resolveRecovery={resolveRecovery}
      onSkipYesterdayReview={onSkipYesterdayReview}
    />
  );
}

const styles = StyleSheet.create({
  lockedContainer: {
    flex: 1,
    backgroundColor: Colors.paper,
    justifyContent: 'center',
    alignItems: 'center',
  },
  lockedContent: {
    alignItems: 'center',
    padding: 32,
    backgroundColor: Colors.white,
    borderRadius: 24,
    width: '80%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 12,
    elevation: 8,
  },
  lockedTitle: {
    fontFamily: Typography.playfairBold,
    fontSize: 24,
    color: Colors.ink,
    marginBottom: 12,
  },
  lockedText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.taupe,
    textAlign: 'center',
    marginBottom: 32,
    lineHeight: 24,
  },
  backButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.thaiGold,
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 30,
    gap: 8,
  },
  backButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
  },
});
</file>

<file path="src/stores/moduleAccessStore.ts">
// src/stores/moduleAccessStore.ts

/**
 * æ¨¡å—è®¿é—®æ§åˆ¶ Store
 * 
 * åŠŸèƒ½ï¼š
 * 1. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æŸä¸ªæ¨¡å—
 * 2. ç¼“å­˜è®¿é—®æƒé™ç»“æœ
 * 3. æä¾›å…¨å±€è¿›åº¦æ•°æ®
 */

import { create } from 'zustand';
import { callCloudFunction } from '@/src/utils/apiClient';
import { API_ENDPOINTS } from '@/src/config/api.endpoints';
import { useUserStore } from './userStore';
import { LESSON_METADATA } from '@/src/config/alphabet/lessonMetadata.config';
import AsyncStorage from '@react-native-async-storage/async-storage';


const getCompletedLessonsStorageKey = (userId: string): string =>
    `@alphabet_completed_lessons_${userId}`;



// ==================== ç±»å‹å®šä¹‰ ====================

/**
 * æ¨¡å—ç±»å‹
 * 
 * æ³¨æ„ï¼š
 * - ä¸åç«¯ memory-engine.checkModuleAccess ä¿æŒä¸€è‡´ï¼Œå­—æ¯æ¨¡å—ä½¿ç”¨ 'letter'
 */
export type ModuleType = 'letter' | 'word' | 'sentence' | 'article';

/**
 * ç”¨æˆ·è¿›åº¦æ•°æ®
 */
export interface UserProgress {
    // å­—æ¯å­¦ä¹ è¿›åº¦
    letterProgress: number;           // 0-1 (åç«¯å­˜å‚¨ä¸ºæ¯”ä¾‹å€¼)
    letterCompleted: boolean;         // Added: Whether letter learning is completed
    letterMasteredCount: number;      // å·²æŒæ¡å­—æ¯æ•°
    letterTotalCount: number;         // æ€»å­—æ¯æ•°

    // å•è¯å­¦ä¹ è¿›åº¦
    wordProgress: number;             // 0-100
    wordMasteredCount: number;        // å·²æŒæ¡å•è¯æ•°
    wordTotalCount: number;           // æ€»å•è¯æ•°

    // å¥å­å­¦ä¹ è¿›åº¦
    sentenceProgress: number;         // 0-100
    sentenceMasteredCount: number;    // å·²æŒæ¡å¥å­æ•°
    sentenceTotalCount: number;       // æ€»å¥å­æ•°

    // æ–‡ç« å­¦ä¹ è¿›åº¦
    articleProgress: number;          // 0-100
    articleMasteredCount: number;     // å·²æŒæ¡æ–‡ç« æ•°
    articleTotalCount: number;        // æ€»æ–‡ç« æ•°

    // è§£é”çŠ¶æ€
    wordUnlocked: boolean;            // å•è¯æ¨¡å—æ˜¯å¦è§£é”
    sentenceUnlocked: boolean;        // å¥å­æ¨¡å—æ˜¯å¦è§£é”
    articleUnlocked: boolean;         // æ–‡ç« æ¨¡å—æ˜¯å¦è§£é”

    /**
     * å­—æ¯è¯¾ç¨‹å®Œæˆæƒ…å†µï¼ˆä»…å‰ç«¯ä½¿ç”¨ï¼‰
     * ä¾‹å¦‚: ['lesson1','lesson2',...]
     */
    completedAlphabetLessons?: string[];

    // è®¾ç½®
    dailyLimit?: number;              // æ¯æ—¥å­¦ä¹ æ•°é‡è®¾ç½®
}

/**
 * è®¿é—®æ£€æŸ¥å“åº”
 */
interface CheckAccessResponse {
    allowed: boolean;
    reason?: string;
    requiredProgress?: number;
    currentProgress?: number;
}

/**
 * ç”¨æˆ·è¿›åº¦å“åº”ï¼ˆåç«¯è¿”å›ï¼‰
 */
interface UserProgressResponse {
    progress: UserProgress & {
        completedLessons?: string[];  // ğŸ”¥ åç«¯è¿”å›å­—æ®µï¼ˆuser_alphabet_progress.completedLessonsï¼‰
    };
}

// ==================== Store å®šä¹‰ ====================

interface ModuleAccessStore {
    // ===== çŠ¶æ€ =====
    userProgress: UserProgress | null;
    accessCache: Map<ModuleType, boolean>;
    isLoading: boolean;
    error: string | null;

    // ===== æ–¹æ³• =====
    checkAccess: (moduleType: ModuleType) => Promise<boolean>;
    checkAccessLocally: (moduleType: ModuleType) => boolean;
    getUserProgress: () => Promise<void>;
    clearCache: () => void;
    setError: (error: string | null) => void;
    setDailyLimit: (moduleType: ModuleType, limit: number) => void;
    /**
     * æ ‡è®°æŸä¸ªå­—æ¯è¯¾ç¨‹å·²å®Œæˆï¼ˆä»…ç”¨äºå­—æ¯æ¨¡å—è§£é”é“¾è·¯ï¼‰
     */
    markAlphabetLessonCompleted: (lessonId: string) => void;
}

// ==================== é»˜è®¤è¿›åº¦æ•°æ® ====================

const defaultProgress: UserProgress = {
    letterProgress: 0,
    letterCompleted: false,
    letterMasteredCount: 0,
    letterTotalCount: 44,
    wordProgress: 0,
    wordMasteredCount: 0,
    wordTotalCount: 0,
    sentenceProgress: 0,
    sentenceMasteredCount: 0,
    sentenceTotalCount: 0,
    articleProgress: 0,
    articleMasteredCount: 0,
    articleTotalCount: 0,
    wordUnlocked: false,
    sentenceUnlocked: false,
    articleUnlocked: false,
};

// ==================== Store å®ç° ====================

export const useModuleAccessStore = create<ModuleAccessStore>()((set, get) => ({
    // ===== åˆå§‹çŠ¶æ€ =====
    userProgress: null,
    accessCache: new Map<ModuleType, boolean>(),
    isLoading: false,
    error: null,

    // ===== æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™ =====
    /**
     * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æŸä¸ªæ¨¡å—
     * 
     * @param moduleType æ¨¡å—ç±»å‹
     * @returns æ˜¯å¦æœ‰æƒé™è®¿é—®
     */
    checkAccess: async (moduleType: ModuleType): Promise<boolean> => {
        const { accessCache } = get();
        const userId = useUserStore.getState().currentUser?.userId;

        if (!userId) {
            console.warn('âš ï¸ ç”¨æˆ·æœªç™»å½•ï¼Œæ— æ³•æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™');
            return false;
        }

        // 1. æ£€æŸ¥ç¼“å­˜
        if (accessCache.has(moduleType)) {
            const cachedResult = accessCache.get(moduleType);
            console.log(`âœ… ä»ç¼“å­˜è·å– ${moduleType} è®¿é—®æƒé™:`, cachedResult);
            return cachedResult!;
        }

        try {
            set({ isLoading: true, error: null });

            // 2. è°ƒç”¨äº‘å‡½æ•°æ£€æŸ¥æƒé™
            const result = await callCloudFunction<CheckAccessResponse>(
                'checkModuleAccess',
                {
                    userId,
                    moduleType,
                },
                {
                    endpoint: API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase,
                }
            );

            if (result.success && result.data) {
                const allowed = result.data.allowed;

                // 3. ç¼“å­˜ç»“æœ
                const newCache = new Map(accessCache);
                newCache.set(moduleType, allowed);
                set({ accessCache: newCache, isLoading: false });

                console.log(`âœ… ${moduleType} è®¿é—®æƒé™æ£€æŸ¥å®Œæˆ:`, allowed);

                // å¦‚æœä¸å…è®¸ï¼Œè®°å½•åŸå› 
                if (!allowed && result.data.reason) {
                    console.log(`ğŸ“Œ æ‹’ç»åŸå› : ${result.data.reason}`);
                }

                return allowed;
            } else {
                // è¯·æ±‚å¤±è´¥ï¼Œé™çº§å¤„ç†
                console.warn('âš ï¸ äº‘å‡½æ•°è°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°é€»è¾‘åˆ¤æ–­');
                const localAllowed = get().checkAccessLocally(moduleType);

                // ç¼“å­˜æœ¬åœ°åˆ¤æ–­ç»“æœ
                const newCache = new Map(accessCache);
                newCache.set(moduleType, localAllowed);
                set({ accessCache: newCache, isLoading: false });

                return localAllowed;
            }
        } catch (error: any) {
            console.error('âŒ checkAccess error:', error);
            set({ error: error.message || 'æ£€æŸ¥æƒé™å¤±è´¥', isLoading: false });

            // é™çº§åˆ°æœ¬åœ°é€»è¾‘
            const localAllowed = get().checkAccessLocally(moduleType);

            // ç¼“å­˜æœ¬åœ°åˆ¤æ–­ç»“æœ
            const newCache = new Map(get().accessCache);
            newCache.set(moduleType, localAllowed);
            set({ accessCache: newCache });

            return localAllowed;
        }
    },

    // ===== æœ¬åœ°æƒé™æ£€æŸ¥é€»è¾‘ï¼ˆé™çº§æ–¹æ¡ˆï¼‰=====
    /**
     * æœ¬åœ°æƒé™æ£€æŸ¥é€»è¾‘ï¼ˆé™çº§æ–¹æ¡ˆï¼‰
     * 
     * @param moduleType æ¨¡å—ç±»å‹
     * @returns æ˜¯å¦æœ‰æƒé™è®¿é—®
     */
    checkAccessLocally: (moduleType: ModuleType): boolean => {
        const { userProgress } = get();

        if (!userProgress) {
            // å¦‚æœæ²¡æœ‰è¿›åº¦æ•°æ®ï¼Œå…è®¸è®¿é—®å­—æ¯æ¨¡å—ï¼Œå…¶ä»–æ¨¡å—ä¸å…è®¸
            return moduleType === 'letter';
        }

        // ä¸åç«¯ memory-engine.checkModuleAccess çš„æ„å›¾ä¿æŒä¸€è‡´ï¼š
        // - å­—æ¯æ¨¡å—å§‹ç»ˆå¯è®¿é—®
        // - åªè¦ letterCompleted ä¸º trueï¼Œæˆ– letterProgress â‰¥ 0.8ï¼Œæ‰€æœ‰éå­—æ¯æ¨¡å—ç»Ÿä¸€è§£é”
        if (moduleType === 'letter') {
            return true;
        }

        const finishedByTest = !!userProgress.letterCompleted;
        const finishedByProgress = (userProgress.letterProgress ?? 0) >= 0.8;

        return finishedByTest || finishedByProgress;
    },

    // ===== è·å–ç”¨æˆ·è¿›åº¦ =====
    // ===== è·å–ç”¨æˆ·è¿›åº¦ =====
    /**
     * ä»åç«¯è·å–ç”¨æˆ·è¿›åº¦æ•°æ®
     */
    getUserProgress: async (): Promise<void> => {
        const userId = useUserStore.getState().currentUser?.userId;

        if (!userId) {
            console.warn('âš ï¸ ç”¨æˆ·æœªç™»å½•ï¼Œæ— æ³•è·å–è¿›åº¦æ•°æ®');
            set({ userProgress: defaultProgress });
            return;
        }

        try {
            const oldKey = '@alphabet_completed_lessons';
            const oldData = await AsyncStorage.getItem(oldKey);
            if (oldData) {
                await AsyncStorage.removeItem(oldKey);
                console.log('Old key has been delete.');
            }
        } catch (e) {
            console.warn('åˆ é™¤æ—§keyå¤±è´¥ï¼š', e)
        }

        set({ isLoading: true, error: null });

        // Helper to try fetch
        const fetchProgress = async (endpoint: string) => {
            return await callCloudFunction<UserProgressResponse>(
                'getUserProgress',
                { userId, entityType: 'letter' },  // ğŸ”¥ æ·»åŠ  entityType å‚æ•°
                { endpoint }
            );
        };

        try {
            // 1. Try Primary Endpoint (memory-engine)
            let result = await fetchProgress(API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase);

            // 2. Fallback to Legacy Endpoint (learn-vocab) if failed
            if (!result.success) {
                console.warn(`âš ï¸ Primary endpoint failed (${result.error}), trying fallback...`);
                result = await fetchProgress(API_ENDPOINTS.MODULE.CHECK_ACCESS.cloudbase);
            }

            if (result.success && result.data) {
                // ğŸ”¥ Step 3: ä»¥åç«¯æ•°æ®ä¸ºå‡†ï¼Œæœ¬åœ°ä»…ä½œç¼“å­˜
                const remoteCompleted = result.data.progress.completedLessons || [];

                // ğŸ”¥ æ›´æ–°æœ¬åœ°ç¼“å­˜ï¼ˆç”¨äºç¦»çº¿æ—¶åŠ é€Ÿï¼‰
                const storageKey = getCompletedLessonsStorageKey(userId);
                AsyncStorage.setItem(storageKey, JSON.stringify(remoteCompleted)).catch(err => {
                    console.warn('âš ï¸ Failed to cache completed lessons:', err);
                });

                set({
                    userProgress: {
                        ...result.data.progress,
                        completedAlphabetLessons: remoteCompleted  // ğŸ”¥ å­—æ®µæ˜ å°„
                    },
                    isLoading: false,
                });
                console.log('âœ… ç”¨æˆ·è¿›åº¦æ•°æ®å·²æ›´æ–° (Backend-first):', {
                    ...result.data.progress,
                    completedAlphabetLessons: remoteCompleted
                });
            } else {
                // ğŸ”¥ åç«¯å¤±è´¥æ—¶ï¼Œå°è¯•ä»æœ¬åœ°ç¼“å­˜åŠ è½½ï¼ˆé™çº§æ–¹æ¡ˆï¼‰
                console.warn('âš ï¸ è·å–ç”¨æˆ·è¿›åº¦å¤±è´¥ (Primary & Fallback)ï¼Œå°è¯•ä»æœ¬åœ°ç¼“å­˜åŠ è½½');
                try {
                    const storageKey = getCompletedLessonsStorageKey(userId);
                    const cached = await AsyncStorage.getItem(storageKey);
                    const cachedCompleted = cached ? JSON.parse(cached) : [];

                    set({
                        userProgress: {
                            ...defaultProgress,
                            completedAlphabetLessons: cachedCompleted
                        },
                        isLoading: false,
                        error: result.error || 'Failed to fetch progress'
                    });
                    console.log('âš ï¸ ä½¿ç”¨æœ¬åœ°ç¼“å­˜æ•°æ®:', cachedCompleted);
                } catch (cacheError) {
                    set({
                        userProgress: defaultProgress,
                        isLoading: false,
                        error: result.error || 'Failed to fetch progress'
                    });
                }
            }
        } catch (error: any) {
            console.error('âŒ getUserProgress error:', error);

            // ğŸ”¥ å¼‚å¸¸æ—¶ï¼Œå°è¯•ä»æœ¬åœ°ç¼“å­˜åŠ è½½ï¼ˆé™çº§æ–¹æ¡ˆï¼‰
            try {
                const storageKey = getCompletedLessonsStorageKey(userId);
                const cached = await AsyncStorage.getItem(storageKey);
                const cachedCompleted = cached ? JSON.parse(cached) : [];

                set({
                    error: error.message || 'è·å–è¿›åº¦å¤±è´¥',
                    userProgress: {
                        ...defaultProgress,
                        completedAlphabetLessons: cachedCompleted
                    },
                    isLoading: false,
                });
                console.log('âš ï¸ å¼‚å¸¸æ—¶ä½¿ç”¨æœ¬åœ°ç¼“å­˜:', cachedCompleted);
            } catch (cacheError) {
                set({
                    error: error.message || 'è·å–è¿›åº¦å¤±è´¥',
                    userProgress: defaultProgress,
                    isLoading: false,
                });
            }
        }
    },

    // ===== æ¸…é™¤ç¼“å­˜ =====
    /**
     * æ¸…é™¤è®¿é—®æƒé™ç¼“å­˜
     * ç”¨äºï¼šç”¨æˆ·å®Œæˆå­¦ä¹ åéœ€è¦é‡æ–°æ£€æŸ¥æƒé™
     */
    clearCache: (): void => {
        set({ accessCache: new Map<ModuleType, boolean>() });
        console.log('ğŸ—‘ï¸ è®¿é—®æƒé™ç¼“å­˜å·²æ¸…é™¤');
    },

    // ===== è®¾ç½®é”™è¯¯ =====
    setError: (error: string | null): void => {
        set({ error });
    },

    // ===== æ›´æ–°æ¯æ—¥å­¦ä¹ é‡ï¼ˆå‰ç«¯ç¼“å­˜ï¼‰=====
    setDailyLimit: (moduleType: ModuleType, limit: number) => {
        set((state) => ({
            userProgress: {
                ...(state.userProgress || { ...defaultProgress }),
                dailyLimit: limit,
            },
        }));

        console.log(`ğŸ“Œ å·²æ›´æ–° ${moduleType} dailyLimit ä¸º ${limit}`);
    },

    // ===== æ ‡è®°å­—æ¯è¯¾ç¨‹å®Œæˆï¼ˆå‰ç«¯æœ¬åœ°ï¼‰=====
    markAlphabetLessonCompleted: (lessonId: string) => {
        const userId = useUserStore.getState().currentUser?.userId;
        if (!userId) {
            console.warn('âš ï¸ ç”¨æˆ·æœªç™»å½•ï¼Œæ— æ³•æ ‡è®°è¯¾ç¨‹å®Œæˆ');
            return;
        }

        const totalLessons = Object.keys(LESSON_METADATA).length;
        const coreLessons = 6; // å®Œæˆå‰ 6 è¯¾è§†ä¸ºâ€œæ ¸å¿ƒå­—æ¯å·²å­¦å®Œâ€

        set((state) => {
            const prev = state.userProgress || { ...defaultProgress };

            const prevCompleted = new Set(prev.completedAlphabetLessons ?? []);
            prevCompleted.add(lessonId);
            const completedAlphabetLessons = Array.from(prevCompleted);

            const completedCount = completedAlphabetLessons.length;
            const allLessonsDone = completedCount >= totalLessons;

            // è¿›åº¦ï¼š
            // - å®Œæˆ lesson1-4 è§†ä¸º 0.8
            // - å®Œæˆ lesson1-6 è§†ä¸º 0.9ï¼ˆæ ¸å¿ƒå­—æ¯å…¨éƒ¨å®Œæˆï¼‰
            // - å®Œæˆå…¨éƒ¨ 7 è¯¾è§†ä¸º 1.0ï¼ˆå«ç½•ç”¨/å¤ä½“å­—æ¯ï¼‰
            let nextLetterProgress = prev.letterProgress;
            if (completedCount >= 4 && nextLetterProgress < 0.8) {
                nextLetterProgress = 0.8;
            }
            if (completedCount >= coreLessons && nextLetterProgress < 0.9) {
                nextLetterProgress = 0.9;
            }
            if (completedCount >= totalLessons && nextLetterProgress < 1) {
                nextLetterProgress = 1;
            }

            // å®Œæˆå‰ 6 è¯¾å³è§†ä¸ºæ ¸å¿ƒå­—æ¯å­¦ä¹ å®Œæˆï¼Œ
            // lesson7 ä½œä¸ºè¡¥å……è¯¾ç¨‹ä¸å½±å“å…¶ä»–æ¨¡å—è§£é”
            const coreLessonsDone = completedCount >= coreLessons;
            const nextLetterCompleted =
                prev.letterCompleted || coreLessonsDone;

            const updated: UserProgress = {
                ...prev,
                completedAlphabetLessons,
                letterCompleted: nextLetterCompleted,
                letterProgress: nextLetterProgress,
            };

            // ğŸ”¥ Persist to AsyncStorage (Fire and forget)
            const storageKey = getCompletedLessonsStorageKey(userId);
            AsyncStorage.setItem(storageKey, JSON.stringify(completedAlphabetLessons)).catch(err => {
                console.error('âŒ Failed to persist completed alphabet lessons:', err);
            });

            return {
                userProgress: updated,
                accessCache: allLessonsDone
                    ? new Map<ModuleType, boolean>()
                    : state.accessCache,
            };
        });

        console.log(`âœ… å­—æ¯è¯¾ç¨‹å·²å®Œæˆ: ${lessonId}`);
    },
}));
</file>

<file path="app/(tabs)/index.tsx">
// app/(tabs)/index.tsx
import React, { useState, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { ScrollView, View, Text, Pressable, StyleSheet } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { Play, TrendingUp, Clock, Award, Star, Wrench } from 'lucide-react-native';
import { BlurView } from 'expo-blur';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { FloatingBubbles } from '@/src/components/common/FloatingBubbles';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { ReviewItem } from '@/src/entities/types/entities';
import { useUserStore } from '@/src/stores/userStore';
import { useModuleAccessStore } from '@/src/stores/moduleAccessStore';

const MOCK_REVIEWS: ReviewItem[] = [
  { id: '1', char: 'à¸‚', phonetic: 'Khor Khai', type: 'Review', dueIn: 'Today' },
  { id: '2', char: 'à¸„', phonetic: 'Khor Khwai', type: 'Hard', dueIn: 'Today' },
  { id: '3', char: 'à¸‡', phonetic: 'Ngor Ngu', type: 'New', dueIn: 'Today' },
  { id: '4', char: 'à¸ˆ', phonetic: 'Jor Jan', type: 'Review', dueIn: 'Today' },
];

export default function HomeScreen() {
  const { t } = useTranslation();
  const [reviews, setReviews] = useState<ReviewItem[]>([]);
  const router = useRouter();

  // Stores
  const { currentUser } = useUserStore();
  const { userProgress } = useModuleAccessStore();

  useEffect(() => {
    setTimeout(() => setReviews(MOCK_REVIEWS), 800);
  }, []);

  const handleBubbleClick = () => {
    router.push('/review-modal');
    setTimeout(() => setReviews([]), 500);
  };

  // Helper to determine current course based on progress
  const getCurrentCourse = () => {
    if (!userProgress) {
      return {
        name: t('modules.alphabet'),
        level: t('alphabet.level'),
        progress: 0,
        route: '/learning' as const,
        module: 'letter' as const,
        thaiText: 'à¸à¸‚à¸ƒà¸„',
        translation: t('alphabet.description'),
      };
    }

    const { letterProgress, wordProgress, sentenceProgress } = userProgress;

    // 1. Alphabet Phase
    // åç«¯ letterProgress ä¸º 0-1ï¼Œè¿™é‡Œç”¨ 80% ä½œä¸ºé˜¶æ®µåˆ‡æ¢é˜ˆå€¼
    if (letterProgress < 0.8) {
      return {
        name: t('modules.alphabet'),
        level: t('alphabet.level'),
        progress: Math.round(letterProgress * 100),
        route: '/learning' as const,
        module: 'letter' as const,
        thaiText: 'à¸ à¸‚ à¸ƒ à¸„',
        translation: t('alphabet.description'),
      };
    }

    // 2. Vocabulary Phase
    if (wordProgress < 80) {
      return {
        name: t('modules.word'),
        level: 'Intermediate 1', // TODO: Add to i18n
        progress: wordProgress,
        route: '/learning' as const, // Points to app/learning/index.tsx
        module: 'word' as const,
        thaiText: 'à¸„à¸³à¸¨à¸±à¸à¸—à¹Œ',
        translation: 'Expand your vocabulary',
      };
    }

    // 3. Sentence Phase
    if (sentenceProgress < 80) {
      return {
        name: t('modules.sentence'),
        level: 'Intermediate 2',
        progress: sentenceProgress,
        route: '/learning' as const, // Placeholder
        module: 'sentence' as const,
        thaiText: 'à¸›à¸£à¸°à¹‚à¸¢à¸„',
        translation: 'Master sentence structures',
      };
    }

    // 4. Article Phase
    return {
      name: t('modules.article'),
      level: 'Advanced',
      progress: userProgress.articleProgress || 0,
      route: '/learning' as const, // Placeholder
      module: 'article' as const,
      thaiText: 'à¸šà¸—à¸„à¸§à¸²à¸¡',
      translation: 'Read authentic articles',
    };
  };

  const currentCourse = getCurrentCourse();
  const displayName = currentUser?.displayName || 'Student';

  return (
    <SafeAreaView edges={['top']} style={styles.safeArea}>
      <ThaiPatternBackground opacity={0.15} />

      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        {/* Header */}
        <View style={styles.header}>
          <BlurView intensity={80} tint="light" style={StyleSheet.absoluteFill} />

          <View style={styles.headerContent}>
            <View>
              <View style={styles.greetingContainer}>
                <Text style={styles.greetingText}>àºªàº°àºšàº²àºàº”àºµ, {displayName}</Text>
                <Text style={styles.greetingDot}>.</Text>
              </View>
              <Text style={styles.subtitleText}>
                {t('home.todayProgress')} {currentCourse.progress}%
              </Text>
            </View>

            <View style={styles.awardBadge}>
              {/* å³ä¸Šè§’è£èª‰å›¾æ ‡ */}
              <Award size={18} color={Colors.ink} />
            </View>
          </View>
        </View>

        <View style={styles.contentContainer}>
          {/* Floating Bubbles */}
          <FloatingBubbles reviews={reviews} onOpenReview={handleBubbleClick} />

          {/* Hero Progress Card */}
          <View>
            {(() => {
              // ğŸ”’ Lock Check for Hero Card
              const { checkAccessLocally } = useModuleAccessStore.getState();
              const isHeroLocked = currentCourse.module !== 'letter' && !checkAccessLocally(currentCourse.module);

              return (
                <Pressable
                  style={[styles.heroCard, isHeroLocked && { opacity: 0.8, backgroundColor: '#333' }]} // Visual feedback
                  disabled={isHeroLocked}
                  onPress={() => {
                    if (isHeroLocked) return;

                    router.push({
                      pathname: currentCourse.route,
                      params: { module: currentCourse.module }
                    });
                  }}
                >
                  <View style={styles.heroContent}>
                    <View style={styles.heroTopRow}>
                      <View>
                        <Text style={styles.courseLabel}>{t('home.currentCourse')}</Text>
                        <Text style={styles.courseName}>
                          {currentCourse.name} {isHeroLocked ? '(Locked)' : ''}
                        </Text>
                      </View>
                      <View style={styles.levelBadge}>
                        <Text style={styles.levelText}>{currentCourse.level}</Text>
                      </View>
                    </View>

                    <View style={styles.heroBottomRow}>
                      <View style={styles.heroTextContainer}>
                        <Text style={styles.thaiText}>{currentCourse.thaiText}</Text>
                        <Text style={styles.translationText}>{currentCourse.translation}</Text>
                      </View>

                      <View style={[styles.playButtonLarge, isHeroLocked && { backgroundColor: '#666' }]}>
                        <Play size={20} fill={isHeroLocked ? '#999' : Colors.ink} color={isHeroLocked ? '#999' : Colors.ink} />
                      </View>
                    </View>
                  </View>

                  <View style={styles.heroGradient1} />
                  <View style={styles.heroGradient2} />
                </Pressable>
              );
            })()}
          </View>

          {/* Stats Grid */}
          <View style={styles.statsGrid}>
            <View style={styles.statCard}>
              <View style={styles.statTopRow}>
                <View style={styles.statIconContainer}>
                  <TrendingUp size={20} color={Colors.ink} />
                </View>
                <Text style={styles.statLabel}>{t('profile.streakDays')}</Text>
              </View>
              <Text style={styles.statValue}>12</Text>
              <Text style={styles.statUnit}>{t('home.streak')}</Text>
            </View>

            <View style={styles.statCard}>
              <View style={styles.statTopRow}>
                <View style={styles.statIconContainer}>
                  <Clock size={20} color={Colors.ink} />
                </View>
                <Text style={styles.statLabel}>{t('profile.studyTime')}</Text>
              </View>
              <Text style={styles.statValue}>4.5</Text>
              <Text style={styles.statUnit}>{t('home.hoursThisWeek')}</Text>
            </View>
          </View>

          {/* Recent Achievements */}
          <View style={styles.achievementsSection}>
            <View style={styles.achievementsHeader}>
              <Star size={16} color={Colors.thaiGold} fill={Colors.thaiGold} />
              <Text style={styles.achievementsTitle}>{t('home.recentMastered')}</Text>
            </View>

            <View style={styles.achievementsList}>
              <AchievementItem
                char="à¸‚"
                name="Khor Khai (è›‹)"
                category="é«˜è¾…éŸ³"
              />
              <View style={styles.divider} />
              <AchievementItem
                char="à¸ªà¸µ"
                name="Sii (é¢œè‰²)"
                category="ä¸Šå£°"
              />
            </View>
          </View>
          {/* Dev Playground Entry - Only visible in DEV */}
          {__DEV__ && (
            <Pressable
              style={{
                marginTop: 20,
                padding: 12,
                backgroundColor: Colors.ink,
                borderRadius: 16,
                alignItems: 'center',
                flexDirection: 'row',
                justifyContent: 'center',
                gap: 8,
              }}
              onPress={() => router.push('/(dev)/playground')}
            >
              <Wrench size={16} color={Colors.thaiGold} />
              <Text style={{ color: Colors.white, fontFamily: Typography.notoSerifBold, fontSize: 12 }}>
                Open Dev Playground
              </Text>
            </Pressable>
          )}
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

interface AchievementItemProps {
  char: string;
  name: string;
  category: string;
}

const AchievementItem: React.FC<AchievementItemProps> = ({ char, name, category }) => (
  <Pressable style={styles.achievementItem}>
    <View style={styles.achievementLeft}>
      <View style={styles.achievementIconBox}>
        <Text style={styles.achievementChar}>{char}</Text>
      </View>
      <View>
        <Text style={styles.achievementName}>{name}</Text>
        <Text style={styles.achievementCategory}>{category}</Text>
      </View>
    </View>
    <View style={styles.masteredBadge}>
      <Text style={styles.masteredText}>å·²æŒæ¡</Text>
    </View>
  </Pressable>
);

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: Colors.paper,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    paddingBottom: 120,
  },
  header: {
    paddingHorizontal: 24,
    paddingBottom: 24,
    paddingTop: 48,
    borderBottomWidth: 1,
    borderBottomColor: 'transparent',
  },
  headerContent: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    justifyContent: 'space-between',
    zIndex: 10,
  },
  greetingContainer: {
    flexDirection: 'row',
    alignItems: 'baseline',
    position: 'relative',
  },
  greetingText: {
    fontFamily: Typography.playfairRegular,
    fontSize: 30,
    letterSpacing: -0.5,
    color: Colors.ink,
  },
  greetingDot: {
    fontFamily: Typography.playfairRegular,
    position: 'absolute',
    right: -12,
    top: -4,
    fontSize: 20,
    color: Colors.thaiGold,
  },
  subtitleText: {
    fontFamily: Typography.notoSerifRegular,
    marginTop: 4,
    fontSize: 14,
    letterSpacing: 0.5,
    color: Colors.taupe,
  },
  awardBadge: {
    width: 40,
    height: 40,
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: 20,
    borderWidth: 1,
    borderColor: 'rgba(212, 175, 55, 0.2)',
    backgroundColor: 'rgba(212, 175, 55, 0.1)',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
    elevation: 1,
  },
  contentContainer: {
    paddingHorizontal: 24,
    width: '100%',
    maxWidth: 672,
    alignSelf: 'center',
  },
  heroCard: {
    backgroundColor: Colors.ink,
    padding: 32,
    borderRadius: 32,
    marginBottom: 32,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.15,
    shadowRadius: 16,
    elevation: 8,
  },
  heroContent: {
    zIndex: 10,
  },
  heroTopRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 48,
  },
  courseLabel: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 10,
    fontWeight: '700',
    letterSpacing: 1.5,
    color: Colors.thaiGold,
    marginBottom: 4,
    textTransform: 'uppercase',
  },
  courseName: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 20,
    color: Colors.white,
  },
  levelBadge: {
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  levelText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 10,
    color: Colors.sand,
  },
  heroBottomRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-end',
  },
  heroTextContainer: {
    flex: 1,
  },
  thaiText: {
    fontFamily: Typography.sarabunRegular,
    fontSize: 48,
    letterSpacing: 1,
    color: Colors.white,
    marginBottom: 8,
  },
  translationText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    fontWeight: '300',
    color: Colors.sand,
    opacity: 0.6,
  },
  playButtonLarge: {
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: Colors.thaiGold,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: 'rgba(212, 175, 55, 0.4)',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 1,
    shadowRadius: 15,
    elevation: 8,
  },
  heroGradient1: {
    position: 'absolute',
    right: -48,
    top: -48,
    width: 192,
    height: 192,
    borderRadius: 96,
    backgroundColor: 'rgba(212, 175, 55, 0.2)',
    opacity: 0.5,
  },
  heroGradient2: {
    position: 'absolute',
    left: -40,
    bottom: -40,
    width: 160,
    height: 160,
    borderRadius: 80,
    backgroundColor: 'rgba(184, 149, 106, 0.2)',
  },
  statsGrid: {
    flexDirection: 'row',
    gap: 16,
    marginBottom: 32,
  },
  statCard: {
    flex: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.8)',
    padding: 24,
    borderRadius: 24,
    borderWidth: 1,
    borderColor: Colors.sand,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 4,
    elevation: 2,
  },
  statTopRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  statIconContainer: {
    padding: 8,
    backgroundColor: Colors.paper,
    borderRadius: 12,
  },
  statLabel: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 10,
    letterSpacing: 1.5,
    color: Colors.taupe,
    textTransform: 'uppercase',
  },
  statValue: {
    fontFamily: Typography.playfairRegular,
    fontSize: 36,
    color: Colors.ink,
  },
  statUnit: {
    fontFamily: Typography.notoSerifRegular,
    marginTop: 4,
    fontSize: 12,
    color: Colors.taupe,
  },
  achievementsSection: {
    paddingBottom: 24,
  },
  achievementsHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    marginBottom: 16,
  },
  achievementsTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 18,
    fontWeight: '700',
    color: Colors.ink,
  },
  achievementsList: {
    backgroundColor: 'rgba(255, 255, 255, 0.6)',
    borderRadius: 24,
    borderWidth: 1,
    borderColor: Colors.sand,
    padding: 8,
  },
  achievementItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 16,
    borderRadius: 16,
  },
  achievementLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 16,
  },
  achievementIconBox: {
    width: 48,
    height: 48,
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: 16,
    borderWidth: 1,
    borderColor: Colors.sand,
    backgroundColor: Colors.paper,
  },
  achievementChar: {
    fontFamily: Typography.sarabunRegular,
    fontSize: 20,
    color: Colors.ink,
  },
  achievementName: {
    fontFamily: Typography.playfairRegular,
    fontSize: 16,
    fontWeight: '500',
    color: Colors.ink,
  },
  achievementCategory: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 10,
    letterSpacing: 1,
    color: Colors.taupe,
    textTransform: 'uppercase',
  },
  masteredBadge: {
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: Colors.sand,
    backgroundColor: Colors.paper,
  },
  masteredText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 12,
    color: 'rgba(26, 26, 26, 0.6)',
  },
  divider: {
    width: '90%',
    height: 1,
    backgroundColor: 'rgba(229, 226, 219, 0.5)',
    alignSelf: 'center',
    marginVertical: 4,
  },
});
</file>

<file path="cloudbase/functions/memory-engine/handlers/getTodayMemories.js">
/**
 * ç»Ÿä¸€è·å–ä»Šæ—¥å­¦ä¹ å†…å®¹ (å­—æ¯/å•è¯/å¥å­)
 * Action: getTodayMemories
 */
'use strict';

// å‡è®¾ memoryEngine å†…éƒ¨æ²¡æœ‰ä¸¥é‡çš„å…¨å±€å‰¯ä½œç”¨ï¼Œå¦‚æœæœ‰é—®é¢˜ï¼Œå¯èƒ½éœ€è¦æ£€æŸ¥ memoryEngine
const { getTodayReviewEntities, getOrCreateMemory, checkModuleAccess } = require('../utils/memoryEngine');
const { createResponse } = require('../utils/response');
const {
  getLessonMetadataFromDb,
  getPhonicsRuleByLessonFromDb,
} = require('../config/alphabetLessonConfig');

const MAX_NEW_LETTERS = 12; // å•è¯¾å®‰å…¨ä¸Šé™ï¼Œé˜²æ­¢ 3s è¶…æ—¶
const MAX_LETTER_DAILY_LIMIT = 20; // å­—æ¯æ¨¡å—æ¯æ—¥å­¦ä¹ ç¡¬ä¸Šé™ï¼ˆç¨³å®šæ¨¡å¼ï¼‰
const MAX_GENERIC_DAILY_LIMIT = 200; // å…¶ä»–æ¨¡å—çš„å…œåº•ä¸Šé™ï¼Œé˜²æ­¢æ— ç•Œè¯·æ±‚

/**
 * æ‡’åˆå§‹åŒ–ï¼šå­—æ¯è¿›åº¦è¡¨
 * å…¼å®¹æ—§ç”¨æˆ·ï¼šå¦‚æœ user_alphabet_progress ä¸­æ²¡æœ‰è®°å½•ï¼Œåˆ™æ’å…¥ä¸€æ¡é»˜è®¤è®°å½•
 *
 * @param {Object} db
 * @param {string} userId
 */
async function ensureUserAlphabetProgress(db, userId) {
  const col = db.collection('user_alphabet_progress');
  const existing = await col.where({ userId }).limit(1).get();

  if (!existing.data || existing.data.length === 0) {
    const now = new Date().toISOString();

    // ğŸ”¥ å¹¶å‘ä¿æŠ¤ï¼šäºŒæ¬¡æ£€æŸ¥é˜²æ­¢é‡å¤è®°å½•
    const checkAgain = await col.where({ userId }).limit(1).get();
    if (checkAgain.data && checkAgain.data.length > 0) {
      console.log('âš ï¸ [ensureUserAlphabetProgress] è®°å½•å·²è¢«å¹¶å‘åˆ›å»º, è·³è¿‡');
      return;
    }

    await col.add({
      data: {
        userId,
        letterProgress: 0.0,
        letterCompleted: false,
        completedLessons: [],
        masteredLetterCount: 0,
        totalLetterCount: 80,
        currentRound: 1,          // ğŸ”¥ æ–°å¢ï¼šé»˜è®¤ä»ç¬¬1è½®å¼€å§‹
        roundHistory: [],         // ğŸ”¥ æ–°å¢ï¼šè½®æ¬¡å†å²è®°å½•
        createdAt: now,
        updatedAt: now,
      },
    });
    console.log('âœ… [ensureUserAlphabetProgress] å·²åˆ›å»ºé»˜è®¤è¿›åº¦è®°å½•');
  }
}

/**
 * æ‡’åˆå§‹åŒ–ï¼šç”¨æˆ·è¯æ±‡è¿›åº¦è¡¨ï¼ˆä¼ ç»Ÿè¿›åº¦è¡¨ï¼‰
 * è¯´æ˜ï¼š
 * - è¯¥é›†åˆåŸæœ¬æŒ‰å•è¯ä¸€æ¡è®°å½•ï¼Œè¿™é‡Œåªä¸ºæ—§ç”¨æˆ·æ’å…¥ä¸€æ¡ã€Œå ä½è®°å½•ã€
 * - ä½¿ç”¨ skipped: trueï¼Œé¿å…å½±å“ getTodayWords ç­‰æŸ¥è¯¢é€»è¾‘
 *
 * @param {Object} db
 * @param {string} userId
 */
async function ensureUserVocabularyProgress(db, userId) {
  const col = db.collection('user_vocabulary_progress');
  const existing = await col.where({ userId }).limit(1).get();

  if (!existing.data || existing.data.length === 0) {
    const now = new Date().toISOString();
    await col.add({
      data: {
        userId,
        vocabularyId: null,
        mastery: null,
        reviewCount: 0,
        lastReviewed: null,
        nextReviewDate: null,
        intervalDays: 0,
        // å ä½è®°å½•é»˜è®¤æ ‡è®°ä¸º skippedï¼Œé¿å…è¢«å½“æˆçœŸå®å¤ä¹ æ•°æ®
        skipped: true,
        easinessFactor: 2.5,
        createdAt: now,
        updatedAt: now,
      },
    });
  }
}

/**
 * @param {Object} db - æ•°æ®åº“å®ä¾‹
 * @param {Object} params - è¯·æ±‚å‚æ•°
 */
async function getTodayMemories(db, params) {
  const start = Date.now();
  const { userId, entityType, limit = 30, includeNew = true, roundNumber } = params;

  // ğŸ” è°ƒè¯•æ—¥å¿—ï¼šæ‰“å°æ”¶åˆ°çš„ userId
  console.log('ğŸ“¥ [getTodayMemories] æ”¶åˆ°è¯·æ±‚ï¼ŒuserId:', userId, ', entityType:', entityType);

  if (!userId || !entityType) {
    return createResponse(false, null, 'Missing userId or entityType', 'INVALID_PARAMS');
  }

  try {
    // 0. æ‡’åˆå§‹åŒ–ç”¨æˆ·ç›¸å…³è¿›åº¦è¡¨ï¼ˆå…¼å®¹åœ¨æ–°å¢æ³¨å†Œé€»è¾‘ä¹‹å‰çš„è€ç”¨æˆ·ï¼‰
    if (entityType === 'letter') {
      await ensureUserAlphabetProgress(db, userId);
    } else if (entityType === 'word') {
      await ensureUserVocabularyProgress(db, userId);
    }

    // 1. æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™
    // ä½¿ç”¨ memoryEngine ä¸­çš„ç»Ÿä¸€æƒé™æ£€æŸ¥
    const accessCheck = await checkModuleAccess(db, userId, entityType);
    if (!accessCheck.allowed) {
      return createResponse(false, null, accessCheck.message, accessCheck.errorCode);
    }

    // 1.5 è·å–/æ›´æ–°ç”¨æˆ·æ¯æ—¥å­¦ä¹ é‡è®¾ç½®
    // æ³¨æ„ï¼š
    // - å­—æ¯æ¨¡å—ï¼ˆentityType === 'letter'ï¼‰ä¸å†å…è®¸å‰ç«¯é€šè¿‡ limit åŠ¨æ€è°ƒæ•´æ¯æ—¥æ–°å­—æ¯æ•°é‡ï¼Œ
    //   åªä½¿ç”¨æœåŠ¡å™¨ç«¯å­˜å‚¨çš„ dailyLimitï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œå¦åˆ™é€€å›é»˜è®¤å€¼ï¼›
    // - å…¶ä»–å®ä½“ç±»å‹ä»æ²¿ç”¨åŸæœ‰é€»è¾‘ã€‚
    let effectiveLimit = limit;
    const userProgress = accessCheck.progress; // checkModuleAccess returns progress

    if (userProgress) {
      if (entityType === 'letter') {
        // å­—æ¯æ¨¡å—ï¼šå¿½ç•¥å‰ç«¯ä¼ å…¥çš„ limitï¼Œåªä½¿ç”¨å­˜å‚¨çš„ dailyLimitï¼ˆå¦‚æœæœ‰ï¼‰
        if (userProgress.dailyLimit) {
          effectiveLimit = Math.min(userProgress.dailyLimit, MAX_LETTER_DAILY_LIMIT);
        }
        effectiveLimit = Math.min(effectiveLimit, MAX_LETTER_DAILY_LIMIT);
      } else {
        // å…¶ä»–æ¨¡å—ï¼šä¿ç•™åŸæœ‰è¡Œä¸º
        if (params.limit && params.limit !== userProgress.dailyLimit) {
          await db.collection('user_progress').where({ userId }).update({
            data: {
              dailyLimit: params.limit,
              updatedAt: new Date().toISOString()
            }
          });
          effectiveLimit = Math.min(params.limit, MAX_GENERIC_DAILY_LIMIT);
        } else if (!params.limit && userProgress.dailyLimit) {
          effectiveLimit = Math.min(userProgress.dailyLimit, MAX_GENERIC_DAILY_LIMIT);
        }
      }
    }
    if (entityType !== 'letter') {
      effectiveLimit = Math.min(effectiveLimit, MAX_GENERIC_DAILY_LIMIT);
    }

    // 3. è·å–ä»Šæ—¥å¤ä¹ å®ä½“
    let reviewMemories = await getTodayReviewEntities(db, userId, entityType, effectiveLimit);

    // ğŸ”¥ P0-C: æ˜¾å¼è·å– Round1 è·¨è¯¾ç¨‹ previous-reviewï¼ˆåªåš round==1 ä¸” lesson>1ï¼‰
    let explicitPreviousCount = 0;

    if (entityType === 'letter' && roundNumber === 1 && params.lessonId && params.lessonId !== 'lesson1') {
      try {
        const currentLessonMeta = await getLessonMetadataFromDb(db, params.lessonId);
        if (currentLessonMeta && currentLessonMeta.order && currentLessonMeta.order > 1) {
          const prevLessonId = `lesson${currentLessonMeta.order - 1}`;

          // æŸ¥è¯¢ä¸Šä¸€è¯¾çš„å­—æ¯
          const prevLettersResult = await db.collection('letters')
            .where({ curriculumLessonIds: db.command.in([prevLessonId]) })
            .limit(20)
            .get();

          const explicitPrevMemories = [];

          // ğŸ”¥ è·å–è¿™äº›å­—æ¯çš„è®°å¿†çŠ¶æ€
          for (const letter of prevLettersResult.data) {
            const mem = await getOrCreateMemory(db, userId, entityType, letter._id, false);
            if (mem) {
              // ğŸ”¥ ç»†èŠ‚æ ¡æ­£3ï¼šæµ…æ‹·è´é¿å…å‰¯ä½œç”¨
              const patched = {
                ...mem,
                reviewStage: Math.max(mem.reviewStage || 0, 1)
              };
              explicitPrevMemories.push(patched);
            }
          }

          explicitPreviousCount = explicitPrevMemories.length;

          // ğŸ”¥ åˆå¹¶åˆ° reviewMemoriesï¼ˆå»é‡ï¼‰
          const existingIds = new Set(reviewMemories.map(m => m.entityId));
          const uniquePrev = explicitPrevMemories.filter(m => !existingIds.has(m.entityId));
          reviewMemories = [...uniquePrev, ...reviewMemories];

          console.log(`ğŸ” [P0-C] lessonId: ${params.lessonId}, prevLessonId: ${prevLessonId}, explicitPrevCount: ${explicitPreviousCount}`);
        }
      } catch (err) {
        console.warn('âš ï¸ [P0-C] è·å–ä¸Šä¸€è¯¾ç¨‹å­—æ¯å¤±è´¥:', err);
      }
    }

    // 4. è·å–æ–°å­¦ä¹ å†…å®¹
    let newMemories = [];
    if (includeNew && reviewMemories.length < effectiveLimit) {
      const remainingSlots = effectiveLimit - reviewMemories.length;

      const collectionMap = {
        letter: 'letters',
        word: 'vocabulary',
        sentence: 'sentences'
      };

      const collectionName = collectionMap[entityType];
      if (!collectionName) {
        return createResponse(false, null, `ä¸æ”¯æŒçš„å®ä½“ç±»å‹: ${entityType}`, 'INVALID_ENTITY_TYPE');
      }

      const query = db.collection(collectionName);
      let newEntities = [];

      // è·å–å·²å­˜åœ¨çš„å®ä½“ID (åŒ…æ‹¬å¤ä¹ é˜Ÿåˆ—ä¸­çš„)
      const existingEntityIds = reviewMemories.map(m => m.entityId);

      if (entityType === 'letter' && params.lessonId) {
        // å­—æ¯æ¨¡å—ï¼šæ ¹æ®è¯¾ç¨‹ä¸€æ¬¡æ€§å–å‡ºè¯¥è¯¾éœ€è¦çš„å…¨éƒ¨å­—æ¯ï¼ˆä¸å— limit é™åˆ¶ï¼‰
        const { lessonId } = params;
        const cmd = db.command;

        const whereCondition = {
          curriculumLessonIds: cmd.in([lessonId]),
        };

        // ğŸ”¥ Round2/3 æ—¶ä¸è¿‡æ»¤å·²æœ‰è®°å¿†çš„å­—æ¯ï¼ˆç”¨äºå¤ä¹ ï¼‰
        if (roundNumber === 1 && existingEntityIds.length > 0) {
          whereCondition._id = cmd.nin(existingEntityIds);
        }
        // Round2/3 æ—¶è¿”å›è¯¥è¯¾ç¨‹çš„å…¨éƒ¨å­—æ¯

        const newEntitiesResult = await query
          .where(whereCondition)
          // ä¸ºäº†å®‰å…¨èµ·è§ï¼Œä»åŠ ä¸€ä¸ªè¾ƒå¤§çš„ä¸Šé™ï¼ˆè¿œå¤§äºå®é™…å­—æ¯æ€»æ•°ï¼‰
          .limit(MAX_NEW_LETTERS)
          .get();

        newEntities = newEntitiesResult.data;
      } else {
        // å…¶ä»–æ¨¡å—æˆ–æœªæŒ‡å®š lessonIdï¼šæ²¿ç”¨åŸé€»è¾‘ï¼ŒæŒ‰å‰©ä½™åé¢å’Œ lessonNumber é¡ºåºè·å–
        let queryRef = query;
        const cmd = db.command;

        if (existingEntityIds.length > 0) {
          queryRef = queryRef.where({
            _id: cmd.nin(existingEntityIds)
          });
        }

        const newEntitiesResult = await queryRef
          .orderBy('lessonNumber', 'asc')
          .orderBy('_id', 'asc')
          .limit(Math.min(remainingSlots, MAX_GENERIC_DAILY_LIMIT))
          .get();

        newEntities = newEntitiesResult.data;
      }

      const cappedNewEntities =
        entityType === 'letter'
          ? newEntities.slice(0, MAX_NEW_LETTERS)
          : newEntities.slice(0, Math.min(remainingSlots, MAX_GENERIC_DAILY_LIMIT));

      const memoryTasks = cappedNewEntities.map((entity) =>
        getOrCreateMemory(db, userId, entityType, entity._id, false)
      );
      const memoryResults = await Promise.all(memoryTasks);
      newMemories = memoryResults.filter(Boolean);
    }

    // 5. åˆå¹¶ & ç©¿æ’ (Interleave)
    // "å•è¯å’Œå­—æ¯å­¦ä¹ å¼€å§‹å‰ï¼Œä¼˜å…ˆå¤ä¹ ä¹‹å‰å­¦çš„å†…å®¹" -> ä¼˜å…ˆæ”¾å…¥å¤ä¹ å†…å®¹
    // "è¿™éƒ¨åˆ†å†…å®¹å¤ä¹ å®Œåæ‰è¿›å…¥ä¸‰æ–°1å¤ä¹ çš„ç©¿æ’å­¦ä¹ " -> å¤ä¹ å®Œè€å†…å®¹åï¼Œæ–°å†…å®¹æŒ‰ 3æ–°:1å¤ä¹ (æ–°) ç©¿æ’
    let allMemories = [...reviewMemories];

    // å¤„ç†æ–°å†…å®¹ (3æ–° : 1å¤ä¹ )
    // è¿™é‡Œ "1å¤ä¹ " æŒ‡çš„æ˜¯å¯¹åˆšåˆšå­¦ä¹ çš„æ–°å†…å®¹çš„å·©å›ºå¤ä¹  (Intra-session repetition)
    // ä¾‹å¦‚: N1, N2, N3, N1(å¤ä¹ ), N4, N5, N6, N4(å¤ä¹ )...
    if (newMemories.length > 0) {
      for (let i = 0; i < newMemories.length; i++) {
        allMemories.push(newMemories[i]);

        // æ¯3ä¸ªæ–°è¯ï¼Œæ’å…¥ä¸€ä¸ªå¤ä¹  (å¤ä¹ è¿™ç»„çš„ç¬¬ä¸€ä¸ª)
        if ((i + 1) % 3 === 0) {
          // æ’å…¥ i-2 (å³è¿™ç»„çš„ç¬¬ä¸€ä¸ª) ä½œä¸ºå¤ä¹ 
          // æ³¨æ„ï¼šè¿™é‡Œç›´æ¥pushåŒä¸€ä¸ªå¯¹è±¡ï¼Œå‰ç«¯ä¼šå†æ¬¡æ¸²æŸ“å®ƒ
          allMemories.push(newMemories[i - 2]);
        }
      }
    }

    if (allMemories.length === 0) {
      return createResponse(true, { items: [], summary: { total: 0 } }, 'ä»Šæ—¥æ— å­¦ä¹ å†…å®¹');
    }

    // 6. è·å–è¯¦æƒ…
    const entityIds = allMemories.map(m => m.entityId);
    const collectionMap = {
      letter: 'letters',
      word: 'vocabulary',
      sentence: 'sentences'
    };

    const entitiesResult = await db.collection(collectionMap[entityType])
      .where({
        _id: db.command.in(entityIds)
      })
      .get();

    const entitiesMap = new Map(entitiesResult.data.map(e => [e._id, e]));

    // 7. ç»„è£…
    const data = allMemories.map(memory => {
      const entity = entitiesMap.get(memory.entityId);
      if (!entity) return null;

      return {
        ...entity,
        memoryState: {
          masteryLevel: memory.masteryLevel,
          reviewStage: memory.reviewStage,
          correctCount: memory.correctCount,
          wrongCount: memory.wrongCount,
          streakCorrect: memory.streakCorrect,
          nextReviewAt: memory.nextReviewAt,
          isNew: memory.reviewStage === 0
        }
      };
    }).filter(Boolean);

    const summary = {
      total: data.length,
      reviewCount: reviewMemories.length,
      newCount: newMemories.length,
      entityType,
    };

    // 8. é™„åŠ è¯¾ç¨‹å…ƒæ•°æ® & æ‹¼è¯»è§„åˆ™ï¼ˆçœŸå®é…ç½®ï¼‰
    let lessonMetadata = null;
    let phonicsRule = null;

    if (entityType === 'letter' && data.length > 0) {
      // ä¼˜å…ˆä½¿ç”¨å‰ç«¯ä¼ å…¥çš„ lessonIdï¼Œå…¶æ¬¡å°è¯•ä»å®ä½“å­—æ®µæ¨å¯¼
      const firstEntity = data[0];
      const lessonIdFromParam = params.lessonId;
      const lessonIdFromField = firstEntity.lessonId || null;
      const lessonIdFromCurriculum =
        (firstEntity.curriculumLessonIds &&
          firstEntity.curriculumLessonIds[0]) ||
        null;
      const lessonIdFromLegacy =
        typeof firstEntity.lessonNumber === 'number' &&
          firstEntity.lessonNumber > 0
          ? `lesson${firstEntity.lessonNumber}`
          : null;

      const resolvedLessonId =
        lessonIdFromParam ||
        lessonIdFromCurriculum ||
        lessonIdFromField ||
        lessonIdFromLegacy;

      if (resolvedLessonId) {
        lessonMetadata = await getLessonMetadataFromDb(db, resolvedLessonId);
        phonicsRule = await getPhonicsRuleByLessonFromDb(db, resolvedLessonId);
      }
    }

    return createResponse(
      true,
      {
        items: data,
        summary,
        lessonMetadata,
        phonicsRule,
      },
      'è·å–ä»Šæ—¥å­¦ä¹ å†…å®¹æˆåŠŸ',
    );

  } catch (error) {
    console.error('getTodayMemories error:', error);
    return createResponse(false, null, error.message, 'SERVER_ERROR');
  } finally {
    console.log('[FunctionCost] getTodayMemories', Date.now() - start, 'ms');
  }
}

module.exports = getTodayMemories;
</file>

<file path="app/(tabs)/courses.tsx">
// app/(tabs)/courses.tsx
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { useRouter } from 'expo-router';
import { View, Text, StyleSheet, ScrollView, TextInput, ImageSourcePropType, Pressable } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Search, BookOpen, Type, Grid } from 'lucide-react-native';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { useTranslation } from 'react-i18next';
import { useVocabularyStore } from '@/src/stores/vocabularyStore';
import { CourseSelectionModal } from '@/src/components/courses/CourseSelectionModal';
import coursesData from '@/assets/courses/courses.json';
import alphabetCourses from '@/assets/courses/alphabetCourses.json';
import { CourseCard, type CourseCardData } from '@/src/components/courses/CourseCard';
import { AlphabetCourseCard } from '@/src/components/courses/AlphabetCourseCard';
import { useLearningPreferenceStore } from '@/src/stores/learningPreferenceStore';
import { useModuleAccessStore, type ModuleType } from '@/src/stores/moduleAccessStore';

const CATEGORIES = [
  { id: 'all', label: 'å…¨éƒ¨', icon: Grid },
  { id: 'letter', label: 'å­—æ¯', icon: Type },
  { id: 'word', label: 'å•è¯', icon: BookOpen },
];

type CourseItem = {
  id: string;
  source: string;
  title: string;
  description: string;
  level: string;
  image: string;
  category: string;
  lessons: number;
};

type CourseWithImage = CourseItem & {
  imageSource: ImageSourcePropType;
};

const COURSE_IMAGE_MAP: Record<string, ImageSourcePropType> = {
  'ThaiBase_1.png': require('@/assets/images/courses/ThaiBase_1.png'),
  'ThaiBase_2.png': require('@/assets/images/courses/ThaiBase_2.png'),
  'ThaiBase_3.png': require('@/assets/images/courses/ThaiBase_3.png'),
  'ThaiBase_4.png': require('@/assets/images/courses/ThaiBase_4.png'),
  'thai_alphabet.png': require('@/assets/images/courses/thai_alphabet.png'),
  default: require('@/assets/images/courses/ThaiBase_1.png'),
};

// åŒ…å«å­—æ¯è¯¾ç¨‹å’Œå•è¯è¯¾ç¨‹
const COURSES: CourseWithImage[] = (
  [
    ...(alphabetCourses as CourseItem[]),
    ...(coursesData as CourseItem[]),
  ]
).map((course) => ({
  ...course,
  imageSource: COURSE_IMAGE_MAP[course.image] || COURSE_IMAGE_MAP.default,
}));

export default function CoursesScreen() {
  const router = useRouter();
  const { t } = useTranslation();
  const [activeCategory, setActiveCategory] = useState('all');
  const [searchQuery, setSearchQuery] = useState('');

  const { currentCourseSource, startCourse } = useVocabularyStore();
  const { hasDailyLimit } = useLearningPreferenceStore();
  const { userProgress, getUserProgress, checkAccess, accessCache } = useModuleAccessStore();
  const [modalVisible, setModalVisible] = useState(false);
  const [pendingCourse, setPendingCourse] = useState<CourseWithImage | null>(null);
  const didDevAccessCheckRef = useRef(false);

  useEffect(() => {
    if (!userProgress) {
      getUserProgress().catch((err) => console.warn('Failed to fetch user progress', err));
    }
  }, [userProgress, getUserProgress]);

  useEffect(() => {
    if (!__DEV__) return;
    if (didDevAccessCheckRef.current) return;
    didDevAccessCheckRef.current = true;

    const uniqueModules = Array.from(new Set(COURSES.map(getModuleType)))
      .filter((moduleType) => moduleType !== 'letter');

    uniqueModules.forEach((moduleType) => {
      checkAccess(moduleType).catch((error) => {
        console.warn('âš ï¸ Dev module access check failed:', moduleType, error);
      });
    });
  }, [checkAccess]);

  const getModuleType = (course: CourseWithImage): ModuleType => {
    switch (course.category) {
      case 'letter':
        return 'letter';
      case 'sentence':
        return 'sentence';
      case 'article':
        return 'article';
      default:
        return 'word';
    }
  };

  const getCourseProgress = (course: CourseWithImage) => {
    if (!userProgress) return undefined;
    const moduleType = getModuleType(course);
    if (moduleType === 'letter') {
      return {
        completed: userProgress.letterMasteredCount,
        total: userProgress.letterTotalCount || course.lessons,
      };
    }
    if (moduleType === 'word') {
      return {
        completed: userProgress.wordMasteredCount,
        total: userProgress.wordTotalCount || course.lessons,
      };
    }
    return undefined;
  };

  const filteredCourses = useMemo(() => {
    return COURSES.filter(course => {
      const matchesCategory = activeCategory === 'all' || course.category === activeCategory;
      const matchesSearch =
        course.title.includes(searchQuery) || course.description.includes(searchQuery);
      return matchesCategory && matchesSearch;
    });
  }, [activeCategory, searchQuery]);



  // â­ ç»Ÿä¸€çš„ Start Learning é€»è¾‘ï¼šæ¥æ”¶ courseï¼Œè¿”å›ä¸€ä¸ªç‚¹å‡» handler
  const handleStartLearning = (course: CourseWithImage) => {
    return () => {
      const moduleType = getModuleType(course);

      // ğŸ”’ Double Check: UI Should be disabled, but logic must be safe
      const { checkAccessLocally, accessCache: cachedAccess } = useModuleAccessStore.getState();
      const devOverrideUnlocked = __DEV__ && cachedAccess.get(moduleType) === true;
      const isLocked = moduleType !== 'letter' && !devOverrideUnlocked && !checkAccessLocally(moduleType);
      if (isLocked) {
        console.warn('Course locked, double-check start prevented');
        return;
      }

      const needsDailySetup = !hasDailyLimit(moduleType);

      // âœ… åŒä¸€ä¸ªè¯¾ç¨‹ï¼šç›´æ¥æŒ‰ç…§æ˜¯å¦å·²è®¾ç½®æ—¥è®¡åˆ’è¿›è¡Œè·³è½¬
      if (currentCourseSource === course.source) {
        // Pass moduleType to startCourse for strict check
        startCourse(course.source, moduleType).then(() => {
          // Special routing for Alphabet, ignoring daily setup check
          if (moduleType === 'letter') {
            router.push('/alphabet');
          } else {
            router.push({
              pathname: needsDailySetup ? '/learning/setup' : '/learning',
              params: {
                module: moduleType,
                source: course.source,
              },
            });
          }
        });
        return;
      }

      // âœ… åˆ‡æ¢è¯¾ç¨‹ï¼šå¼¹ç¡®è®¤æ¡†
      setPendingCourse(course);
      setModalVisible(true);
    };
  };

  const confirmSwitchCourse = async () => {
    if (pendingCourse) {
      await proceedToCourse(pendingCourse);
    }
  };

  const proceedToCourse = async (course: CourseWithImage) => {
    const moduleType = getModuleType(course);
    const needsDailySetup = !hasDailyLimit(moduleType);

    await startCourse(course.source, moduleType);
    setModalVisible(false);
    setPendingCourse(null);

    // Special routing for Alphabet
    if (moduleType === 'letter') {
      router.push('/alphabet');
    } else {
      router.push({
        pathname: needsDailySetup ? '/learning/setup' : '/learning',
        params: {
          module: moduleType,
          source: course.source,
        },
      });
    }
  };

  return (
    <SafeAreaView edges={['top']} style={styles.safeArea}>
      <ThaiPatternBackground opacity={0.12} />

      <View style={styles.header}>
        <Text style={styles.headerTitle}>{t('courses.title')}</Text>
        <Text style={styles.headerSubtitle}>{t('courses.subtitle')}</Text>
      </View>

      <View style={styles.searchContainer}>
        <View style={styles.searchBar}>
          <Search size={20} color={Colors.taupe} />
          <TextInput
            style={styles.searchInput}
            placeholder={t('courses.searchPlaceholder')}
            placeholderTextColor={Colors.taupe}
            value={searchQuery}
            onChangeText={setSearchQuery}
          />
        </View>
      </View>

      <View style={styles.categoryContainer}>
        <ScrollView
          horizontal
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.categoryContent}
        >
          {CATEGORIES.map((cat) => {
            const isActive = activeCategory === cat.id;
            const Icon = cat.icon;
            return (
              <Pressable
                key={cat.id}
                style={[styles.categoryChip, isActive && styles.categoryChipActive]}
                onPress={() => setActiveCategory(cat.id)}
              >
                <Icon size={14} color={isActive ? Colors.white : Colors.taupe} />
                <Text style={[styles.categoryText, isActive && styles.categoryTextActive]}>
                  {cat.label}
                </Text>
              </Pressable>
            );
          })}
        </ScrollView>
      </View>

      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.listContent}
        showsVerticalScrollIndicator={false}
      >
        {/* æ‰€æœ‰è¯¾ç¨‹ï¼ˆåŒ…æ‹¬AlphabetCourseCardå’Œå•è¯è¯¾ç¨‹ï¼‰ */}
        {filteredCourses.map((course) => {
          const isCurrent = currentCourseSource === course.source;
          const moduleType = getModuleType(course);
          const progress = getCourseProgress(course);

          // ğŸ”’ Calculation: Alphabet always unlocked, others check store
          const { checkAccessLocally, accessCache: cachedAccess } = useModuleAccessStore.getState();
          const devOverrideUnlocked = __DEV__ && cachedAccess.get(moduleType) === true;
          const isLocked = moduleType !== 'letter' && !devOverrideUnlocked && !checkAccessLocally(moduleType);

          // å­—æ¯è¯¾ç¨‹ï¼šä½¿ç”¨ AlphabetCourseCardï¼Œç›´æ¥è¿›å…¥ /alphabet æµç¨‹
          if (course.category === 'letter') {
            return (
              <AlphabetCourseCard
                key={course.id}
                course={course}
                isCurrent={isCurrent}
                progress={progress}
                onStart={handleStartLearning(course)} // Connected handleStartLearning
              />
            );
          }

          // å•è¯è¯¾ç¨‹ï¼šä½¿ç”¨æ ‡å‡† CourseCard
          return (
            <CourseCard
              key={course.id}
              course={course as CourseCardData}
              isCurrent={isCurrent}
              progress={progress}
              onStart={handleStartLearning(course)}
              isLocked={isLocked} // Pass locked state
            />
          );
        })}
        <View style={{ height: 100 }} />
      </ScrollView>

      <CourseSelectionModal
        visible={modalVisible}
        courseTitle={pendingCourse?.title || ''}
        onConfirm={confirmSwitchCourse}
        onCancel={() => {
          setModalVisible(false);
          setPendingCourse(null);
        }}
      />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: Colors.paper,
  },
  header: {
    paddingHorizontal: 24,
    paddingTop: 24,
    paddingBottom: 16,
  },
  headerTitle: {
    fontFamily: Typography.playfairBold,
    fontSize: 28,
    color: Colors.ink,
    marginBottom: 4,
  },
  headerSubtitle: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  searchContainer: {
    paddingHorizontal: 24,
    marginBottom: 16,
  },
  searchBar: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.white,
    borderRadius: 16,
    paddingHorizontal: 16,
    height: 48,
    borderWidth: 1,
    borderColor: Colors.sand,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.03,
    shadowRadius: 4,
    elevation: 2,
  },
  searchInput: {
    flex: 1,
    marginLeft: 12,
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.ink,
  },
  categoryContainer: {
    marginBottom: 16,
  },
  categoryContent: {
    paddingHorizontal: 24,
    gap: 20,
  },
  categoryChip: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: Colors.white,
    borderWidth: 1,
    borderColor: Colors.sand,
    gap: 6,
  },
  categoryChipActive: {
    backgroundColor: Colors.thaiGold,
    borderColor: Colors.thaiGold,
  },
  categoryText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 13,
    color: Colors.taupe,
  },
  categoryTextActive: {
    color: Colors.white,
    fontWeight: '600',
  },
  scrollView: {
    flex: 1,
  },
  listContent: {
    paddingHorizontal: 24,
    paddingBottom: 24,
    gap: 16,
  },
});
</file>

<file path="src/hooks/useAlphabetLearningEngine.ts">
// src/hooks/useAlphabetLearningEngine.ts

import { useState, useCallback, useEffect, useMemo, useRef } from 'react';
import { useAlphabetStore } from '@/src/stores/alphabetStore';
import { useModuleAccessStore } from '@/src/stores/moduleAccessStore';
import { useUserStore } from '@/src/stores/userStore';
import type { AlphabetLearningState, AlphabetQueueItem, AlphabetQueueSource } from '@/src/stores/alphabetStore';
import type {
  PhonicsRule,
  RoundEvaluationState,
} from '@/src/entities/types/phonicsRule.types';

// âœ… ä¿®å¤: ç»Ÿä¸€ä½¿ç”¨ enum ä¸­çš„ QuestionType
import { QuestionType } from '@/src/entities/enums/QuestionType.enum';
import { QualityButton } from '@/src/entities/enums/QualityScore.enum';
import { callCloudFunction } from '@/src/utils/apiClient';
import { API_ENDPOINTS } from '@/src/config/api.endpoints';
import { Alert, AppState } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';


// ğŸ”¥ TODO-03: Phase = AlphabetQueueSource + ç‰¹æ®ŠçŠ¶æ€
// Phase ä»…ç”¨äº UI å±•ç¤ºï¼Œä¸å‚ä¸æ‰§è¡Œå†³ç­–
export type Phase = AlphabetQueueSource | 'finished' | 'round-completed';

const SESSION_STORAGE_KEY = '@alphabet_learning_session';

interface SessionRecoveryState {
  lessonId: string;
  round: 1 | 2 | 3;
  phase: Phase;
  answeredCount: number;
  currentIndex: number; // ğŸ”¥ Bug 3 ä¿®å¤ï¼šæ·»åŠ  currentIndex
  status: 'in-progress' | 'completed';
}


// ===== Hook ä¸»ä½“ =====

export function useAlphabetLearningEngine(lessonId: string) {
  const {
    queue,
    currentItem,
    currentIndex,
    currentRound: storeCurrentRound, // ä» Store è¯»å– currentRound
    lessonMetadata,
    phonicsRule,
    initializeSession,
    submitRoundEvaluation: submitRoundToStore,
    next: nextInQueue,
    appendQueue,
    setCurrentIndex, // å¼•å…¥ setCurrentIndex æ–¹æ³•
    setCurrentRound: setStoreCurrentRound, // å¼•å…¥ setCurrentRound æ–¹æ³•
  } = useAlphabetStore();

  const { currentUser } = useUserStore();
  const { userProgress } = useModuleAccessStore();
  const userId = currentUser?.userId ?? 'test-user';

  const [initialized, setInitialized] = useState(false);
  // REMOVED explicit phase state. Phase is now derived.
  // const [phase, setPhase] = useState<Phase>('finished'); 

  // ğŸ”¥ TODO-03: ä»¥ä¸‹çŠ¶æ€ä»…ç”¨äº UI å±•ç¤ºï¼Œä¸å‚ä¸æ‰§è¡Œå†³ç­– (legacy UI only)
  const [isLessonFinished, setIsLessonFinished] = useState(false);
  const [explicitPhase, setExplicitPhase] = useState<Phase | null>(null);

  // ===== Phase Logic (Derived) =====
  // ğŸ”¥ TODO-03: derivedPhase ä»…ç”¨äº UI å±•ç¤ºï¼Œä¸å‚ä¸æ‰§è¡Œå†³ç­– (legacy UI only)
  const derivedPhase: Phase = useMemo(() => {
    if (explicitPhase) return explicitPhase;
    if (isLessonFinished) return 'finished';
    if (!currentItem) return 'finished';

    // ç›´æ¥è¿”å› sourceï¼Œä¸å†è¿›è¡Œæ˜ å°„è½¬æ¢
    return currentItem.source;
  }, [currentItem, isLessonFinished, explicitPhase]);

  const [phonicsRuleShown, setPhonicsRuleShown] = useState(false);
  const [showPhonicsRuleCard, setShowPhonicsRuleCard] = useState(false);

  const [learnedCount, setLearnedCount] = useState(0);
  const [todayList, setTodayList] = useState<AlphabetLearningState[]>([]);
  const [wrongAnswers, setWrongAnswers] = useState<Set<string>>(new Set());

  // âœ… ä¿®å¤: currentRound ç±»å‹ä¸º 1 | 2 | 3
  // ğŸ”¥ Bug 2 ä¿®å¤ï¼šåˆå§‹åŒ–æ—¶ä» Store è¯»å– currentRound
  const [currentRound, setCurrentRound] = useState<1 | 2 | 3>(storeCurrentRound || 1);
  const [roundEvaluation, setRoundEvaluation] = useState<RoundEvaluationState>({
    currentRound: 1,
    rounds: [],
    allRoundsPassed: false,
  });

  const roundMemoryResultsRef = useRef<Record<string, QualityButton>>({});
  const [answeredCount, setAnsweredCount] = useState(0);
  const [recoveryPrompted, setRecoveryPrompted] = useState(false);
  // æ–°å¢: å°†æ¢å¤çŠ¶æ€æš´éœ²ç»™ UI
  const [pendingRecoverySession, setPendingRecoverySession] = useState<SessionRecoveryState | null>(null);

  // ğŸ”¥ æ–°å¢: æ ‡è®°ç”¨æˆ·æ˜¯å¦å·²ç»å¼€å§‹ç­”é¢˜ï¼ˆç”¨äºå»¶è¿Ÿ session ä¿å­˜æ—¶æœºï¼‰
  const [hasStartedAnswering, setHasStartedAnswering] = useState(false);

  const prevRoundRef = useRef<1 | 2 | 3>(currentRound);


  // ğŸ› P0-2 FIX: é˜²æ­¢é‡å¤ç‚¹å‡»
  const [isProcessingNext, setIsProcessingNext] = useState(false);

  const writeSessionState = useCallback(async (state: SessionRecoveryState | null) => {
    try {
      if (state) {
        await AsyncStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(state));
      } else {
        await AsyncStorage.removeItem(SESSION_STORAGE_KEY);
      }
    } catch (error) {
      console.error('âš ï¸ å­—æ¯å­¦ä¹ ä¼šè¯çŠ¶æ€æŒä¹…åŒ–å¤±è´¥:', error);
    }
  }, []);

  const persistSessionState = useCallback(async () => {
    // ğŸ”¥ TODO-03: ä¸ä¾èµ– derivedPhaseï¼Œæ”¹ä¸ºåˆ¤æ–­ isLessonFinished å’Œ currentItem
    // å½“è¯¾ç¨‹ç»“æŸæˆ–æ²¡æœ‰å½“å‰é¢˜ç›®æ—¶ï¼Œæ¸…é™¤ session
    if (!lessonId || !initialized || isLessonFinished || !currentItem) {
      console.log('ğŸ’¾ [Persist] Clearing session (finished or no item)');
      await writeSessionState(null);
      return;
    }

    // ğŸ”¥ æ–°å¢ï¼šåªæœ‰ç”¨æˆ·å¼€å§‹ç­”é¢˜åï¼Œæ‰ä¿å­˜ session
    if (!hasStartedAnswering) {
      console.log('ğŸ’¾ [Persist] User has not started answering, skip persisting');
      return;
    }

    const sessionData: SessionRecoveryState = {
      lessonId,
      round: currentRound,
      phase: currentItem.source, // ğŸ”¥ TODO-03: ç›´æ¥ä½¿ç”¨ sourceï¼Œä¸å†æ˜ å°„
      answeredCount,
      currentIndex, // ğŸ”¥ Bug 3 ä¿®å¤ï¼šä¿å­˜ currentIndex
      status: 'in-progress', // é»˜è®¤çŠ¶æ€ä¸º in-progress
    };
    console.log('ğŸ’¾ [Persist] Writing session:', sessionData);
    await writeSessionState(sessionData);
  }, [lessonId, initialized, isLessonFinished, currentItem, currentRound, answeredCount, currentIndex, writeSessionState, hasStartedAnswering]);

  const clearStoredSessionState = useCallback(async () => {
    await writeSessionState(null);
  }, [writeSessionState]);

  const handleContinueStoredSession = useCallback((session: SessionRecoveryState) => {
    setCurrentRound(session.round);
    // setPhase(session.phase); // Phase derived from queue restoration
    setAnsweredCount(session.answeredCount ?? 0);
    setTodayList([]);
    setWrongAnswers(new Set());
    setRecoveryPrompted(true);

    // ğŸ”¥ æ¢å¤å­¦ä¹ æ—¶ï¼Œæ ‡è®°ä¸ºå·²ç»å¼€å§‹ç­”é¢˜ï¼ˆå› ä¸ºæ˜¯ä¸­æ–­åæ¢å¤ï¼‰
    setHasStartedAnswering(true);

    // ğŸ”¥ Bug 3 ä¿®å¤ï¼šæ¢å¤é˜Ÿåˆ—ä½ç½®
    if (session.currentIndex !== undefined && session.currentIndex >= 0) {
      setCurrentIndex(session.currentIndex);
      console.log(`ğŸ”„ æ¢å¤é˜Ÿåˆ—ä½ç½®: currentIndex = ${session.currentIndex}`);
    }
  }, [setCurrentIndex]);

  const handleRestartStoredSession = useCallback(async (session?: SessionRecoveryState) => {
    // ğŸ”¥ Bug 4 ä¿®å¤ï¼šé‡æ–°å¼€å§‹æœ¬è½®æ—¶ï¼Œéœ€è¦è°ƒç”¨ initializeSession é‡æ–°åŠ è½½é˜Ÿåˆ—
    // ä» Round1 çš„ç¬¬ä¸€ä¸ªé˜¶æ®µå¼€å§‹ï¼ˆprevious-round-review æˆ– new-learningï¼‰
    const targetRound = session?.round ?? 1;

    setCurrentRound(targetRound);
    setAnsweredCount(0);
    setTodayList([]);
    setWrongAnswers(new Set());
    setRecoveryPrompted(true);

    // ğŸ”¥ é‡æ–°å¼€å§‹æ—¶ï¼Œé‡ç½®ç­”é¢˜æ ‡è®°
    setHasStartedAnswering(false);

    // ğŸ”¥ æ¸…é™¤æ—§ session
    await clearStoredSessionState();

    // ğŸ”¥ é‡æ–°åˆå§‹åŒ–é˜Ÿåˆ—ï¼ŒæŒ‡å®š round
    try {
      await initializeSession(userId, { lessonId, round: targetRound });
      console.log(`ğŸ”„ é‡æ–°åŠ è½½é˜Ÿåˆ—: Round ${targetRound}`);
    } catch (error) {
      console.error('âŒ handleRestartStoredSession: initializeSession å¤±è´¥:', error);
    }
  }, [clearStoredSessionState, initializeSession, userId, lessonId]);

  // ===== åˆå§‹åŒ– =====
  useEffect(() => {
    let cancelled = false;

    // ğŸ”¥ æ¯æ¬¡é‡æ–°åˆå§‹åŒ–æ—¶ï¼Œé‡ç½®ç­”é¢˜æ ‡è®°
    setHasStartedAnswering(false);

    (async () => {
      try {
        await initializeSession(userId, { lessonId });
      } catch (e) {
        console.error('[useAlphabetLearningEngine] initializeSession å¤±è´¥:', e);
        if (cancelled) return;
        // åç«¯å¤±è´¥æ—¶ä¹Ÿä¸èƒ½æ°¸è¿œåœç•™åœ¨ loading
        setInitialized(true);
        // setPhase('finished');
        return;
      }

      if (cancelled) return;
      setInitialized(true);
    })();

    return () => {
      cancelled = true;
    };
  }, [lessonId, userId, initializeSession]);

  useEffect(() => {
    void persistSessionState();
  }, [persistSessionState]);

  useEffect(() => {
    const subscription = AppState.addEventListener('change', (nextState) => {
      if (nextState === 'background' || nextState === 'inactive') {
        void persistSessionState();
      }
    });

    return () => {
      void persistSessionState();
      subscription.remove();
    };
  }, [persistSessionState]);

  useEffect(() => {
    if (!initialized || recoveryPrompted || !lessonId) {
      console.log('ğŸ” [Recovery Check] Skipped:', { initialized, recoveryPrompted, lessonId });
      return;
    }

    console.log('ğŸ” [Recovery Check] Starting check...');

    let cancelled = false;
    (async () => {
      try {
        const stored = await AsyncStorage.getItem(SESSION_STORAGE_KEY);
        console.log('ğŸ” [Recovery Check] Stored session:', stored ? 'Found' : 'Not found');

        if (!stored) return;

        const parsed: SessionRecoveryState = JSON.parse(stored);
        console.log('ğŸ” [Recovery Check] Parsed session:', {
          lessonId: parsed.lessonId,
          round: parsed.round,
          phase: parsed.phase,
          status: parsed.status,
          currentIndex: parsed.currentIndex
        });

        // éªŒè¯ lessonId åŒ¹é…
        if (parsed.lessonId !== lessonId) {
          console.log('ğŸ” [Recovery Check] LessonId mismatch, clearing...');
          await clearStoredSessionState();
          return;
        }

        // ğŸ”¥ å…³é”®ä¿®å¤ï¼šä»…å½“ status === 'in-progress' æ—¶æ‰å¼¹å‡ºæ¢å¤æç¤º
        if (parsed.status !== 'in-progress') {
          console.log('ğŸ” [Recovery Check] Status not in-progress, clearing...', parsed.status);
          await clearStoredSessionState();
          return;
        }

        if (cancelled) return;

        // æ›¿æ¢ Alert.alert ä¸º UI çŠ¶æ€
        console.log('ğŸ” [Recovery Check] Showing recovery dialog');
        setPendingRecoverySession(parsed);
        setRecoveryPrompted(true);

      } catch (error) {
        console.error('âš ï¸ è¯»å–å­—æ¯å­¦ä¹ ä¼šè¯çŠ¶æ€å¤±è´¥:', error);
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [
    initialized,
    lessonId,
    recoveryPrompted,
    clearStoredSessionState,
  ]);

  // æ–°å¢: å¤„ç†ç”¨æˆ·çš„æ¢å¤é€‰æ‹©
  const handleResolveRecovery = useCallback((choice: 'continue' | 'restart') => {
    if (!pendingRecoverySession) return;

    if (choice === 'continue') {
      handleContinueStoredSession(pendingRecoverySession);
    } else {
      handleRestartStoredSession(pendingRecoverySession);
    }
    setPendingRecoverySession(null);
  }, [pendingRecoverySession, handleContinueStoredSession, handleRestartStoredSession]);

  // ğŸ”¥ Bug 2 ä¿®å¤ï¼šä» Store åŒæ­¥ currentRound åˆ° Hook æœ¬åœ°çŠ¶æ€
  useEffect(() => {
    if (storeCurrentRound && storeCurrentRound !== currentRound) {
      console.log(`ğŸ”„ Syncing currentRound from Store: ${storeCurrentRound}`);
      setCurrentRound(storeCurrentRound);
    }
  }, [storeCurrentRound, currentRound]);

  useEffect(() => {
    if (prevRoundRef.current !== currentRound) {
      prevRoundRef.current = currentRound;
      setAnsweredCount(0);
    }
  }, [currentRound]);

  // ===== é¦–æ¬¡è¿›å…¥ï¼šå¦‚æœæ²¡æœ‰ä»»ä½•â€œæ—§å­—æ¯â€ï¼Œè‡ªåŠ¨è·³è¿‡æ˜¨æ—¥å¤ä¹  =====
  useEffect(() => {
    if (!initialized) return;
    if (!currentItem) return;
    // setPhase(currentItem.source); // REMOVED: Phase is derived
  }, [initialized, currentItem, queue]);

  // ===== Today Learning é¦–æ¬¡æ˜¾ç¤ºæ‹¼è¯»è§„åˆ™ =====
  useEffect(() => {
    // ğŸ”¥ TODO-03: ç»Ÿä¸€ä½¿ç”¨ 'new-learning'
    const isNew = currentItem?.source === 'new-learning';
    if (isNew && !phonicsRuleShown && phonicsRule && learnedCount === 0) {
      setShowPhonicsRuleCard(true);
    }
  }, [phonicsRuleShown, phonicsRule, learnedCount, currentItem]);

  const handleCompletePhonicsRule = useCallback(() => {
    setShowPhonicsRuleCard(false);
    setPhonicsRuleShown(true);
  }, []);

  const recordMemoryResult = useCallback((letterId: string, quality: QualityButton) => {
    roundMemoryResultsRef.current[letterId] = quality;
  }, []);

  const submitAlphabetMemoryResults = useCallback(
    async (roundNumber: number) => {
      const entries = Object.entries(roundMemoryResultsRef.current);
      if (entries.length === 0) return;

      const results = entries.map(([entityId, quality]) => ({
        entityType: 'letter' as const,
        entityId,
        quality,
      }));

      try {
        await callCloudFunction(
          'submitMemoryResult',
          {
            userId,
            lessonId,
            roundNumber,
            results,
          },
          {
            endpoint: API_ENDPOINTS.MEMORY.SUBMIT_MEMORY_RESULT.cloudbase,
          }
        );
      } catch (error) {
        console.error('âŒ submitAlphabetMemoryResults error:', error);
      }
    },
    [lessonId, userId]
  );

  // ===== ç­”é¢˜å›è°ƒ =====
  const handleAnswer = useCallback(
    async (isCorrect: boolean, questionType: QuestionType) => {
      if (!currentItem) return;

      // ğŸ”¥ æ ‡è®°ç”¨æˆ·å·²ç»å¼€å§‹ç­”é¢˜ï¼ˆè§¦å‘ session ä¿å­˜ï¼‰
      if (!hasStartedAnswering) {
        setHasStartedAnswering(true);
        console.log('ğŸ¯ User started answering, session will now persist');
      }

      const quality = isCorrect ? QualityButton.KNOW : QualityButton.FORGET;
      recordMemoryResult(currentItem.alphabetId, quality);
      setAnsweredCount((prev) => prev + 1);

      const wrongKey = currentItem.alphabetId;

      setWrongAnswers((prev) => {
        const next = new Set(prev);
        if (isCorrect && currentItem.source === 'error-review') {
          next.delete(wrongKey);
        } else if (!isCorrect) {
          next.add(wrongKey);
        }
        return next;
      });
    },
    [currentItem, recordMemoryResult, hasStartedAnswering]
  );

  // REMOVED DUPLICATE derivedPhase definition from here (moved to top)


  // ===== Question Type Logic (Engine Driven) =====

  // ğŸ”¥ TODO-03: é¢˜å‹é€‰æ‹©åªèƒ½åŸºäº currentItem.sourceï¼Œä¸ä¾èµ– Phase
  const currentQuestionType = useMemo<QuestionType | null>(() => {
    if (!currentItem) return null;

    const source = currentItem.source;

    // 1. New Learning / Mini Review: ALLOW Simple Types
    if (source === 'new-learning') {
      return QuestionType.SOUND_TO_LETTER;
    }

    if (source === 'mini-review') {
      return Math.random() > 0.5 ? QuestionType.SOUND_TO_LETTER : QuestionType.LETTER_TO_SOUND;
    }

    // 2. Strict Review Phases: FORBID Simple Types (where possible)
    // ğŸ”¥ TODO-03: ç»Ÿä¸€ä½¿ç”¨ 'previous-review'
    if (source === 'previous-review' || source === 'final-review') {
      const complexTypes = [];

      // Only allow CONSONANT_CLASS for Consonants
      if (currentItem.letter.type === 'consonant') {
        complexTypes.push(QuestionType.CLASS_CHOICE); // CONSONANT_CLASS
        // Initial/Final sound usually applies to consonants acting as such
        if (currentItem.letter.initialSound) complexTypes.push(QuestionType.INITIAL_SOUND);
        if (currentItem.letter.finalSound) complexTypes.push(QuestionType.FINAL_CONSONANT);
      } else {
        // Vowels / Tones:
        // Currently we lack "Complex" types for vowels (Tone Calculation is TODO).
        // Fallback to LETTER_TO_SOUND (Reading) which is harder than Sound-to-Letter.
        // We cannot use CONSONANT_CLASS.
      }

      // TODO: Enable these when data/logic is ready
      // complexTypes.push(QuestionType.TONE_CALCULATION);

      if (complexTypes.length === 0) {
        // Fallback for Vowels in Strict Phase
        // Prefer LETTER_TO_SOUND (Reading)
        return QuestionType.LETTER_TO_SOUND;
      }

      const hash = currentItem.alphabetId.charCodeAt(0) + (currentItem.round || 0) + Date.now();
      return complexTypes[hash % complexTypes.length];
    }

    if (source === 'error-review') {
      // Error Review: Retry what they failed.
      // If we don't know what they failed, default to SOUND_TO_LETTER for safety?
      // Or make it strict if it was a strict phase failure?
      // For now, allow simple types to ensure they at least get the basics.
      return QuestionType.SOUND_TO_LETTER;
    }

    return QuestionType.SOUND_TO_LETTER;
  }, [currentItem]);


  // ===== ä¸‹ä¸€é¢˜ =====
  const handleNext = useCallback(async () => {
    // ğŸ› P0-2 FIX: é˜²æ­¢é‡å¤ç‚¹å‡»
    if (isProcessingNext) {
      console.log('ğŸš« é˜²æ­¢é‡å¤ç‚¹å‡» handleNext');
      return;
    }

    // ğŸ”¥ TODO-03: ä¸ä¾èµ– explicitPhaseï¼Œæ”¹ä¸ºåˆ¤æ–­ currentItem
    // å½“è½®æ¬¡å®Œæˆåï¼ŒcurrentItem ä¸º nullï¼Œæ— æ³•ç»§ç»­ç­”é¢˜
    if (!currentItem) {
      console.warn('âš ï¸ No current item, round may be completed.');
      return;
    }

    console.log('=== handleNext è°ƒç”¨ ===');
    console.log('è°ƒç”¨å‰çŠ¶æ€:', {
      phase: derivedPhase,
      currentRound,
      learnedCount,
      queueLength: queue.length,
      currentLetter: currentItem?.letter?.thaiChar || 'unknown',
      source: currentItem?.source,
      errorQueueSize: wrongAnswers.size, // Approximation of potential error queue
    });

    setIsProcessingNext(true);

    // ğŸ”¥ TODO-03: ç»Ÿä¸€ä½¿ç”¨ 'new-learning'
    const isCurrentNew = currentItem?.source === 'new-learning';
    // STRICT Condition: End of Queue
    const atEnd = currentIndex >= queue.length - 1;

    try {
      if (currentItem && isCurrentNew) {
        setTodayList((prev) => [...prev, currentItem]);
        setLearnedCount((prev) => prev + 1);
      }

      if (atEnd) {
        // 1. Check if we have pending errors
        if (wrongAnswers.size > 0) {
          const errorItems: AlphabetQueueItem[] = [];
          const wrongArray = Array.from(wrongAnswers);

          wrongArray.forEach((letterId) => {
            const target = queue.find((q) => q.alphabetId === letterId);
            if (target) {
              errorItems.push({ ...target, source: 'error-review', round: currentRound });
            }
          });

          if (errorItems.length > 0) {
            appendQueue(errorItems);
            console.log('ğŸ” è¿½åŠ é”™é¢˜å›é¡¾é˜Ÿåˆ—:', errorItems.map((i) => i.alphabetId));
            // Just move next to start error review
            nextInQueue();
            return;
          }
        }

        // 2. Strict Round Completion Check
        // Condition: End of Queue AND No Errors allowed
        if (wrongAnswers.size === 0) {
          console.log('âœ… Round Completed Check Passed.');
          await submitRoundResults();
          // DO NOT call nextInQueue, just stop here.
          return;
        }
      }

      nextInQueue();
    } finally {
      setTimeout(() => {
        setIsProcessingNext(false);
      }, 300);
    }
  }, [currentItem, learnedCount, nextInQueue, queue, currentRound, isProcessingNext, currentIndex, wrongAnswers, appendQueue]); // ğŸ”¥ TODO-03: ç§»é™¤ derivedPhase å’Œ explicitPhase ä¾èµ–

  // âœ… ä¿®å¤: submitRoundResults
  const submitRoundResults = useCallback(async () => {
    console.log(`ğŸš€ Submitting Round ${currentRound} Results...`);

    const totalQuestions = queue.length; // Note: includes error retries
    const correctCount = Math.max(0, totalQuestions - wrongAnswers.size); // Rough calc

    const accuracy = totalQuestions > 0 ? correctCount / totalQuestions : 0;
    const passed = wrongAnswers.size === 0; // Round passes only if no errors

    // ğŸ”¥ TODO-05: åˆ¤å®š modeï¼Œfree-play æ¨¡å¼ä¸‹ç¦æ­¢ä»»ä½•å†™å…¥
    const mode = userProgress?.letterCompleted ? 'free-play' : 'learning';

    if (mode === 'learning') {
      // ===== learning æ¨¡å¼ï¼šæ­£å¸¸å†™å…¥è¿›åº¦ =====

      // 1. Submit to Backend
      await submitRoundToStore({
        userId,
        lessonId,
        roundNumber: currentRound,
        totalQuestions,
        correctCount,
        accuracy: 1, // Hack: If they cleared error queue, they technically "passed".
      });

      // 2. Log
      console.log(`âœ… Round ${currentRound} Submit Success.`);

      // ğŸ”¥ Step 5: Round3 å®Œæˆååˆ·æ–°ç”¨æˆ·è¿›åº¦ï¼ˆä»åç«¯è·å–æœ€æ–° completedLessonsï¼‰
      if (currentRound === 3 && passed) {
        console.log('ğŸ“š Round3 completed! Refreshing user progress from backend...');

        // ğŸ”¥ åˆ·æ–°è¿›åº¦ï¼ˆä¼šä»åç«¯è·å–æœ€æ–°çš„ completedLessonsï¼‰
        await useModuleAccessStore.getState().getUserProgress();

        console.log('âœ… User progress refreshed from backend');
      }

      // 3. ğŸ”¥ æ¨è¿›åˆ°ä¸‹ä¸€è½®ï¼ˆRound1 â†’ Round2 â†’ Round3ï¼‰
      const nextRound = Math.min(currentRound + 1, 3) as 1 | 2 | 3;

      // ğŸ”¥ å…ˆæ›´æ–° Store çš„ currentRound (é¿å… useEffect åŒæ­¥æ—¶è¦†ç›–)
      setStoreCurrentRound(nextRound);
      console.log(`ğŸ”„ Store currentRound updated: ${nextRound}`);

      // ğŸ”¥ å†æ›´æ–° Hook çš„æœ¬åœ°çŠ¶æ€
      setCurrentRound(nextRound);

      // 4. ğŸ”¥ æ˜¾å¼æ¸…é™¤ sessionï¼ˆé¿å…ä¸‹æ¬¡è¿›å…¥æ—¶å¼¹å‡ºæ¢å¤å¼¹çª—ï¼‰
      await clearStoredSessionState();
      console.log('ğŸ—‘ï¸ Round completed, session cleared');

      // 5. ENTER 'round-completed' PHASE
      setExplicitPhase('round-completed');
    } else {
      // ===== free-play æ¨¡å¼ï¼šåªè¯»å­¦ä¹ ï¼Œä¸å†™å…¥ä»»ä½•è¿›åº¦ =====
      console.log(`ğŸ® free-play æ¨¡å¼ï¼šRound å®Œæˆï¼Œä½†ä¸å†™å…¥è¿›åº¦`);

      // ä»…æ¸…é™¤ sessionï¼Œä¸æ¨è¿› round
      await clearStoredSessionState();

      // æ˜¾ç¤ºå®Œæˆ UI
      setExplicitPhase('round-completed');
    }

  }, [currentRound, queue.length, wrongAnswers, userId, lessonId, submitRoundToStore, clearStoredSessionState, setStoreCurrentRound, userProgress, setCurrentRound, setExplicitPhase]);

  // REMOVED: handleStartNextRound. 
  // User must exit to Lesson page and restart to trigger next round init.
  /*
  const handleStartNextRound = useCallback(async () => { ... });
  */



  const letterPool = useMemo(() => queue.map((item) => item.letter), [queue]);

  // ğŸ”¥ æ–°å¢: åœ¨ RoundCompleted æˆ–è¯¾ç¨‹å®Œæˆæ—¶è°ƒç”¨ï¼Œæ¸…é™¤ session
  const handleFinishRound = useCallback(async () => {
    await clearStoredSessionState();
  }, [clearStoredSessionState]);

  // ğŸ”¥ æ–°å¢: Skip (Bury) functionality for previous-review
  const handleSkipYesterdayReview = useCallback(async () => {
    // Only valid in previous-review phase
    // ğŸ”¥ TODO-03: derivedPhase is legacy, check source directly
    if (currentItem?.source !== 'previous-review') {
      console.warn('âš ï¸ handleSkipYesterdayReview called outside of previous-review phase');
      return;
    }

    console.log('â­ï¸ Skipping (Burying) review item:', currentItem.alphabetId);

    // 1. Mark as Known (Correct) to "bury" it for this session quality-wise
    // Using currentQuestionType or fallback to SOUND_TO_LETTER
    await handleAnswer(true, currentQuestionType ?? QuestionType.SOUND_TO_LETTER);

    // 2. Advance to next item immediately
    console.log('â­ï¸ Item skipped, advancing...');
    await handleNext();
  }, [currentItem, currentQuestionType, handleAnswer, handleNext]);

  return {
    initialized,
    phase: derivedPhase,
    currentRound,
    queueIndex: currentIndex,
    totalQueue: queue.length,
    roundEvaluation,
    currentItem,
    currentQuestionType,
    letterPool,
    onAnswer: handleAnswer,
    onNext: handleNext,
    // onStartNextRound: handleStartNextRound, // REMOVED
    phonicsRule,
    showPhonicsRuleCard,
    onCompletePhonicsRule: handleCompletePhonicsRule,
    // é€å‡ºç»™ UI
    pendingRecoverySession,
    resolveRecovery: handleResolveRecovery,
    onFinishRound: handleFinishRound,
    onSkipYesterdayReview: handleSkipYesterdayReview,
  };
}
</file>

<file path="src/stores/alphabetStore.ts">
// src/stores/alphabetStore.ts

/**
 * å­—æ¯å­¦ä¹  Storeï¼ˆV9 ç‰ˆæœ¬ï¼‰
 *
 * èŒè´£ï¼š
 * - é€šè¿‡ memory-engineï¼ˆ/memory-engine äº‘å‡½æ•°ï¼‰è·å–ä»Šæ—¥å­—æ¯é˜Ÿåˆ—
 * - ç»´æŠ¤å‰ç«¯ä¼šè¯çŠ¶æ€ï¼ˆå½“å‰å­—æ¯ã€å®Œæˆæ•°é‡ç­‰ï¼‰
 * - æ¥æ”¶ã€Œå¯¹ / é”™ã€ç»“æœï¼Œè‡ªåŠ¨æ˜ å°„ä¸º è®°å¾—/é™Œç”Ÿ å¹¶è°ƒç”¨ submitMemoryResult
 *
 * æ³¨æ„ï¼š
 * - ä¸å†ä¾èµ–æœ¬åœ° letterData.tsï¼Œæ‰€æœ‰å­—æ¯æ•°æ®æ¥è‡ªåç«¯ Letter æ–‡æ¡£
 * - æ–°å­—æ¯å­¦ä¹ ï¼ˆè¯¾ç¨‹ï¼‰è´Ÿè´£æŠŠå­—æ¯å¡è¿›è®°å¿†å¼•æ“ï¼›å¤ä¹ é˜Ÿåˆ—å®Œå…¨äº¤ç»™ getTodayMemories
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';
// ä½¿ç”¨ expo-file-system çš„ legacy APIï¼Œé¿å… v54 æ–° File API
// æŠ›å‡ºçš„ getInfoAsync ç­‰æ–¹æ³•åºŸå¼ƒé”™è¯¯ã€‚
import * as FileSystem from 'expo-file-system/legacy';

import { callCloudFunction } from '@/src/utils/apiClient';
import { API_ENDPOINTS, MODULE_ENDPOINTS } from '@/src/config/api.endpoints';

import type { Letter } from '@/src/entities/types/letter.types';
import { buildAlphabetQueue } from '@/src/utils/alphabet/buildAlphabetQueue';
import type { ApiResponse } from '@/src/entities/types/api.types';
import { LearningPhase } from '@/src/entities/enums/LearningPhase.enum';
import {
  QualityButton,
  QUALITY_SCORE_MAP,
  ATTEMPTS_INCREMENT_MAP,
} from '@/src/entities/enums/QualityScore.enum';


// ==================== åç«¯è®°å¿†çŠ¶æ€ ====================

export interface MemoryStatus {
  masteryLevel: number;
  reviewStage: number;
  correctCount: number;
  wrongCount: number;
  streakCorrect: number;
  nextReviewAt: string;
  isNew: boolean;
}

// ==================== ä¼šè¯ä¸­çš„å­—æ¯çŠ¶æ€ ====================

export type AlphabetLearningMode = 'learning' | 'free-play';

export interface AlphabetLearningState {
  // åŸºç¡€
  alphabetId: string;
  _id: string; // Letter çš„ _idï¼Œç”¨äºé¢˜ç›®ç”Ÿæˆ
  letter: Letter;
  thaiChar: string;
  pronunciation: string;
  example: string;
  audioUrl: string;
  category: string;

  // å‘éŸ³ç›¸å…³å­—æ®µï¼ˆç”¨äºé¢˜ç›®ç”Ÿæˆï¼‰
  syllableSoundName?: string; // éŸ³èŠ‚å‘éŸ³åç§°ï¼ˆå¦‚: "d"ï¼‰
  initialSound?: string; // é¦–éŸ³ï¼ˆå¦‚: "d"ï¼‰
  syllableSoundUrl?: string; // éŸ³èŠ‚å‘éŸ³URL
  letterPronunciationUrl?: string; // å­—æ¯å‘éŸ³URL
  audioPath?: string; // æ—§ç‰ˆéŸ³é¢‘è·¯å¾„

  // ä¼šè¯è¿›åº¦
  currentAttempts: number;
  requiredAttempts: number;
  qualityHistory: number[];
  isCompleted: boolean;
  timestamp: string;

  // åç«¯è®°å¿†ä¿¡æ¯ï¼ˆåªè¯»ï¼‰
  memoryState?: MemoryStatus;
}

// ==================== é˜Ÿåˆ—é¡¹ï¼ˆå‰ç«¯æ„å»ºï¼‰ ====================

// ğŸ”¥ TODO-03: ç»Ÿä¸€ source å‘½åï¼Œä¸ ALPHABET_MODULE_IMPLEMENTATION_SKELETON.md å¯¹é½
export type AlphabetQueueSource =
  | 'previous-review'      // ä¹‹å‰è½®æ¬¡çš„å¤ä¹ 
  | 'new-learning'         // æ–°å­—æ¯å­¦ä¹ 
  | 'mini-review'          // è¿·ä½ å¤ä¹ ï¼ˆæ¯3ä¸ªå­—æ¯ï¼‰
  | 'final-review'         // æœ€ç»ˆå¤ä¹ 
  | 'error-review';        // é”™é¢˜å¤ä¹ 

export interface AlphabetQueueItem extends AlphabetLearningState {
  source: AlphabetQueueSource;
  round: number;
}

// ==================== åç«¯è¿”å›ç»“æ„ ====================

import type {
  LessonMetadata,
  PhonicsRule,
} from '@/src/entities/types/phonicsRule.types';

interface TodayLettersResponse {
  items: Array<Letter & { memoryState?: MemoryStatus }>;
  summary: {
    total: number;
    newCount: number;
    reviewCount: number;
    entityType: string;
  };
  unlockInfo?: Record<string, any>;
  lessonMetadata?: LessonMetadata | null;
  phonicsRule?: PhonicsRule | null;
}

// ==================== Store çŠ¶æ€å®šä¹‰ ====================

interface AlphabetStoreState {
  phase: LearningPhase;

  queue: AlphabetQueueItem[];
  currentIndex: number;
  currentItem: AlphabetQueueItem | null;

  completedCount: number;
  totalCount: number;

  isLoading: boolean;
  error: string | null;

  // å·²ç¼“å­˜çš„éŸ³é¢‘ URLï¼ˆç”¨äºé¿å…é‡å¤é¢„ä¸‹è½½ï¼‰
  cachedAudioKeys: string[];

  // å½“å‰è¯¾ç¨‹å…ƒæ•°æ® / æ‹¼è¯»è§„åˆ™ï¼ˆç”±åç«¯è¿”å›ï¼‰
  lessonMetadata: LessonMetadata | null;
  phonicsRule: PhonicsRule | null;

  // ğŸ”¥ Bug 2 ä¿®å¤ï¼šæ·»åŠ  currentRound å­—æ®µ
  currentRound: 1 | 2 | 3;

  // Actions
  initializeSession: (
    userId: string,
    options?: {
      limit?: number;
      lessonId?: string;
      round?: number;
    }
  ) => Promise<void>;
  /**
   * å‰ç«¯ç»„ä»¶åªå‘Šè¯‰æˆ‘è¿™é¢˜ã€Œå¯¹/é”™ã€
   * è¿™é‡Œè‡ªåŠ¨æ˜ å°„ä¸º QualityButton å¹¶è°ƒç”¨ submitMemoryResult
   */
  submitResult: (userId: string, isCorrect: boolean) => Promise<void>;
  submitRoundEvaluation: (params: {
    userId: string;
    lessonId: string;
    roundNumber: number;
    totalQuestions: number;
    correctCount: number;
    accuracy: number;
  }) => Promise<void>;

  next: () => void;
  appendQueue: (items: AlphabetQueueItem[]) => void;
  previous: () => void;
  // ğŸ”¥ Bug 3 ä¿®å¤ï¼šæ·»åŠ  setCurrentIndex æ–¹æ³•
  setCurrentIndex: (index: number) => void;
  // ğŸ”¥ Bug 2 ä¿®å¤ï¼šæ·»åŠ  setCurrentRound æ–¹æ³•
  setCurrentRound: (round: 1 | 2 | 3) => void;

  reset: () => void;
  clearError: () => void;
}

// ==================== éŸ³é¢‘ URL è§£æ ====================


// ==================== è¾…åŠ©ï¼šLetter â†’ AlphabetLearningState ====================

function mapLetterToState(
  letter: Letter,
  memoryState?: MemoryStatus
): AlphabetLearningState {
  const pronunciation =
    letter.letterNamePronunciation ||
    letter.syllableSoundName ||
    letter.initialSound ||
    '';

  const example =
    letter.exampleWord && letter.exampleMeaning
      ? `${letter.exampleWord}ï¼ˆ${letter.exampleMeaning}ï¼‰`
      : letter.exampleWord || '';

  const rawAudioKey =
    letter.fullSoundLocalPath ||
    letter.fullSoundUrl ||
    letter.letterPronunciationLocalPath ||
    letter.letterPronunciationUrl ||
    letter.syllableSoundLocalPath ||
    letter.syllableSoundUrl ||
    letter.audioPath ||
    '';

  // ä¸ºæ»¡è¶³ã€Œæ’­æ”¾åªä»æœ¬åœ°è¯»å–ã€çš„ç›®æ ‡ï¼ŒaudioUrl ä»…åœ¨é¢„ä¸‹è½½é˜¶æ®µè¢«è®¾ç½®ä¸º file:// è·¯å¾„ã€‚
  // è¿™é‡Œå¦‚æœå·²ç»æœ‰æœ¬åœ°è·¯å¾„ï¼ˆ*_LocalPathï¼‰ï¼Œå°±ä½¿ç”¨ï¼›å¦åˆ™å…ˆç½®ç©ºï¼Œç­‰å¾…é¢„ä¸‹è½½ä»»åŠ¡å¡«å……ã€‚
  const initialAudioUrl =
    (rawAudioKey.startsWith('file://') ? rawAudioKey : '');

  return {
    alphabetId: letter._id,
    _id: letter._id,
    letter,
    thaiChar: letter.thaiChar,
    pronunciation,
    example,
    audioUrl: initialAudioUrl,
    category: letter.category,

    // å‘éŸ³ç›¸å…³å­—æ®µ
    syllableSoundName: letter.syllableSoundName,
    initialSound: letter.initialSound,
    syllableSoundUrl: letter.syllableSoundUrl,
    letterPronunciationUrl: letter.letterPronunciationUrl,
    audioPath: letter.audioPath,

    currentAttempts: 0,
    requiredAttempts: 3,
    qualityHistory: [],
    isCompleted: false,
    timestamp: new Date().toISOString(),

    memoryState,
  };
}

// ==================== Store å®ç° ====================

export const useAlphabetStore = create<AlphabetStoreState>()(
  persist(
    (set, get) => ({
      phase: LearningPhase.IDLE,
      queue: [],
      currentIndex: 0,
      currentItem: null,
      completedCount: 0,
      totalCount: 0,
      isLoading: false,
      error: null,
      cachedAudioKeys: [],
      lessonMetadata: null,
      phonicsRule: null,
      // ğŸ”¥ Bug 2 ä¿®å¤ï¼šæ·»åŠ åˆå§‹å€¼
      currentRound: 1,

      // è·å–ä»Šæ—¥å­—æ¯å­¦ä¹ /å¤ä¹ é˜Ÿåˆ—
      initializeSession: async (
        userId: string,
        options?: { limit?: number; lessonId?: string; round?: number }
      ) => {
        set({ isLoading: true, error: null });

        const limit = options?.limit ?? 30;
        const lessonId = options?.lessonId;

        // ğŸ”¥ ä»åç«¯è¯»å–å½“å‰è½®æ¬¡ï¼ˆå¦‚æœæœªæ˜¾å¼ä¼ å…¥ï¼‰
        let round = options?.round ?? 1;
        let mode: AlphabetLearningMode = 'learning';

        try {
          // è¯»å– user_alphabet_progressï¼Œç»Ÿä¸€åˆ¤å®š currentRound ä¸ mode
          const progressCol = await callCloudFunction<any>(
            'getUserProgress',
            { userId, entityType: 'letter' },
            { endpoint: MODULE_ENDPOINTS.GET_USER_PROGRESS.cloudbase }
          );

          if (progressCol.success && progressCol.data?.progress) {
            const progress = progressCol.data.progress;

            // ğŸ”¥ P0-A: lesson-scoped round æ¨å¯¼ï¼ˆä¸å†ä½¿ç”¨å…¨å±€ currentRoundï¼‰
            if (!options?.round && lessonId) {
              const roundHistory = progress.roundHistory || [];

              // è¿‡æ»¤å‡ºå½“å‰è¯¾ç¨‹ä¸” passed çš„ round è®°å½•
              const lessonHistoryRounds = roundHistory
                .filter((r: any) => r.lessonId === lessonId && r.passed === true)
                .map((r: any) => r.roundNumber);

              const lastPassedRound = lessonHistoryRounds.length > 0
                ? Math.max(...lessonHistoryRounds)
                : 0;

              const computedRound = Math.min(Math.max(lastPassedRound + 1, 1), 3);
              round = computedRound;

              console.log(`ğŸ” [P0-A] lessonId: ${lessonId}, backendCurrentRound: ${progress.currentRound || 'N/A'}, computedRound: ${computedRound}, lessonHistoryRounds: [${lessonHistoryRounds.join(',')}]`);
            }

            mode = progress.letterCompleted ? 'free-play' : 'learning';
            console.log(`âœ… AlphabetLearningMode: ${mode}`);
          } else {
            console.log('âš ï¸ æœªè·å–åˆ° progressï¼Œé»˜è®¤ä½¿ç”¨ learning æ¨¡å¼');
          }
        } catch (e) {
          console.warn('âš ï¸ è¯»å– user_alphabet_progress å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼:', e);
        }

        try {
          const response = await callCloudFunction<TodayLettersResponse>(
            'getTodayMemories',
            {
              userId,
              entityType: 'letter',
              limit,
              includeNew: true,
              lessonId,
              roundNumber: round, // ğŸ”¥ ä¼ é€’ roundNumber
            },
            {
              endpoint: API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase,
            }
          );

          if (!response.success || !response.data) {
            throw new Error(response.error ?? 'è·å–ä»Šæ—¥å­—æ¯å¤±è´¥');
          }

          const { items, lessonMetadata, phonicsRule } = response.data;

          if (!items || items.length === 0) {
            set({
              phase: LearningPhase.COMPLETED,
              queue: [],
              currentItem: null,
              currentIndex: 0,
              completedCount: 0,
              totalCount: 0,
              isLoading: false,
              lessonMetadata: lessonMetadata ?? null,
              phonicsRule: phonicsRule ?? null,
            });
            return;
          }

          const learningItems = items.map((item) =>
            mapLetterToState(item, item.memoryState)
          );

          // ğŸ”¥ P0-D: æŒ‰ lessonId åˆ‡åˆ†ï¼ˆä¸ä¾èµ– isNewï¼‰
          // ç¡®ä¿å››æ®µç»“æ„æ°¸è¿œå­˜åœ¨ï¼Œä¸”ç¬¦åˆäº§å“è§„åˆ™
          const currentLessonLetters = learningItems.filter(
            (item) => lessonId && item.letter.curriculumLessonIds?.includes(lessonId)
          );

          const nonCurrentLessonLetters = learningItems.filter(
            (item) => lessonId && !item.letter.curriculumLessonIds?.includes(lessonId)
          );

          let reviewLetters: AlphabetLearningState[];
          let newLetters: AlphabetLearningState[];

          if (round === 1) {
            // Round1: previous = éæœ¬è¯¾å­—æ¯ï¼ˆè·¨è¯¾ï¼‰ï¼Œnew = æœ¬è¯¾å­—æ¯
            reviewLetters = nonCurrentLessonLetters;
            newLetters = currentLessonLetters;
          } else {
            // Round2/3: previous = æœ¬è¯¾å­—æ¯ï¼ˆåŒè¯¾å¤ä¹ ï¼‰ï¼Œnew = æœ¬è¯¾å­—æ¯ï¼ˆä¿è¯ new-learning/mini/final å­˜åœ¨ï¼‰
            reviewLetters = currentLessonLetters;
            newLetters = currentLessonLetters;
          }

          const queue = buildAlphabetQueue({
            lessonLetters: newLetters,           // ğŸ”¥ ä¿è¯ new-learning/mini/final æ°¸è¿œæœ‰å†…å®¹
            round,
            mode,
            previousRoundLetters: reviewLetters, // ğŸ”¥ Round1=è·¨è¯¾ï¼ŒRound2/3=æœ¬è¯¾
          });

          // ğŸ”¥ å¼€å‘ç¯å¢ƒæ—¥å¿— + å››æ®µç»“æ„éªŒè¯ï¼ˆåœ¨æ„å»ºåç»Ÿè®¡ï¼‰
          if (__DEV__) {
            const sourceCounts = queue.reduce((acc, item) => {
              acc[item.source] = (acc[item.source] || 0) + 1;
              return acc;
            }, {} as Record<string, number>);

            console.log('ğŸ“Š [buildQueue] é˜Ÿåˆ—åˆ†æ:', {
              round,
              mode,
              lessonId,
              total: learningItems.length,
              currentLessonCount: currentLessonLetters.length,
              nonCurrentLessonCount: nonCurrentLessonLetters.length,
              reviewCount: reviewLetters.length,
              newCount: newLetters.length,
              queueTotal: queue.length,
              sourceCounts,  // ğŸ”¥ å››æ®µç»Ÿè®¡ {'previous-review': 5, 'new-learning': 12, ...}
              reviewIds: reviewLetters.map(l => l.thaiChar).slice(0, 5),
              newIds: newLetters.map(l => l.thaiChar).slice(0, 5),
            });
          }

          // ğŸ› P0-3 DEBUG: æ£€æŸ¥åç«¯è¿”å›çš„é˜Ÿåˆ—æ˜¯å¦åŒ…å«ä¸‰æ–°ä¸€å¤é€»è¾‘
          console.log('=== åç«¯è¿”å›çš„é˜Ÿåˆ—åˆ†æ ===');
          console.log('æ€»å­—æ¯æ•°:', queue.length);
          console.log(
            'todayQueue:',
            queue.map((item, index) => ({
              index,
              letterId: item.alphabetId,
              thaiChar: item.thaiChar,
              isNew: item.memoryState?.isNew ?? null,
              reviewStage: item.memoryState?.reviewStage ?? null,
              source: item.source,
              round: item.round,
            }))
          );

          // ç»Ÿè®¡æ–°å­—æ¯å’Œå¤ä¹ å­—æ¯çš„åˆ†å¸ƒ
          // ğŸ”¥ TODO-03: ç»Ÿä¸€ä½¿ç”¨ 'new-learning'
          const newLettersInQueue = queue.filter((item) => item.source === 'new-learning');
          const reviewLettersInQueue = queue.filter((item) => item.source !== 'new-learning');
          console.log('æ–°å­—æ¯æ•°é‡:', newLettersInQueue.length);
          console.log('å¤ä¹ å­—æ¯æ•°é‡:', reviewLettersInQueue.length);

          set({
            phase: LearningPhase.IDLE,
            queue,
            currentItem: queue[0],
            currentIndex: 0,
            completedCount: 0,
            totalCount: queue.length,
            currentRound: round as 1 | 2 | 3, // ğŸ”¥ Bug 2 ä¿®å¤ï¼šä¿å­˜ currentRound
            isLoading: false,
            lessonMetadata: lessonMetadata ?? null,
            phonicsRule: phonicsRule ?? null,
          });

          // é¢„ä¸‹è½½æœ¬è¯¾æ‰€æœ‰å­—æ¯éŸ³é¢‘åˆ°æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿï¼ˆé¦–æ¬¡è¿›å…¥è¯¥è¯¾æ—¶ï¼‰
          (async () => {
            try {
              const cacheDir = `${
                // expo-file-system åœ¨ç±»å‹å®šä¹‰é‡Œæ²¡æœ‰æš´éœ² cacheDirectoryï¼Œ
                // è¿™é‡Œé€šè¿‡ any è®¿é—®ä»¥é¿å… TS æŠ¥é”™ã€‚
                (FileSystem as any).cacheDirectory ??
                (FileSystem as any).documentDirectory ??
                ''
                }alphabet-audio/`;
              const dirInfo = await FileSystem.getInfoAsync(cacheDir);
              if (!dirInfo.exists) {
                await FileSystem.makeDirectoryAsync(cacheDir, {
                  intermediates: true,
                });
              }

              const updatedQueue = [...queue];
              const urlToLocalPath = new Map<string, string>();

              const toHttpUrl = (path?: string | null): string => {
                if (!path) return '';
                if (path.startsWith('http://') || path.startsWith('https://')) {
                  return path;
                }
                let finalPath = path;
                if (!/\.mp3($|\?)/.test(finalPath)) {
                  finalPath = `${finalPath}.mp3`;
                }
                return `https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/${finalPath}`;
              };

              // eslint-disable-next-line no-console
              console.log(
                'ğŸ§ å¼€å§‹é¢„ä¸‹è½½æœ¬è¯¾å­—æ¯éŸ³é¢‘, é˜Ÿåˆ—é•¿åº¦:',
                updatedQueue.length,
              );

              for (let index = 0; index < updatedQueue.length; index += 1) {
                const current = updatedQueue[index];
                const letter = { ...current.letter };

                const fieldEntries: Array<{
                  key: 'full' | 'syllable' | 'end' | 'letter';
                  raw?: string;
                }> = [
                    { key: 'full', raw: letter.fullSoundUrl },
                    { key: 'syllable', raw: letter.syllableSoundUrl },
                    { key: 'end', raw: letter.endSyllableSoundUrl },
                    { key: 'letter', raw: letter.letterPronunciationUrl },
                  ];

                for (const entry of fieldEntries) {
                  if (!entry.raw) continue;
                  const httpUrl = toHttpUrl(entry.raw);
                  if (!httpUrl) continue;

                  let localPath = urlToLocalPath.get(httpUrl);
                  if (!localPath) {
                    const fileName = encodeURIComponent(httpUrl);
                    localPath = `${cacheDir}${fileName}`;

                    let success = false;
                    for (
                      let attempt = 0;
                      attempt < 3 && !success;
                      attempt += 1
                    ) {
                      try {
                        const info = await FileSystem.getInfoAsync(localPath);
                        if (!info.exists) {
                          // eslint-disable-next-line no-console
                          console.log(
                            `ğŸ“¥ ä¸‹è½½éŸ³é¢‘(ç¬¬ ${attempt + 1} æ¬¡):`
                          );
                          await FileSystem.downloadAsync(httpUrl, localPath);
                        }
                        success = true;
                      } catch (err) {
                        console.warn(
                          `âš ï¸ ä¸‹è½½å­—æ¯éŸ³é¢‘å¤±è´¥(ç¬¬ ${attempt + 1} æ¬¡):`,
                          httpUrl,
                          err,
                        );
                        await new Promise((resolve) =>
                          setTimeout(resolve, 500 * (attempt + 1)),
                        );
                      }
                    }

                    if (!success) {
                      // eslint-disable-next-line no-console
                      console.warn('âŒ å¤šæ¬¡ä¸‹è½½å¤±è´¥,æ”¾å¼ƒè¯¥éŸ³é¢‘:', httpUrl);
                      continue;
                    }

                    urlToLocalPath.set(httpUrl, localPath);
                  }

                  if (entry.key === 'full') {
                    letter.fullSoundLocalPath = localPath;
                  } else if (entry.key === 'syllable') {
                    letter.syllableSoundLocalPath = localPath;
                  } else if (entry.key === 'end') {
                    letter.endSyllableSoundLocalPath = localPath;
                  } else if (entry.key === 'letter') {
                    letter.letterPronunciationLocalPath = localPath;
                  }
                }

                const primaryAudio =
                  letter.fullSoundLocalPath ||
                  letter.letterPronunciationLocalPath ||
                  letter.syllableSoundLocalPath ||
                  letter.endSyllableSoundLocalPath ||
                  current.audioUrl;

                updatedQueue[index] = {
                  ...current,
                  letter,
                  audioUrl: primaryAudio && primaryAudio.startsWith('file://')
                    ? primaryAudio
                    : primaryAudio,
                };
              }

              set((state) => {
                const { currentIndex } = state;
                const currentItem = updatedQueue[currentIndex] ?? state.currentItem;

                // è°ƒè¯•ï¼šå½“å‰é¡¹åœ¨é¢„ä¸‹è½½åçš„éŸ³é¢‘æƒ…å†µ
                if (currentItem) {
                  // eslint-disable-next-line no-console
                  console.log('ğŸ¯ é¢„ä¸‹è½½åå½“å‰å­—æ¯çŠ¶æ€:', {
                    id: currentItem.letter._id,
                    thaiChar: currentItem.letter.thaiChar,
                  });
                }

                return {
                  queue: updatedQueue,
                  currentItem,
                };
              });
              // eslint-disable-next-line no-console
              console.log('ğŸ§ é¢„ä¸‹è½½å…¨éƒ¨å®Œæˆ, é˜Ÿåˆ—æ›´æ–°æˆåŠŸ');
            } catch (err) {
              console.warn('âš ï¸ é¢„ä¸‹è½½å­—æ¯éŸ³é¢‘ä»»åŠ¡å¤±è´¥:', err);
            }
          })();
        } catch (e: any) {
          console.error('âŒ initializeSession error:', e);
          set({
            isLoading: false,
            error: e?.message ?? 'åŠ è½½å¤±è´¥',
          });
        }
      },

      // å¤ä¹ æäº¤ï¼šåªæ›´æ–°æœ¬åœ°ä¼šè¯çŠ¶æ€ï¼Œè®°å¿†å†™å…¥ç”± round å®Œæˆæ—¶ç»Ÿä¸€å¤„ç†
      submitResult: async (userId: string, isCorrect: boolean) => {
        const { currentItem, currentIndex, queue } = get();
        if (!currentItem) return;

        // è‡ªåŠ¨æ˜ å°„ä¸ºè´¨é‡æšä¸¾
        const quality: QualityButton = isCorrect
          ? QualityButton.KNOW
          : QualityButton.FORGET;

        try {
          const updatedQueue = [...queue];
          const item = updatedQueue[currentIndex];

          if (item) {
            item.currentAttempts += ATTEMPTS_INCREMENT_MAP[quality];
            item.qualityHistory.push(QUALITY_SCORE_MAP[quality]);

            if (item.currentAttempts >= item.requiredAttempts) {
              item.isCompleted = true;
            }

            item.timestamp = new Date().toISOString();
          }

          const completedCount = updatedQueue.filter(
            (it) => it.isCompleted
          ).length;

          set({
            queue: updatedQueue,
            completedCount,
          });

        } catch (e: any) {
          console.error('âŒ submitResult error:', e);
          set({
            error: e?.message ?? 'æäº¤å¤±è´¥',
          });
        }
      },

      // æäº¤å­—æ¯æ¨¡å—ä¸‰è½®è¯„ä¼°ç»“æœï¼ˆä»…è®°å½•ç»Ÿè®¡ä¿¡æ¯ï¼Œä¸å½±å“è®°å¿†ç®—æ³•ï¼‰
      submitRoundEvaluation: async ({
        userId,
        lessonId,
        roundNumber,
        totalQuestions,
        correctCount,
        accuracy,
      }) => {
        try {
          await callCloudFunction(
            'submitRoundEvaluation',
            {
              userId,
              entityType: 'letter',
              lessonId,
              roundNumber,
              totalQuestions,
              correctCount,
              accuracy,
            },
            {
              endpoint: API_ENDPOINTS.MEMORY.SUBMIT_ROUND_EVALUATION.cloudbase,
            },
          );
        } catch (e: any) {
          console.error('âŒ submitRoundEvaluation error:', e);
          // ä¸å½±å“å‰ç«¯æµç¨‹ï¼Œå‡ºé”™æ—¶åªè®°å½•æ—¥å¿—
        }
      },

      // ä¸‹ä¸€ä¸ªå­—æ¯
      next: () => {
        const { currentIndex, queue } = get();
        const nextIndex = currentIndex + 1;

        if (nextIndex < queue.length) {
          set({
            currentIndex: nextIndex,
            currentItem: queue[nextIndex],
          });
        } else {
          set({
            phase: LearningPhase.COMPLETED,
            currentItem: null,
          });
        }
      },

      // è¿½åŠ é˜Ÿåˆ—ï¼ˆç”¨äºé”™é¢˜å›é¡¾ç­‰åŠ¨æ€æ’å…¥ï¼‰
      appendQueue: (items: AlphabetQueueItem[]) => {
        const { queue, currentIndex } = get();
        const newQueue = [...queue, ...items];
        set({
          queue: newQueue,
          totalCount: newQueue.length,
          currentItem: newQueue[currentIndex] ?? null,
        });
      },

      // ä¸Šä¸€ä¸ªå­—æ¯ï¼ˆä¸»è¦ç”¨äºè°ƒè¯•æˆ–æŸäº› UIï¼‰
      previous: () => {
        const { currentIndex, queue } = get();
        const prevIndex = Math.max(0, currentIndex - 1);

        set({
          currentIndex: prevIndex,
          currentItem: queue[prevIndex] ?? null,
        });
      },

      // ğŸ”¥ Bug 3 ä¿®å¤ï¼šè®¾ç½®é˜Ÿåˆ—ä½ç½®
      setCurrentIndex: (index: number) => {
        const { queue } = get();
        set({
          currentIndex: index,
          currentItem: queue[index] ?? null,
        });
      },

      // ğŸ”¥ Bug 2 ä¿®å¤ï¼šè®¾ç½®å½“å‰è½®æ¬¡
      setCurrentRound: (round: 1 | 2 | 3) => {
        set({ currentRound: round });
      },

      // é‡ç½®ï¼ˆä¾‹å¦‚åˆ‡æ¢ç”¨æˆ·ï¼‰
      reset: () =>
        set({
          phase: LearningPhase.IDLE,
          queue: [],
          currentIndex: 0,
          currentItem: null,
          completedCount: 0,
          totalCount: 0,
          isLoading: false,
          error: null,
          cachedAudioKeys: [],
        }),

      clearError: () => set({ error: null }),
    }),
    {
      name: 'alphabet-storage',
      storage: createJSONStorage(() => AsyncStorage),
      // åªæŒä¹…åŒ–ç»Ÿè®¡æ•°æ®ï¼Œé˜Ÿåˆ—ä¿æŒä¼šè¯çº§åˆ«
      partialize: (state) => ({
        completedCount: state.completedCount,
        totalCount: state.totalCount,
        cachedAudioKeys: state.cachedAudioKeys,
      }),
    }
  )
);

// ==================== ä¸€äº›ä¾¿æ· Hooks ====================

export const useAlphabetProgress = () => {
  const { completedCount, totalCount } = useAlphabetStore();
  if (!totalCount) return 0;
  return (completedCount / totalCount) * 100;
};

export const useCurrentAlphabet = () =>
  useAlphabetStore((s) => s.currentItem);

export const useAlphabetPhase = () => useAlphabetStore((s) => s.phase);
</file>

<file path="package.json">
{
  "name": "thailearningapp",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo-google-fonts/noto-serif-sc": "^0.4.2",
    "@expo-google-fonts/playfair-display": "^0.4.2",
    "@expo-google-fonts/sarabun": "^0.4.1",
    "@expo/cli": "^54.0.18",
    "@expo/vector-icons": "15.0.3",
    "@react-native-async-storage/async-storage": "2.2.0",
    "@react-native-community/slider": "5.0.1",
    "axios": "^1.13.2",
    "expo": "54.0.27",
    "expo-asset": "12.0.11",
    "expo-av": "16.0.8",
    "expo-blur": "15.0.8",
    "expo-constants": "18.0.11",
    "expo-file-system": "19.0.20",
    "expo-font": "14.0.10",
    "expo-linear-gradient": "15.0.8",
    "expo-linking": "8.0.10",
    "expo-localization": "17.0.8",
    "expo-router": "6.0.17",
    "expo-splash-screen": "31.0.12",
    "expo-status-bar": "3.0.9",
    "i18next": "^25.6.3",
    "lucide-react-native": "^0.554.0",
    "react": "19.1.0",
    "react-i18next": "^16.3.4",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-linear-gradient": "^2.8.3",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "5.6.2",
    "react-native-screens": "~4.16.0",
    "react-native-svg": "15.12.1",
    "react-native-worklets": "0.5.1",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "@testing-library/react-native": "^13.0.0",
    "@types/react": "~19.1.10",
    "@types/react-native": "^0.72.8",
    "babel-plugin-module-resolver": "^5.0.2",
    "react-test-renderer": "^19.2.1",
    "typescript": "^5.1.3"
  },
  "private": true
}
</file>

</files>
````

## File: app/(dev)/_layout.tsx
````typescript
import { Stack } from 'expo-router';
import React from 'react';
import { View, Text } from 'react-native';

export default function DevLayout() {
    // ğŸ›¡ï¸ æ ¸å¿ƒå®‰å…¨ç½‘ï¼šç”Ÿäº§ç¯å¢ƒç›´æ¥è¿”å› nullï¼Œç¡®ä¿è·¯ç”±ä¸å¯è¾¾
    if (!__DEV__) {
        return null;
    }

    return (
        <Stack
            screenOptions={{
                headerStyle: {
                    backgroundColor: '#F5F5F5',
                },
                headerTintColor: '#333',
                headerTitleStyle: {
                    fontWeight: 'bold',
                },
            }}
        >
            <Stack.Screen
                name="playground"
                options={{
                    title: 'ğŸ› ï¸ Playground',
                    headerLargeTitle: true,
                }}
            />
            <Stack.Screen
                name="viewer"
                options={{
                    title: 'Component Viewer',
                    presentation: 'modal', // æ¨¡æ€å±•ç¤ºæ„Ÿè§‰æ›´åƒç‹¬ç«‹çš„ Debug ç¯å¢ƒ
                }}
            />
        </Stack>
    );
}
````

## File: app/(dev)/playground.tsx
````typescript
import React from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import { useRouter } from 'expo-router';
import { COMPONENT_REGISTRY } from '@/src/dev/registry';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { ChevronRight, FlaskConical, ChevronLeft } from 'lucide-react-native';

export default function PlaygroundScreen() {
    const router = useRouter();

    if (!__DEV__) return null;

    return (
        <ScrollView style={styles.container} contentContainerStyle={styles.content}>
            <View style={styles.header}>
                <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 12 }}>
                    <TouchableOpacity
                        onPress={() => router.back()}
                        style={{ marginRight: 12, padding: 4 }}
                    >
                        <ChevronLeft size={24} color={Colors.ink} />
                    </TouchableOpacity>
                    <Text style={{ fontFamily: Typography.notoSerifBold, fontSize: 24, color: Colors.ink }}>
                        Dev Playground
                    </Text>
                </View>
                <Text style={styles.description}>
                    UI ç»„ä»¶éš”ç¦»å¼€å‘ç¯å¢ƒã€‚æ­¤å¤„åˆ—å‡ºçš„ç»„ä»¶ä½¿ç”¨ Mock æ•°æ®ç‹¬ç«‹è¿è¡Œï¼Œä¸è§¦å‘çœŸå®ä¸šåŠ¡é€»è¾‘ã€‚
                </Text>
            </View>

            {COMPONENT_REGISTRY.map((component) => (
                <View key={component.id} style={styles.section}>
                    <View style={styles.sectionHeader}>
                        <Text style={styles.sectionTitle}>{component.name}</Text>
                        <Text style={styles.categoryBadge}>{component.category}</Text>
                    </View>

                    <View style={styles.card}>
                        {component.variants.map((variant, index) => (
                            <TouchableOpacity
                                key={variant.id}
                                style={[
                                    styles.item,
                                    index < component.variants.length - 1 && styles.borderBottom,
                                ]}
                                onPress={() => {
                                    router.push({
                                        pathname: '/(dev)/viewer',
                                        params: {
                                            componentId: component.id,
                                            variantId: variant.id,
                                            mockId: variant.mockId,
                                        },
                                    });
                                }}
                            >
                                <View style={styles.itemIcon}>
                                    <FlaskConical size={16} color={Colors.thaiGold} />
                                </View>
                                <Text style={styles.itemText}>{variant.name}</Text>
                                <ChevronRight size={16} color={Colors.taupe} />
                            </TouchableOpacity>
                        ))}
                    </View>
                </View>
            ))}
        </ScrollView>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#F2F2F7', // iOS Grouped Background color
    },
    content: {
        padding: 16,
        paddingBottom: 40,
    },
    header: {
        marginBottom: 24,
    },
    description: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.taupe,
        lineHeight: 20,
    },
    section: {
        marginBottom: 24,
    },
    sectionHeader: {
        flexDirection: 'row',
        alignItems: 'center',
        marginBottom: 8,
        paddingHorizontal: 4,
        justifyContent: 'space-between',
    },
    sectionTitle: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 13,
        color: '#666',
        textTransform: 'uppercase',
    },
    categoryBadge: {
        fontSize: 10,
        color: Colors.white,
        backgroundColor: Colors.taupe,
        paddingHorizontal: 6,
        paddingVertical: 2,
        borderRadius: 4,
        overflow: 'hidden',
    },
    card: {
        backgroundColor: Colors.white,
        borderRadius: 10,
        overflow: 'hidden',
    },
    item: {
        flexDirection: 'row',
        alignItems: 'center',
        padding: 16,
        backgroundColor: Colors.white,
    },
    borderBottom: {
        borderBottomWidth: StyleSheet.hairlineWidth,
        borderBottomColor: '#C6C6C8',
        marginLeft: 16, // iOS style separator inset
    },
    itemIcon: {
        marginRight: 12,
    },
    itemText: {
        flex: 1,
        fontFamily: Typography.notoSerifRegular,
        fontSize: 16,
        color: Colors.ink,
    },
});
````

## File: app/(dev)/viewer.tsx
````typescript
import React from 'react';
import { View, Text, StyleSheet, SafeAreaView, ScrollView } from 'react-native';
import { useLocalSearchParams } from 'expo-router';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

// Components
import { PhonicsRuleCard } from '@/src/components/learning/alphabet/PhonicsRuleCard';

// Mocks
import { MOCK_PHONICS_RULES } from '@/src/dev/mocks/phonicsRule.mock';

export default function ComponentViewer() {
    const { componentId, variantId, mockId } = useLocalSearchParams<{
        componentId: string;
        variantId: string;
        mockId: string;
    }>();

    if (!__DEV__) return null;

    const renderContent = () => {
        switch (componentId) {
            case 'PhonicsRuleCard': {
                const rule = MOCK_PHONICS_RULES[mockId];
                if (!rule) return <ErrorState message={`Mock ID not found: ${mockId}`} />;

                return (
                    <PhonicsRuleCard
                        rule={rule}
                        onComplete={() => console.log('âœ… [Dev] onComplete triggered')}
                        showCloseButton={true}
                        onClose={() => console.log('âŒ [Dev] onClose triggered')}
                    />
                );
            }
            default:
                return <ErrorState message={`Component ID not found: ${componentId}`} />;
        }
    };

    return (
        <View style={styles.container}>
            {/* å±…ä¸­å®¹å™¨ï¼Œæ¨¡æ‹Ÿ Modal æ•ˆæœ */}
            <View style={styles.stage}>
                {renderContent()}
            </View>

            <View style={styles.debugPanel}>
                <Text style={styles.debugText}>Component: {componentId}</Text>
                <Text style={styles.debugText}>Variant: {variantId}</Text>
                <Text style={styles.debugText}>Mock Data: {mockId}</Text>
            </View>
        </View>
    );
}

function ErrorState({ message }: { message: string }) {
    return (
        <View style={styles.errorContainer}>
            <Text style={styles.errorText}>{message}</Text>
        </View>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#333', // æ·±è‰²èƒŒæ™¯çªå‡ºç»„ä»¶
    },
    stage: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
    },
    debugPanel: {
        backgroundColor: '#000',
        padding: 12,
        borderTopWidth: 1,
        borderTopColor: '#444',
    },
    debugText: {
        color: '#0F0',
        fontFamily: 'Menlo',
        fontSize: 12,
        marginBottom: 4,
    },
    errorContainer: {
        padding: 20,
        backgroundColor: Colors.error,
        borderRadius: 8,
    },
    errorText: {
        color: Colors.white,
        fontFamily: Typography.notoSerifBold,
    },
});
````

## File: app/learning/_layout.tsx
````typescript
import { Stack } from "expo-router";

export default function LearningLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }} />
  );
}
````

## File: cloudbase/functions/alphabet/handlers/getAllLetters.js
````javascript
// âœ… è·å–æ‰€æœ‰å­—æ¯ï¼ˆç”¨äºå‰ç«¯ç”Ÿæˆæµ‹è¯•é¢˜ï¼‰
const { createResponse } = require('../utils/response');

/**
 * è·å–æ‰€æœ‰å­—æ¯æ•°æ®
 * @param {Object} db - æ•°æ®åº“å®ä¾‹
 * @returns {Promise} è¿”å›æ‰€æœ‰å­—æ¯æ•°æ®
 */
async function getAllLetters(db) {
    try {
        // ä» letters é›†åˆè·å–æ‰€æœ‰å­—æ¯
        const res = await db.collection('letters')
            .limit(1000) // è®¾ç½®ä¸€ä¸ªè¶³å¤Ÿå¤§çš„é™åˆ¶ï¼ˆå­—æ¯æ€»æ•°çº¦ 80 ä¸ªï¼‰
            .get();

        return createResponse(true, {
            total: res.data.length,
            letters: res.data
        }, 'è·å–å­—æ¯æˆåŠŸ');
    } catch (error) {
        console.error('[getAllLetters] æŸ¥è¯¢å¤±è´¥:', error);
        return createResponse(false, null, 'è·å–å­—æ¯å¤±è´¥', 'DB_ERROR');
    }
}

module.exports = getAllLetters;
````

## File: cloudbase/functions/alphabet/utils/database.js
````javascript
const cloud = require('wx-server-sdk');

cloud.init({
    env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();
const _ = db.command;

const collections = {
    users: db.collection('users'),
    vocabulary: db.collection('vocabulary'),
    letters: db.collection('letters'),
    sentences: db.collection('sentences'),
    memory_status: db.collection('memory_status'),
    user_progress: db.collection('user_progress'),
    user_vocabulary_progress: db.collection('user_vocabulary_progress')
};

module.exports = {
    db,
    _,
    userCollection: collections.users,
    vocabularyCollection: collections.vocabulary,
    letterCollection: collections.letters,
    sentenceCollection: collections.sentences,
    memoryStatusCollection: collections.memory_status,
    userProgressCollection: collections.user_progress,
    progressCollection: collections.user_vocabulary_progress,
    collections
};
````

## File: cloudbase/functions/alphabet/utils/index.js
````javascript
/**
 * Shared Utilities Package Entry Point
 * 
 * ç»Ÿä¸€å¯¼å‡ºæ‰€æœ‰å…±äº«æ¨¡å—
 * ä½¿ç”¨æ–¹å¼: const { response, constants, sm2 } = require('@thai-app/shared');
 */

'use strict';

module.exports = {
    // å“åº”æ ¼å¼åŒ–æ¨¡å—
    response: require('./response'),

    // å¸¸é‡å®šä¹‰æ¨¡å—
    constants: require('./constants'),

    // SM-2 ç®—æ³•æ¨¡å—
    sm2: require('./sm2'),

    // å‚æ•°éªŒè¯æ¨¡å—
    validators: require('./validators'),

    // ç»Ÿä¸€è®°å¿†å¼•æ“æ¨¡å—
    memoryEngine: require('./memoryEngine'),

    // æ•°æ®åº“è¿æ¥æ¨¡å—
    database: require('./database')
};
````

## File: cloudbase/functions/alphabet/utils/sm2.js
````javascript
/**
 * SM-2 é—´éš”é‡å¤ç®—æ³•æ¨¡å—ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
 * 
 * åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–:
 * - æ—©æœŸå¤ä¹ é—´éš”æ›´å¯†é›†: 1â†’2â†’4â†’7â†’14 å¤©
 * - "æ¨¡ç³Š"çŠ¶æ€ç¼©çŸ­é—´éš”è€Œéç»´æŒä¸å˜
 * - "é™Œç”Ÿ"çŠ¶æ€é‡ç½®å¤ä¹ è¿›åº¦
 * 
 * ç®—æ³•è®ºæ–‡: https://www.supermemo.com/en/archives1990-2015/english/ol/sm2
 */

'use strict';

const { MasteryLevel, SM2_PARAMS, EARLY_INTERVALS } = require('./constants');

/**
 * å°†æŒæ¡ç¨‹åº¦æ˜ å°„åˆ° SM-2 Quality å€¼
 * 
 * SM-2 Quality å®šä¹‰:
 * 0 - å®Œå…¨ä¸è®°å¾—
 * 1 - é”™è¯¯å›ç­”ï¼Œä½†çœ‹åˆ°æ­£ç¡®ç­”æ¡ˆåæƒ³èµ·
 * 2 - é”™è¯¯å›ç­”ï¼Œæ­£ç¡®ç­”æ¡ˆçœ‹èµ·æ¥å¾ˆç†Ÿæ‚‰
 * 3 - æ­£ç¡®å›ç­”ï¼Œä½†å›°éš¾è¾ƒå¤§
 * 4 - æ­£ç¡®å›ç­”ï¼Œæœ‰äº›çŠ¹è±«
 * 5 - æ­£ç¡®å›ç­”ï¼Œæ¯«æ— å›°éš¾
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦
 * @returns {number} Qualityå€¼ (1-5)
 */
function masteryToQuality(mastery) {
    switch (mastery) {
        case MasteryLevel.UNFAMILIAR:
            return 1;  // å®Œå…¨ä¸è®°å¾—
        case MasteryLevel.FUZZY:
            return 3;  // æœ‰å°è±¡ä½†ä¸ç¡®å®š
        case MasteryLevel.REMEMBERED:
            return 5;  // å®Œå…¨è®°å¾—
        default:
            return 1;
    }
}

/**
 * è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸï¼ˆä¼˜åŒ–ç‰ˆ SM-2 ç®—æ³•ï¼‰
 * 
 * æ”¹è¿›ç‚¹:
 * 1. æ—©æœŸé˜¶æ®µï¼ˆå‰5æ¬¡ï¼‰ä½¿ç”¨å›ºå®šçš„æ¸è¿›é—´éš” [1,2,4,7,14]
 * 2. "æ¨¡ç³Š"æ—¶ç¼©çŸ­é—´éš”è€Œéç»´æŒä¸å˜
 * 3. "é™Œç”Ÿ"æ—¶å®Œå…¨é‡ç½®å¤ä¹ è¿›åº¦
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦: å¿˜è®°/æ¨¡ç³Š/è®¤è¯†
 * @param {number} currentInterval - å½“å‰å¤ä¹ é—´éš”ï¼ˆå¤©ï¼‰
 * @param {number} easinessFactor - ç®€æ˜“åº¦å› å­ï¼ˆ1.3-2.5+ï¼‰
 * @param {number} reviewCount - å·²å¤ä¹ æ¬¡æ•°
 * @returns {Object} ç®—æ³•è®¡ç®—ç»“æœ
 * 
 * @example
 * const result = calculateSM2Optimized('è®¤è¯†', 2, 2.5, 1);
 * // {
 * //   nextInterval: 4,
 * //   nextEasinessFactor: 2.6,
 * //   nextReviewDate: "2025-12-01T10:00:00Z",
 * //   shouldResetCount: false
 * // }
 * */
function calculateSM2Optimized(
    mastery,
    currentInterval = 1,
    easinessFactor = SM2_PARAMS.INITIAL_EASINESS_FACTOR,
    reviewCount = 0
) {
    let nextInterval = currentInterval;
    let nextEF = easinessFactor;
    let shouldResetCount = false;

    const quality = masteryToQuality(mastery);

    // ==================== æ ¸å¿ƒç®—æ³•é€»è¾‘ ====================

    if (quality < 3) {
        // ========== å¿˜è®°: å®Œå…¨é‡ç½® ==========
        // ç”¨æˆ·å®Œå…¨ä¸è®°å¾—ï¼Œéœ€è¦ä»å¤´å¼€å§‹å­¦ä¹ 
        nextInterval = 1;
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF - 0.2);
        shouldResetCount = true;

    } else if (quality === 3) {
        // ========== æ¨¡ç³Š: ç¼©çŸ­é—´éš”ï¼ŒåŠ å¼ºå¤ä¹  ==========
        // æ”¹è¿›: ä¸æ˜¯ç»´æŒä¸å˜ï¼Œè€Œæ˜¯ç¼©çŸ­20%
        nextInterval = Math.max(1, Math.round(currentInterval * SM2_PARAMS.FUZZY_MULTIPLIER));
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF - 0.1);

    } else {
        // ========== è®°å¾—: ä½¿ç”¨ä¼˜åŒ–çš„é—´éš”åºåˆ— ==========
        if (reviewCount < EARLY_INTERVALS.length) {
            // æ—©æœŸé˜¶æ®µ: ä½¿ç”¨é¢„å®šä¹‰çš„æ¸è¿›é—´éš”
            // è¿™æ˜¯å…³é”®æ”¹è¿›: 1â†’2â†’4â†’7â†’14 è€ŒéåŸç‰ˆçš„ 1â†’6
            nextInterval = EARLY_INTERVALS[reviewCount];
        } else {
            // åæœŸé˜¶æ®µ: ä½¿ç”¨ EF è®¡ç®—æŒ‡æ•°å¢é•¿
            nextInterval = Math.round(currentInterval * nextEF);
        }

        // æé«˜ç®€æ˜“åº¦ (æ ‡å‡† SM-2 å…¬å¼)
        nextEF = nextEF + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF);
    }

    // é™åˆ¶æœ€å¤§é—´éš”
    nextInterval = Math.min(nextInterval, SM2_PARAMS.MAX_INTERVAL_DAYS);

    // è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸ
    const nextReviewDate = new Date();
    nextReviewDate.setDate(nextReviewDate.getDate() + nextInterval);

    // è®¡ç®—æ–°çš„å¤ä¹ æ¬¡æ•°
    const newRepetitions = shouldResetCount ? 0 : reviewCount + 1;

    return {
        // === å…¼å®¹ memoryEngine.js çš„æ—§æ¥å£ ===
        interval: nextInterval,
        easinessFactor: parseFloat(nextEF.toFixed(2)),
        repetitions: newRepetitions,

        // === æ–°æ¥å£ï¼ˆä¿ç•™ä¾›æœªæ¥ä½¿ç”¨ï¼‰===
        nextInterval,
        nextEasinessFactor: parseFloat(nextEF.toFixed(2)),
        nextReviewDate: nextReviewDate.toISOString(),
        shouldResetCount,
    };
}

/**
 * ç”Ÿæˆé¢„è®¡å¤ä¹ æ—¶é—´çº¿
 * 
 * ç”¨äºå‰ç«¯å±•ç¤ºæœªæ¥çš„å¤ä¹ è®¡åˆ’
 * 
 * @param {number} currentReviewCount - å½“å‰å¤ä¹ æ¬¡æ•°
 * @param {number} maxItems - è¿”å›çš„æ—¶é—´çº¿é¡¹æ•° (é»˜è®¤5)
 * @returns {Array} æœªæ¥å¤ä¹ è®¡åˆ’
 * 
 * @example
 * generateReviewTimeline(2);
 * // [
 * //   { reviewNumber: 3, intervalDays: 4 },
 * //   { reviewNumber: 4, intervalDays: 7 },
 * //   { reviewNumber: 5, intervalDays: 14 },
 * //   ...
 * // ]
 */
function generateReviewTimeline(currentReviewCount, maxItems = 5) {
    const timeline = [];
    let interval = 1;
    let ef = SM2_PARAMS.INITIAL_EASINESS_FACTOR;

    for (let i = currentReviewCount; i < currentReviewCount + maxItems; i++) {
        if (i < EARLY_INTERVALS.length) {
            interval = EARLY_INTERVALS[i];
        } else {
            interval = Math.round(interval * ef);
        }
        interval = Math.min(interval, SM2_PARAMS.MAX_INTERVAL_DAYS);

        timeline.push({
            reviewNumber: i + 1,
            intervalDays: interval,
        });
    }

    return timeline;
}

/**
 * è·å–ä»Šå¤©çš„æ—¶é—´èŒƒå›´ (UTC)
 * 
 * @returns {Object} { startOfDay, endOfDay, timestamp }
 */
function getTodayRange() {
    const now = new Date();
    const startOfDay = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate(),
        0, 0, 0, 0
    ));
    const endOfDay = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate() + 1,
        0, 0, 0, 0
    ));

    return {
        startOfDay: startOfDay.toISOString(),
        endOfDay: endOfDay.toISOString(),
        timestamp: now.toISOString(),
    };
}

/**
 * è·å–ç®—æ³•ä¿¡æ¯ (ç”¨äºå‰ç«¯å±•ç¤º)
 * 
 * @returns {Object} ç®—æ³•å…ƒä¿¡æ¯
 */
function getAlgorithmInfo() {
    return {
        name: 'Optimized SM-2',
        version: '1.1.0',
        earlyIntervals: EARLY_INTERVALS,
        maxInterval: SM2_PARAMS.MAX_INTERVAL_DAYS,
        description: 'åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–çš„é—´éš”é‡å¤ç®—æ³•',
    };
}

module.exports = {
    calculateSM2Optimized,
    generateReviewTimeline,
    getTodayRange,
    getAlgorithmInfo,
    masteryToQuality,
};
````

## File: cloudbase/functions/alphabet/utils/validators.js
````javascript
/**
 * å‚æ•°éªŒè¯æ¨¡å—
 * 
 * ç”¨æˆ·ã€è¯æ±‡éªŒè¯åŠé€šç”¨éªŒè¯å·¥å…·
 */

'use strict';

const { userCollection, vocabularyCollection } = require('./database');
const { MasteryLevel } = require('./constants');

/**
 * éªŒè¯ç”¨æˆ·æ˜¯å¦å­˜åœ¨
 * 
 * @param {string} userId - ç”¨æˆ·ID
 * @returns {Promise<Object|null>} ç”¨æˆ·å¯¹è±¡æˆ– null
 */
async function validateUser(userId) {
    if (!userId || typeof userId !== 'string') {
        return null;
    }

    try {
        const { data } = await userCollection
            .where({ userId })
            .limit(1)
            .get();

        return data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('[validateUser] Error:', error);
        return null;
    }
}

/**
 * éªŒè¯è¯æ±‡æ˜¯å¦å­˜åœ¨
 * 
 * @param {string} vocabularyId - è¯æ±‡ID
 * @returns {Promise<Object|null>} è¯æ±‡å¯¹è±¡æˆ– null
 */
async function validateVocabulary(vocabularyId) {
    if (!vocabularyId || typeof vocabularyId !== 'string') {
        return null;
    }

    try {
        const { data } = await vocabularyCollection
            .where({ vocabularyId })
            .limit(1)
            .get();

        return data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('[validateVocabulary] Error:', error);
        return null;
    }
}

/**
 * éªŒè¯æŒæ¡ç¨‹åº¦æ˜¯å¦æœ‰æ•ˆ
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦
 * @returns {boolean} æ˜¯å¦æœ‰æ•ˆ
 */
function isValidMastery(mastery) {
    const validValues = Object.values(MasteryLevel);
    return validValues.includes(mastery);
}

/**
 * éªŒè¯å¹¶è§„èŒƒåŒ–åˆ†é¡µå‚æ•°
 * 
 * @param {number} limit - é™åˆ¶æ•°é‡
 * @param {number} offset - åç§»é‡
 * @param {number} maxLimit - æœ€å¤§é™åˆ¶ (é»˜è®¤100)
 * @returns {Object} éªŒè¯åçš„åˆ†é¡µå‚æ•°
 */
function validatePagination(limit, offset, maxLimit = 100) {
    return {
        limit: Math.min(Math.max(1, parseInt(limit) || 20), maxLimit),
        offset: Math.max(0, parseInt(offset) || 0),
    };
}

/**
 * éªŒè¯å¿…å¡«å­—ç¬¦ä¸²å‚æ•°
 * 
 * @param {string} value - å‚æ•°å€¼
 * @param {string} name - å‚æ•°å (ç”¨äºé”™è¯¯æ¶ˆæ¯)
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateRequiredString(value, name) {
    if (!value || typeof value !== 'string' || value.trim() === '') {
        return {
            valid: false,
            error: `${name} æ˜¯å¿…å¡«å‚æ•°ä¸”ä¸èƒ½ä¸ºç©º`,
        };
    }
    return { valid: true };
}

/**
 * éªŒè¯å¸ƒå°”å‚æ•°
 * 
 * @param {any} value - å‚æ•°å€¼
 * @param {string} name - å‚æ•°å
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateBoolean(value, name) {
    if (typeof value !== 'boolean') {
        return {
            valid: false,
            error: `${name} å¿…é¡»æ˜¯å¸ƒå°”å€¼`,
        };
    }
    return { valid: true };
}
/**
 * é€šç”¨å‚æ•°éªŒè¯å‡½æ•°
 * 
 * @param {Object} params - éœ€è¦éªŒè¯çš„å‚æ•°å¯¹è±¡
 * @param {Array<string>} requiredFields - å¿…éœ€å­—æ®µåˆ—è¡¨
 * @returns {Object} { isValid: boolean, message?: string }
 */
function validateParams(params, requiredFields) {
    const missing = [];

    for (const field of requiredFields) {
        if (params[field] === undefined || params[field] === null || params[field] === '') {
            missing.push(field);
        }
    }

    if (missing.length > 0) {
        return {
            isValid: false,
            message: `ç¼ºå°‘å¿…å¡«å‚æ•°: ${missing.join(', ')}`
        };
    }

    return { isValid: true };
}

module.exports = {
    validateUser,
    validateVocabulary,
    isValidMastery,
    validatePagination,
    validateRequiredString,
    validateBoolean,
    validateParams,
};
````

## File: cloudbase/functions/learn-vocab/utils/index.js
````javascript
/**
 * Shared Utilities Package Entry Point
 * 
 * ç»Ÿä¸€å¯¼å‡ºæ‰€æœ‰å…±äº«æ¨¡å—
 * ä½¿ç”¨æ–¹å¼: const { response, constants, sm2 } = require('@thai-app/shared');
 */

'use strict';

module.exports = {
    // å“åº”æ ¼å¼åŒ–æ¨¡å—
    response: require('./response'),

    // å¸¸é‡å®šä¹‰æ¨¡å—
    constants: require('./constants'),

    // SM-2 ç®—æ³•æ¨¡å—
    sm2: require('./sm2'),

    // å‚æ•°éªŒè¯æ¨¡å—
    validators: require('./validators'),

    // ç»Ÿä¸€è®°å¿†å¼•æ“æ¨¡å—
    memoryEngine: require('./memoryEngine'),

    // æ•°æ®åº“è¿æ¥æ¨¡å—
    database: require('./database')
};
````

## File: cloudbase/functions/memory-engine/config/alphabetLessonConfig.js
````javascript
'use strict';

/**
 * Alphabet lesson & phonics rule config for backend.
 *
 * æ³¨æ„ï¼š
 * - LESSON_METADATA / PHONICS_RULES ä½œä¸ºæœ¬åœ° fallbackï¼›
 * - ä¼˜å…ˆä» DB é›†åˆ alphabet_lessons / phonics_rules ä¸­è¯»å–ï¼Œ
 *   è¯»ä¸åˆ°æˆ–å‡ºé”™æ—¶å†é€€å›æœ¬åœ°å¸¸é‡ï¼Œé¿å…å‰åç«¯æ•°æ®æ¼‚ç§»ã€‚
 */

// ==================== Lesson Metadata (7 è¯¾) - æœ¬åœ°å¤‡ä»½ ====================

const LESSON_METADATA = {
  lesson1: {
    lessonId: 'lesson1',
    title: 'ç¬¬ä¸€è¯¾:åŸºç¡€æ‹¼è¯»èƒ½åŠ›',
    description: 'æŒæ¡æœ€åŸºç¡€çš„ä¸­è¾…éŸ³å’Œå¸¸è§å…ƒéŸ³,å»ºç«‹CVæ‹¼è¯»æ¦‚å¿µ',
    consonants: ['à¸', 'à¸”', 'à¸•', 'à¸™', 'à¸¡'],
    vowels: ['à¸²', 'à¸°', 'à¸´'],
    tones: [],
    phonicsRuleId: 'rule_1_cv_structure',
    totalCount: 8,
    minPassRate: 0.95,
    miniReviewInterval: 3,
    order: 1,
  },

  lesson2: {
    lessonId: 'lesson2',
    title: 'ç¬¬äºŒè¯¾:å‰ç½®å…ƒéŸ³ç³»ç»Ÿ',
    description: 'å­¦ä¹ å‰ç½®å…ƒéŸ³(à¹€ à¹ à¹‚)å’Œæ›´å¤šé«˜é¢‘è¾…éŸ³',
    consonants: ['à¸š', 'à¸›', 'à¸£', 'à¸¥', 'à¸§', 'à¸¢'],
    vowels: ['à¹€', 'à¹', 'à¹‚', 'à¸­'],
    tones: [],
    phonicsRuleId: 'rule_2_leading_vowel',
    totalCount: 10,
    minPassRate: 0.9,
    miniReviewInterval: 3,
    order: 2,
  },

  lesson3: {
    lessonId: 'lesson3',
    title: 'ç¬¬ä¸‰è¯¾:å£°è°ƒå…¥é—¨',
    description: 'æŒæ¡é€æ°”/ä¸é€æ°”å¯¹æ¯”,å¼•å…¥åŸºç¡€å£°è°ƒç³»ç»Ÿ',
    consonants: ['à¸‚', 'à¸–', 'à¸œ', 'à¸ª', 'à¸«'],
    vowels: ['à¸°', 'à¸¸', 'à¸¹'],
    tones: ['à¹ˆ', 'à¹‰'],
    phonicsRuleId: 'rule_3_tone_basics',
    totalCount: 10,
    minPassRate: 0.9,
    miniReviewInterval: 3,
    order: 3,
  },

  lesson4: {
    lessonId: 'lesson4',
    title: 'ç¬¬å››è¯¾:è¾…éŸ³ç±»ä¸å£°è°ƒ',
    description: 'ç†è§£é«˜/ä¸­/ä½è¾…éŸ³å¯¹å£°è°ƒçš„å½±å“,æŒæ¡å®Œæ•´å£°è°ƒç³»ç»Ÿ',
    consonants: ['à¸„', 'à¸—', 'à¸', 'à¸Š', 'à¸ˆ', 'à¸‡'],
    vowels: ['à¹„', 'à¹ƒ', 'à¹€à¸­à¸²', 'à¸­à¸³'],
    tones: ['à¹Š', 'à¹‹'],
    phonicsRuleId: 'rule_4_consonant_class_tones',
    totalCount: 12,
    minPassRate: 0.85,
    miniReviewInterval: 3,
    order: 4,
  },

  lesson5: {
    lessonId: 'lesson5',
    title: 'ç¬¬äº”è¯¾:å¤åˆå…ƒéŸ³ç³»ç»Ÿ',
    description: 'æŒæ¡ä¸‰åˆå…ƒéŸ³(à¹€à¸­à¸µà¸¢ à¹€à¸­à¸·à¸­ à¸­à¸±à¸§)ç­‰å¤æ‚å…ƒéŸ³ç»„åˆ',
    consonants: ['à¸‹', 'à¸‰', 'à¸', 'à¸Ÿ', 'à¸¨', 'à¸©', 'à¸®', 'à¸­'],
    vowels: ['à¹€à¸­à¸µà¸¢', 'à¹€à¸­à¸·à¸­', 'à¸­à¸±à¸§', 'à¹€à¸­à¸­', 'à¸·', 'à¸¶'],
    tones: [],
    phonicsRuleId: 'rule_5_compound_vowels',
    totalCount: 14,
    minPassRate: 0.85,
    miniReviewInterval: 3,
    order: 5,
  },

  lesson6: {
    lessonId: 'lesson6',
    title: 'ç¬¬å…­è¯¾:å®Œæ•´è¦†ç›–(å¸¸ç”¨è¿›é˜¶)',
    description: 'è¡¥å……å¸¸ç”¨è¿›é˜¶è¾…éŸ³ä¸å¤åˆå…ƒéŸ³,æŒæ¡ç‰¹æ®Šè§„åˆ™(å¦‚ à¸« à¸™à¸³ ç­‰)',
    consonants: ['à¸‘', 'à¸’', 'à¸“', 'à¸ ', 'à¸˜', 'à¸Œ', 'à¸', 'à¸¬', 'à¸', 'à¸', 'à¸'],
    vowels: ['à¸­à¸²à¸¢', 'à¸­à¸¸à¸¢', 'à¹€à¸­à¸¢', 'à¹‚à¸­à¸¢', 'à¸­à¸­à¸¢'],
    tones: [],
    phonicsRuleId: 'rule_6_special_cases',
    totalCount: 19,
    minPassRate: 0.9,
    miniReviewInterval: 4,
    order: 6,
  },

  lesson7: {
    lessonId: 'lesson7',
    title: 'ç¬¬ä¸ƒè¯¾:ç½•ç”¨å­—æ¯ä¸ç‰¹æ®Šå…ƒéŸ³',
    description: 'é›†ä¸­å­¦ä¹ ç°ä»£æ³°è¯­ä¸­è¾ƒå°‘ä½¿ç”¨çš„è¾…éŸ³ä¸å¤æ‚å…ƒéŸ³,ç”¨äºé˜…è¯»å¤æ–‡ä¸ç‰¹æ®Šä¸“æœ‰åè¯',
    consonants: ['à¸ƒ', 'à¸…'],
    vowels: ['à¸¤', 'à¸¤à¹…', 'à¸¦', 'à¸¦à¹…', 'à¹à¸­à¸°', 'à¹‚à¸­à¸°', 'à¹€à¸­à¸°', 'à¹€à¸­à¸²à¸°'],
    tones: [],
    phonicsRuleId: 'rule_6_special_cases',
    totalCount: 10,
    minPassRate: 0.8,
    miniReviewInterval: 4,
    order: 7,
  },
};

// ==================== Phonics Rules (6 æ¡) - æœ¬åœ°å¤‡ä»½ ====================

const PHONICS_RULES = {
  rule_1_cv_structure: {
    id: 'rule_1_cv_structure',
    lessonId: 'lesson1',
    title: 'æ‹¼è¯»è§„åˆ™ 1: è¾…éŸ³+å…ƒéŸ³',
    content: [
      'âœ… æ³°è¯­éŸ³èŠ‚ = è¾…éŸ³(C) + å…ƒéŸ³(V)',
      'âœ… å…ƒéŸ³å¯åœ¨è¾…éŸ³å‰/å/ä¸Š/ä¸‹',
      'âœ… ä¾‹: à¸ + à¸² = à¸à¸² [ka:] (ä¹Œé¸¦)',
      '',
      'ğŸ¯ è®°å¿†å£è¯€: å…ˆè¯»è¾…éŸ³,å†è¯»å…ƒéŸ³',
    ],
    interactiveExample: {
      consonant: 'à¸',
      vowel: 'à¸²',
      syllable: 'à¸à¸²',
      pronunciation: 'ka:',
      audioUrl:
        'https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/word-ka.mp3',
    },
    duration: 30,
    order: 1,
  },

  rule_2_leading_vowel: {
    id: 'rule_2_leading_vowel',
    lessonId: 'lesson2',
    title: 'æ‹¼è¯»è§„åˆ™ 2: å‰ç½®å…ƒéŸ³',
    content: [
      'âš ï¸ å†™åœ¨è¾…éŸ³å‰,è¯»åœ¨è¾…éŸ³å',
      '',
      'âœ… à¹€à¸ = [ke:] ä¸æ˜¯ [ek]',
      'âœ… à¹à¸¡ = [mÉ›:] ä¸æ˜¯ [É›m]',
      'âœ… à¹‚à¸£ = [ro:] ä¸æ˜¯ [or]',
      '',
      'ğŸ¯ è®°å¿†å£è¯€: çœ‹åˆ° à¹€ à¹ à¹‚,å…ˆè¯»è¾…éŸ³å†è¯»å…ƒéŸ³',
    ],
    interactiveExample: {
      consonant: 'à¸',
      vowel: 'à¹€',
      syllable: 'à¹€à¸',
      pronunciation: 'ke:',
      audioUrl:
        'https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/syllable-ke.mp3',
    },
    duration: 30,
    order: 2,
  },

  rule_3_tone_basics: {
    id: 'rule_3_tone_basics',
    lessonId: 'lesson3',
    title: 'æ‹¼è¯»è§„åˆ™ 3: å£°è°ƒå…¥é—¨',
    content: [
      'ğŸµ æ³°è¯­5ä¸ªå£°è°ƒ:',
      '  1. ä¸­å¹³è°ƒ Â¯ (å¦‚: à¸à¸² [ka:Â¯])',
      '  2. ä½é™è°ƒ ` (å¦‚: à¸à¹ˆà¸² [kÃ :])',
      '  3. é™è°ƒ Ë† (å¦‚: à¸à¹‰à¸² [kÃ¢:])',
      '  4. é«˜è°ƒ Â´ (å¦‚: à¸à¹Šà¸² [kÃ¡:])',
      '  5. å‡è°ƒ Ë‡ (å¦‚: à¸à¹‹à¸² [kÇ:])',
      '',
      'ğŸ“Œ å£°è°ƒç”±4ä¸ªå› ç´ å†³å®š:',
      '  â€¢ è¾…éŸ³ç±»(é«˜/ä¸­/ä½)',
      '  â€¢ å…ƒéŸ³é•¿çŸ­',
      '  â€¢ å£°è°ƒç¬¦å·(à¹ˆ à¹‰ à¹Š à¹‹)',
      '  â€¢ éŸ³èŠ‚ç±»å‹(Live/Dead)',
    ],
    visualChart: {
      columns: ['è¾…éŸ³ç±»', 'é•¿+æ— ', 'çŸ­+æ— ', 'à¹ˆ', 'à¹‰'],
      rows: [
        ['ä¸­è¾…éŸ³', 'Â¯', '`', '`', 'Ë†'],
        ['é«˜è¾…éŸ³', 'Â´', '`', '`', 'Ë†'],
      ],
      interactive: true,
    },
    duration: 45,
    order: 3,
  },

  rule_4_consonant_class_tones: {
    id: 'rule_4_consonant_class_tones',
    lessonId: 'lesson4',
    title: 'æ‹¼è¯»è§„åˆ™ 4: è¾…éŸ³ç±»ä¸å£°è°ƒ',
    content: [
      'ğŸ”‘ æ ¸å¿ƒæ¦‚å¿µ: åŒæ ·çš„å…ƒéŸ³+ç¬¦å·,ä¸åŒè¾…éŸ³ç±» â†’ ä¸åŒå£°è°ƒ',
      '',
      'ä¾‹: à¸² + æ— ç¬¦å·',
      '  â€¢ à¸ + à¸² = à¸à¸² [ä¸­å¹³Â¯] (ä¸­è¾…éŸ³)',
      '  â€¢ à¸‚ + à¸² = à¸‚à¸² [å‡è°ƒÂ´] (é«˜è¾…éŸ³)',
      '  â€¢ à¸„ + à¸² = à¸„à¸² [ä¸­å¹³Â¯] (ä½è¾…éŸ³)',
      '',
      'ğŸ¯ å­¦ä¹ ç­–ç•¥:',
      '  1. å…ˆè®°è¾…éŸ³ç±»(é«˜/ä¸­/ä½)',
      '  2. å†æŸ¥å£°è°ƒè¡¨',
      '  3. å¤šå¬å¤šç»ƒ,å½¢æˆç›´è§‰',
    ],
    visualChart: {
      columns: ['è¾…éŸ³ç±»', 'é•¿+æ— ', 'çŸ­+æ— ', 'à¹ˆ', 'à¹‰', 'à¹Š', 'à¹‹'],
      rows: [
        ['ä¸­è¾…éŸ³', 'Â¯', '`', '`', 'Ë†', 'Â´', 'Ë‡'],
        ['é«˜è¾…éŸ³', 'Â´', '`', '`', 'Ë†', '-', '-'],
        ['ä½è¾…éŸ³', 'Â¯', 'Â´', 'Ë†', 'Â´', '-', '-'],
      ],
      interactive: true,
    },
    duration: 45,
    order: 4,
  },

  rule_5_compound_vowels: {
    id: 'rule_5_compound_vowels',
    lessonId: 'lesson5',
    title: 'æ‹¼è¯»è§„åˆ™ 5: å¤åˆå…ƒéŸ³',
    content: [
      'ğŸ”— å¤åˆå…ƒéŸ³ = 2-3ä¸ªå…ƒéŸ³ç¬¦å·ç»„åˆ',
      '',
      'âœ… à¹€à¸­à¸µà¸¢ [ia]: à¹€ + à¸µ + à¸¢',
      '   ä¾‹: à¹€à¸¡à¸µà¸¢ [mia] (å¦»å­)',
      '',
      'âœ… à¹€à¸­à¸·à¸­ [É¯a]: à¹€ + à¸· + à¸­',
      '   ä¾‹: à¹€à¸¡à¸·à¸­à¸‡ [mÉ¯aÅ‹] (åŸå¸‚)',
      '',
      'âœ… à¸­à¸±à¸§ [ua]: à¸± + à¸§',
      '   ä¾‹: à¸„à¸§à¸²à¸¢ [khwaËy] (æ°´ç‰›)',
      '',
      'ğŸ“Œ æ‹¼è¯»æŠ€å·§: å…ˆè¯»è¾…éŸ³,å†æ»‘è¿‡æ•´ä¸ªå¤åˆå…ƒéŸ³',
    ],
    interactiveExample: {
      consonant: 'à¸¡',
      vowel: 'à¹€à¸­à¸µà¸¢',
      syllable: 'à¹€à¸¡à¸µà¸¢',
      pronunciation: 'mia',
      audioUrl:
        'https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/word-mia.mp3',
    },
    duration: 30,
    order: 5,
  },

  rule_6_special_cases: {
    id: 'rule_6_special_cases',
    lessonId: 'lesson6',
    title: 'æ‹¼è¯»è§„åˆ™ 6: ç‰¹æ®Šè§„åˆ™',
    content: [
      'ğŸ”¸ à¸: ä½œå£°æ¯è¯» [y],ä½œå°¾éŸ³è¯» [n]',
      '   ä¾‹: à¸à¸²à¸•à¸´ [yÃ¢Ët] (äº²æˆš), à¸«à¸à¸´à¸‡ [yÇÅ‹] (å¥³äºº)',
      '',
      'ğŸ”¸ à¸¤/à¸¦: æ¢µæ–‡ä¸“ç”¨,ç°ä»£æ³°è¯­å°‘è§',
      '   ä¾‹: à¸¤à¸”à¸¹ [rÉ¯ÌdÃ¹Ë] (å­£èŠ‚)',
      '',
      'ğŸ”¸ à¸« + ä½è¾…éŸ³: å˜é«˜è°ƒè§„åˆ™',
      '   ä¾‹: à¸«à¸™à¸¹ [nÇ”Ë] = à¸«(é™éŸ³) + à¸™à¸¹ (å˜é«˜è°ƒ)',
      '',
      'ğŸ”¸ à¹„/à¹ƒ: åŒéŸ³ä¸åŒå½¢,à¹ƒä»…28ä¸ªè¯',
      '   ä¾‹: à¹ƒà¸à¸¥à¹‰ [klÃ¢y] (è¿‘), à¹„à¸à¸¥ [klay] (è¿œ)',
    ],
    duration: 40,
    order: 6,
  },
};

/**
 * ä» DB è¯»å–è¯¾ç¨‹å…ƒæ•°æ®ï¼Œå¤±è´¥æ—¶å›é€€åˆ°æœ¬åœ° LESSON_METADATAã€‚
 * @param {object} db - cloud.database() å®ä¾‹
 * @param {string} lessonId
 * @returns {Promise<object|null>}
 */
async function getLessonMetadataFromDb(db, lessonId) {
  if (!lessonId) return null;

  try {
    const col = db.collection('alphabet_lessons');
    const res = await col.doc(lessonId).get();
    if (res && res.data && res.data.length > 0) {
      return res.data[0];
    }
  } catch (err) {
    console.warn(
      '[alphabetLessonConfig] getLessonMetadataFromDb error:',
      lessonId,
      err && err.message,
    );
  }

  return LESSON_METADATA[lessonId] || null;
}

/**
 * ä» DB è¯»å–æŸè¯¾å¯¹åº”çš„æ‹¼è¯»è§„åˆ™ï¼Œå¤±è´¥æ—¶å›é€€åˆ°æœ¬åœ° PHONICS_RULESã€‚
 * @param {object} db - cloud.database() å®ä¾‹
 * @param {string} lessonId
 * @returns {Promise<object|null>}
 */
async function getPhonicsRuleByLessonFromDb(db, lessonId) {
  if (!lessonId) return null;

  try {
    const col = db.collection('phonics_rules');
    const res = await col
      .where({ lessonId })
      .limit(1)
      .get();

    if (res && res.data && res.data.length > 0) {
      return res.data[0];
    }
  } catch (err) {
    console.warn(
      '[alphabetLessonConfig] getPhonicsRuleByLessonFromDb error:',
      lessonId,
      err && err.message,
    );
  }

  const fallback = Object.values(PHONICS_RULES).find(
    (r) => r.lessonId === lessonId,
  );
  return fallback || null;
}

module.exports = {
  LESSON_METADATA,
  PHONICS_RULES,
  getLessonMetadataFromDb,
  getPhonicsRuleByLessonFromDb,
};
````

## File: cloudbase/functions/memory-engine/handlers/getAlphabetLessons.js
````javascript
'use strict';

/**
 * è·å–å­—æ¯è¯¾ç¨‹å…ƒæ•°æ®åˆ—è¡¨
 *
 * è®¾è®¡ç›®æ ‡ï¼š
 * - ä½œä¸ºå‰ç«¯ã€Œå­—æ¯è¯¾ç¨‹æ€»è§ˆã€é¡µçš„æ•°æ®æºï¼›
 * - ä¼˜å…ˆä» DB é›†åˆ alphabet_lessons è¯»å–ï¼Œå¤±è´¥æ—¶å›é€€åˆ°æœ¬åœ° LESSON_METADATAï¼›
 * - è¿”å›ç»“æ„ä¸å‰ç«¯ LessonMetadata ç±»å‹å…¼å®¹ã€‚
 */

const { createResponse } = require('../utils/response');
const { LESSON_METADATA } = require('../config/alphabetLessonConfig');

/**
 * @param {object} db    cloud.database()
 * @param {object} params ç›®å‰æœªä½¿ç”¨ï¼Œé¢„ç•™è¿‡æ»¤/åˆ†é¡µ
 */
async function getAlphabetLessons(db, params) {
  try {
    let lessons = [];

    try {
      const col = db.collection('alphabet_lessons');
      const res = await col.orderBy('order', 'asc').get();
      if (res && Array.isArray(res.data) && res.data.length > 0) {
        lessons = res.data;
      }
    } catch (err) {
      console.warn('[getAlphabetLessons] DB æŸ¥è¯¢å¤±è´¥ï¼Œå°†ä½¿ç”¨æœ¬åœ° LESSON_METADATA ä½œä¸ºå›é€€:', err.message);
    }

    if (!lessons.length) {
      lessons = Object.values(LESSON_METADATA).sort(
        (a, b) => (a.order || 0) - (b.order || 0),
      );
    }

    return createResponse(true, { lessons }, 'è·å–å­—æ¯è¯¾ç¨‹åˆ—è¡¨æˆåŠŸ');
  } catch (error) {
    console.error('[getAlphabetLessons] error:', error);
    return createResponse(
      false,
      null,
      error.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      'SERVER_ERROR',
    );
  }
}

module.exports = getAlphabetLessons;
````

## File: cloudbase/functions/memory-engine/utils/index.js
````javascript
/**
 * Shared Utilities Package Entry Point
 * 
 * ç»Ÿä¸€å¯¼å‡ºæ‰€æœ‰å…±äº«æ¨¡å—
 * ä½¿ç”¨æ–¹å¼: const { response, constants, sm2 } = require('@thai-app/shared');
 */

'use strict';

module.exports = {
    // å“åº”æ ¼å¼åŒ–æ¨¡å—
    response: require('./response'),

    // å¸¸é‡å®šä¹‰æ¨¡å—
    constants: require('./constants'),

    // SM-2 ç®—æ³•æ¨¡å—
    sm2: require('./sm2'),

    // å‚æ•°éªŒè¯æ¨¡å—
    validators: require('./validators'),

    // ç»Ÿä¸€è®°å¿†å¼•æ“æ¨¡å—
    memoryEngine: require('./memoryEngine'),

    // æ•°æ®åº“è¿æ¥æ¨¡å—
    database: require('./database')
};
````

## File: cloudbase/functions/shared/constants.js
````javascript
/**
 * å¸¸é‡å®šä¹‰æ¨¡å—
 * 
 * ä¸å‰ç«¯ src/config/constants.ts ä¿æŒä¸€è‡´çš„è®¾è®¡é£æ ¼
 * é›†ä¸­ç®¡ç†æ‰€æœ‰äº‘å‡½æ•°å¸¸é‡
 */

'use strict';

// ==================== æ•°æ®åº“é›†åˆåç§° ====================
// ä¸å‰ç«¯ COLLECTIONS ä¿æŒä¸€è‡´
const COLLECTIONS = {
  USERS: 'users',
  VOCABULARY: 'vocabulary',
  USER_VOCABULARY_PROGRESS: 'user_vocabulary_progress',
  LETTERS: 'letters',
  USER_ALPHABET_PROGRESS: 'user_alphabet_progress',
  LETTER_TEST_BANK: 'letter_test_bank',
  COURSES: 'courses',
  LESSONS: 'lessons',
  PROGRESS: 'progress',
};

// ==================== æŒæ¡ç¨‹åº¦ ====================
// ä½¿ç”¨ä¸­æ–‡å€¼ï¼Œä¾¿äºå‰ç«¯ç›´æ¥æ˜¾ç¤º
const MasteryLevel = Object.freeze({
  UNFAMILIAR: 'é™Œç”Ÿ',
  FUZZY: 'æ¨¡ç³Š',
  REMEMBERED: 'è®°å¾—',
});

// ==================== å­¦ä¹ ç­‰çº§ ====================
// ä¸å‰ç«¯ LEVELS ä¿æŒä¸€è‡´
const LEVELS = Object.freeze({
  BEGINNER_A: 'BEGINNER_A',
  BEGINNER_B: 'BEGINNER_B',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED',
});

// ==================== SM-2 ç®—æ³•å‚æ•° ====================
// ä¼˜åŒ–ç‰ˆå‚æ•°ï¼ŒåŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿
const SM2_PARAMS = Object.freeze({
  INITIAL_EASINESS_FACTOR: 2.5,   // åˆå§‹ç®€æ˜“åº¦
  MIN_EASINESS_FACTOR: 1.3,       // æœ€å°ç®€æ˜“åº¦
  MAX_INTERVAL_DAYS: 180,         // æœ€å¤§é—´éš”ï¼ˆå¤©ï¼‰
  FUZZY_MULTIPLIER: 0.8,          // "æ¨¡ç³Š"æ—¶é—´éš”ç¼©çŸ­æ¯”ä¾‹
});

// ==================== æ—©æœŸå¤ä¹ é—´éš”åºåˆ— ====================
// åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–: 1â†’2â†’4â†’7â†’14 å¤©
const EARLY_INTERVALS = Object.freeze([1, 2, 4, 7, 14]);

// ==================== æ¯æ—¥å­¦ä¹ é…ç½® ====================
const DAILY_LEARNING_CONFIG = Object.freeze({
  MAX_NEW_WORDS: 10,              // æ¯æ—¥æ–°è¯ä¸Šé™
  MAX_REVIEW_WORDS: 20,           // æ¯æ—¥å¤ä¹ ä¸Šé™
  TOTAL_WORDS_LIMIT: 30,          // æ¯æ—¥æ€»è¯æ•°ä¸Šé™
});

// ==================== é”™è¯¯ç  ====================
// ç»Ÿä¸€é”™è¯¯ç å®šä¹‰
const ErrorCodes = Object.freeze({
  SUCCESS: 'SUCCESS',
  USER_NOT_FOUND: 'USER_NOT_FOUND',
  VOCABULARY_NOT_FOUND: 'VOCABULARY_NOT_FOUND',
  INVALID_PARAMS: 'INVALID_PARAMS',
  INVALID_MASTERY: 'INVALID_MASTERY',
  UNKNOWN_ACTION: 'UNKNOWN_ACTION',
  SERVER_ERROR: 'SERVER_ERROR',
});

// ==================== é”™è¯¯æ¶ˆæ¯ ====================
// ä¸å‰ç«¯ ERROR_MESSAGES é£æ ¼ä¸€è‡´
const ERROR_MESSAGES = Object.freeze({
  USER_NOT_FOUND: 'ç”¨æˆ·ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥ç”¨æˆ·IDæˆ–é‡æ–°ç™»å½•',
  VOCABULARY_NOT_FOUND: 'è¯æ±‡ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥è¯æ±‡ID',
  INVALID_PARAMS: 'å‚æ•°æ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥è¾“å…¥',
  INVALID_MASTERY: 'æ— æ•ˆçš„æŒæ¡ç¨‹åº¦ï¼Œå…è®¸å€¼: é™Œç”Ÿ/æ¨¡ç³Š/è®°å¾—',
  UNKNOWN_ACTION: 'æœªçŸ¥æ“ä½œç±»å‹',
  SERVER_ERROR: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•',
});

// ==================== æ”¯æŒçš„ Actions ====================
const SUPPORTED_ACTIONS = Object.freeze([
  'getTodayWords',
  'updateMastery',
  'toggleSkipWord',
  'getVocabularyDetail',
  'getReviewStatistics',
  'getVocabularyList',
  'getSkippedWords',
  'getLetterTest',
  'submitLetterTest',
  'passLetterTest',
  'getTodayMemories',
  'submitMemoryResult',
  'checkModuleAccess',
  'getUserProgress'
]);

module.exports = {
  // é›†åˆ
  COLLECTIONS,

  // æšä¸¾
  MasteryLevel,
  LEVELS,
  ErrorCodes,

  // ç®—æ³•å‚æ•°
  SM2_PARAMS,
  EARLY_INTERVALS,

  // é…ç½®
  DAILY_LEARNING_CONFIG,

  // æ¶ˆæ¯
  ERROR_MESSAGES,
  SUPPORTED_ACTIONS,
};
````

## File: cloudbase/functions/shared/database.js
````javascript
const cloud = require('wx-server-sdk');

cloud.init({
    env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();
const _ = db.command;

const collections = {
    users: db.collection('users'),
    vocabulary: db.collection('vocabulary'),
    letters: db.collection('letters'),
    sentences: db.collection('sentences'),
    memory_status: db.collection('memory_status'),
    user_progress: db.collection('user_progress'),
    user_vocabulary_progress: db.collection('user_vocabulary_progress')
};

module.exports = {
    db,
    _,
    userCollection: collections.users,
    vocabularyCollection: collections.vocabulary,
    letterCollection: collections.letters,
    sentenceCollection: collections.sentences,
    memoryStatusCollection: collections.memory_status,
    userProgressCollection: collections.user_progress,
    progressCollection: collections.user_vocabulary_progress,
    collections
};
````

## File: cloudbase/functions/shared/index.js
````javascript
/**
 * Shared Utilities Package Entry Point
 * 
 * ç»Ÿä¸€å¯¼å‡ºæ‰€æœ‰å…±äº«æ¨¡å—
 * ä½¿ç”¨æ–¹å¼: const { response, constants, sm2 } = require('@thai-app/shared');
 */

'use strict';

module.exports = {
    // å“åº”æ ¼å¼åŒ–æ¨¡å—
    response: require('./response'),

    // å¸¸é‡å®šä¹‰æ¨¡å—
    constants: require('./constants'),

    // SM-2 ç®—æ³•æ¨¡å—
    sm2: require('./sm2'),

    // å‚æ•°éªŒè¯æ¨¡å—
    validators: require('./validators'),

    // ç»Ÿä¸€è®°å¿†å¼•æ“æ¨¡å—
    memoryEngine: require('./memoryEngine'),

    // æ•°æ®åº“è¿æ¥æ¨¡å—
    database: require('./database')
};
````

## File: cloudbase/functions/shared/memoryEngine.js
````javascript
/**
 * ç»Ÿä¸€è®°å¿†å¼•æ“æ ¸å¿ƒæ¨¡å—
 * æ”¯æŒå­—æ¯/å•è¯/å¥å­çš„ç»Ÿä¸€è®°å¿†ç®¡ç†
 * 
 * ä¿®å¤ï¼šwx-server-sdk ä¸æ”¯æŒ getOne()ï¼Œæ”¹ç”¨ get() + data[0]
 */

const { calculateSM2Optimized } = require('./sm2');

/**
 * åˆ›å»ºæ–°çš„è®°å¿†è®°å½•
 */
async function createMemoryRecord(db, userId, entityType, entityId, isLocked = false) {

    // éªŒè¯å‚æ•°
    if (!userId || !entityType || !entityId) {
        console.error('[createMemoryRecord] å‚æ•°ç¼ºå¤±:', { userId, entityType, entityId });
        throw new Error('userId, entityType, entityId éƒ½æ˜¯å¿…éœ€å‚æ•°');
    }

    const now = new Date();
    const nextReviewAt = isLocked ? null : new Date(now.getTime() + 24 * 60 * 60 * 1000).toISOString();

    const memoryRecord = {
        userId,
        entityType,
        entityId,
        masteryLevel: 0.0,
        reviewStage: 0,
        easinessFactor: 2.5,
        intervalDays: 1,
        lastReviewAt: null,
        nextReviewAt,
        correctCount: 0,
        wrongCount: 0,
        streakCorrect: 0,
        isLocked,
        createdAt: now.toISOString(),
        updatedAt: now.toISOString()
    };

    try {
        // å°è¯•æ’å…¥
        const result = await db.collection('memory_status').add(memoryRecord);

        console.log('[createMemoryRecord] åˆ›å»ºæˆåŠŸ:', { userId, entityType, entityId });

        return {
            _id: result._id,
            ...memoryRecord
        };
    } catch (error) {
        // å¦‚æœæ˜¯é‡å¤é”®é”™è¯¯ï¼ŒæŸ¥è¯¢å¹¶è¿”å›ç°æœ‰è®°å½•
        if (error.errCode === -502001 || error.message.includes('duplicate key')) {
            console.log('[createMemoryRecord] è®°å½•å·²å­˜åœ¨ï¼ŒæŸ¥è¯¢è¿”å›:', { userId, entityType, entityId });

            const existingResult = await db.collection('memory_status')
                .where({ userId, entityType, entityId })
                .get();

            if (existingResult.data && existingResult.data.length > 0) {
                return existingResult.data[0];
            }
        }

        // å…¶ä»–é”™è¯¯ç»§ç»­æŠ›å‡º
        console.error('[createMemoryRecord] åˆ›å»ºå¤±è´¥:', error);
        throw error;
    }
}

/**
 * è·å–æˆ–åˆ›å»ºè®°å¿†è®°å½•
 * ä¿®å¤ï¼šä½¿ç”¨ get() ä»£æ›¿ getOne()
 */
async function getOrCreateMemory(db, userId, entityType, entityId, isLocked = false) {
    // 1. å°è¯•æŸ¥è¯¢ç°æœ‰è®°å½•
    const existingMemory = await db.collection('memory_status')
        .where({
            userId,
            entityType,
            entityId
        })
        .get();

    // 2. å¦‚æœå­˜åœ¨,ç›´æ¥è¿”å›ç¬¬ä¸€æ¡
    if (existingMemory.data && existingMemory.data.length > 0) {
        return existingMemory.data[0];
    }

    // 3. ä¸å­˜åœ¨åˆ™åˆ›å»ºæ–°è®°å½•
    return await createMemoryRecord(db, userId, entityType, entityId, isLocked);
}

/**
 * æ›´æ–°è®°å¿†çŠ¶æ€(ç­”é¢˜åè°ƒç”¨)
 */
async function updateMemoryAfterReview(db, userId, entityType, entityId, quality) {
    console.log('ã€æµ‹è¯•ã€‘updateMemoryAfterReview è¢«è°ƒç”¨äº†ï¼', { userId, quality });
    console.log('=== [updateMemoryAfterReview] å¼€å§‹ ===');
    console.log('å‚æ•°:', JSON.stringify({ userId, entityType, entityId, quality }));

    try {
        // 1. è·å–å½“å‰è®°å¿†è®°å½•
        console.log('æ­¥éª¤1: è·å–è®°å¿†è®°å½•');
        const memory = await getOrCreateMemory(db, userId, entityType, entityId);
        console.log('è®°å¿†è®°å½•:', JSON.stringify(memory));

        // 2. æ˜ å°„è´¨é‡åˆ°SM-2è¯„åˆ†
        console.log('æ­¥éª¤2: æ˜ å°„è´¨é‡');
        const qualityMap = {
            'é™Œç”Ÿ': 1,
            'æ¨¡ç³Š': 3,
            'è®°å¾—': 5
        };
        const sm2Quality = qualityMap[quality] || 3;
        console.log('SM-2è´¨é‡:', sm2Quality);

        // 3. è®¡ç®—æ–°çš„SM-2å‚æ•°
        console.log('æ­¥éª¤3: è°ƒç”¨ calculateSM2Optimized');
        console.log('è°ƒç”¨å‚æ•°:', {
            quality,
            intervalDays: memory.intervalDays,
            easinessFactor: memory.easinessFactor,
            reviewStage: memory.reviewStage
        });

        const sm2Result = calculateSM2Optimized(
            quality,
            memory.intervalDays,
            memory.easinessFactor,
            memory.reviewStage
        );

        console.log('SM-2ç»“æœ:', JSON.stringify(sm2Result));

        // 4. æ›´æ–°æŒæ¡åº¦
        console.log('æ­¥éª¤4: è®¡ç®—æ–°æŒæ¡åº¦');
        let newMasteryLevel = memory.masteryLevel;
        if (quality === 'è®°å¾—') {
            newMasteryLevel = Math.min(1.0, memory.masteryLevel + 0.15);
        } else if (quality === 'æ¨¡ç³Š') {
            newMasteryLevel = Math.max(0.0, memory.masteryLevel + 0.05);
        } else {
            newMasteryLevel = Math.max(0.0, memory.masteryLevel - 0.2);
        }
        console.log('æ–°æŒæ¡åº¦:', newMasteryLevel);

        // 5. æ›´æ–°è¿èƒœå’Œè®¡æ•°
        console.log('æ­¥éª¤5: è®¡ç®—è¿èƒœ');
        const newStreakCorrect = quality === 'è®°å¾—' ? memory.streakCorrect + 1 : 0;
        const newCorrectCount = quality === 'è®°å¾—' ? memory.correctCount + 1 : memory.correctCount;
        const newWrongCount = quality === 'é™Œç”Ÿ' ? memory.wrongCount + 1 : memory.wrongCount;

        // 6. è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´
        console.log('æ­¥éª¤6: è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´');
        const now = new Date();
        const nextReviewAt = new Date(now.getTime() + sm2Result.interval * 24 * 60 * 60 * 1000);
        console.log('ä¸‹æ¬¡å¤ä¹ æ—¶é—´:', nextReviewAt);

        // 7. å‡†å¤‡æ›´æ–°æ•°æ®
        console.log('æ­¥éª¤7: å‡†å¤‡æ›´æ–°æ•°æ®åº“');
        const updateData = {
            masteryLevel: newMasteryLevel,
            reviewStage: sm2Result.repetitions,
            easinessFactor: sm2Result.easinessFactor,
            intervalDays: sm2Result.interval,
            lastReviewAt: now.toISOString(),
            nextReviewAt: nextReviewAt.toISOString(),
            correctCount: newCorrectCount,
            wrongCount: newWrongCount,
            streakCorrect: newStreakCorrect,
            updatedAt: now.toISOString()
        };

        console.log('æ›´æ–°æ•°æ®å¯¹è±¡:', JSON.stringify(updateData));

        // æ£€æŸ¥æ˜¯å¦æœ‰ undefined
        for (const [key, value] of Object.entries(updateData)) {
            if (value === undefined) {
                console.error(`âŒ å‘ç° undefined å€¼: ${key}`);
            }
        }

        // 8. æ‰§è¡Œæ›´æ–°
        console.log('æ­¥éª¤8: æ‰§è¡Œæ•°æ®åº“æ›´æ–°');
        await db.collection('memory_status')
            .where({
                userId,
                entityType,
                entityId
            })
            .update({
                data: updateData   // âœ… CloudBase å¿…é¡»è¿™æ ·å†™
            });

        console.log('âœ… æ›´æ–°æˆåŠŸ');

        return {
            entityId,
            entityType,
            masteryLevel: newMasteryLevel,
            reviewStage: sm2Result.repetitions,
            easinessFactor: sm2Result.easinessFactor,
            intervalDays: sm2Result.interval,
            nextReviewAt: nextReviewAt.toISOString(),
            correctCount: newCorrectCount,
            wrongCount: newWrongCount,
            streakCorrect: newStreakCorrect
        };

    } catch (error) {
        console.error('âŒ [updateMemoryAfterReview] é”™è¯¯:', error);
        console.error('é”™è¯¯å †æ ˆ:', error.stack);
        throw error;
    }
}

/**
 * è·å–ä»Šæ—¥å¾…å¤ä¹ çš„å®ä½“
 */
async function getTodayReviewEntities(db, userId, entityType, limit = 20) {
    const now = new Date();

    const result = await db.collection('memory_status')
        .where({
            userId,
            entityType,
            isLocked: false,
            nextReviewAt: db.command.lte(now)
        })
        .orderBy('nextReviewAt', 'asc')
        .limit(limit)
        .get();

    return result.data || [];
}

/**
 * æ£€æŸ¥å¹¶è§£é”ä¸‹ä¸€é˜¶æ®µå­¦ä¹ 
 */
// async function checkAndUnlockNextStage(db, userId) {

//   if (process.env.FORCE_UNLOCK === 'true') {
//     return {
//       allowed: true,
//       progress: 100,
//       stage: "all",
//       message: 'ã€è°ƒè¯•æ¨¡å¼ã€‘å¼ºåˆ¶è§£é”'
//     };
//   }

//   // ä¿®å¤ï¼šä½¿ç”¨ get() + data[0]
//   const progressResult = await db.collection('user_progress')
//     .where({ userId })
//     .get();

//   if (!progressResult.data || progressResult.data.length === 0) {
//     await initUserProgress(db, userId);
//     return {
//       unlocked: false,
//       stage: 'letter',
//       message: 'åˆå§‹åŒ–å­¦ä¹ è¿›åº¦æˆåŠŸ'
//     };
//   }

//   const progress = progressResult.data[0];

//   if (!progress.letterCompleted) {
//     const letterMemories = await db.collection('memory_status')
//       .where({
//         userId,
//         entityType: 'letter'
//       })
//       .get();

//     const totalLetters = 44;
//     const masteredLetters = letterMemories.data.filter(m => m.masteryLevel >= 0.7).length;
//     const letterProgress = masteredLetters / totalLetters;

//     if (letterProgress >= 0.95) {
//       await db.collection('user_progress').where({ userId }).update({
//         data: {
//           letterCompleted: true,
//           letterProgress: 1.0,
//           wordUnlocked: true,
//           currentStage: 'word',
//           updatedAt: new Date().toISOString()
//         }
//       });

//       await db.collection('memory_status')
//         .where({
//           userId,
//           entityType: 'word',
//           isLocked: true
//         })
//         .update({
//           data: {
//             isLocked: false,
//             nextReviewAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
//           }
//         });

//       return {
//         unlocked: true,
//         stage: 'word',
//         message: 'æ­å–œ!å­—æ¯å­¦ä¹ å®Œæˆ,å•è¯å­¦ä¹ å·²è§£é”!'
//       };
//     }

//     return {
//       unlocked: false,
//       stage: 'letter',
//       progress: letterProgress,
//       remaining: Math.ceil((0.95 - letterProgress) * totalLetters),
//       message: `è¿˜éœ€æŒæ¡ ${Math.ceil((0.95 - letterProgress) * totalLetters)} ä¸ªå­—æ¯`
//     };
//   }

//   return {
//     unlocked: false,
//     stage: progress.currentStage,
//     message: 'ç»§ç»­åŠ æ²¹!'
//   };
// }

/**
 * åˆå§‹åŒ–ç”¨æˆ·çš„å­¦ä¹ è¿›åº¦è®°å½•
 */
async function initUserProgress(db, userId) {
    const now = new Date();

    const progressRecord = {
        userId,
        letterCompleted: false,
        letterProgress: 0.0,
        wordUnlocked: false,
        wordProgress: 0.0,
        sentenceUnlocked: false,
        sentenceProgress: 0.0,
        articleUnlocked: false,
        currentStage: 'letter',
        totalStudyDays: 0,
        streakDays: 0,
        lastStudyDate: null,
        createdAt: now,
        updatedAt: now
    };

    await db.collection('user_progress').add(progressRecord);
    return progressRecord;
}

/**
 * æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™
 * ä¿®å¤ï¼šä½¿ç”¨ get() + data[0]
 */
async function checkModuleAccess(db, userId, moduleType) {

    // âœ…âœ…âœ…ã€è°ƒè¯•æ€»å¼€å…³ï¼šè·³è¿‡æ‰€æœ‰å­¦ä¹ é”ã€‘
    if (process.env.FORCE_UNLOCK === 'true') {
        console.warn('âš ï¸ FORCE_UNLOCK å·²å¼€å¯, å¼ºåˆ¶æ”¾è¡Œæ¨¡å—:', moduleType);
        return {
            allowed: true,
            progress: {
                letterCompleted: true,
                letterProgress: 1,
                wordUnlocked: true,
                sentenceUnlocked: true,
                articleUnlocked: true,
                currentStage: moduleType
            }
        };
    }

    const progressResult = await db.collection('user_progress')
        .where({ userId })
        .get();

    if (!progressResult.data || progressResult.data.length === 0) {
        return {
            allowed: false,
            errorCode: 'USER_PROGRESS_NOT_FOUND',
            message: 'ç”¨æˆ·å­¦ä¹ è¿›åº¦ä¸å­˜åœ¨,è¯·è”ç³»ç®¡ç†å‘˜'
        };
    }

    const progress = progressResult.data[0];

    // âœ… å­—æ¯æ¨¡å—æ°¸è¿œå…è®¸è®¿é—®
    if (moduleType === 'letter') {
        return {
            allowed: true,
            progress
        };
    }

    // âœ… å…¶ä»–æ‰€æœ‰æ¨¡å—åªä¾èµ– letterCompleted
    if (!progress.letterCompleted) {
        return {
            allowed: false,
            errorCode: 'MODULE_LOCKED',
            message: `è¯·å…ˆå®Œæˆå­—æ¯å­¦ä¹ ï¼ˆå½“å‰è¿›åº¦ï¼š${Math.round(progress.letterProgress * 100)}%ï¼‰`,
            progress
        };
    }

    // âœ… å­—æ¯å®Œæˆ â†’ å…¨éƒ¨æ¨¡å—æ”¾è¡Œ
    return {
        allowed: true,
        progress
    };
}

module.exports = {
    createMemoryRecord,
    getOrCreateMemory,
    updateMemoryAfterReview,
    getTodayReviewEntities,
    // checkAndUnlockNextStage,
    initUserProgress,
    checkModuleAccess
};
````

## File: cloudbase/functions/shared/response.js
````javascript
/**
 * å“åº”æ ¼å¼åŒ–æ¨¡å—
 * 
 * ç»Ÿä¸€ API å“åº”æ ¼å¼
 * ä¸å‰ç«¯ ApiResponse<T> ç±»å‹å®šä¹‰ä¿æŒä¸€è‡´
 */

'use strict';

const { ErrorCodes, ERROR_MESSAGES } = require('./constants');

/**
 * åˆ›å»ºæ ‡å‡†åŒ– API å“åº”
 * 
 * å¯¹åº”å‰ç«¯ç±»å‹:
 * interface ApiResponse<T> {
 *   success: boolean;
 *   data?: T;
 *   message?: string;
 *   errorCode?: string;
 *   timestamp: string;
 * }
 * 
 * @param {boolean} success - æ˜¯å¦æˆåŠŸ
 * @param {Object} data - è¿”å›æ•°æ®
 * @param {string} message - æç¤ºæ¶ˆæ¯
 * @param {string} errorCode - é”™è¯¯ç 
 * @returns {Object} æ ‡å‡†åŒ–å“åº”å¯¹è±¡
 */
function createResponse(success, data = null, message = '', errorCode = null) {
  return {
    success,
    data,
    message,
    errorCode,
    timestamp: new Date().toISOString(),
  };
}

/**
 * åˆ›å»ºæˆåŠŸå“åº”
 * 
 * @param {Object} data - è¿”å›æ•°æ®
 * @param {string} message - æˆåŠŸæ¶ˆæ¯
 * @returns {Object} æˆåŠŸå“åº”å¯¹è±¡
 */
function successResponse(data, message = 'æ“ä½œæˆåŠŸ') {
  return createResponse(true, data, message, null);
}

/**
 * åˆ›å»ºé”™è¯¯å“åº”
 * 
 * @param {string} errorCode - é”™è¯¯ç  (æ¥è‡ª ErrorCodes)
 * @param {string} customMessage - è‡ªå®šä¹‰æ¶ˆæ¯ (å¯é€‰)
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function errorResponse(errorCode, customMessage = null) {
  const message = customMessage || ERROR_MESSAGES[errorCode] || 'æœªçŸ¥é”™è¯¯';
  return createResponse(false, null, message, errorCode);
}

/**
 * åˆ›å»ºå‚æ•°é”™è¯¯å“åº”
 * 
 * @param {string} detail - é”™è¯¯è¯¦æƒ…
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function invalidParamsResponse(detail) {
  return errorResponse(ErrorCodes.INVALID_PARAMS, detail);
}

/**
 * åˆ›å»ºç”¨æˆ·ä¸å­˜åœ¨å“åº”
 * 
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function userNotFoundResponse() {
  return errorResponse(ErrorCodes.USER_NOT_FOUND);
}

/**
 * åˆ›å»ºè¯æ±‡ä¸å­˜åœ¨å“åº”
 * 
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function vocabularyNotFoundResponse() {
  return errorResponse(ErrorCodes.VOCABULARY_NOT_FOUND);
}

/**
 * åˆ›å»ºæœåŠ¡å™¨é”™è¯¯å“åº”
 * 
 * @param {Error} error - é”™è¯¯å¯¹è±¡
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function serverErrorResponse(error) {
  // ç”Ÿäº§ç¯å¢ƒä¸æš´éœ²é”™è¯¯è¯¦æƒ…
  const message = process.env.NODE_ENV === 'development' 
    ? `æœåŠ¡å™¨é”™è¯¯: ${error.message}`
    : ERROR_MESSAGES.SERVER_ERROR;
  
  return errorResponse(ErrorCodes.SERVER_ERROR, message);
}

module.exports = {
  createResponse,
  successResponse,
  errorResponse,
  invalidParamsResponse,
  userNotFoundResponse,
  vocabularyNotFoundResponse,
  serverErrorResponse,
};
````

## File: cloudbase/functions/shared/sm2.js
````javascript
/**
 * SM-2 é—´éš”é‡å¤ç®—æ³•æ¨¡å—ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
 * 
 * åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–:
 * - æ—©æœŸå¤ä¹ é—´éš”æ›´å¯†é›†: 1â†’2â†’4â†’7â†’14 å¤©
 * - "æ¨¡ç³Š"çŠ¶æ€ç¼©çŸ­é—´éš”è€Œéç»´æŒä¸å˜
 * - "é™Œç”Ÿ"çŠ¶æ€é‡ç½®å¤ä¹ è¿›åº¦
 * 
 * ç®—æ³•è®ºæ–‡: https://www.supermemo.com/en/archives1990-2015/english/ol/sm2
 */

'use strict';

const { MasteryLevel, SM2_PARAMS, EARLY_INTERVALS } = require('./constants');

/**
 * å°†æŒæ¡ç¨‹åº¦æ˜ å°„åˆ° SM-2 Quality å€¼
 * 
 * SM-2 Quality å®šä¹‰:
 * 0 - å®Œå…¨ä¸è®°å¾—
 * 1 - é”™è¯¯å›ç­”ï¼Œä½†çœ‹åˆ°æ­£ç¡®ç­”æ¡ˆåæƒ³èµ·
 * 2 - é”™è¯¯å›ç­”ï¼Œæ­£ç¡®ç­”æ¡ˆçœ‹èµ·æ¥å¾ˆç†Ÿæ‚‰
 * 3 - æ­£ç¡®å›ç­”ï¼Œä½†å›°éš¾è¾ƒå¤§
 * 4 - æ­£ç¡®å›ç­”ï¼Œæœ‰äº›çŠ¹è±«
 * 5 - æ­£ç¡®å›ç­”ï¼Œæ¯«æ— å›°éš¾
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦
 * @returns {number} Qualityå€¼ (1-5)
 */
function masteryToQuality(mastery) {
    switch (mastery) {
        case MasteryLevel.UNFAMILIAR:
            return 1;  // å®Œå…¨ä¸è®°å¾—
        case MasteryLevel.FUZZY:
            return 3;  // æœ‰å°è±¡ä½†ä¸ç¡®å®š
        case MasteryLevel.REMEMBERED:
            return 5;  // å®Œå…¨è®°å¾—
        default:
            return 1;
    }
}

/**
 * è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸï¼ˆä¼˜åŒ–ç‰ˆ SM-2 ç®—æ³•ï¼‰
 * 
 * æ”¹è¿›ç‚¹:
 * 1. æ—©æœŸé˜¶æ®µï¼ˆå‰5æ¬¡ï¼‰ä½¿ç”¨å›ºå®šçš„æ¸è¿›é—´éš” [1,2,4,7,14]
 * 2. "æ¨¡ç³Š"æ—¶ç¼©çŸ­é—´éš”è€Œéç»´æŒä¸å˜
 * 3. "é™Œç”Ÿ"æ—¶å®Œå…¨é‡ç½®å¤ä¹ è¿›åº¦
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦: å¿˜è®°/æ¨¡ç³Š/è®¤è¯†
 * @param {number} currentInterval - å½“å‰å¤ä¹ é—´éš”ï¼ˆå¤©ï¼‰
 * @param {number} easinessFactor - ç®€æ˜“åº¦å› å­ï¼ˆ1.3-2.5+ï¼‰
 * @param {number} reviewCount - å·²å¤ä¹ æ¬¡æ•°
 * @returns {Object} ç®—æ³•è®¡ç®—ç»“æœ
 * 
 * @example
 * const result = calculateSM2Optimized('è®¤è¯†', 2, 2.5, 1);
 * // {
 * //   nextInterval: 4,
 * //   nextEasinessFactor: 2.6,
 * //   nextReviewDate: "2025-12-01T10:00:00Z",
 * //   shouldResetCount: false
 * // }
 * */
function calculateSM2Optimized(
    mastery,
    currentInterval = 1,
    easinessFactor = SM2_PARAMS.INITIAL_EASINESS_FACTOR,
    reviewCount = 0
) {
    let nextInterval = currentInterval;
    let nextEF = easinessFactor;
    let shouldResetCount = false;

    const quality = masteryToQuality(mastery);

    // ==================== æ ¸å¿ƒç®—æ³•é€»è¾‘ ====================

    if (quality < 3) {
        // ========== å¿˜è®°: å®Œå…¨é‡ç½® ==========
        // ç”¨æˆ·å®Œå…¨ä¸è®°å¾—ï¼Œéœ€è¦ä»å¤´å¼€å§‹å­¦ä¹ 
        nextInterval = 1;
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF - 0.2);
        shouldResetCount = true;

    } else if (quality === 3) {
        // ========== æ¨¡ç³Š: ç¼©çŸ­é—´éš”ï¼ŒåŠ å¼ºå¤ä¹  ==========
        // æ”¹è¿›: ä¸æ˜¯ç»´æŒä¸å˜ï¼Œè€Œæ˜¯ç¼©çŸ­20%
        nextInterval = Math.max(1, Math.round(currentInterval * SM2_PARAMS.FUZZY_MULTIPLIER));
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF - 0.1);

    } else {
        // ========== è®°å¾—: ä½¿ç”¨ä¼˜åŒ–çš„é—´éš”åºåˆ— ==========
        if (reviewCount < EARLY_INTERVALS.length) {
            // æ—©æœŸé˜¶æ®µ: ä½¿ç”¨é¢„å®šä¹‰çš„æ¸è¿›é—´éš”
            // è¿™æ˜¯å…³é”®æ”¹è¿›: 1â†’2â†’4â†’7â†’14 è€ŒéåŸç‰ˆçš„ 1â†’6
            nextInterval = EARLY_INTERVALS[reviewCount];
        } else {
            // åæœŸé˜¶æ®µ: ä½¿ç”¨ EF è®¡ç®—æŒ‡æ•°å¢é•¿
            nextInterval = Math.round(currentInterval * nextEF);
        }

        // æé«˜ç®€æ˜“åº¦ (æ ‡å‡† SM-2 å…¬å¼)
        nextEF = nextEF + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF);
    }

    // é™åˆ¶æœ€å¤§é—´éš”
    nextInterval = Math.min(nextInterval, SM2_PARAMS.MAX_INTERVAL_DAYS);

    // è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸ
    const nextReviewDate = new Date();
    nextReviewDate.setDate(nextReviewDate.getDate() + nextInterval);

    // è®¡ç®—æ–°çš„å¤ä¹ æ¬¡æ•°
    const newRepetitions = shouldResetCount ? 0 : reviewCount + 1;

    return {
        // === å…¼å®¹ memoryEngine.js çš„æ—§æ¥å£ ===
        interval: nextInterval,
        easinessFactor: parseFloat(nextEF.toFixed(2)),
        repetitions: newRepetitions,

        // === æ–°æ¥å£ï¼ˆä¿ç•™ä¾›æœªæ¥ä½¿ç”¨ï¼‰===
        nextInterval,
        nextEasinessFactor: parseFloat(nextEF.toFixed(2)),
        nextReviewDate: nextReviewDate.toISOString(),
        shouldResetCount,
    };
}

/**
 * ç”Ÿæˆé¢„è®¡å¤ä¹ æ—¶é—´çº¿
 * 
 * ç”¨äºå‰ç«¯å±•ç¤ºæœªæ¥çš„å¤ä¹ è®¡åˆ’
 * 
 * @param {number} currentReviewCount - å½“å‰å¤ä¹ æ¬¡æ•°
 * @param {number} maxItems - è¿”å›çš„æ—¶é—´çº¿é¡¹æ•° (é»˜è®¤5)
 * @returns {Array} æœªæ¥å¤ä¹ è®¡åˆ’
 * 
 * @example
 * generateReviewTimeline(2);
 * // [
 * //   { reviewNumber: 3, intervalDays: 4 },
 * //   { reviewNumber: 4, intervalDays: 7 },
 * //   { reviewNumber: 5, intervalDays: 14 },
 * //   ...
 * // ]
 */
function generateReviewTimeline(currentReviewCount, maxItems = 5) {
    const timeline = [];
    let interval = 1;
    let ef = SM2_PARAMS.INITIAL_EASINESS_FACTOR;

    for (let i = currentReviewCount; i < currentReviewCount + maxItems; i++) {
        if (i < EARLY_INTERVALS.length) {
            interval = EARLY_INTERVALS[i];
        } else {
            interval = Math.round(interval * ef);
        }
        interval = Math.min(interval, SM2_PARAMS.MAX_INTERVAL_DAYS);

        timeline.push({
            reviewNumber: i + 1,
            intervalDays: interval,
        });
    }

    return timeline;
}

/**
 * è·å–ä»Šå¤©çš„æ—¶é—´èŒƒå›´ (UTC)
 * 
 * @returns {Object} { startOfDay, endOfDay, timestamp }
 */
function getTodayRange() {
    const now = new Date();
    const startOfDay = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate(),
        0, 0, 0, 0
    ));
    const endOfDay = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate() + 1,
        0, 0, 0, 0
    ));

    return {
        startOfDay: startOfDay.toISOString(),
        endOfDay: endOfDay.toISOString(),
        timestamp: now.toISOString(),
    };
}

/**
 * è·å–ç®—æ³•ä¿¡æ¯ (ç”¨äºå‰ç«¯å±•ç¤º)
 * 
 * @returns {Object} ç®—æ³•å…ƒä¿¡æ¯
 */
function getAlgorithmInfo() {
    return {
        name: 'Optimized SM-2',
        version: '1.1.0',
        earlyIntervals: EARLY_INTERVALS,
        maxInterval: SM2_PARAMS.MAX_INTERVAL_DAYS,
        description: 'åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–çš„é—´éš”é‡å¤ç®—æ³•',
    };
}

module.exports = {
    calculateSM2Optimized,
    generateReviewTimeline,
    getTodayRange,
    getAlgorithmInfo,
    masteryToQuality,
};
````

## File: cloudbase/functions/shared/validators.js
````javascript
/**
 * å‚æ•°éªŒè¯æ¨¡å—
 * 
 * ç”¨æˆ·ã€è¯æ±‡éªŒè¯åŠé€šç”¨éªŒè¯å·¥å…·
 */

'use strict';

const { userCollection, vocabularyCollection } = require('./database');
const { MasteryLevel } = require('./constants');

/**
 * éªŒè¯ç”¨æˆ·æ˜¯å¦å­˜åœ¨
 * 
 * @param {string} userId - ç”¨æˆ·ID
 * @returns {Promise<Object|null>} ç”¨æˆ·å¯¹è±¡æˆ– null
 */
async function validateUser(userId) {
    if (!userId || typeof userId !== 'string') {
        return null;
    }

    try {
        const { data } = await userCollection
            .where({ userId })
            .limit(1)
            .get();

        return data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('[validateUser] Error:', error);
        return null;
    }
}

/**
 * éªŒè¯è¯æ±‡æ˜¯å¦å­˜åœ¨
 * 
 * @param {string} vocabularyId - è¯æ±‡ID
 * @returns {Promise<Object|null>} è¯æ±‡å¯¹è±¡æˆ– null
 */
async function validateVocabulary(vocabularyId) {
    if (!vocabularyId || typeof vocabularyId !== 'string') {
        return null;
    }

    try {
        const { data } = await vocabularyCollection
            .where({ vocabularyId })
            .limit(1)
            .get();

        return data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('[validateVocabulary] Error:', error);
        return null;
    }
}

/**
 * éªŒè¯æŒæ¡ç¨‹åº¦æ˜¯å¦æœ‰æ•ˆ
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦
 * @returns {boolean} æ˜¯å¦æœ‰æ•ˆ
 */
function isValidMastery(mastery) {
    const validValues = Object.values(MasteryLevel);
    return validValues.includes(mastery);
}

/**
 * éªŒè¯å¹¶è§„èŒƒåŒ–åˆ†é¡µå‚æ•°
 * 
 * @param {number} limit - é™åˆ¶æ•°é‡
 * @param {number} offset - åç§»é‡
 * @param {number} maxLimit - æœ€å¤§é™åˆ¶ (é»˜è®¤100)
 * @returns {Object} éªŒè¯åçš„åˆ†é¡µå‚æ•°
 */
function validatePagination(limit, offset, maxLimit = 100) {
    return {
        limit: Math.min(Math.max(1, parseInt(limit) || 20), maxLimit),
        offset: Math.max(0, parseInt(offset) || 0),
    };
}

/**
 * éªŒè¯å¿…å¡«å­—ç¬¦ä¸²å‚æ•°
 * 
 * @param {string} value - å‚æ•°å€¼
 * @param {string} name - å‚æ•°å (ç”¨äºé”™è¯¯æ¶ˆæ¯)
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateRequiredString(value, name) {
    if (!value || typeof value !== 'string' || value.trim() === '') {
        return {
            valid: false,
            error: `${name} æ˜¯å¿…å¡«å‚æ•°ä¸”ä¸èƒ½ä¸ºç©º`,
        };
    }
    return { valid: true };
}

/**
 * éªŒè¯å¸ƒå°”å‚æ•°
 * 
 * @param {any} value - å‚æ•°å€¼
 * @param {string} name - å‚æ•°å
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateBoolean(value, name) {
    if (typeof value !== 'boolean') {
        return {
            valid: false,
            error: `${name} å¿…é¡»æ˜¯å¸ƒå°”å€¼`,
        };
    }
    return { valid: true };
}
/**
 * é€šç”¨å‚æ•°éªŒè¯å‡½æ•°
 * 
 * @param {Object} params - éœ€è¦éªŒè¯çš„å‚æ•°å¯¹è±¡
 * @param {Array<string>} requiredFields - å¿…éœ€å­—æ®µåˆ—è¡¨
 * @returns {Object} { isValid: boolean, message?: string }
 */
function validateParams(params, requiredFields) {
    const missing = [];

    for (const field of requiredFields) {
        if (params[field] === undefined || params[field] === null || params[field] === '') {
            missing.push(field);
        }
    }

    if (missing.length > 0) {
        return {
            isValid: false,
            message: `ç¼ºå°‘å¿…å¡«å‚æ•°: ${missing.join(', ')}`
        };
    }

    return { isValid: true };
}

module.exports = {
    validateUser,
    validateVocabulary,
    isValidMastery,
    validatePagination,
    validateRequiredString,
    validateBoolean,
    validateParams,
};
````

## File: cloudbase/functions/storage-download/index.js
````javascript
// functions/storage-download/index.js
'use strict';

const cloud = require('wx-server-sdk');
const { createResponse } = require('../shared/response'); // å¤ç”¨å·²æœ‰å·¥å…·

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV,
});

/**
 * HTTP å…¥å£
 * event.body å¯èƒ½æ˜¯ string / object
 */
exports.main = async (event, context) => {
  let body;

  try {
    body =
      typeof event.body === 'string'
        ? JSON.parse(event.body)
        : event.body || {};
  } catch (err) {
    console.error('[storage-download] è§£æ body å¤±è´¥:', err);
    return createResponse(false, null, 'è¯·æ±‚ä½“è§£æå¤±è´¥', 'PARSE_ERROR');
  }

  const { action } = body || {};
  if (!action) {
    return createResponse(false, null, 'ç¼ºå°‘ action å‚æ•°', 'MISSING_ACTION');
  }

  try {
    switch (action) {
      case 'getDownloadUrl':
        return await getDownloadUrl(body);
      case 'batchGetDownloadUrls':
        return await batchGetDownloadUrls(body);
      default:
        return createResponse(
          false,
          null,
          `ä¸æ”¯æŒçš„æ“ä½œ: ${action}`,
          'UNSUPPORTED_ACTION',
        );
    }
  } catch (error) {
    console.error('[storage-download] æœªæ•è·é”™è¯¯:', error);
    return createResponse(
      false,
      null,
      error.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      'SERVER_ERROR',
    );
  }
};

/**
 * å•æ–‡ä»¶ï¼šè·å–ä¸´æ—¶ä¸‹è½½é“¾æ¥
 * data.fileId éœ€æ˜¯ CloudBase çš„ fileIDï¼ˆcloud:// å¼€å¤´ï¼‰
 */
async function getDownloadUrl(data) {
  const { fileId, maxAge = 7200 } = data || {};

  if (!fileId) {
    return createResponse(false, null, 'ç¼ºå°‘ fileId å‚æ•°', 'INVALID_PARAMS');
  }

  try {
    const result = await cloud.getTempFileURL({
      fileList: [fileId],
      maxAge,
    });

    if (!result.fileList || result.fileList.length === 0) {
      return createResponse(false, null, 'æ–‡ä»¶ä¸å­˜åœ¨', 'FILE_NOT_FOUND');
    }

    const fileInfo = result.fileList[0];

    if (fileInfo.status !== 0) {
      return createResponse(
        false,
        null,
        fileInfo.errmsg || 'è·å–ä¸‹è½½é“¾æ¥å¤±è´¥',
        'DOWNLOAD_URL_ERROR',
      );
    }

    const now = Date.now();
    return createResponse(
      true,
      {
        fileId: fileInfo.fileID,
        downloadUrl: fileInfo.tempFileURL,
        maxAge,
        expiresAt: new Date(now + maxAge * 1000).toISOString(),
      },
      'è·å–ä¸‹è½½é“¾æ¥æˆåŠŸ',
    );
  } catch (error) {
    console.error('[getDownloadUrl] error:', error);
    return createResponse(
      false,
      null,
      error.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      'SERVER_ERROR',
    );
  }
}

/**
 * æ‰¹é‡ï¼šè·å–ä¸´æ—¶ä¸‹è½½é“¾æ¥ï¼ˆæœ€å¤š 50 ä¸ªï¼‰
 */
async function batchGetDownloadUrls(data) {
  const { fileIds, maxAge = 7200 } = data || {};

  if (!Array.isArray(fileIds) || fileIds.length === 0) {
    return createResponse(
      false,
      null,
      'fileIds å¿…é¡»æ˜¯éç©ºæ•°ç»„',
      'INVALID_PARAMS',
    );
  }

  if (fileIds.length > 50) {
    return createResponse(
      false,
      null,
      'å•æ¬¡æœ€å¤šæ”¯æŒ 50 ä¸ªæ–‡ä»¶',
      'TOO_MANY_FILES',
    );
  }

  try {
    const result = await cloud.getTempFileURL({
      fileList: fileIds,
      maxAge,
    });

    const files = (result.fileList || []).map((f) => ({
      fileId: f.fileID,
      downloadUrl: f.status === 0 ? f.tempFileURL : null,
      status: f.status === 0 ? 'success' : 'failed',
      error: f.status === 0 ? null : f.errmsg,
    }));

    const success = files.filter((f) => f.status === 'success').length;
    const now = Date.now();

    return createResponse(
      true,
      {
        files,
        summary: {
          total: files.length,
          success,
          failed: files.length - success,
        },
        maxAge,
        expiresAt: new Date(now + maxAge * 1000).toISOString(),
      },
      `è·å– ${success}/${files.length} ä¸ªæ–‡ä»¶ä¸‹è½½é“¾æ¥æˆåŠŸ`,
    );
  } catch (error) {
    console.error('[batchGetDownloadUrls] error:', error);
    return createResponse(
      false,
      null,
      error.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      'SERVER_ERROR',
    );
  }
}
````

## File: cloudbase/functions/storage-download/package.json
````json
{
  "name": "storage-download",
  "version": "1.0.0",
  "description": "Storage download cloud function",
  "main": "index.js",
  "dependencies": {
    "wx-server-sdk": "~2.6.3",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2"
  }
}
````

## File: cloudbase/functions/user-register/package.json
````json
{
  "name": "user-register",
  "version": "1.0.0",
  "description": "User registration cloud function",
  "main": "index.js",
  "dependencies": {
    "wx-server-sdk": "~2.6.3",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2"
  }
}
````

## File: cloudbase/functions/user-reset-password/package.json
````json
{
  "name": "user-reset-password",
  "version": "1.0.0",
  "description": "User password reset cloud function",
  "main": "index.js",
  "dependencies": {
    "wx-server-sdk": "~2.6.3"
  }
}
````

## File: cloudbase/functions/user-update-profile/package.json
````json
{
  "name": "user-update-profile",
  "version": "1.0.0",
  "description": "User profile update cloud function",
  "main": "index.js",
  "dependencies": {
    "wx-server-sdk": "~2.6.3"
  }
}
````

## File: cloudbase/fix-cloud-functions.sh
````bash
#!/bin/bash
set -e

echo "========================================="
echo "ğŸš€ Cloud Functions Automatic Cleanup Tool"
echo "========================================="

BASE_DIR="./cloudbase/functions"

echo ""
echo "ğŸ“Œ Step 1: åˆ é™¤æ‰€æœ‰ node_modules æ–‡ä»¶å¤¹..."
find $BASE_DIR -type d -name "node_modules" -prune -exec rm -rf {} +

echo "âœ” å·²åˆ é™¤æœ¬åœ° node_modules"

echo ""
echo "ğŸ“Œ Step 2: åˆ é™¤ä¸åº”è¯¥ä¸Šä¼ çš„æ–‡ä»¶ï¼ˆ.DS_Storeã€æ„å»ºäº§ç‰©ï¼‰"
find $BASE_DIR -name ".DS_Store" -delete
find $BASE_DIR -name "*.log" -delete
find $BASE_DIR -name "*.tmp" -delete
find $BASE_DIR -name "dist" -prune -exec rm -rf {} +
find $BASE_DIR -name ".turbo" -prune -exec rm -rf {} +

echo "âœ” æ¸…ç†å®Œæˆ"

echo ""
echo "ğŸ“Œ Step 3: è‡ªåŠ¨ä¸ºæ¯ä¸ªäº‘å‡½æ•°ç”Ÿæˆ package.json"

FUNCTIONS=$(find $BASE_DIR -maxdepth 1 -mindepth 1 -type d)

for FN in $FUNCTIONS; do
  if [ ! -f "$FN/index.js" ]; then
    echo "âš ï¸ è­¦å‘Š: $FN ç¼ºå°‘ index.jsï¼Œè·³è¿‡ package.json ç”Ÿæˆ"
    continue
  fi

  PKG="$FN/package.json"

  echo "ğŸ“¦ ç”Ÿæˆ package.json â†’ $PKG"

  cat > "$PKG" <<EOF
{
  "name": "$(basename $FN)",
  "version": "1.0.0",
  "description": "CloudBase Function: $(basename $FN)",
  "main": "index.js",
  "dependencies": {
    "wx-server-sdk": "^2.10.0"
  }
}
EOF

done

echo "âœ” package.json åˆ›å»ºå®Œæˆ"

echo ""
echo "ğŸ“Œ Step 4: ä¿®å¤ cloudbaserc.jsonï¼ˆè®¾ç½® runtime & å®‰è£…ä¾èµ–ï¼‰"

cat > cloudbaserc.json <<EOF
{
  "functions": [
    {
      "name": "alphabet",
      "timeout": 10,
      "runtime": "Nodejs18.15",
      "installDependency": true
    },
    {
      "name": "learn-vocab",
      "timeout": 10,
      "runtime": "Nodejs18.15",
      "installDependency": true
    },
    {
      "name": "memory-engine",
      "timeout": 10,
      "runtime": "Nodejs18.15",
      "installDependency": true
    }
  ]
}
EOF

echo "âœ” cloudbaserc.json å·²æ›´æ–°"

echo ""
echo "ğŸ“Œ Step 5: æ£€æŸ¥é”™è¯¯ require è·¯å¾„ï¼ˆè·¨å‡½æ•° require ä¼šå¯¼è‡´éƒ¨ç½²å¤±è´¥ï¼‰"

BAD_IMPORTS=$(grep -R "\.\./shared" -n $BASE_DIR || true)

if [ -n "$BAD_IMPORTS" ]; then
  echo "âŒ æ£€æµ‹åˆ°è·¨å‡½æ•° require é”™è¯¯:"
  echo "$BAD_IMPORTS"
  echo "â— è¯·å°† shared ä»£ç å¤åˆ¶åˆ°æ¯ä¸ªå‡½æ•° utils/ ä¸‹"
else
  echo "âœ” æœªæ£€æµ‹åˆ°è·¨å‡½æ•° require"
fi

echo ""
echo "========================================="
echo "ğŸ‰  Cloud Functions Cleanup Completed!"
echo "========================================="
````

## File: cloudbase/package.json
````json
{
  "name": "cloudbase",
  "version": "1.0.0",
  "description": "",
  "main": "initAlphabetLessonsAndRules.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "wx-server-sdk": "^3.0.1"
  }
}
````

## File: docs/project-freeze/courses-and-learningstore-spec.md
````markdown
# è¯¾ç¨‹å…¥å£ & LearningStore æœ€ç»ˆè§„æ ¼è¯´æ˜ï¼ˆCourses + LearningStore Spec, Freeze V2.0.1ï¼‰

> ç›®å½•ï¼š`docs/project-freeze/courses-and-learningstore-spec.md`  
> é€‚ç”¨èŒƒå›´ï¼š**Courses æ ‡ç­¾é¡µ + è¯¾ç¨‹é…ç½® JSON + LearningStore å…¨å±€å­¦ä¹ ç®¡ç†å±‚**  
> ç›®æ ‡ï¼šå†»ç»“è¯¾ç¨‹å…¥å£å±‚çš„èŒè´£åˆ’åˆ†ä¸æ•°æ®ç»“æ„ï¼Œä¸ºåç»­ Vocabulary / Alphabet / AI æ¨¡å—æä¾›ç¨³å®šå…¥å£ã€‚

---

## 1. æ¨¡å—å®šä½ä¸è¾¹ç•Œ

### 1.1 Courses æ¨¡å—èŒè´£

- ä¸€è‡´çš„è¯¾ç¨‹å…¥å£ï¼š
  - åœ¨ `app/(tabs)/courses.tsx` ä¸­å±•ç¤ºæ‰€æœ‰**å¯é€‰å­¦ä¹ é¡¹ç›®**ï¼š
    - å­—æ¯é¡¹ç›®ï¼š`assets/courses/alphabetCourses.json`ï¼›
    - å•è¯é¡¹ç›®ï¼š`assets/courses/courses.json`ï¼ˆåŸºç¡€æ³°è¯­ 1/2/3/4ï¼‰ã€‚
- ç»Ÿä¸€çš„â€œå¼€å§‹/ç»§ç»­å­¦ä¹ â€è¡Œä¸ºï¼š
  - å¯¹äºå•è¯è¯¾ç¨‹ï¼šæ ¹æ®æ˜¯å¦å·²è®¾ç½®æ¯æ—¥è®¡åˆ’ï¼Œè·³è½¬åˆ° `/learning` æˆ– `/learning/setup`ï¼›
  - å¯¹äºå­—æ¯è¯¾ç¨‹ï¼šè·³è½¬åˆ°å­—æ¯æ¨¡å—å…¥å£ `/alphabet`ï¼ˆå†ç”±å­—æ¯æ¨¡å—å†…éƒ¨å†³å®šåç»­æµç¨‹ï¼‰ã€‚
- å±•ç¤ºæ¯ä¸ªè¯¾ç¨‹çš„æ•´ä½“è¿›åº¦ï¼ˆå·²å®Œæˆå­—æ¯/å•è¯æ•°é‡ï¼‰ï¼Œæ•°æ®æ¥æºï¼š
  - `moduleAccessStore.userProgress`ï¼ˆåç«¯ `memory-engine.getUserProgress` / `learn-vocab`ï¼‰ã€‚

### 1.2 LearningStore èŒè´£ï¼ˆç›®æ ‡å½¢æ€ï¼‰

> è¯´æ˜ï¼šå½“å‰ `src/stores/learningStore.ts` æ˜¯æ—§ç‰ˆ demoï¼ŒåŒ…å«å¤§é‡å†™æ­»å€¼ã€‚  
> æœ¬è§„èŒƒæè¿°çš„æ˜¯ **ç›®æ ‡è®¾è®¡**ï¼Œåç»­éœ€è¦ refactor ä½¿å®ç°ä¸æœ¬è§„èŒƒå¯¹é½ã€‚

- å…¨å±€â€œå­¦ä¹ ä»ªè¡¨ç›˜â€çš„çŠ¶æ€æºï¼š
  - å½“å‰ä¸»è¯¾ç¨‹ `currentCourseId`ï¼ˆä¾‹å¦‚ `thai_1`ï¼‰ï¼›
  - å½“å‰å­—æ¯é¡¹ç›® `currentAlphabetProgramId`ï¼ˆä¾‹å¦‚ `alphabet` / `alphabet_core_v1`ï¼‰ï¼›
  - å…¨å±€ç»Ÿè®¡ï¼š`streakDays`, `totalStudyMinutes`, `lastStudyAt` ç­‰ã€‚
- ä¸å…·ä½“æ¨¡å—çš„å…³ç³»ï¼š
  - ä¸ç›´æ¥å‚ä¸å­—æ¯æˆ–å•è¯çš„ SRS é€»è¾‘ï¼›
  - åªè®°å½•â€œç”¨æˆ·æ­£åœ¨å­¦å“ªé—¨è¯¾â€å’Œâ€œæ•´ä½“å­¦äº†å¤šä¹…â€ç­‰å®è§‚ä¿¡æ¯ï¼›
  - é¦–é¡µ Hero Cardã€Profile æˆå°±ç³»ç»Ÿä»è¿™é‡Œè¯»å–ä¿¡æ¯ã€‚

### 1.3 æ¨¡å—è¾¹ç•Œ

- Courses æ¨¡å— **ä¸è´Ÿè´£**ï¼š
  - å†³å®šå…·ä½“å­—æ¯/å•è¯é˜Ÿåˆ—ï¼ˆäº¤ç»™ `alphabetStore` / `vocabularyStore` + `memory-engine`/`learn-vocab`ï¼‰ï¼›
  - ä¿®æ”¹ `memory_status` æˆ– `user_*_progress`ã€‚
- LearningStore **ä¸è´Ÿè´£**ï¼š
  - å•ä¸ªå­—æ¯/å•è¯çš„è¿›åº¦ï¼ˆå·²æŒæ¡å¤šå°‘ä¸ªå…·ä½“å®ä½“ï¼‰ï¼›
  - SRS ç®—æ³•æˆ–ä¸‹æ¬¡å¤ä¹ æ—¶é—´ã€‚

---

## 2. ç›¸å…³ä»£ç  / é…ç½®æ€»è§ˆ

### 2.1 è¯¾ç¨‹é…ç½® JSON

- `assets/courses/courses.json`ï¼ˆå•è¯è¯¾ç¨‹ï¼Œå¤§è¯¾ç¨‹ï¼‰

```json
[
  {
    "id": "thai_1",
    "source": "Thai_1",
    "title": "åŸºç¡€æ³°è¯­1",
    "description": "ä»é›¶å¼€å§‹å­¦ä¹ æ³°è¯­ï¼ŒæŒæ¡ä¸€ç‚¹ç‚¹è¯æ±‡ã€‚",
    "level": "å…¥é—¨",
    "image": "ThaiBase_1.png",
    "category": "word",
    "lessons": 20
  },
  ...
]
```

- `assets/courses/alphabetCourses.json`ï¼ˆå­—æ¯é¡¹ç›®ï¼Œå¤§è¯¾ç¨‹ï¼‰

```json
[
  {
    "id": "alphabet",
    "source": "alphabet",
    "title": "æ³°è¯­å­—æ¯è¡¨",
    "description": "ä»44ä¸ªè¾…éŸ³åˆ°å…ƒéŸ³ä¸å£°è°ƒï¼Œé€æ­¥æŒæ¡æ³°è¯­è¯»å†™åŸºç¡€ã€‚",
    "level": "å…¥é—¨",
    "image": "thai_alphabet.png",
    "category": "letter",
    "lessons": 44
  }
]
```

> çº¦å®šï¼š
> - `id`ï¼šç”¨äº UI å’Œæœ¬åœ°é€»è¾‘ï¼›
> - `source`ï¼šä¼ ç»™åç«¯ / vocabularyStore çš„è¯¾ç¨‹æºæ ‡è¯†ï¼ˆå¦‚ `Thai_1`ï¼‰ï¼›
> - `category`ï¼šå†³å®šæ¨¡å—ç±»å‹ï¼š
>   - `'letter'` â†’ å­—æ¯æ¨¡å—ï¼›
>   - `'word'`   â†’ è¯æ±‡æ¨¡å—ï¼›
>   - `'sentence'` / `'article'` é¢„ç•™ç»™åç»­æ¨¡å—ã€‚

### 2.2 Courses Screenï¼ˆapp/(tabs)/courses.tsxï¼‰

- æ ¸å¿ƒç±»å‹ï¼š

```ts
type CourseItem = {
  id: string;
  source: string;
  title: string;
  description: string;
  level: string;
  image: string;
  category: string;   // 'letter' | 'word' | ...
  lessons: number;
};

type CourseWithImage = CourseItem & {
  imageSource: ImageSourcePropType;
};
```

- è¯¾ç¨‹åˆ—è¡¨æ„é€ ï¼š

```ts
const COURSES: CourseWithImage[] = (
  [
    ...(alphabetCourses as CourseItem[]),
    ...(coursesData as CourseItem[]),
  ]
).map((course) => ({
  ...course,
  imageSource: COURSE_IMAGE_MAP[course.image] || COURSE_IMAGE_MAP.default,
}));
```

- ä¾èµ–çš„ Storeï¼š

```ts
const { currentCourseSource, startCourse } = useVocabularyStore();
const { hasDailyLimit } = useLearningPreferenceStore();
const { userProgress, getUserProgress } = useModuleAccessStore();
```

> æ³¨æ„ï¼šå½“å‰å®ç°ä¸­ **å°šæœªä½¿ç”¨ learningStore**ï¼›  
> åç»­å¯åœ¨æœ¬æ–‡ä»¶ä¸­å¢åŠ å¯¹ `useLearningStore` çš„è°ƒç”¨ï¼ˆè§ç¬¬ 4 èŠ‚ï¼‰ã€‚

### 2.3 AlphabetCourseCardï¼ˆsrc/components/courses/AlphabetCourseCard.tsxï¼‰

- Propsï¼š

```ts
interface AlphabetCourseCardProps {
  course: {
    id: string;
    source: string;
    title: string;
    description: string;
    level: string;
    imageSource: ImageSourcePropType;
    lessons: number;
  };
  isCurrent: boolean;
  progress?: {
    completed: number;
    total: number;
  };
}
```

- è¡Œä¸ºï¼š
  - å±•ç¤ºå°é¢å›¾ã€æ ‡é¢˜ã€ç­‰çº§ã€æè¿°ï¼›
  - è‹¥æœ‰ `progress`ï¼Œæ˜¾ç¤ºè¿›åº¦æ¡ä¸ â€œå·²å®Œæˆ/æ€»æ•°â€ï¼›
  - ç‚¹å‡»ã€Œå¼€å§‹å­¦ä¹  / ç»§ç»­å­¦ä¹ ã€æŒ‰é’®ï¼š

```ts
<Pressable
  style={[styles.startBtn, isCurrent && styles.activeStartBtn]}
  onPress={() => router.push('/alphabet')}
>
  <Text>å¼€å§‹å­¦ä¹  / ç»§ç»­å­¦ä¹ </Text>
</Pressable>
```

> å½“å‰ AlphabetCourseCard åªè´Ÿè´£ **è·³è½¬åˆ° `/alphabet`**ï¼Œ  
> ä¸è´Ÿè´£è®¾ç½®å½“å‰å­—æ¯ Program æˆ–è°ƒç”¨ learningStoreã€‚  
> è¿™éƒ¨åˆ†å°†åœ¨æœªæ¥ç‰ˆæœ¬ä¸­æ¥å…¥ `useLearningStore.setCurrentAlphabetProgram`ã€‚

### 2.4 LearningStoreï¼ˆå½“å‰å®ç° & ç›®æ ‡å·®å¼‚ï¼‰

- ç°æœ‰æ–‡ä»¶ï¼š`src/stores/learningStore.ts`

```ts
interface LearningState {
  currentCourse: Course | null;          // æ—§ï¼šæ•´ä¸ª Course å¯¹è±¡
  progress: LearningProgress | null;     // æ—§ï¼šåŒ…å«å„ç§å†™æ­»å­—æ®µ
  completedContent: string[];

  setCourse: (course: Course) => void;
  updateProgress: (contentType: string, score: number) => void;
  getCompletionRate: () => number;
  resetLearning: () => void;
}
```

> ç°çŠ¶é—®é¢˜ï¼š
> - `setCourse` ä¼šç”Ÿæˆä¸€ä»½å†™æ­»æ•°æ®ï¼ˆuserId='user_1', completedAlphabets=30 ç­‰ï¼‰ï¼Œä¸åæ˜ çœŸå®è¿›åº¦ï¼›
> - é¡¹ç›®ä¸­å‡ ä¹æœªä½¿ç”¨ `setCourse`ï¼Œä»…åœ¨ Profile é¡µè¯» `progress` åšæˆå°±å±•ç¤ºï¼›
> - ä¸ memory-engine / moduleAccessStore çš„çœŸå®è¿›åº¦æœ‰å‰²è£‚ã€‚

**ç›®æ ‡è®¾è®¡ï¼ˆå»ºè®®é‡æ„åå½¢æ€ï¼‰ï¼š**

```ts
interface LearningState {
  // å½“å‰â€œä¸»è¯¾ç¨‹â€ï¼Œç”¨äºé¦–é¡µ / Profile å±•ç¤º
  currentCourseId: string | null;              // å¦‚ 'thai_1'

  // å½“å‰å­—æ¯ Programï¼ˆå¤§è¯¾ç¨‹ï¼‰
  currentAlphabetProgramId: string | null;     // å¦‚ 'alphabet'

  // å…¨å±€å­¦ä¹ ç»Ÿè®¡
  streakDays: number;                          // è¿ç»­æ‰“å¡å¤©æ•°
  totalStudyMinutes: number;                   // æ€»å­¦ä¹ æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
  lastStudyAt: string | null;                  // æœ€è¿‘ä¸€æ¬¡å­¦ä¹ æ—¶é—´ ISO å­—ç¬¦ä¸²

  setCurrentCourse: (courseId: string) => void;
  setCurrentAlphabetProgram: (programId: string) => void;
  registerStudySession: (params: {
    module: 'letter' | 'word' | 'sentence' | 'article';
    minutes: number;
    finishedLessonId?: string;
  }) => void;

  resetLearningDashboard: () => void;
}
```

> é‡æ„åŸåˆ™ï¼š
> - LearningStore ä¸å†ä¿å­˜â€œè™šå‡çš„è¯¦ç»†è¿›åº¦â€ï¼›  
> - åªè´Ÿè´£**â€œå½“å‰åœ¨å­¦å“ªé—¨è¯¾ + å…¨å±€æ—¶é•¿/æ‰“å¡â€**ï¼›  
> - è¯¦ç»†è¿›åº¦ä»¥ `moduleAccessStore.userProgress` + `memory_status` / `user_*_progress` ä¸ºå‡†ã€‚

---

## 3. Courses é¡µé¢é€»è¾‘ä¸ Store äº¤äº’

### 3.1 åˆ†ç±» / æœç´¢ / è¿‡æ»¤

```ts
const CATEGORIES = [
  { id: 'all',    label: 'å…¨éƒ¨', icon: Grid },
  { id: 'letter', label: 'å­—æ¯', icon: Type },
  { id: 'word',   label: 'å•è¯', icon: BookOpen },
];

const [activeCategory, setActiveCategory] = useState('all');
const [searchQuery, setSearchQuery] = useState('');

const filteredCourses = useMemo(() => {
  return COURSES.filter(course => {
    const matchesCategory = activeCategory === 'all' || course.category === activeCategory;
    const matchesSearch =
      course.title.includes(searchQuery) || course.description.includes(searchQuery);
    return matchesCategory && matchesSearch;
  });
}, [activeCategory, searchQuery]);
```

- åˆ†ç±» Chip æ§åˆ¶ `activeCategory`ï¼›
- æœç´¢æ¡†æ§åˆ¶ `searchQuery`ï¼›
- `filteredCourses` æ˜¯ä¹‹åæ¸²æŸ“çš„å”¯ä¸€æ•°æ®æºã€‚

### 3.2 è¯¾ç¨‹è¿›åº¦ï¼ˆgetCourseProgressï¼‰

```ts
const { userProgress, getUserProgress } = useModuleAccessStore();

useEffect(() => {
  if (!userProgress) {
    getUserProgress().catch((err) => console.warn('Failed to fetch user progress', err));
  }
}, [userProgress, getUserProgress]);

const getModuleType = (course: CourseWithImage): ModuleType => {
  switch (course.category) {
    case 'letter':   return 'letter';
    case 'sentence': return 'sentence';
    case 'article':  return 'article';
    default:         return 'word';
  }
};

const getCourseProgress = (course: CourseWithImage) => {
  if (!userProgress) return undefined;
  const moduleType = getModuleType(course);
  if (moduleType === 'letter') {
    return {
      completed: userProgress.letterMasteredCount,
      total: userProgress.letterTotalCount || course.lessons,
    };
  }
  if (moduleType === 'word') {
    return {
      completed: userProgress.wordMasteredCount,
      total: userProgress.wordTotalCount || course.lessons,
    };
  }
  return undefined;
};
```

- è¯¾ç¨‹å¡ç‰‡ä¸Šçš„è¿›åº¦æ¡åªä½¿ç”¨ `userProgress` çš„èšåˆå­—æ®µï¼›
- ä¸å…³å¿ƒ memory-engine å†…éƒ¨çš„ç»†èŠ‚ï¼›  
- å¯¹ sentence/article ç±»å‹å½“å‰è¿”å› `undefined`ï¼Œå³æš‚ä¸æ˜¾ç¤ºè¿›åº¦ã€‚

### 3.3 å•è¯è¯¾ç¨‹ Start/Continue é€»è¾‘

```ts
const { currentCourseSource, startCourse } = useVocabularyStore();
const { hasDailyLimit } = useLearningPreferenceStore();

const getModuleType = (course): ModuleType => { ... }; // å¦‚ä¸Š

const handleStartLearning = (course: CourseWithImage) => {
  return () => {
    const moduleType = getModuleType(course);
    const needsDailySetup = !hasDailyLimit(moduleType);

    // è‹¥å½“å‰å·²ç»åœ¨å­¦åŒä¸€ä¸ª sourceï¼Œç›´æ¥è·³è½¬
    if (currentCourseSource === course.source) {
      router.push({
        pathname: needsDailySetup ? '/learning/setup' : '/learning',
        params: { module: moduleType, source: course.source },
      });
      return;
    }

    // å¦åˆ™å¼¹çª—ç¡®è®¤åˆ‡æ¢è¯¾ç¨‹
    setPendingCourse(course);
    setModalVisible(true);
  };
};

const proceedToCourse = async (course: CourseWithImage) => {
  const moduleType = getModuleType(course);
  const needsDailySetup = !hasDailyLimit(moduleType);

  await startCourse(course.source);  // vocabularyStore å†…éƒ¨ä¼šè®°ä½ currentCourseSource
  setModalVisible(false);
  setPendingCourse(null);

  router.push({
    pathname: needsDailySetup ? '/learning/setup' : '/learning',
    params: { module: moduleType, source: course.source },
  });
};
```

- `CourseCard`ï¼ˆå•è¯è¯¾ç¨‹å¡ç‰‡ï¼‰çš„ `onStart` ä¼šç»‘å®š `handleStartLearning(course)`ï¼›
- `startCourse(source)` æ˜¯è¯æ±‡æ¨¡å—çš„å…¥å£ï¼Œç”¨äºåˆå§‹åŒ–è¯æ±‡å­¦ä¹ ä¸Šä¸‹æ–‡ã€‚

### 3.4 å­—æ¯è¯¾ç¨‹ Start/Continue é€»è¾‘

```tsx
{filteredCourses.map((course) => {
  const isCurrent = currentCourseSource === course.source;
  const moduleType = getModuleType(course);
  const progress = getCourseProgress(course);

  // å­—æ¯è¯¾ç¨‹ï¼šä½¿ç”¨ AlphabetCourseCardï¼Œç›´æ¥è¿›å…¥ /alphabet æµç¨‹
  if (course.category === 'letter') {
    return (
      <AlphabetCourseCard
        key={course.id}
        course={course}
        isCurrent={isCurrent}
        progress={progress}
      />
    );
  }

  // å•è¯è¯¾ç¨‹ï¼šä½¿ç”¨æ ‡å‡† CourseCard
  ...
})}
```

- å½“å‰ `AlphabetCourseCard` ä¸è°ƒç”¨ `startCourse` æˆ– `learningStore`ï¼š
  - å®ƒåªåœ¨ç‚¹å‡»æ—¶ `router.push('/alphabet')`ï¼›
  - å­—æ¯æ¨¡å—å†…éƒ¨æ ¹æ®è‡ªèº« Store + memory-engine å†³å®šä»Šæ—¥è¯¾ç¨‹ã€‚

**å»ºè®®çš„æœªæ¥æ‰©å±•ï¼ˆä¸ LearningStore é›†æˆï¼‰ï¼š**

- åœ¨ `AlphabetCourseCard` çš„ç‚¹å‡» handler ä¸­å¢åŠ ï¼š

```ts
const { setCurrentAlphabetProgram } = useLearningStore();

onPress={() => {
  setCurrentAlphabetProgram(course.id);  // ä¾‹å¦‚ 'alphabet'
  router.push('/alphabet');
}}
```

- è¿™æ ·é¦–é¡µ / Profile å°±å¯ä»¥æ˜¾ç¤ºâ€œå½“å‰å­—æ¯é¡¹ç›®ï¼šæ³°è¯­å­—æ¯è¡¨â€ï¼Œå®ç°è·¨æ¨¡å—å…±äº«ã€‚

---

## 4. LearningStore ä¸å…¶ä»–æ¨¡å—çš„é›†æˆå»ºè®®

> æœ¬èŠ‚æè¿°çš„æ˜¯â€œç›®æ ‡é›†æˆæ–¹å¼â€ï¼Œå…·ä½“å®ç°éœ€ refactor ç°æœ‰ `learningStore`ã€‚

### 4.1 åœ¨ Courses é¡µä¸­è®¾ç½®å½“å‰è¯¾ç¨‹ / å­—æ¯é¡¹ç›®

- å•è¯è¯¾ç¨‹ï¼š

```ts
const { setCurrentCourse } = useLearningStore();

const proceedToCourse = async (course: CourseWithImage) => {
  const moduleType = getModuleType(course);
  const needsDailySetup = !hasDailyLimit(moduleType);

  await startCourse(course.source);
  setCurrentCourse(course.id);          // 'thai_1' / 'thai_2' ...

  router.push({
    pathname: needsDailySetup ? '/learning/setup' : '/learning',
    params: { module: moduleType, source: course.source },
  });
};
```

- å­—æ¯è¯¾ç¨‹ï¼š

```ts
<AlphabetCourseCard
  ...
  onPress={() => {
    setCurrentAlphabetProgram(course.id);  // 'alphabet'
    router.push('/alphabet');
  }}
/>
```

> æ³¨æ„ï¼šAlphabetCourseCard ç›®å‰æ²¡æœ‰ `onPress` propsï¼Œ  
> å¯ä»¥åœ¨é‡æ„æ—¶æ·»åŠ  `onStart`ï¼Œå’Œ `CourseCard` ä¿æŒä¸€è‡´ã€‚

### 4.2 åœ¨å­¦ä¹ ç»“æŸæ—¶æ›´æ–°æ‰“å¡ / æ—¶é•¿

- åœ¨å­—æ¯æ¨¡å— / å•è¯æ¨¡å—çš„â€œå®Œæˆä¸€è¯¾â€é€»è¾‘ä¸­è°ƒç”¨ï¼š

```ts
const { registerStudySession } = useLearningStore();

registerStudySession({
  module: 'letter',        // æˆ– 'word'
  minutes: sessionMinutes, // æœ¬æ¬¡å­¦ä¹ æ—¶é—´
  finishedLessonId: lessonId,
});
```

- `registerStudySession` å†…éƒ¨å¯ä»¥ï¼š
  - æ ¹æ® `lastStudyAt` ä¸å½“å‰æ—¶é—´åˆ¤æ–­æ˜¯å¦è·¨æ—¥ï¼š
    - è‹¥è·¨æ—¥åˆ™ streakDays++ï¼›
  - ç´¯åŠ  `totalStudyMinutes`ï¼›
  - æ›´æ–° `lastStudyAt` ä¸ºå½“å‰æ—¶é—´ã€‚

### 4.3 é¦–é¡µ / Profile ä¸­çš„ä½¿ç”¨æ–¹å¼ï¼ˆç¤ºæ„ï¼‰

- é¦–é¡µ HeroCardï¼š

```ts
const { currentCourseId, currentAlphabetProgramId, streakDays, totalStudyMinutes } = useLearningStore();

// é€šè¿‡ courses.json / alphabetCourses.json æŸ¥æ‰¾å½“å‰è¯¾ç¨‹ä¿¡æ¯ï¼š
const heroCourse = useMemo(
  () => courses.find(c => c.id === currentCourseId),
  [currentCourseId],
);
```

- Profile æˆå°±å‹‹ç« ï¼š
  - ä½¿ç”¨ `streakDays` å†³å®šæ˜¯å¦è§£é”â€œè¿ç»­å­¦ä¹  7 å¤©â€ç­‰å¾½ç« ï¼›
  - ä½¿ç”¨ `totalStudyMinutes` ç»Ÿè®¡æ€»å­¦ä¹ æ—¶é•¿æ®µä½ï¼ˆä¾‹å¦‚ 10 å°æ—¶ã€50 å°æ—¶ç­‰ï¼‰ã€‚

---

## 5. ASCII è°ƒç”¨å›¾æ€»è§ˆ

ä¸ºäº†æ–¹ä¾¿ä»æ•´ä½“ä¸Šç†è§£ Courses + LearningStore ä¸å…¶ä»–æ¨¡å—çš„å…³ç³»ï¼Œæœ¬èŠ‚ç»™å‡ºä¸€å¼ â€œæ¨ªå‘ ASCII è°ƒç”¨å›¾â€ã€‚

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç”¨æˆ·ç‚¹å‡» Courses Tab                                      â”‚
â”‚  app/(tabs)/courses.tsx                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â”‚ æ¸²æŸ“è¯¾ç¨‹åˆ—è¡¨ï¼ˆCOURSES: alphabetCourses + courses.jsonï¼‰
                â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ å­—æ¯è¯¾ç¨‹å¡ AlphabetCourseCard â”‚      â”‚ å•è¯è¯¾ç¨‹å¡ CourseCard      â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚ onPress                         â”‚ onStart
                â”‚                                 â”‚
                â–¼                                 â–¼
      router.push('/alphabet')          handleStartLearning(course)
                                               â”‚
                                               â–¼
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚ vocabularyStore.startCourse(source)â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                               â”‚
                                               â–¼
                          router.push('/learning' or '/learning/setup')

ï¼ˆæœªæ¥é›†æˆ LearningStore åï¼‰

  AlphabetCourseCard.onPress:
    setCurrentAlphabetProgram(course.id)  // è®°å½•å½“å‰å­—æ¯é¡¹ç›®
    router.push('/alphabet')

  proceedToCourseï¼ˆå•è¯ï¼‰:
    startCourse(course.source)
    setCurrentCourse(course.id)           // è®°å½•å½“å‰ä¸»è¯¾ç¨‹
    router.push('/learning...')
```

---

## 6. å®ç°ä¸æ‰©å±•æ³¨æ„äº‹é¡¹

1. **LearningStore åªåšâ€œä»ªè¡¨ç›˜â€ï¼Œä¸åš SRS**  
   - ç»†ç²’åº¦è¿›åº¦å’Œè®°å¿†æ›²çº¿å®Œå…¨äº¤ç»™ `memory-engine` + `alphabetStore` / `vocabularyStore`ï¼›
   - LearningStore ä¸ä¿å­˜â€œå®Œæˆå¤šå°‘å­—æ¯/å•è¯â€è¿™ç§æ˜ç»†ã€‚

2. **Courses é¡µåªè´Ÿè´£å…¥å£ï¼Œä¸åšä¸šåŠ¡å†³ç­–**  
   - è¯¾ç¨‹å¡ç‰‡åªå†³å®šè·³åˆ°å“ªä¸ªæ¨¡å—è·¯ç”±ï¼ˆ/alphabet /learningï¼‰ï¼Œå¹¶è°ƒç”¨å¯¹åº” Store çš„å…¥å£æ–¹æ³•ï¼›
   - å…·ä½“æ¨¡å—å†…éƒ¨å¦‚ä½•å­¦ä¹ ã€å¦‚ä½•è¯„ä¼°ç”±å„è‡ªæ¨¡å—çš„ Spec å†³å®šã€‚

3. **æ‰€æœ‰è¯¾ç¨‹é…ç½®ç»Ÿä¸€é›†ä¸­åœ¨ assets/courses ä¸‹**  
   - æ–°å¢è¯¾ç¨‹æ—¶ï¼Œå¿…é¡»ï¼š
     - åœ¨ `courses.json` æˆ– `alphabetCourses.json` ä¸­æ·»åŠ æ¡ç›®ï¼›
     - ç¡®ä¿ `image` èƒ½åœ¨ `COURSE_IMAGE_MAP` ä¸­æ‰¾åˆ°å¯¹åº”å›¾ç‰‡ï¼›
     - åœ¨æœ¬ Spec æ–‡æ¡£ä¸­å¤‡æ³¨æ–°å¢è¯¾ç¨‹çš„ç”¨é€”ã€‚

4. **æœªæ¥æ‰©å±• AI æ¨¡å—æ—¶ï¼Œä»é€šè¿‡ Courses é¡µå…¥å£**  
   - å¯åœ¨ `courses.json` ä¸­æ–°å¢ `category: 'ai'` çš„è¯¾ç¨‹é¡¹ç›®ï¼›
   - Courses é¡µæ ¹æ® category è·³è½¬åˆ° `/ai/...` è·¯ç”±ï¼Œå¹¶ä½¿ç”¨ç‹¬ç«‹çš„ aiStoreï¼›
   - ä¸æ”¹å˜æ—¢æœ‰ letter / word æµç¨‹ã€‚

---

æœ¬è§„æ ¼æ–‡æ¡£å†»ç»“äº† Courses + LearningStore åœ¨é¡¹ç›®ä¸­çš„è§’è‰²ã€æ•°æ®ç»“æ„ä¸è°ƒç”¨å…³ç³»ã€‚
````

## File: docs/project-freeze/frontend-shell-module-spec.md
````markdown
# å‰ç«¯å£³å±‚ä¸å±•ç¤ºæ¨¡å—è§„æ ¼è¯´æ˜ï¼ˆFrontend Shell & Navigation Spec, Freeze V2.0.1ï¼‰

> ç›®å½•ï¼š`docs/project-freeze/frontend-shell-module-spec.md`  
> èŒƒå›´ï¼š`app/(tabs)/*`ã€é€šç”¨å¯¼èˆªã€é¦–é¡µå±•ç¤ºã€ç”¨æˆ·ä¸­å¿ƒä¸è®¾ç½®é¡µé¢ã€‚  
> ç›®æ ‡ï¼šå°†â€œApp å¤–å£³ + å¯¼èˆª + åŸºç¡€è®¾ç½®â€å•ç‹¬è§†ä¸ºä¸€ä¸ªæ¨¡å—ï¼Œå†»ç»“å…¶èŒè´£ä¸è¾¹ç•Œï¼Œé¿å…ä¸å…·ä½“å­¦ä¹ æ¨¡å—ï¼ˆå­—æ¯/è¯æ±‡ï¼‰çš„é€»è¾‘æ··æ·†ã€‚

---

## 1. æ¨¡å—å®šä½ä¸è¾¹ç•Œ

### 1.1 æ¨¡å—èŒè´£

- æä¾›ç»Ÿä¸€çš„ **ä¸»å¯¼èˆªä¸å¤–å£³å¸ƒå±€**ï¼š
  - åº•éƒ¨ Tab å¯¼èˆªï¼šHome / Courses / Profileï¼›
  - åç»­å¯æ‰©å±• Settings / AI ç­‰å…¥å£ï¼Œä½†ä¸åµŒå…¥ä¸šåŠ¡é€»è¾‘ã€‚
- æä¾› **é¦–é¡µæ€»è§ˆï¼ˆHomeï¼‰**ï¼š
  - æ˜¾ç¤ºå½“å‰ä¸»è¯¾ç¨‹ã€ä»Šæ—¥è¿›åº¦ç™¾åˆ†æ¯”ã€å­¦ä¹ æ°›å›´èƒŒæ™¯ä¸åŠ¨æ•ˆï¼›
  - æä¾›â€œç»§ç»­å­¦ä¹ â€å…¥å£ï¼ˆè·³è½¬åˆ° `/learning` æˆ– `/alphabet`ï¼‰ã€‚
- æä¾› **ç”¨æˆ·ä¸­å¿ƒï¼ˆProfileï¼‰**ï¼š
  - å±•ç¤ºç”¨æˆ·åŸºæœ¬ä¿¡æ¯ä¸æˆå°±å¾½ç« ï¼›
  - é›†ä¸­æ”¾ç½® App çº§è®¾ç½®é¡¹ï¼ˆè¯­è¨€ã€æ¯æ—¥å­¦ä¹ é‡ã€TTS é€‰æ‹©ç­‰ï¼‰ï¼›
  - æä¾›ç™»å‡ºæŒ‰é’®ã€‚
- ä¸å…¶ä»–æ¨¡å—çš„å…³ç³»ï¼š
  - åªä¾èµ–å®ƒä»¬æš´éœ²çš„â€œæ±‡æ€»ä¿¡æ¯â€ï¼ˆå¦‚ `userProgress`ã€`learningStore.progress`ï¼‰ï¼Œä¸ç›´æ¥ç®¡ç†å­¦ä¹ é˜Ÿåˆ—ã€SRS æˆ–è¯¾ç¨‹å†…éƒ¨çŠ¶æ€ã€‚

### 1.2 æ¨¡å—è¾¹ç•Œï¼ˆä¸åšä»€ä¹ˆï¼‰

- ä¸è´Ÿè´£ï¼š
  - å­—æ¯/è¯æ±‡/å¥å­å…·ä½“å­¦ä¹ æµç¨‹ï¼›  
  - è®°å¿†å¼•æ“è°ƒç”¨ï¼ˆ`getTodayMemories` / `submitMemoryResult` ç­‰ï¼‰ï¼›  
  - è¯¾ç¨‹è§£é”é€»è¾‘ï¼ˆç”± `memory-engine` + `moduleAccessStore` ç®¡ç†ï¼‰ã€‚
- ä¸ç›´æ¥è¯»å†™æ•°æ®åº“ï¼Œåªé€šè¿‡å·²æœ‰ Store / äº‘å‡½æ•°æ¥å£è·å–ç»Ÿè®¡ä¿¡æ¯ã€‚

---

## 2. ç›¸å…³ä»£ç æ–‡ä»¶æ€»è§ˆ

### 2.1 è·¯ç”±å±‚ï¼ˆapp/(tabs)ï¼‰

- `app/(tabs)/_layout.tsx`
  - å®šä¹‰ Tab å¯¼èˆªç»“æ„ï¼ŒåŒ…å«ï¼š
    - `index`ï¼ˆHomeï¼‰ã€`courses`ï¼ˆè¯¾ç¨‹ï¼‰ã€`profile`ï¼ˆç”¨æˆ·ä¸­å¿ƒï¼‰ã€‚  
  - è´Ÿè´£è®¾ç½® Tab å›¾æ ‡ã€æ ‡é¢˜ä¸é…è‰²ã€‚

- `app/(tabs)/index.tsx`ï¼ˆHomeScreenï¼‰
  - èŒè´£ï¼š
    - å±•ç¤ºâ€œä»Šæ—¥è¿›åº¦ + å½“å‰è¯¾ç¨‹â€çš„ Hero å¡ç‰‡ï¼›  
    - å±•ç¤ºæµ®åŠ¨å¤ä¹ æ°”æ³¡ï¼ˆç›®å‰åŸºäº `MOCK_REVIEWS`ï¼‰ï¼›  
    - å±•ç¤ºå­¦ä¹ ç»Ÿè®¡ï¼ˆè¿ç»­å¤©æ•° / æœ¬å‘¨å­¦ä¹ æ—¶é•¿ï¼‰å’Œè¿‘æœŸæˆå°±ã€‚
  - ä¾èµ–ï¼š
    - `useUserStore`ï¼šå½“å‰ç™»å½•ç”¨æˆ·æ˜µç§°ï¼›  
    - `useModuleAccessStore`ï¼š`userProgress`ï¼ˆletterProgress/wordProgress/sentenceProgress/articleProgressï¼‰ï¼›  
    - `FloatingBubbles` / `ThaiPatternBackground` ç­‰ UI ç»„ä»¶ã€‚
  - å½“å‰å®ç°ä¸­çš„ `getCurrentCourse()`ï¼š
    - å½“ `letterProgress < 0.8` â†’ æ¨è Alphabet æ¨¡å—ï¼›  
    - å¦åˆ™æŒ‰ `wordProgress` / `sentenceProgress` / `articleProgress` ä¾æ¬¡æ¨èåç»­æ¨¡å—ï¼›  
    - ç‚¹å‡» Hero å¡ç‰‡æ—¶ï¼Œæ ¹æ®å½“å‰æ¨èæ¨¡å—è·³è½¬åˆ° `/learning` å¹¶é™„å¸¦ `module` å‚æ•°ï¼ˆå­—æ¯æˆ–å•è¯ï¼‰ã€‚

- `app/(tabs)/courses.tsx`
  - å·²åœ¨ `courses-and-learningstore-spec.md` ä¸­è¯¦è¿°ï¼Œæ­¤å¤„ä½œä¸ºå£³å±‚çš„ä¸€éƒ¨åˆ†è¢«å¼•ç”¨ã€‚  

- `app/(tabs)/profile.tsx`ï¼ˆProfileScreenï¼‰
  - èŒè´£ï¼š
    - å±•ç¤ºç”¨æˆ·å¤´åƒ/æ˜µç§°ï¼ˆå½“å‰å¤´åƒä¸ºå ä½ç¬¦ï¼‰ï¼›  
    - å±•ç¤ºæˆå°±å¾½ç« åˆ—è¡¨ï¼ˆå¦‚è¿ç»­æ‰“å¡ 7 å¤©ç­‰ï¼‰ï¼›  
    - æä¾› App çº§è®¾ç½®å…¥å£ï¼›  
    - æä¾›æ³¨é”€æŒ‰é’®ã€‚
  - ä¾èµ–ï¼š
    - `useUserStore`ï¼šè·å–ç”¨æˆ·ä¿¡æ¯ä¸ `logout()`ï¼›  
    - `useLearningStore`ï¼šè¯»å– streakDays ç­‰å­¦ä¹ ç»Ÿè®¡ï¼ˆå½“å‰ä¸º demo æ•°æ®ï¼‰ï¼›  
    - `useModuleAccessStore`ï¼šè¯»å– `userProgress.dailyLimit`ï¼›  
    - `LanguageSwitcher`ï¼šåˆ‡æ¢ä¸­/æ³°/è‹±ç­‰ UI æ–‡æ¡ˆè¯­è¨€ã€‚

---

## 3. å½“å‰å·²å®ç°çš„å‰ç«¯å±•ç¤ºåŠŸèƒ½

### 3.1 HomeScreen åŠŸèƒ½ç‚¹

- é¡¶éƒ¨é—®å€™åŒºï¼š
  - æ˜¾ç¤ºâ€œàºªàº°àºšàº²àºàº”àºµ, {displayName}`â€é£æ ¼é—®å€™è¯­ï¼›
  - æ˜¾ç¤º `todayProgress` æ–‡æ¡ˆ + å½“å‰æ¨èè¯¾ç¨‹çš„å®Œæˆç™¾åˆ†æ¯”ã€‚
- æµ®åŠ¨å¤ä¹ æ°”æ³¡ï¼š
  - `FloatingBubbles` ç»„ä»¶åŸºäº `MOCK_REVIEWS` æ˜¾ç¤ºå­—æ¯å¡ç‰‡ï¼ˆå­—ç¬¦ +ç±»å‹ + dueInï¼‰ï¼›  
  - ç‚¹å‡»ä»»æ„æ°”æ³¡ â†’ æ‰“å¼€ `/review-modal`ï¼ˆæš‚æœªä¸è®°å¿†å¼•æ“å®Œå…¨æ¥å…¥ï¼‰ã€‚
- Hero è¯¾ç¨‹å¡ï¼š
  - å±•ç¤ºå½“å‰é˜¶æ®µè¯¾ç¨‹åç§°ï¼ˆå­—æ¯/å•è¯/å¥å­/æ–‡ç« ï¼‰ã€è¯¾ç¨‹ç­‰çº§æ ‡ç­¾åŠæ³°æ–‡çŸ­è¯­ï¼›  
  - æ˜¾ç¤ºâ€œç»§ç»­å­¦ä¹ â€å¤§æŒ‰é’®ï¼ˆå¸¦ Play iconï¼‰ï¼Œç‚¹å‡»åï¼š
    - è‹¥ `currentCourse.module === 'letter'` â†’ `router.push('/learning?module=letter')`ï¼›  
    - è‹¥ä¸ºè¯æ±‡/å¥å­/æ–‡ç«  â†’ `router.push('/learning')`ï¼ˆç›®å‰ä¸ºå ä½è¡Œä¸ºï¼‰ã€‚
- å­¦ä¹ ç»Ÿè®¡å¡ç‰‡ï¼š
  - æ˜¾ç¤ºå‡æ•°æ®ï¼šè¿ç»­å­¦ä¹ å¤©æ•°ï¼ˆ12ï¼‰ä¸æœ¬å‘¨å­¦ä¹ æ—¶é•¿ï¼ˆ4.5 å°æ—¶ï¼‰ï¼›  
  - åç»­å°†ä½¿ç”¨ `learningStore` çš„çœŸå®ç»Ÿè®¡å­—æ®µæ›¿ä»£ã€‚
- æœ€è¿‘æˆå°±åŒºåŸŸï¼š
  - å±•ç¤ºè‹¥å¹²â€œæŒæ¡å­—æ¯/å•è¯â€çš„å¡ç‰‡ï¼Œå ä½ UIã€‚

### 3.2 ProfileScreen åŠŸèƒ½ç‚¹

- ä¸ªäººä¿¡æ¯å¡ï¼š
  - æ˜¾ç¤ºå¤´åƒï¼ˆå½“å‰ä¸ºå­—æ¯ Lï¼‰ã€ç”¨æˆ·åã€ç®€ä»‹æ–‡æ¡ˆã€‚
- æˆå°±å¾½ç« åˆ—è¡¨ï¼š
  - é€šè¿‡æœ¬åœ° `achievements` æ•°ç»„é©±åŠ¨ï¼ŒåŒ…æ‹¬ï¼š
    - è¿ç»­æ‰“å¡ 7 å¤©ï¼ˆæ ¹æ® `learningStore.progress.streakDays` åˆ¤æ–­æ˜¯å¦è§£é”ï¼‰ï¼›  
    - å…¶ä»–æˆå°±å ä½ï¼ˆMasterã€Vocab100 ç­‰ï¼‰ã€‚
- è®¾ç½®å¡ç‰‡ï¼š
  - æ¯æ—¥æé†’å¼€å…³ï¼ˆæœ¬åœ° `dailyReminder` çŠ¶æ€ï¼Œæš‚æœªæ¥å…¥é€šçŸ¥æœåŠ¡ï¼‰ï¼›  
  - æ¯æ—¥å­¦ä¹ æ•°é‡è®¾ç½®ï¼š
    - å¼¹å‡º Alert ä¾›ç”¨æˆ·é€‰æ‹© 10/20/50 ä¸ªï¼›
    - æœ¬åœ°è°ƒç”¨ `useModuleAccessStore.setState` æ›´æ–° `userProgress.dailyLimit`ï¼ˆå‰ç«¯æ¨¡æ‹Ÿï¼‰ï¼›
  - TTS å¼•æ“é€‰æ‹©ï¼ˆç›®å‰å›ºå®šä¸º `Tencent TTS` æ–‡æ¡ˆï¼Œå°šæœªè·³è½¬åˆ°è¯¦æƒ…é¡µï¼‰ï¼›  
  - è¯­è¨€åˆ‡æ¢ï¼šåµŒå…¥ `LanguageSwitcher variant="full"` ç»„ä»¶ã€‚
- æ³¨é”€æŒ‰é’®ï¼š
  - è°ƒç”¨ `logout()` å¹¶ `router.replace('/(auth)/login')`ã€‚

---

## 4. æœªæ¥è§„åˆ’çš„å¤–å£³ä¸è®¾ç½®åŠŸèƒ½ï¼ˆä¸å½±å“å½“å‰å†»ç»“æ¨¡å—ï¼‰

> æœ¬èŠ‚ä»…åš**æ–¹å‘æ€§è§„åˆ’**ï¼Œå®é™…å¼€å‘å‰éœ€åœ¨æœ¬ spec ä¸­è¡¥å……å¯¹åº”å­—æ®µä¸è·¯ç”±ï¼Œå¹¶åœ¨é¡¹ç›®æ€»çº²ä¸­ç™»è®°ä¸ºæ–°ä»»åŠ¡ã€‚

### 4.1 å¯¼èˆªå±‚æ‰©å±•

- å¢åŠ  Settings ç‹¬ç«‹ Tab æˆ–å­è·¯ç”±ï¼š
  - ä¾‹å¦‚ï¼š`app/(tabs)/settings.tsx` æˆ– `app/settings/index.tsx`ï¼›  
  - Profile åªå±•ç¤ºç”¨æˆ·ä¿¡æ¯å’Œæˆå°±ï¼Œæ‰€æœ‰è®¾ç½®é¡¹é›†ä¸­åˆ° Settings é¡µé¢ã€‚
- åœ¨ HomeScreen ä¸­å¢åŠ â€œå¿«é€Ÿå…¥å£åŒºåŸŸâ€ï¼š
  - ä»Šæ—¥ä»»åŠ¡ï¼ˆå­—æ¯/å•è¯å¤ä¹ æ•°é‡ï¼‰ï¼›  
  - AI å‘éŸ³ç»ƒä¹ å…¥å£ï¼›  
  - å­—æ¯å¤ä¹ ä¸­å¿ƒ/è¯æ±‡å¤ä¹ ä¸­å¿ƒå…¥å£ã€‚

### 4.2 è®¾ç½®é¡¹æ‰©å±•

- å­¦ä¹ åå¥½ï¼š
  - æ¯æ—¥å­¦ä¹ ç›®æ ‡ï¼ˆå­—æ¯/å•è¯åˆ†å¼€è®¾ç½®ï¼‰ï¼›  
  - å¤ä¹ ä¼˜å…ˆçº§ï¼ˆæ˜¨æ—¥å¤ä¹ ä¼˜å…ˆ vs æ–°è¯ä¼˜å…ˆç­‰ï¼‰ã€‚
- éŸ³é¢‘ä¸ UIï¼š
  - TTS å¼•æ“é€‰æ‹©ï¼ˆTencent / CloudBase / æœ¬åœ°éŸ³é¢‘ä¼˜å…ˆçº§ï¼‰ï¼›  
  - è‡ªåŠ¨æ’­æ”¾é€‰é¡¹ï¼ˆè¿›å…¥é¢˜ç›®æ—¶æ˜¯å¦è‡ªåŠ¨æ’­æ”¾éŸ³é¢‘ï¼‰ï¼›  
  - ä¸»é¢˜æ¨¡å¼ï¼ˆæµ…è‰² / æ·±è‰²ï¼‰ã€‚
- é€šçŸ¥ä¸æé†’ï¼š
  - å­¦ä¹ æé†’æ—¶é—´ / é¢‘ç‡ï¼›  
  - è¿ç»­æ‰“å¡æé†’ã€‚

### 4.3 ç”¨æˆ·ä¸­å¿ƒæ‰©å±•

- å®Œæ•´å­¦ä¹ ç»Ÿè®¡é¡µï¼š
  - æ€»å­¦ä¹ æ—¶é•¿ã€å­¦ä¹ å¤©æ•°ã€å„æ¨¡å—æŒæ¡åº¦ç»Ÿè®¡ï¼ˆä» `user_progress` / `user_alphabet_progress` / `user_vocabulary_progress` æ¨å¯¼ï¼‰ï¼›  
  - é”™è¯¯æœ€å¤šçš„å­—æ¯/å•è¯ Top Nï¼Œç”¨ä½œ AI æ¨¡å—è¾“å…¥ã€‚  
- æˆå°±ç³»ç»Ÿï¼š
  - æŒ‰å­¦ä¹ è¡Œä¸ºï¼ˆå­—æ¯å®Œæˆã€è¯æ±‡æ•°ã€æ‰“å¡è¿ç»­å¤©æ•°ç­‰ï¼‰è‡ªåŠ¨è§£é”å¾½ç« ï¼›  
  - æˆå°±è¯¦æƒ…é¡µå±•ç¤ºè§£é”æ¡ä»¶ä¸è¾¾æˆæ—¥æœŸã€‚

---

## 5. å®æ–½æ³¨æ„äº‹é¡¹

1. å£³å±‚ç»„ä»¶ï¼ˆHome / Profile / Settingsï¼‰ä¸å¾—ç›´æ¥è°ƒç”¨è®°å¿†å¼•æ“ï¼Œåªèƒ½é€šè¿‡ Storeï¼ˆ`moduleAccessStore` / `learningStore` / `learningPreferenceStore` / `userStore`ï¼‰è¯»å–ç»Ÿè®¡æˆ–åŸºç¡€è®¾ç½®ã€‚  
2. æ‰€æœ‰æ–°å¢å…¨å±€è®¾ç½®é¡¹ï¼Œéƒ½éœ€è¦ï¼š
   - åœ¨æœ¬ spec ä¸­ç™»è®°ï¼›
   - åœ¨ç›¸åº” Store ä¸­å¢åŠ å­—æ®µä¸æ¥å£ï¼›
   - åœ¨å¿…è¦æ—¶æ‰©å±•åç«¯æ¥å£ï¼ˆä¾‹å¦‚å­˜å‚¨æ¯æ—¥å­¦ä¹ ç›®æ ‡ï¼‰ï¼Œå¹¶åœ¨ `backend-memory-engine-spec.md` æˆ–ç›¸å…³åç«¯ Spec ä¸­è¯´æ˜ã€‚  
3. å¯¼èˆªç»“æ„å˜æ›´ï¼ˆæ–°å¢ Tabã€è°ƒæ•´è·¯ç”±ï¼‰å¿…é¡»åŒæ­¥æ›´æ–°ï¼š
   - `app/(tabs)/_layout.tsx` ä»£ç ï¼›  
   - æœ¬ spec è·¯ç”±å°èŠ‚ï¼›  
   - `PROJECT_OVERVIEW_SPEC.md` ä¸­çš„æ¨¡å—è¡¨ä¸ä»»åŠ¡åˆ—è¡¨ã€‚

æœ¬è§„æ ¼å°†å‰ç«¯å£³å±‚çš„èŒè´£ä¸è¾¹ç•Œä»å­—æ¯/è¯æ±‡å­¦ä¹ é€»è¾‘ä¸­æŠ½ç¦»å‡ºæ¥ï¼Œä¿è¯å¯¼èˆªã€ç”¨æˆ·ä¸­å¿ƒä¸è®¾ç½®ç›¸å…³æ”¹åŠ¨ä¸ä¼šæ„å¤–å½±å“æ ¸å¿ƒå­¦ä¹ æ¨¡å—ã€‚***
````

## File: docs/PRONUNCIATION_RESTORATION_FROZEN.md
````markdown
# å†»ç»“æ–‡æ¡£ï½œå‘éŸ³è¿˜åŸï¼ˆPronunciation Restorationï¼‰åŠŸèƒ½è§„èŒƒ v1.0

ï¼ˆæœ¬æ–‡ä»¶æ‰¿æ¥å‰æ–‡è®¾è®¡èƒŒæ™¯ã€åŠŸèƒ½è¾¹ç•Œã€æµæ°´çº¿ä¸å¯¹æ¥è§„èŒƒï¼‰

---

## 9. å…¸å‹ç¤ºä¾‹ï¼ˆå†»ç»“å‚è€ƒï¼‰

> ä»¥ä¸‹ç¤ºä¾‹ç”¨äº**è¡Œä¸ºå†»ç»“**ï¼Œä¸æ˜¯æ•™å­¦ç¤ºä¾‹  
> åç»­å®ç°å¿…é¡»ä¸è¿™äº›ç¤ºä¾‹åœ¨è§„åˆ™ç‰ˆæœ¬ä¸€è‡´çš„æƒ…å†µä¸‹è¾“å‡ºç›¸åŒç»“æœ

### 9.1 å•éŸ³èŠ‚

| è¾“å…¥ | è¾“å‡ºï¼ˆThaiï¼‰ | è¯´æ˜ |
|----|----|----|
| à¸à¸² | à¸à¸² | ç¬¬ä¸€è°ƒï¼Œä¸æ ‡ |
| à¸ˆà¸° | à¸ˆà¹ˆà¸° | å®é™…ä¸ºç¬¬äºŒè°ƒ |
| à¹‚à¸•à¹Šà¸° | à¹‚à¸•à¹Šà¸° | ç¬¬å››è°ƒï¼Œä¿ç•™ |
| à¹ƒà¸«à¸¡à¹ˆ | à¹ƒà¸«à¸¡à¹ˆ | æ‹¼å†™æœ‰ à¹ˆï¼Œä½†å®é™…ç¬¬ä¸€è°ƒï¼Œä¸æ ‡ |

### 9.2 å¤šéŸ³èŠ‚

| è¾“å…¥ | è¾“å‡ºï¼ˆThaiï¼‰ |
|----|----|
| à¸ à¸²à¸©à¸²à¹„à¸—à¸¢ | à¸à¸² à¸ªà¸² à¹„à¸— |
| à¸›à¸£à¸°à¹€à¸—à¸¨ | à¸›à¸ºà¸£à¸° à¹€à¸—à¸” |
| à¹€à¸‚à¹‰à¸²à¹ƒà¸ˆ | à¹€à¸‚à¹‰à¸² à¹ƒà¸ˆ |
| à¸—à¸£à¸²à¸š | à¸‹à¹‰à¸²à¸š |

### 9.3 å«å‡å¤è¾…éŸ³

| è¾“å…¥ | è¾“å‡ºï¼ˆThaiï¼‰ |
|----|----|
| à¸—à¸£à¸²à¸¢ | à¸‹à¹‰à¸²à¸¢ |
| à¸—à¸£à¸²à¸š | à¸‹à¹‰à¸²à¸š |

---

## 10. å¼‚å¸¸ä¸ä¾‹å¤–ç­–ç•¥ï¼ˆå†»ç»“ï¼‰

### 10.1 åŸåˆ™
- **è§„åˆ™ä¼˜å…ˆï¼Œè¯è¡¨å…œåº•**
- ä»»ä½•æ— æ³•ä»…é€šè¿‡ `pron_thai.json` å†³å®šçš„è¡Œä¸ºï¼š
  - å¿…é¡»è¿›å…¥ exception è¯è¡¨
  - ä¸å…è®¸åœ¨ä»£ç ä¸­ hardcode è¯­è¨€ç›´è§‰

### 10.2 Exception è¯è¡¨å»ºè®®
- æ–‡ä»¶å½¢å¼ï¼š`pron_thai.exceptions.jsonl`
- æ¯è¡Œä¸€ä¸ªè¯æ¡ï¼ŒåŒ…å«ï¼š
  - word
  - syllable_overrideï¼ˆå¯é€‰ï¼‰
  - tone_overrideï¼ˆå¯é€‰ï¼‰
  - noteï¼ˆä»…è¯´æ˜ï¼Œä¸å‚ä¸æ‰§è¡Œï¼‰

---

## 11. å˜æ›´ä¸æ‰©å±•çº¦æŸï¼ˆéå¸¸é‡è¦ï¼‰

### 11.1 å…è®¸çš„å˜æ›´
- å¢åŠ  exception è¯æ¡
- å¢åŠ æµ‹è¯•ç”¨ä¾‹
- ä¼˜åŒ–æ€§èƒ½ï¼ˆä¸æ”¹å˜ç»“æœï¼‰

### 11.2 ç¦æ­¢çš„å˜æ›´
- ä¿®æ”¹æ—¢æœ‰è§„åˆ™è¯­ä¹‰
- å¼•å…¥â€œè¯­è¨€ç›´è§‰â€è§„åˆ™
- ä¸ºæŸäº›è¯â€œä¸´æ—¶ç‰¹æ®Šå¤„ç†â€è€Œä¸å…¥è¯è¡¨
- æ”¹å˜å£°è°ƒæ˜¾å¼ç­–ç•¥ï¼ˆT1 ä¸æ ‡ï¼‰

---

## 12. å†»ç»“å£°æ˜ï¼ˆFinalï¼‰

è‡ªæœ¬æ–‡ä»¶å‘å¸ƒä¹‹æ—¥èµ·ï¼š

- **â€œå‘éŸ³è¿˜åŸï¼ˆPronunciation Restorationï¼‰â€åŠŸèƒ½çš„è®¾è®¡ç›®æ ‡ã€è¾¹ç•Œã€è¾“å‡ºå½¢å¼ã€è§„åˆ™æ¥æºä¸æ‰§è¡Œæµæ°´çº¿å…¨éƒ¨å†»ç»“**
- åç»­å¼€å‘å¿…é¡»ï¼š
  - ä»¥ `pron_thai.json` ä¸ºå”¯ä¸€è§„åˆ™æº
  - éµå¾ªé¡¹ç›®æ—¢æœ‰è„šæ‰‹æ¶ä¸æ¨¡å—åˆ†å±‚
  - ä¸å°†è¯¥åŠŸèƒ½å®ç°ä¸ºå­¤ç«‹ demo
- è‹¥æœªæ¥éœ€è¦æ‰©å±•ï¼ˆå¦‚ IPAã€æ–¹è¨€ã€TTSï¼‰ï¼Œå¿…é¡»ï¼š
  - æ–°å¢ç‹¬ç«‹æ¨¡å—
  - ä¸ç ´åæœ¬åŠŸèƒ½çš„æ—¢æœ‰è¡Œä¸º

> æœ¬å†»ç»“æ–‡æ¡£çš„ç›®æ ‡ä¸æ˜¯â€œåšå¾—æœ€å°‘â€ï¼Œ  
> è€Œæ˜¯ **ä¿è¯ç³»ç»Ÿåœ¨æ•´ä¸ªç”Ÿå‘½å‘¨æœŸå†…ï¼š  
> å¯æ§ã€å¯è¿½æº¯ã€å¯æŒç»­ã€ä¸å¤±çœŸã€‚**
````

## File: docs/PRONUNCIATION_RESTORATION_MODULE_SPEC_FROZEN_v1.0.md
````markdown
# å†»ç»“è®¾è®¡æ–‡æ¡£ï½œå‘éŸ³è¿˜åŸæ¨¡å—ï¼ˆPronunciation Restoration Moduleï¼‰v1.0

> çŠ¶æ€ï¼š**å†»ç»“ï¼ˆFrozenï¼‰**  
> æ¨¡å—åï¼š`pronunciation-restoration`  
> å•ä¸€äº‹å®æºï¼ˆSSoTï¼‰ï¼š`pron_thai.json`  
> é€‚ç”¨èŒƒå›´ï¼šThaiLearnAppï¼ˆå‰ç«¯ / åç«¯ / AIï¼‰  

---

## 0. æ¨¡å—å®šä½ï¼ˆæ˜¯ä»€ä¹ˆï¼‰

æœ¬æ¨¡å—ä¸æ˜¯æ•™å­¦è§„åˆ™å±•ç¤ºå™¨ï¼Œè€Œæ˜¯**å‘éŸ³ç»“æœè¿˜åŸæ¨¡å—**ã€‚

å®ƒçš„èŒè´£æ˜¯ï¼š  
> å°†ä»»æ„æ³°è¯­æ‹¼å†™ï¼ˆå•è¯æˆ–çŸ­è¯­ï¼‰è½¬æ¢ä¸º  
> **â€œæ— éœ€ç”¨æˆ·æ€è€ƒä»»ä½•æ‹¼è¯»è§„åˆ™å³å¯ç›´æ¥æœ—è¯»çš„å‘éŸ³æ€è¡¨ç¤ºâ€**ã€‚

---

## 1. è¾“å‡ºæ•ˆæœç›®æ ‡ï¼ˆå¿…é¡»è¾¾åˆ°ï¼‰

### 1.1 ç”¨æˆ·ä¾§
- ç”¨æˆ·çœ‹åˆ°è¾“å‡ºå³å¯è¯»
- ä¸éœ€è¦çŸ¥é“ï¼š
  - ä¸­ / é«˜ / ä½è¾…éŸ³
  - æ¸…å°¾ / æµŠå°¾
  - æ ‡ 2 è¯» 3ã€æ ‡ 3 è¯» 4 ç­‰è§„åˆ™
- ç¬¬ä¸€è°ƒæ°¸è¿œä¸æ ‡ï¼Œå…¶ä½™ 4 è°ƒåªæ ‡**å®é™…å£°è°ƒ**

### 1.2 å·¥ç¨‹ä¾§
- è¾“å‡ºç»“æ„åŒ–ï¼Œå¯è¢« UI / åç«¯ / AI æ¶ˆè´¹
- åŒä¸€è§„åˆ™ç‰ˆæœ¬ä¸‹ç»“æœç¡®å®š

---

## 2. æœ¬æ¨¡å—å¼•å…¥å¹¶å†»ç»“çš„æ–°åŸåˆ™

### 2.1 å£°è°ƒç¬¦å·é‡å»ºåŸåˆ™
- æ°¸è¿œä¸ç›´æ¥å¤ç”¨åŸæ‹¼å†™ä¸­çš„å£°è°ƒç¬¦å·
- å¿…é¡»ï¼š
  1. ç§»é™¤å†å²å£°è°ƒç¬¦å·
  2. æ¨å¯¼å®é™…å£°è°ƒ
  3. æŒ‰å®é™…å£°è°ƒé‡å»ºç¬¦å·ï¼ˆT1 ä¸æ ‡ï¼‰

### 2.2 ç½—é©¬éŸ³ä»…ä¸ºæ¸²æŸ“å±‚
- ä¸å‚ä¸è§„åˆ™æ¨å¯¼
- ä»…åŸºäºå‘éŸ³æ€ç»“æœç”Ÿæˆ
- å¿…é¡»æ˜¾å¼æ ‡å£°è°ƒï¼ˆå»ºè®®æ•°å­—ï¼‰

### 2.3 éŸ³èŠ‚è¾¹ç•Œå³è¾“å‡ºå¥‘çº¦
- è¾“å‡ºæ³°æ–‡å¿…é¡»ä»¥ç©ºæ ¼åˆ†éš”éŸ³èŠ‚
- ç½—é©¬éŸ³ï¼ˆè‹¥æœ‰ï¼‰åŒæ ·æŒ‰éŸ³èŠ‚å¯¹é½

---

## 3. å•ä¸€äº‹å®æºï¼ˆSSoTï¼‰

- æ‰€æœ‰è§„åˆ™æ¥è‡ª `pron_thai.json`
- ä¸å…è®¸è¯­è¨€ç›´è§‰ç¡¬ç¼–ç 
- å…è®¸ç”Ÿæˆè¿è¡Œæ—¶è£å‰ªç‰ˆï¼Œä½†å¿…é¡»å¯è¿½æº¯

---

## 4. è¾“å…¥ / è¾“å‡ºå¥‘çº¦

### 4.1 è¾“å…¥
- `inputText: string`

### 4.2 è¾“å‡ºï¼ˆå»ºè®®å†»ç»“ï¼‰

```ts
type SyllableResult = {
  original: string;
  surface_base: string;
  tone: "T1" | "T2" | "T3" | "T4" | "T5";
  surface: string;
  roman?: string;
};

type PronRestoreResult = {
  input: string;
  syllables: SyllableResult[];
  output_thai: string;
  output_roman?: string;
};
```

---

## 5. æµæ°´çº¿ï¼ˆå†»ç»“ï¼‰

1. Normalize
2. Tokenize
3. Syllable Segmentation
4. Orthography Rewrite + å»å†å²å£°è°ƒ
5. Feature Extraction
6. Tone Resolution
7. Tone Explicit Render
8. Romanization Renderï¼ˆå¯é€‰ï¼‰
9. Join

---

## 6. å®ç°å»ºè®®ä¼ªä»£ç 

```ts
function restorePronunciation(input: string, opts): PronRestoreResult {
  const syllables = segment(input);
  const results = [];

  for (const s of syllables) {
    const base = rewriteAndStripTone(s);
    const tone = resolveTone(base);
    const surface = renderTone(base, tone);
    const roman = opts.roman ? renderRoman(base, tone) : undefined;

    results.push({ original: s, surface_base: base, tone, surface, roman });
  }

  return {
    input,
    syllables: results,
    output_thai: results.map(r => r.surface).join(" "),
    output_roman: opts.roman ? results.map(r => r.roman).join(" ") : undefined
  };
}
```

---

## 7. ç³»ç»Ÿå¯¹æ¥ï¼ˆé Demoï¼‰

- å‰ç«¯ï¼šè¯å¡ / å­¦ä¹  / å¤ä¹ ç»Ÿä¸€è°ƒç”¨
- åç«¯ï¼šè®°å½•ç»“æœä¸è§„åˆ™ç‰ˆæœ¬
- AIï¼šéŸ³èŠ‚ + å£°è°ƒä½œä¸ºè¯„æµ‹ç›®æ ‡

---

## 8. æµ‹è¯•ä¸éªŒæ”¶

- åŒä¸€è¾“å…¥ + åŒä¸€è§„åˆ™ç‰ˆæœ¬ â†’ å¿…é¡»è¾“å‡ºä¸€è‡´
- ä¸å‡ºç°å£°è°ƒè¯¯å¯¼
- ç”¨æˆ·ä»…æŒ‰è¾“å‡ºå³å¯è¯»

---

## 9. å†»ç»“å£°æ˜

æœ¬æ¨¡å—è®¾è®¡ã€åŸåˆ™ã€è¾“å‡ºå½¢å¼ä¸æµæ°´çº¿å…¨éƒ¨å†»ç»“ã€‚  
ä»»ä½•æ‰©å±•å¿…é¡»ä»¥æ–°æ¨¡å—å½¢å¼è¿›è¡Œï¼Œä¸ç ´åæœ¬æ¨¡å—è¡Œä¸ºã€‚
````

## File: scripts/getAudioJsonFromWeb.js
````javascript
(function() {
    // 1. åŠ è½½ JSZip
    var script = document.createElement('script');
    script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
    document.head.appendChild(script);

    setTimeout(() => {
        if (typeof JSZip === 'undefined') return alert("åº“åŠ è½½å¤±è´¥");
        console.log("%cğŸš€ å¼€å§‹æŠ“å–å…¨é‡éŸ³é¢‘æ•°æ®...", "color: blue; font-weight: bold;");
        startScraping();
    }, 3000);

    async function startScraping() {
        const BASE_URL = "https://cdn.langeek.cn/thaik/corpus/thai/rv/BaseThai_4";
        const CATALOG_URL = `${BASE_URL}/p/O5G1e3lD7B0I2o6C9f8A4L1`;

        // A. è·å–ç›®å½•
        const catalogResp = await fetch(CATALOG_URL);
        const catalogData = await catalogResp.json();
        const uniqueLessons = [...new Set(catalogData.words.map(w => w.lessonNumber).filter(l => l))];
        uniqueLessons.sort((a, b) => parseFloat(a) - parseFloat(b));

        const zip = new JSZip();
        const folder = zip.folder("Audio_JSONL_Full");
        let count = 0;

        // B. éå†è¯¾ç¨‹
        for (const lessonId of uniqueLessons) {
            const bUrl = `${BASE_URL}/b/${lessonId}`;
            console.log(`â¬‡ï¸ ä¸‹è½½ç¬¬ ${lessonId} è¯¾éŸ³é¢‘...`);

            try {
                const res = await fetch(bUrl);
                if (res.ok) {
                    const rawData = await res.json();
                    let lines = [];

                    // --- ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šéå†æ‰€æœ‰åˆ†ç±» ---
                    // categories: words(å•è¯), sentences(ä¾‹å¥), dialogue(å¯¹è¯), cognates(åŒæºè¯)
                    const categories = ['words', 'sentences', 'dialogue', 'cognates'];

                    categories.forEach(cat => {
                        const mapData = rawData[cat] || {};
                        Object.entries(mapData).forEach(([key, base64Str]) => {
                            if (typeof base64Str === 'string' && base64Str.startsWith('data:audio')) {
                                lines.push(JSON.stringify({
                                    category: cat,   // æ ‡è®°åˆ†ç±»ï¼šwords, sentences...
                                    originalKey: key, // åŸå§‹Keyï¼š7_sentence_å®ç”¨åœºæ™¯1...
                                    content: base64Str // éŸ³é¢‘æ•°æ®
                                }));
                            }
                        });
                    });
                    // -------------------------------

                    if (lines.length > 0) {
                        folder.file(`${lessonId}.json`, lines.join('\n'));
                        count++;
                    }
                }
            } catch (e) {
                console.error(e);
            }
            await new Promise(r => setTimeout(r, 200));
        }

        // C. ä¸‹è½½
        const content = await zip.generateAsync({type: "blob"});
        const link = document.createElement("a");
        link.href = URL.createObjectURL(content);
        link.download = "Thai_4_Audio.zip";
        link.click();
        console.log("âœ… ä¸‹è½½å®Œæˆ");
    }
})();
````

## File: scripts/getVocabJsonFromWeb.js
````javascript
//è¯¥è„šæœ¬ä»…é€‚ç”¨äºæµè§ˆå™¨æ§åˆ¶å°
//è¯¥è„šæœ¬ç”¨äºçˆ¬å–ç½‘ç«™ä¸Šçš„jsonæ–‡ä»¶

(function() {
    // 1. åŠ¨æ€åŠ è½½ JSZip åº“
    console.log("%câ³ æ­£åœ¨åŠ è½½ JSZip åº“...", "color: blue; font-weight: bold;");
    var script = document.createElement('script');
    script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
    document.head.appendChild(script);

    // 2. è®¾ç½®å®šæ—¶å™¨ï¼Œ3ç§’åæ‰§è¡Œä¸»é€»è¾‘
    setTimeout(function() {
        if (typeof JSZip === 'undefined') {
            console.error("âŒ JSZip åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–é‡æ–°è¿è¡Œä»£ç ã€‚");
            return;
        }
        console.log("%câœ… åº“åŠ è½½æˆåŠŸï¼3ç§’å·²åˆ°ï¼Œå¼€å§‹æ‰§è¡Œçˆ¬å–ä»»åŠ¡...", "color: green; font-weight: bold; font-size: 14px;");
        startScrapingTask();
    }, 3000);

    // 3. ä¸»ä»»åŠ¡é€»è¾‘
    async function startScrapingTask() {
        // ================= é…ç½®åŒºåŸŸ =================
        const BASE_URL = "https://cdn.langeek.cn/thaik/corpus/thai/rv/BaseThai_4";
        const CATALOG_URL = `${BASE_URL}/p/O5G1e3lD7B0I2o6C9f8A4L1`;
        // ===========================================

        try {
            // A. è·å–æ€»è¡¨
            console.log("1ï¸âƒ£ æ­£åœ¨è·å–è¯¾ç¨‹ç›®å½•...");
            const catalogResp = await fetch(CATALOG_URL);
            if (!catalogResp.ok) throw new Error(`æ€»è¡¨è·å–å¤±è´¥: ${catalogResp.status}`);
            const catalogData = await catalogResp.json();

            // B. æå–ç« èŠ‚å·
            const rawLessons = catalogData.words.map(w => w.lessonNumber).filter(l => l);
            const uniqueLessons = [...new Set(rawLessons)];
            uniqueLessons.sort((a, b) => parseFloat(a) - parseFloat(b));

            console.log(`âœ… ç›®å½•è·å–æˆåŠŸï¼å…±å‘ç° ${uniqueLessons.length} ä¸ªè¯¾ç¨‹ç« èŠ‚ã€‚`);

            // C. å‡†å¤‡ ZIP
            const zip = new JSZip();
            const folder = zip.folder("Thai_Vocab_JSONL");

            // D. å¾ªç¯ä¸‹è½½å¹¶è½¬æ¢æ ¼å¼
            let successCount = 0;
            
            for (let i = 0; i < uniqueLessons.length; i++) {
                const lessonId = uniqueLessons[i];
                const jUrl = `${BASE_URL}/j/${lessonId}`;
                
                console.log(`â¬‡ï¸ [${i + 1}/${uniqueLessons.length}] æ­£åœ¨å¤„ç†ç¬¬ ${lessonId} è¯¾...`);

                try {
                    const jResp = await fetch(jUrl);
                    if (jResp.ok) {
                        const rawContent = await jResp.json(); // å…ˆè§£æä¸ºå¯¹è±¡/æ•°ç»„
                        
                        let jsonlContent = "";

                        // --- æ ¸å¿ƒè½¬æ¢é€»è¾‘ï¼šè½¬ä¸º JSONL (NDJSON) ---
                        if (Array.isArray(rawContent)) {
                            // å¦‚æœæ˜¯æ•°ç»„ï¼ŒæŠŠæ¯ä¸€é¡¹è½¬ä¸ºå­—ç¬¦ä¸²ï¼Œç”¨æ¢è¡Œç¬¦è¿æ¥
                            // æ•ˆæœï¼š
                            // {"id":1, ...}
                            // {"id":2, ...}
                            jsonlContent = rawContent.map(item => JSON.stringify(item)).join('\n');
                        } else if (typeof rawContent === 'object') {
                            // å¦‚æœæ˜¯å•ä¸ªå¯¹è±¡ï¼Œç›´æ¥è½¬å­—ç¬¦ä¸²ï¼ˆæˆ–è€…æ£€æŸ¥æ˜¯å¦æœ‰å†…éƒ¨ listï¼‰
                            // æœ‰äº›ç»“æ„å¯èƒ½æ˜¯ { words: [...] }ï¼Œè¿™é‡Œåšä¸ªå…¼å®¹
                            if (rawContent.words && Array.isArray(rawContent.words)) {
                                jsonlContent = rawContent.words.map(item => JSON.stringify(item)).join('\n');
                            } else {
                                jsonlContent = JSON.stringify(rawContent);
                            }
                        } else {
                            // çº¯æ–‡æœ¬æˆ–å…¶ä»–
                            jsonlContent = String(rawContent);
                        }
                        // ----------------------------------------

                        // ä¿å­˜æ–‡ä»¶ï¼Œè™½ç„¶å†…å®¹æ˜¯ JSONLï¼Œä½†åç¼€ä¿æŒ .json (æ–¹ä¾¿ç¼–è¾‘å™¨è¯†åˆ«)
                        folder.file(`${lessonId}.json`, jsonlContent);
                        successCount++;
                    } else {
                        console.warn(`âš ï¸ è¯¾ç¨‹ ${lessonId} ä¸‹è½½å¤±è´¥ (Status: ${jResp.status})`);
                    }
                } catch (err) {
                    console.error(`âŒ è¯¾ç¨‹ ${lessonId} å¤„ç†å‡ºé”™:`, err);
                }

                // ç¨å¾®å»¶æ—¶ï¼Œé˜²æ­¢è¯·æ±‚è¿‡å¿«
                await new Promise(r => setTimeout(r, 200));
            }

            // E. æ‰“åŒ…ä¸‹è½½
            console.log("ğŸ“¦ æ­£åœ¨æ‰“åŒ…ä¸º ZIP...");
            const content = await zip.generateAsync({type: "blob"});
            
            const link = document.createElement("a");
            link.href = URL.createObjectURL(content);
            link.download = "Thai_4_Vocab.zip";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            console.log(`%cğŸ‰ å…¨éƒ¨å®Œæˆï¼å·²ä¸‹è½½ ${successCount} ä¸ª JSONL æ ¼å¼çš„æ–‡ä»¶ã€‚`, "color: green; font-size: 16px; font-weight: bold;");

        } catch (e) {
            console.error("âŒ å‘ç”Ÿä¸¥é‡é”™è¯¯:", e);
        }
    }
})();
````

## File: src/components/common/Card.tsx
````typescript
import React from 'react';
import { View, StyleSheet, ViewStyle } from 'react-native';

interface CardProps {
  children: React.ReactNode;
  style?: ViewStyle;
}

export default function Card({ children, style }: CardProps) {
  return <View style={[styles.card, style]}>{children}</View>;
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: '#fff',
    padding: 15,
    borderRadius: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
});
````

## File: src/components/common/LanguageSwitcher.tsx
````typescript
// src/components/LanguageSwitcher.tsx
import React from 'react';
import { View, Text, Pressable, StyleSheet } from 'react-native';
import { useTranslation } from 'react-i18next';
import { Globe } from 'lucide-react-native';
import { useLanguageStore, Language } from '@/src/stores/languageStore';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

interface LanguageSwitcherProps {
  variant?: 'compact' | 'full';
}

export const LanguageSwitcher: React.FC<LanguageSwitcherProps> = ({ variant = 'compact' }) => {
  const { t } = useTranslation();
  const { currentLanguage, changeLanguage } = useLanguageStore();

  const languages: { code: Language; label: string; flag: string }[] = [
    { code: 'zh', label: t('profile.chinese'), flag: 'ğŸ‡¨ğŸ‡³' },
    { code: 'en', label: t('profile.english'), flag: 'ğŸ‡ºğŸ‡¸' },
  ];

  if (variant === 'compact') {
    return (
      <Pressable
        style={styles.compactButton}
        onPress={() => changeLanguage(currentLanguage === 'zh' ? 'en' : 'zh')}
      >
        <Globe size={20} color={Colors.ink} />
        <Text style={styles.compactText}>
          {currentLanguage === 'zh' ? 'EN' : 'ä¸­'}
        </Text>
      </Pressable>
    );
  }

  return (
    <View style={styles.fullContainer}>
      <Text style={styles.fullTitle}>{t('profile.selectLanguage')}</Text>
      {languages.map((lang) => (
        <Pressable
          key={lang.code}
          style={[
            styles.languageOption,
            currentLanguage === lang.code && styles.languageOptionActive,
          ]}
          onPress={() => changeLanguage(lang.code)}
        >
          <View style={styles.languageLeft}>
            <Text style={styles.flag}>{lang.flag}</Text>
            <Text style={[
              styles.languageLabel,
              currentLanguage === lang.code && styles.languageLabelActive,
            ]}>
              {lang.label}
            </Text>
          </View>
          {currentLanguage === lang.code && (
            <Text style={styles.checkmark}>âœ“</Text>
          )}
        </Pressable>
      ))}
    </View>
  );
};

const styles = StyleSheet.create({
  compactButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: Colors.white,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: Colors.sand,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 4,
    elevation: 2,
  },
  compactText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    fontWeight: '600',
    color: Colors.ink,
  },
  fullContainer: {
    width: '100%',
  },
  fullTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    fontWeight: '600',
    color: Colors.ink,
    marginBottom: 12,
  },
  languageOption: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 16,
    paddingHorizontal: 20,
    backgroundColor: Colors.white,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: Colors.sand,
    marginBottom: 12,
  },
  languageOptionActive: {
    borderColor: Colors.thaiGold,
    backgroundColor: 'rgba(212, 175, 55, 0.05)',
  },
  languageLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  flag: {
    fontSize: 24,
  },
  languageLabel: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.ink,
  },
  languageLabelActive: {
    fontFamily: Typography.notoSerifBold,
    fontWeight: '600',
  },
  checkmark: {
    fontSize: 20,
    color: Colors.thaiGold,
  },
});
````

## File: src/components/common/ListContainer.tsx
````typescript
import { View, Text } from "react-native";

export default function ListContainer() {
    return (
        <View>
            <Text>åˆ—è¡¨å®¹å™¨</Text>
        </View>
    )
}
````

## File: src/components/common/ThaiPatternBackground.tsx
````typescript
// src/components/ThaiPatternBackground.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import Svg, { Defs, Pattern, Rect, G, Path } from 'react-native-svg';

interface ThaiPatternBackgroundProps {
  opacity?: number;
}

export const ThaiPatternBackground: React.FC<ThaiPatternBackgroundProps> = ({
  opacity = 0.15,
}) => {
  return (
    <View style={styles.container}>
      <Svg width="100%" height="100%" style={StyleSheet.absoluteFill}>
        <Defs>
          <Pattern
            id="thaiElephantPattern"
            x="0"
            y="0"
            width="40"
            height="40"
            patternUnits="userSpaceOnUse"
          >
            <G transform="scale(0.4) translate(10, 10)" opacity={opacity}>
              {/* Head and Trunk */}
              <Path
                d="M 20 20 Q 10 20 10 30 Q 10 45 25 45 L 25 55 Q 20 50 15 55"
                fill="none"
                stroke="#1A1A1A"
                strokeWidth="2.5"
              />
              {/* Ear */}
              <Path
                d="M 25 25 Q 35 15 40 25 Q 40 35 30 35"
                fill="none"
                stroke="#1A1A1A"
                strokeWidth="2.5"
              />
              {/* Back and Body */}
              <Path
                d="M 25 20 Q 40 10 55 25 Q 60 40 55 50 L 55 60"
                fill="none"
                stroke="#1A1A1A"
                strokeWidth="2.5"
              />
              {/* Legs */}
              <Path d="M 25 45 L 25 60" fill="none" stroke="#1A1A1A" strokeWidth="2.5" />
              <Path d="M 45 50 L 45 60" fill="none" stroke="#1A1A1A" strokeWidth="2.5" />
            </G>
          </Pattern>
        </Defs>
        <Rect width="100%" height="100%" fill="url(#thaiElephantPattern)" />
      </Svg>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    ...StyleSheet.absoluteFillObject,
    zIndex: 0,
    overflow: 'hidden',
  },
});
````

## File: src/components/learning/alphabet/AlphabetCompletionView.tsx
````typescript
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView } from 'react-native';
import { CheckCircle, Trophy, Home } from 'lucide-react-native';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import type { RoundEvaluationState } from '@/src/entities/types/phonicsRule.types';

interface AlphabetCompletionViewProps {
    roundEvaluation?: RoundEvaluationState;
    onFinish: () => void;
}

export function AlphabetCompletionView({
    roundEvaluation,
    onFinish,
}: AlphabetCompletionViewProps) {
    const rounds = roundEvaluation?.rounds ?? [];
    const averageAccuracy =
        rounds.reduce((acc, r) => acc + r.accuracy, 0) / (rounds.length || 1);
    const isAllPassed = rounds.every((r) => r.passed);

    return (
        <View style={styles.container}>
            <ScrollView contentContainerStyle={styles.content}>
                {/* Header / Hero Section */}
                <View style={styles.heroSection}>
                    <View style={styles.iconContainer}>
                        {isAllPassed ? (
                            <Trophy size={64} color={Colors.thaiGold} strokeWidth={1.5} />
                        ) : (
                            <CheckCircle size={64} color={Colors.success} strokeWidth={1.5} />
                        )}
                    </View>

                    <Text style={styles.title}>Lesson Complete!</Text>
                    <Text style={styles.subtitle}>
                        {isAllPassed
                            ? 'Excellent work! You mastered this letter.'
                            : 'Good effort! Keep practicing to improve.'}
                    </Text>
                </View>

                {/* Stats Card */}
                <View style={styles.card}>
                    <Text style={styles.cardTitle}>Session Summary</Text>

                    {rounds.map((round) => (
                        <View key={round.roundNumber} style={styles.roundRow}>
                            <Text style={styles.roundLabel}>Round {round.roundNumber}</Text>
                            <View style={styles.statContainer}>
                                <Text
                                    style={[
                                        styles.accuracyText,
                                        { color: round.passed ? '#2A9D8F' : '#E63946' },
                                    ]}
                                >
                                    {(round.accuracy * 100).toFixed(0)}%
                                </Text>
                                <Text style={styles.statusLabel}>
                                    {round.passed ? 'PASSED' : 'RETRY'}
                                </Text>
                            </View>
                        </View>
                    ))}

                    <View style={styles.divider} />

                    <View style={styles.totalRow}>
                        <Text style={styles.totalLabel}>Average Accuracy</Text>
                        <Text style={styles.totalValue}>{(averageAccuracy * 100).toFixed(0)}%</Text>
                    </View>
                </View>
            </ScrollView>

            {/* Footer Action */}
            <View style={styles.footer}>
                <TouchableOpacity style={styles.primaryButton} onPress={onFinish}>
                    <Text style={styles.primaryButtonText}>Finish Lesson</Text>
                </TouchableOpacity>
            </View>
        </View>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: Colors.paper,
    },
    content: {
        padding: 24,
        paddingTop: 60,
        alignItems: 'center',
    },
    heroSection: {
        alignItems: 'center',
        marginBottom: 40,
    },
    iconContainer: {
        width: 120,
        height: 120,
        borderRadius: 60,
        backgroundColor: '#FFF9E6', // Light gold bg
        justifyContent: 'center',
        alignItems: 'center',
        marginBottom: 24,
        borderWidth: 4,
        borderColor: '#FFFFFF',
        shadowColor: '#D4AF37',
        shadowOffset: { width: 0, height: 8 },
        shadowOpacity: 0.15,
        shadowRadius: 16,
        elevation: 10,
    },
    title: {
        fontFamily: Typography.playfairBold,
        fontSize: 32,
        color: Colors.ink,
        marginBottom: 8,
        textAlign: 'center',
    },
    subtitle: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 16,
        color: Colors.taupe,
        textAlign: 'center',
        maxWidth: '80%',
        lineHeight: 24,
    },
    card: {
        width: '100%',
        backgroundColor: Colors.white,
        borderRadius: 24,
        padding: 24,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.06,
        shadowRadius: 12,
        elevation: 4,
        borderWidth: 1,
        borderColor: '#F0F0F0',
    },
    cardTitle: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 18,
        color: Colors.ink,
        marginBottom: 16,
        textAlign: 'left',
    },
    roundRow: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: 16,
    },
    roundLabel: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 16,
        color: Colors.ink,
    },
    statContainer: {
        flexDirection: 'row',
        alignItems: 'center',
        gap: 12,
    },
    accuracyText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
    },
    statusLabel: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 12,
        color: Colors.taupe,
        backgroundColor: '#F5F5F5',
        paddingHorizontal: 8,
        paddingVertical: 4,
        borderRadius: 6,
        overflow: 'hidden',
    },
    divider: {
        height: 1,
        backgroundColor: '#F0F0F0',
        marginVertical: 16,
    },
    totalRow: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
    },
    totalLabel: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.ink,
    },
    totalValue: {
        fontFamily: Typography.playfairBold,
        fontSize: 24,
        color: Colors.thaiGold,
    },
    footer: {
        padding: 24,
        paddingBottom: 40,
        backgroundColor: Colors.paper,
    },
    primaryButton: {
        backgroundColor: Colors.ink,
        height: 56,
        borderRadius: 100,
        justifyContent: 'center',
        alignItems: 'center',
        shadowColor: Colors.ink,
        shadowOffset: { width: 0, height: 8 },
        shadowOpacity: 0.2,
        shadowRadius: 16,
        elevation: 8,
    },
    primaryButtonText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 18,
        color: Colors.white,
    },
});
````

## File: src/components/learning/alphabet/AspiratedContrastQuestion.tsx
````typescript
// src/components/learning/alphabet/AspiratedContrastQuestion.tsx

import React, { useState, useCallback, useRef, useEffect } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
} from 'react-native';
import { Audio } from 'expo-av';
import { Wind } from 'lucide-react-native';

import type { Letter } from '@/src/entities/types/letter.types';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

// ==================== Props æ¥å£ ====================

interface AspiratedContrastQuestionProps {
  /** ç›®æ ‡å­—æ¯ */
  target: Letter;
  
  /** å¯¹æ¯”å­—æ¯ç»„(æœ€å°å¯¹ç«‹ç»„) */
  contrasts: Letter[];
  
  /** ç­”é¢˜å›è°ƒ */
  onAnswer: (isCorrect: boolean) => void;
  
  /** ä¸‹ä¸€é¢˜å›è°ƒ */
  onNext: () => void;
}

// ==================== ä¸»ç»„ä»¶ ====================

export function AspiratedContrastQuestion({
  target,
  contrasts,
  onAnswer,
  onNext,
}: AspiratedContrastQuestionProps) {
  const [answered, setAnswered] = useState(false);
  const [selectedLetter, setSelectedLetter] = useState<string | null>(null);
  const [isPlayingTarget, setIsPlayingTarget] = useState(false);
  const [isPlayingContrast, setIsPlayingContrast] = useState<string | null>(null);
  
  const soundRef = useRef<Audio.Sound | null>(null);

  // æ‰€æœ‰é€‰é¡¹(ç›®æ ‡å­—æ¯+å¯¹æ¯”å­—æ¯)
  const allOptions = [target, ...contrasts];

  // ===== æ¸…ç†éŸ³é¢‘ =====
  useEffect(() => {
    return () => {
      if (soundRef.current) {
        soundRef.current.unloadAsync().catch(() => {});
        soundRef.current = null;
      }
    };
  }, []);

  // ===== æ’­æ”¾éŸ³é¢‘ =====
  const playAudio = useCallback(async (audioUrl: string, letterId: string) => {
    try {
      if (letterId === target._id) {
        setIsPlayingTarget(true);
      } else {
        setIsPlayingContrast(letterId);
      }

      if (soundRef.current) {
        await soundRef.current.unloadAsync();
        soundRef.current = null;
      }

      const { sound } = await Audio.Sound.createAsync(
        { uri: audioUrl },
        { shouldPlay: true }
      );

      soundRef.current = sound;

      sound.setOnPlaybackStatusUpdate((status) => {
        if (status.isLoaded && status.didJustFinish) {
          setIsPlayingTarget(false);
          setIsPlayingContrast(null);
        }
      });
    } catch (error) {
      console.warn('[AspiratedContrast] æ’­æ”¾å¤±è´¥:', error);
      setIsPlayingTarget(false);
      setIsPlayingContrast(null);
    }
  }, [target._id]);

  // ===== é€‰æ‹©ç­”æ¡ˆ =====
  const handleSelectLetter = useCallback(
    (letter: Letter) => {
      if (answered) return;

      setSelectedLetter(letter._id);
      setAnswered(true);

      const isCorrect = letter._id === target._id;
      onAnswer(isCorrect);
    },
    [answered, target._id, onAnswer]
  );

  // ===== åˆ¤æ–­æ˜¯å¦é€æ°” =====
  const isAspirated = (letter: Letter): boolean => {
    return letter.initialSound.includes('h');
  };

  return (
    <View style={styles.container}>
      {/* é¢˜å‹æ ‡é¢˜ */}
      <View style={styles.header}>
        <Wind size={24} color={Colors.thaiGold} />
        <Text style={styles.title}>é€æ°”éŸ³å¯¹æ¯”è®­ç»ƒ</Text>
      </View>

      {/* è¯´æ˜ */}
      <Text style={styles.instruction}>
        ğŸ”Š å…ˆæ’­æ”¾ç›®æ ‡éŸ³é¢‘,ç„¶åä»ä¸‹æ–¹é€‰é¡¹ä¸­é€‰æ‹©å¯¹åº”çš„å­—æ¯
      </Text>

      {/* ç›®æ ‡éŸ³é¢‘æ’­æ”¾ */}
      <TouchableOpacity
        style={styles.targetAudioButton}
        onPress={() => {
          const audioUrl =
            target.fullSoundUrl ||
            target.letterPronunciationUrl ||
            target.audioPath ||
            '';
          playAudio(audioUrl, target._id);
        }}
        disabled={isPlayingTarget}
        accessibilityRole="button"
        accessibilityLabel="æ’­æ”¾ç›®æ ‡å‘éŸ³"
      >
        {isPlayingTarget ? (
          <ActivityIndicator size="small" color={Colors.white} />
        ) : (
          <>
            <Text style={styles.targetAudioIcon}>ğŸ”Š</Text>
            <Text style={styles.targetAudioText}>æ’­æ”¾ç›®æ ‡å‘éŸ³</Text>
          </>
        )}
      </TouchableOpacity>

      {/* æç¤ºå¡ç‰‡ */}
      <View style={styles.hintCard}>
        <Text style={styles.hintTitle}>ğŸ’¡ åŒºåˆ†æŠ€å·§</Text>
        <Text style={styles.hintText}>
          â€¢ é€æ°”éŸ³: å‘éŸ³æ—¶æœ‰æ˜æ˜¾æ°”æµ (å¦‚ à¸‚ à¸– à¸œ)
        </Text>
        <Text style={styles.hintText}>
          â€¢ ä¸é€æ°”éŸ³: å‘éŸ³æ—¶æ°”æµè¾ƒå¼± (å¦‚ à¸ à¸” à¸š)
        </Text>
        <Text style={styles.hintText}>
          â€¢ ç”¨æ‰‹æ”¾åœ¨å˜´å‰æ„Ÿå—æ°”æµå¼ºåº¦!
        </Text>
      </View>

      {/* é€‰é¡¹(æœ€å°å¯¹ç«‹ç»„) */}
      <View style={styles.optionsContainer}>
        {allOptions.map((letter) => {
          const isSelected = selectedLetter === letter._id;
          const isCorrect = answered && letter._id === target._id;
          const isWrong = answered && isSelected && letter._id !== target._id;
          const isPlaying = isPlayingContrast === letter._id;

          return (
            <View key={letter._id} style={styles.optionWrapper}>
              {/* å­—æ¯å¡ç‰‡ */}
              <TouchableOpacity
                style={[
                  styles.optionCard,
                  isSelected && styles.optionSelected,
                  isCorrect && styles.optionCorrect,
                  isWrong && styles.optionWrong,
                ]}
                onPress={() => handleSelectLetter(letter)}
                disabled={answered}
                accessibilityRole="radio"
                accessibilityLabel={`å­—æ¯ ${letter.thaiChar}`}
                accessibilityState={{ selected: isSelected }}
              >
                <Text style={styles.optionChar}>{letter.thaiChar}</Text>
                <Text style={styles.optionName}>{letter.nameThai}</Text>
                
                {/* é€æ°”æ ‡è¯† */}
                {isAspirated(letter) && (
                  <View style={styles.aspiratedBadge}>
                    <Wind size={12} color={Colors.thaiGold} />
                    <Text style={styles.aspiratedText}>é€æ°”</Text>
                  </View>
                )}

                {/* åé¦ˆå›¾æ ‡ */}
                {answered && (
                  <View style={styles.feedbackIcon}>
                    {isCorrect && <Text style={styles.correctIcon}>âœ“</Text>}
                    {isWrong && <Text style={styles.wrongIcon}>âœ—</Text>}
                  </View>
                )}
              </TouchableOpacity>

              {/* æ’­æ”¾å¯¹æ¯”éŸ³é¢‘æŒ‰é’® */}
              <TouchableOpacity
                style={styles.playContrastButton}
                onPress={() => {
                  const audioUrl =
                    letter.fullSoundUrl ||
                    letter.letterPronunciationUrl ||
                    letter.audioPath ||
                    '';
                  playAudio(audioUrl, letter._id);
                }}
                disabled={isPlaying}
                accessibilityRole="button"
                accessibilityLabel={`æ’­æ”¾ ${letter.thaiChar} çš„å‘éŸ³`}
              >
                {isPlaying ? (
                  <ActivityIndicator size="small" color={Colors.thaiGold} />
                ) : (
                  <Text style={styles.playContrastIcon}>â–¶</Text>
                )}
              </TouchableOpacity>
            </View>
          );
        })}
      </View>

      {/* è§£é‡Š(ç­”é¢˜å) */}
      {answered && (
        <View style={styles.explanationCard}>
          <Text style={styles.explanationText}>
            âœ… æ­£ç¡®ç­”æ¡ˆ: {target.thaiChar} ({target.nameThai})
            {'\n'}
            {isAspirated(target)
              ? 'è¿™æ˜¯ä¸€ä¸ªé€æ°”éŸ³,å‘éŸ³æ—¶æœ‰æ˜æ˜¾æ°”æµ'
              : 'è¿™æ˜¯ä¸€ä¸ªä¸é€æ°”éŸ³,å‘éŸ³æ—¶æ°”æµè¾ƒå¼±'}
          </Text>
        </View>
      )}

      {/* ä¸‹ä¸€é¢˜æŒ‰é’® */}
      {answered && (
        <TouchableOpacity
          style={styles.nextButton}
          onPress={onNext}
          accessibilityRole="button"
          accessibilityLabel="ä¸‹ä¸€é¢˜"
        >
          <Text style={styles.nextButtonText}>ä¸‹ä¸€é¢˜ â†’</Text>
        </TouchableOpacity>
      )}
    </View>
  );
}

// ==================== æ ·å¼ ====================

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 24,
    backgroundColor: Colors.paper,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 16,
  },
  title: {
    fontFamily: Typography.playfairBold,
    fontSize: 22,
    color: Colors.ink,
    marginLeft: 12,
  },
  instruction: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
    textAlign: 'center',
    marginBottom: 20,
  },
  targetAudioButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: Colors.thaiGold,
    borderRadius: 12,
    padding: 16,
    marginBottom: 24,
    minHeight: 56,
  },
  targetAudioIcon: {
    fontSize: 24,
    marginRight: 8,
  },
  targetAudioText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
  },
  hintCard: {
    backgroundColor: '#FFF9E6',
    borderRadius: 12,
    padding: 16,
    marginBottom: 24,
  },
  hintTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    color: Colors.ink,
    marginBottom: 8,
  },
  hintText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 13,
    color: Colors.taupe,
    marginBottom: 4,
  },
  optionsContainer: {
    gap: 16,
    marginBottom: 20,
  },
  optionWrapper: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  optionCard: {
    flex: 1,
    backgroundColor: Colors.white,
    borderWidth: 2,
    borderColor: Colors.sand,
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    minHeight: 100,
  },
  optionSelected: {
    borderColor: Colors.thaiGold,
    backgroundColor: '#FFF9E6',
  },
  optionCorrect: {
    borderColor: '#2A9D8F',
    backgroundColor: '#E8F5F3',
  },
  optionWrong: {
    borderColor: '#E63946',
    backgroundColor: '#FFE8EA',
  },
  optionChar: {
    fontFamily: Typography.playfairBold,
    fontSize: 48,
    color: Colors.ink,
    marginBottom: 8,
  },
  optionName: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  aspiratedBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(212, 175, 55, 0.1)',
    borderRadius: 12,
    paddingHorizontal: 8,
    paddingVertical: 4,
    marginTop: 8,
  },
  aspiratedText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 10,
    color: Colors.thaiGold,
    marginLeft: 4,
  },
  feedbackIcon: {
    position: 'absolute',
    top: 8,
    right: 8,
  },
  correctIcon: {
    fontSize: 24,
    color: '#2A9D8F',
  },
  wrongIcon: {
    fontSize: 24,
    color: '#E63946',
  },
  playContrastButton: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: Colors.white,
    borderWidth: 2,
    borderColor: Colors.thaiGold,
    justifyContent: 'center',
    alignItems: 'center',
  },
  playContrastIcon: {
    fontSize: 16,
    color: Colors.thaiGold,
  },
  explanationCard: {
    backgroundColor: '#F0F8FF',
    borderRadius: 12,
    padding: 16,
    marginBottom: 20,
  },
  explanationText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    lineHeight: 20,
    color: Colors.ink,
  },
  nextButton: {
    backgroundColor: Colors.thaiGold,
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
  },
  nextButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
  },
});
````

## File: src/components/learning/alphabet/MiniReviewQuestion.tsx
````typescript
// src/components/learning/alphabet/MiniReviewQuestion.tsx

import React, { useState, useCallback, useRef, useEffect } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
  ScrollView,
} from 'react-native';
import { Audio } from 'expo-av';
import { Volume2 } from 'lucide-react-native';

import type { MiniReviewQuestion as MiniReviewQuestionType } from '@/src/entities/types/phonicsRule.types';
import type { QuestionType } from '@/src/entities/enums/QuestionType.enum';
import {
  QUESTION_TYPE_LABELS,
  QUESTION_TYPE_ICONS,
} from '@/src/entities/enums/QuestionType.enum';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

// ==================== Props æ¥å£ ====================

interface MiniReviewQuestionProps {
  /** é¢˜ç›®æ•°æ® */
  question: MiniReviewQuestionType;
  
  /** ç­”é¢˜å›è°ƒ(isCorrect, questionType) */
  onAnswer: (isCorrect: boolean, type: QuestionType) => void;
  
  /** ä¸‹ä¸€é¢˜å›è°ƒ */
  onNext: () => void;
  
  /** è¿”å›å›è°ƒ(å¯é€‰) */
  onBack?: () => void;
}

// ==================== ä¸»ç»„ä»¶ ====================

export function MiniReviewQuestion({
  question,
  onAnswer,
  onNext,
  onBack,
}: MiniReviewQuestionProps) {
  const [answered, setAnswered] = useState(false);
  const [selectedOption, setSelectedOption] = useState<string | null>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const soundRef = useRef<Audio.Sound | null>(null);

  // ===== æ¸…ç†éŸ³é¢‘èµ„æº =====
  useEffect(() => {
    return () => {
      if (soundRef.current) {
        soundRef.current.unloadAsync().catch(() => {});
        soundRef.current = null;
      }
    };
  }, [question.id]); // é¢˜ç›®åˆ‡æ¢æ—¶æ¸…ç†

  // ===== æ’­æ”¾éŸ³é¢‘ =====
  const handlePlayAudio = useCallback(async () => {
    if (!question.audioUrl) return;

    try {
      setIsPlaying(true);

      if (soundRef.current) {
        await soundRef.current.replayAsync();
        setIsPlaying(false);
        return;
      }

      const { sound } = await Audio.Sound.createAsync(
        { uri: question.audioUrl },
        { shouldPlay: true }
      );

      soundRef.current = sound;

      sound.setOnPlaybackStatusUpdate((status) => {
        if (status.isLoaded && status.didJustFinish) {
          setIsPlaying(false);
        }
      });
    } catch (error) {
      console.warn('[MiniReviewQuestion] æ’­æ”¾éŸ³é¢‘å¤±è´¥:', error);
      setIsPlaying(false);
    }
  }, [question.audioUrl]);

  // ===== é€‰æ‹©ç­”æ¡ˆ =====
  const handleSelectOption = useCallback(
    (optionValue: string) => {
      if (answered) return;

      setSelectedOption(optionValue);
      setAnswered(true);

      const isCorrect = optionValue === question.correct;
      onAnswer(isCorrect, question.type);
    },
    [answered, question.correct, question.type, onAnswer]
  );

  // ===== æ¸²æŸ“å£°å­¦æç¤º =====
  const renderAcousticHint = () => {
    if (!question.acousticHint) return null;

    const { aspirated, voiceless, class: consonantClass } = question.acousticHint;

    return (
      <View style={styles.hintContainer}>
        <Text style={styles.hintTitle}>ğŸ’¡ æç¤º:</Text>
        {aspirated !== undefined && (
          <Text style={styles.hintText}>
            â€¢ {aspirated ? 'é€æ°”éŸ³ (aspirated)' : 'ä¸é€æ°”éŸ³ (unaspirated)'}
          </Text>
        )}
        {voiceless !== undefined && (
          <Text style={styles.hintText}>
            â€¢ {voiceless ? 'æ¸…éŸ³ (voiceless)' : 'æµŠéŸ³ (voiced)'}
          </Text>
        )}
        {consonantClass && (
          <Text style={styles.hintText}>
            â€¢ è¾…éŸ³ç±»: {consonantClass === 'high' ? 'é«˜è¾…éŸ³' : consonantClass === 'mid' ? 'ä¸­è¾…éŸ³' : 'ä½è¾…éŸ³'}
          </Text>
        )}
      </View>
    );
  };

  // ===== æ¸²æŸ“éŸ³é«˜å¯è§†åŒ– =====
  const renderPitchVisualization = () => {
    if (!question.pitchVisualization?.enable) return null;
    if (!answered && !question.pitchVisualization.showAfterAnswer) return null;

    const { curve } = question.pitchVisualization;

    return (
      <View style={styles.pitchContainer}>
        <Text style={styles.pitchTitle}>ğŸµ éŸ³é«˜æ›²çº¿</Text>
        <View style={styles.pitchChart}>
          {curve.map((height, index) => (
            <View
              key={index}
              style={[
                styles.pitchBar,
                { height: `${(height / 5) * 100}%` },
              ]}
            />
          ))}
        </View>
      </View>
    );
  };

  // ===== åˆ¤æ–­é¢˜å‹æ˜¯å¦éœ€è¦éŸ³é¢‘ =====
  const needsAudio = [
    'sound-to-letter',
    'aspirated-contrast',
    'vowel-length-contrast',
    'tone-perception',
  ].includes(question.type);

  return (
    <ScrollView
      style={styles.container}
      contentContainerStyle={styles.contentContainer}
    >
      {/* é¢˜å‹æ ‡é¢˜ */}
      <View style={styles.header}>
        <Text style={styles.typeIcon}>
          {QUESTION_TYPE_ICONS[question.type] || 'ğŸ“'}
        </Text>
        <Text style={styles.typeLabel}>
          {QUESTION_TYPE_LABELS[question.type]}
        </Text>
      </View>

      {/* é¢˜å¹² */}
      <Text style={styles.question}>{question.question}</Text>

      {/* å‰¯æ ‡é¢˜ */}
      {question.subtitle && (
        <Text style={styles.subtitle}>{question.subtitle}</Text>
      )}

      {/* éŸ³é¢‘æ’­æ”¾æŒ‰é’® */}
      {needsAudio && question.audioUrl && (
        <TouchableOpacity
          style={styles.audioButton}
          onPress={handlePlayAudio}
          disabled={isPlaying}
          accessibilityRole="button"
          accessibilityLabel="æ’­æ”¾å‘éŸ³"
        >
          {isPlaying ? (
            <ActivityIndicator size="small" color={Colors.white} />
          ) : (
            <>
              <Volume2 size={20} color={Colors.white} />
              <Text style={styles.audioButtonText}>æ’­æ”¾å‘éŸ³</Text>
            </>
          )}
        </TouchableOpacity>
      )}

      {/* å£°å­¦æç¤º(ç­”é¢˜å‰æ˜¾ç¤º) */}
      {!answered && renderAcousticHint()}

      {/* é€‰é¡¹ */}
      <View style={styles.optionsContainer}>
        {question.options.map((option, index) => {
          const isSelected = selectedOption === option.value;
          const isCorrect = answered && option.value === question.correct;
          const isWrong = answered && isSelected && option.value !== question.correct;

          return (
            <TouchableOpacity
              key={index}
              style={[
                styles.optionButton,
                isSelected && styles.optionSelected,
                isCorrect && styles.optionCorrect,
                isWrong && styles.optionWrong,
              ]}
              onPress={() => handleSelectOption(option.value)}
              disabled={answered}
              accessibilityRole="radio"
              accessibilityLabel={option.label}
              accessibilityState={{ selected: isSelected }}
            >
              <View style={styles.optionContent}>
                <Text
                  style={[
                    styles.optionLabel,
                    isSelected && styles.optionLabelSelected,
                  ]}
                >
                  {option.label}
                </Text>
                {option.example && (
                  <Text style={styles.optionExample}>{option.example}</Text>
                )}
              </View>
              {answered && (
                <Text style={styles.feedbackIcon}>
                  {isCorrect ? 'âœ“' : isWrong ? 'âœ—' : ''}
                </Text>
              )}
            </TouchableOpacity>
          );
        })}
      </View>

      {/* è§£é‡Š(ç­”é¢˜åæ˜¾ç¤º) */}
      {answered && question.explanation && (
        <View style={styles.explanationContainer}>
          <Text style={styles.explanationText}>
            ğŸ’¡ {question.explanation}
          </Text>
        </View>
      )}

      {/* éŸ³é«˜å¯è§†åŒ–(ç­”é¢˜åæ˜¾ç¤º) */}
      {answered && renderPitchVisualization()}

      {/* ä¸‹ä¸€é¢˜æŒ‰é’® */}
      {answered && (
        <TouchableOpacity
          style={styles.nextButton}
          onPress={onNext}
          accessibilityRole="button"
          accessibilityLabel="ä¸‹ä¸€é¢˜"
        >
          <Text style={styles.nextButtonText}>ä¸‹ä¸€é¢˜ â†’</Text>
        </TouchableOpacity>
      )}
    </ScrollView>
  );
}

// ==================== æ ·å¼ ====================

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.paper,
  },
  contentContainer: {
    padding: 24,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 20,
  },
  typeIcon: {
    fontSize: 24,
    marginRight: 8,
  },
  typeLabel: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 18,
    color: Colors.ink,
  },
  question: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 20,
    color: Colors.ink,
    textAlign: 'center',
    marginBottom: 12,
  },
  subtitle: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
    textAlign: 'center',
    marginBottom: 20,
  },
  audioButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: Colors.thaiGold,
    borderRadius: 12,
    padding: 14,
    marginBottom: 24,
    minHeight: 50,
  },
  audioButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
    marginLeft: 8,
  },
  hintContainer: {
    backgroundColor: '#FFF9E6',
    borderLeftWidth: 4,
    borderLeftColor: Colors.thaiGold,
    borderRadius: 8,
    padding: 16,
    marginBottom: 20,
  },
  hintTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    color: Colors.ink,
    marginBottom: 8,
  },
  hintText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 13,
    color: Colors.taupe,
    marginBottom: 4,
  },
  optionsContainer: {
    gap: 12,
    marginBottom: 20,
  },
  optionButton: {
    backgroundColor: Colors.white,
    borderWidth: 2,
    borderColor: Colors.sand,
    borderRadius: 12,
    padding: 16,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    minHeight: 60,
  },
  optionSelected: {
    borderColor: Colors.thaiGold,
    backgroundColor: '#FFF9E6',
  },
  optionCorrect: {
    borderColor: '#2A9D8F',
    backgroundColor: '#E8F5F3',
  },
  optionWrong: {
    borderColor: '#E63946',
    backgroundColor: '#FFE8EA',
  },
  optionContent: {
    flex: 1,
  },
  optionLabel: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 18,
    color: Colors.ink,
  },
  optionLabelSelected: {
    color: Colors.thaiGold,
  },
  optionExample: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 12,
    color: Colors.taupe,
    marginTop: 4,
  },
  feedbackIcon: {
    fontSize: 24,
    marginLeft: 12,
  },
  explanationContainer: {
    backgroundColor: '#F0F8FF',
    borderLeftWidth: 4,
    borderLeftColor: '#457B9D',
    borderRadius: 8,
    padding: 16,
    marginBottom: 20,
  },
  explanationText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    lineHeight: 20,
    color: Colors.ink,
  },
  pitchContainer: {
    backgroundColor: '#F5F5F5',
    borderRadius: 12,
    padding: 16,
    marginBottom: 20,
  },
  pitchTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    color: Colors.ink,
    marginBottom: 12,
    textAlign: 'center',
  },
  pitchChart: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    justifyContent: 'space-around',
    height: 100,
    backgroundColor: Colors.white,
    borderRadius: 8,
    padding: 12,
  },
  pitchBar: {
    width: 40,
    backgroundColor: Colors.thaiGold,
    borderRadius: 4,
  },
  nextButton: {
    backgroundColor: Colors.thaiGold,
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
  },
  nextButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
  },
});
````

## File: src/components/learning/alphabet/RoundCompletionView.tsx
````typescript
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { CheckCircle2 } from 'lucide-react-native';

interface RoundCompletionViewProps {
    roundNumber: number;
    onFinish: () => void;
}

export function RoundCompletionView({
    roundNumber,
    onFinish,
}: RoundCompletionViewProps) {
    const isFinal = roundNumber >= 3;

    return (
        <View style={styles.container}>
            <View style={styles.content}>
                <CheckCircle2 size={80} color={Colors.thaiGold} style={styles.icon} />

                <Text style={styles.title}>
                    {isFinal ? 'è¯¾ç¨‹å®Œæˆï¼' : `Round ${roundNumber} å®Œæˆ`}
                </Text>

                <Text style={styles.subtitle}>
                    {isFinal
                        ? 'æ­å–œä½ å®Œæˆäº†æœ¬èŠ‚è¯¾ç¨‹çš„æ‰€æœ‰å­¦ä¹ å†…å®¹ï¼'
                        : 'ä¼‘æ¯ä¸€ä¸‹ï¼Œå‡†å¤‡è¿›å…¥ä¸‹ä¸€è½®å­¦ä¹ \næ¯èŠ‚è¯¾éœ€å®Œæˆ3è½®å­¦ä¹ '}
                </Text>

                <TouchableOpacity
                    style={styles.button}
                    onPress={onFinish}
                    activeOpacity={0.8}
                >
                    <Text style={styles.buttonText}>
                        {isFinal ? 'å®Œæˆè¯¾ç¨‹' : 'è¿”å›é€‰è¯¾'}
                    </Text>
                </TouchableOpacity>
            </View>
        </View>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: Colors.paper,
        justifyContent: 'center',
        padding: 24,
    },
    content: {
        alignItems: 'center',
        backgroundColor: Colors.white,
        padding: 32,
        borderRadius: 24,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.1,
        shadowRadius: 12,
        elevation: 4,
    },
    icon: {
        marginBottom: 24,
    },
    title: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 24,
        color: Colors.ink,
        marginBottom: 12,
        textAlign: 'center',
    },
    subtitle: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 16,
        color: Colors.taupe,
        marginBottom: 32,
        textAlign: 'center',
        lineHeight: 24,
    },
    button: {
        backgroundColor: Colors.ink,
        paddingHorizontal: 48,
        paddingVertical: 16,
        borderRadius: 100,
        width: '100%',
        alignItems: 'center',
    },
    buttonText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.white,
    },
});
````

## File: src/components/learning/alphabet/SessionRecoveryCard.tsx
````typescript
// src/components/learning/alphabet/SessionRecoveryCard.tsx

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

interface SessionRecoveryCardProps {
    onContinue: () => void;
    onRestart: () => void;
}

export function SessionRecoveryCard({
    onContinue,
    onRestart,
}: SessionRecoveryCardProps) {
    return (
        <View style={styles.overlay}>
            <View style={styles.card}>
                <Text style={styles.title}>ç»§ç»­ä¸Šæ¬¡å­¦ä¹ ï¼Ÿ</Text>
                <Text style={styles.description}>
                    æ£€æµ‹åˆ°æ‚¨åœ¨è¯¥è¯¾ç¨‹å­˜åœ¨æœªå®Œæˆçš„è½®æ¬¡ï¼Œæ˜¯å¦ç»§ç»­ä¹‹å‰çš„é˜¶æ®µï¼Ÿ
                </Text>

                <View style={styles.buttonRow}>
                    <TouchableOpacity
                        style={[styles.button, styles.restartButton]}
                        onPress={onRestart}
                    >
                        <Text style={styles.restartText}>é‡æ–°å¼€å§‹æœ¬è½®</Text>
                    </TouchableOpacity>

                    <TouchableOpacity
                        style={[styles.button, styles.continueButton]}
                        onPress={onContinue}
                    >
                        <Text style={styles.continueText}>ç»§ç»­å­¦ä¹ </Text>
                    </TouchableOpacity>
                </View>
            </View>
        </View>
    );
}

const styles = StyleSheet.create({
    overlay: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        justifyContent: 'center',
        alignItems: 'center',
        zIndex: 1000,
    },
    card: {
        width: '85%',
        maxWidth: 400,
        backgroundColor: Colors.paper, // slightly off-white like the Phonics card
        borderRadius: 20,
        padding: 24,
        alignItems: 'center',
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.25,
        shadowRadius: 10,
        elevation: 10,
    },
    title: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 20,
        color: Colors.ink,
        marginBottom: 12,
        textAlign: 'center',
    },
    description: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 15,
        color: Colors.taupe,
        textAlign: 'center',
        lineHeight: 22,
        marginBottom: 24,
    },
    buttonRow: {
        flexDirection: 'row',
        width: '100%',
        gap: 12,
        borderTopWidth: 1,
        borderTopColor: '#E0E0E0',
        paddingTop: 16,
    },
    button: {
        flex: 1,
        paddingVertical: 14,
        borderRadius: 12,
        justifyContent: 'center',
        alignItems: 'center',
    },
    restartButton: {
        backgroundColor: '#F5F5F5',
    },
    continueButton: {
        backgroundColor: '#F0F8FF', // Light blueish/interaction hint
    },
    restartText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 15,
        color: '#E63946', // Red destructive color
    },
    continueText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 15,
        color: '#007AFF', // Standard action blue, or we can use another brand color
    },
});
````

## File: src/components/learning/NewWordView.tsx
````typescript
import React, { useState } from 'react';
import { useTranslation } from 'react-i18next';
import { View, Text, StyleSheet, Pressable, ScrollView, Dimensions } from 'react-native';
import { Volume2 } from 'lucide-react-native';
import { BlurView } from 'expo-blur';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

// Define types for the word data
export interface WordData {
    id: string;
    thai: string;
    phonetic: string;
    type: string;
    meaning: string;
    definitions: {
        basic: string;
        examples: { thai: string; meaning: string }[];
        usage: {
            grammar: { label: string; content: string; example?: string }[];
            diff: string;
            mistakes: string;
            similar: string;
        };
    };
}

interface NewWordViewProps {
    word: WordData;
    onNext: () => void;
}

type TabType = 'basic' | 'examples' | 'usage';

export const NewWordView: React.FC<NewWordViewProps> = ({ word, onNext }) => {
    const { t } = useTranslation();
    const [isRevealed, setIsRevealed] = useState(false);
    const [activeTab, setActiveTab] = useState<TabType>('basic');

    const handleViewDefinition = () => {
        setIsRevealed(true);
    };

    return (
        <View style={styles.container}>
            <View style={styles.content}>
                {/* Top Section: Word Display */}
                <View style={styles.cardContainer}>
                    <View style={styles.wordCard}>
                        <Text style={styles.thaiWord}>{word.thai}</Text>

                        <View style={styles.phoneticRow}>
                            <Pressable style={styles.audioButton}>
                                <Volume2 size={20} color={Colors.thaiGold} />
                            </Pressable>
                            <Text style={styles.phoneticText}>{word.phonetic}</Text>
                        </View>
                    </View>
                </View>

                {/* Middle Section: Details */}
                <View style={styles.detailsContainer}>
                    {/* Meaning Header */}
                    <View style={styles.meaningHeader}>
                        <Text style={styles.mainMeaning}>{word.meaning}</Text>
                        <View style={styles.typeTag}>
                            <Text style={styles.typeText}>{word.type}</Text>
                        </View>
                    </View>

                    {/* Tabs */}
                    <View style={styles.tabs}>
                        <Pressable
                            style={[styles.tab, activeTab === 'basic' && styles.activeTab]}
                            onPress={() => setActiveTab('basic')}
                        >
                            <Text style={[styles.tabText, activeTab === 'basic' && styles.activeTabText]}>{t('learning.basicDefinition')}</Text>
                        </Pressable>
                        <Pressable
                            style={[styles.tab, activeTab === 'examples' && styles.activeTab]}
                            onPress={() => setActiveTab('examples')}
                        >
                            <Text style={[styles.tabText, activeTab === 'examples' && styles.activeTabText]}>{t('learning.exampleSentences')}</Text>
                        </Pressable>
                        <Pressable
                            style={[styles.tab, activeTab === 'usage' && styles.activeTab]}
                            onPress={() => setActiveTab('usage')}
                        >
                            <Text style={[styles.tabText, activeTab === 'usage' && styles.activeTabText]}>{t('learning.usageDetails')}</Text>
                        </Pressable>
                    </View>

                    {/* Content Area */}
                    <View style={styles.scrollAreaWrapper}>
                        <ScrollView
                            style={styles.scrollArea}
                            contentContainerStyle={styles.scrollContent}
                            showsVerticalScrollIndicator={false}
                        >
                            {activeTab === 'basic' && (
                                <Text style={styles.bodyText}>{word.definitions.basic}</Text>
                            )}

                            {activeTab === 'examples' && (
                                <View style={styles.examplesList}>
                                    {word.definitions.examples.map((ex, index) => (
                                        <View key={index} style={styles.exampleItem}>
                                            <Text style={styles.exampleThai}>{ex.thai}</Text>
                                            <Text style={styles.exampleMeaning}>{ex.meaning}</Text>
                                        </View>
                                    ))}
                                </View>
                            )}

                            {activeTab === 'usage' && (
                                <View style={styles.usageContent}>
                                    <Text style={styles.sectionTitle}>{t('learning.grammarExamples')}</Text>
                                    {word.definitions.usage.grammar.map((g, i) => (
                                        <View key={i} style={styles.grammarItem}>
                                            <Text style={styles.grammarLabel}>{g.label}:</Text>
                                            <Text style={styles.grammarContent}>{g.content}</Text>
                                            {g.example && <Text style={styles.grammarExample}>{g.example}</Text>}
                                        </View>
                                    ))}

                                    <Text style={[styles.sectionTitle, styles.mt4]}>{t('learning.diffWithChinese')}</Text>
                                    <Text style={styles.bodyText}>{word.definitions.usage.diff}</Text>

                                    <Text style={[styles.sectionTitle, styles.mt4]}>{t('learning.commonMistakes')}</Text>
                                    <Text style={styles.bodyText}>{word.definitions.usage.mistakes}</Text>

                                    <Text style={[styles.sectionTitle, styles.mt4]}>{t('learning.similarWordsDiff')}</Text>
                                    <Text style={styles.bodyText}>{word.definitions.usage.similar}</Text>
                                </View>
                            )}
                            <View style={{ height: 100 }} />
                        </ScrollView>

                        {/* Blur Overlay */}
                        {!isRevealed && (
                            <BlurView intensity={20} style={StyleSheet.absoluteFill} tint="light">
                                <View style={styles.blurOverlayContent} />
                            </BlurView>
                        )}
                    </View>
                </View>
            </View>

            {/* Bottom Buttons */}
            <View style={styles.bottomBar}>
                {!isRevealed ? (
                    <Pressable style={styles.mainButton} onPress={handleViewDefinition}>
                        <Text style={styles.mainButtonText}>{t('learning.viewDefinition')}</Text>
                    </Pressable>
                ) : (
                    <Pressable style={styles.mainButton} onPress={onNext}>
                        <Text style={styles.mainButtonText}>{t('learning.nextEnter')}</Text>
                    </Pressable>
                )}
            </View>
        </View>
    );
};

const styles = StyleSheet.create({
    container: {
        flex: 1,
    },
    content: {
        flex: 1,
        paddingHorizontal: 20,
        paddingTop: 10,
    },
    cardContainer: {
        alignItems: 'center',
        marginBottom: 24,
    },
    wordCard: {
        width: '100%',
        backgroundColor: Colors.white,
        borderRadius: 16,
        paddingVertical: 24,
        alignItems: 'center',
        justifyContent: 'center',
        borderWidth: 1,
        borderColor: Colors.sand,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.05,
        shadowRadius: 8,
        elevation: 2,
    },
    thaiWord: {
        fontFamily: Typography.sarabunBold,
        fontSize: 56,
        color: Colors.ink,
        marginBottom: 8,
    },
    phoneticRow: {
        flexDirection: 'row',
        alignItems: 'center',
        gap: 8,
    },
    audioButton: {
        padding: 6,
        backgroundColor: 'rgba(212, 175, 55, 0.1)',
        borderRadius: 20,
    },
    phoneticText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 18,
        color: Colors.taupe,
    },
    detailsContainer: {
        flex: 1,
    },
    meaningHeader: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        marginBottom: 24,
        gap: 12,
    },
    mainMeaning: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 24,
        color: Colors.ink,
    },
    typeTag: {
        backgroundColor: 'rgba(212, 175, 55, 0.1)',
        paddingHorizontal: 8,
        paddingVertical: 4,
        borderRadius: 6,
    },
    typeText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 12,
        color: Colors.thaiGold,
    },
    tabs: {
        flexDirection: 'row',
        backgroundColor: Colors.white,
        borderRadius: 12,
        padding: 4,
        marginBottom: 16,
        borderWidth: 1,
        borderColor: Colors.sand,
    },
    tab: {
        flex: 1,
        paddingVertical: 8,
        alignItems: 'center',
        borderRadius: 8,
    },
    activeTab: {
        backgroundColor: 'rgba(212, 175, 55, 0.15)',
    },
    tabText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 13,
        color: Colors.taupe,
    },
    activeTabText: {
        color: Colors.ink,
        fontWeight: '600',
    },
    scrollAreaWrapper: {
        flex: 1,
        position: 'relative',
        borderRadius: 12,
        overflow: 'hidden',
    },
    scrollArea: {
        flex: 1,
    },
    scrollContent: {
        padding: 4,
    },
    blurOverlayContent: {
        flex: 1,
        backgroundColor: 'rgba(250, 249, 246, 0.6)', // Colors.paper with opacity
    },
    bodyText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 15,
        lineHeight: 24,
        color: Colors.ink,
    },
    examplesList: {
        gap: 16,
    },
    exampleItem: {
        backgroundColor: Colors.white,
        padding: 16,
        borderRadius: 12,
        borderLeftWidth: 3,
        borderLeftColor: Colors.thaiGold,
        borderWidth: 1,
        borderColor: 'rgba(0,0,0,0.03)',
    },
    exampleThai: {
        fontFamily: Typography.sarabunRegular,
        fontSize: 16,
        color: Colors.ink,
        marginBottom: 4,
    },
    exampleMeaning: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.taupe,
    },
    usageContent: {
        gap: 12,
    },
    sectionTitle: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.thaiGold,
        marginBottom: 8,
    },
    grammarItem: {
        marginBottom: 8,
    },
    grammarLabel: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 14,
        color: Colors.ink,
    },
    grammarContent: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.ink,
        marginTop: 2,
    },
    grammarExample: {
        fontFamily: Typography.sarabunRegular,
        fontSize: 14,
        color: Colors.taupe,
        marginTop: 2,
        fontStyle: 'italic',
    },
    mt4: {
        marginTop: 16,
    },
    bottomBar: {
        flexDirection: 'row',
        padding: 20,
        gap: 16,
        backgroundColor: Colors.paper,
        borderTopWidth: 1,
        borderTopColor: Colors.sand,
    },
    mainButton: {
        flex: 1,
        backgroundColor: Colors.ink,
        borderRadius: 12,
        alignItems: 'center',
        justifyContent: 'center',
        paddingVertical: 14,
        shadowColor: Colors.thaiGold,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.2,
        shadowRadius: 8,
        elevation: 4,
    },
    mainButtonText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.white,
    },
});
````

## File: src/components/learning/ReviewWordView.tsx
````typescript
import React, { useState } from 'react';
import { useTranslation } from 'react-i18next';
import { View, Text, StyleSheet, Pressable, ScrollView } from 'react-native';
import { Volume2 } from 'lucide-react-native';
import { BlurView } from 'expo-blur';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { WordData } from './NewWordView';

interface ReviewWordViewProps {
    word: WordData;
    onAnswer: (quality: 'know' | 'unsure' | 'forgot') => void;
    onNext: () => void;
}

export const ReviewWordView: React.FC<ReviewWordViewProps> = ({ word, onAnswer, onNext }) => {
    const { t } = useTranslation();
    const [isRevealed, setIsRevealed] = useState(false);

    const handleReveal = (quality: 'know' | 'unsure' | 'forgot') => {
        setIsRevealed(true);
        onAnswer(quality);
    };

    // Extract the first example sentence for the context view
    const exampleSentence = word.definitions.examples[0];

    return (
        <View style={styles.container}>
            <ScrollView style={styles.scrollView} contentContainerStyle={styles.scrollContent}>
                {/* Top Section: Word & Phonetic */}
                <View style={styles.topSection}>
                    <Text style={styles.thaiWord}>{word.thai}</Text>

                    <View style={styles.phoneticRow}>
                        <Pressable style={styles.audioButton}>
                            <Volume2 size={20} color={Colors.thaiGold} />
                        </Pressable>
                        <Text style={styles.phoneticText}>{word.phonetic}</Text>
                    </View>
                </View>

                {/* Context Sentence */}
                {exampleSentence && (
                    <View style={styles.contextContainer}>
                        <Text style={styles.contextThai}>
                            {/* Simple logic to bold the word in the sentence if possible, otherwise just show sentence */}
                            {exampleSentence.thai}
                        </Text>
                        <Text style={styles.contextMeaning}>{exampleSentence.meaning}</Text>
                    </View>
                )}

                {/* Blurred Content Area */}
                <View style={styles.blurredAreaContainer}>
                    <View style={styles.blurredContent}>
                        <View style={styles.meaningHeader}>
                            <Text style={styles.mainMeaning}>{word.meaning}</Text>
                            <View style={styles.typeTag}>
                                <Text style={styles.typeText}>{word.type}</Text>
                            </View>
                        </View>
                        <Text style={styles.definitionText}>{word.definitions.basic}</Text>
                    </View>

                    {!isRevealed && (
                        <BlurView intensity={60} style={StyleSheet.absoluteFill} tint="dark">
                            <View style={styles.blurOverlay} />
                        </BlurView>
                    )}
                </View>
            </ScrollView>

            {/* Bottom Buttons */}
            <View style={styles.bottomBar}>
                {!isRevealed ? (
                    <View style={styles.buttonGrid}>
                        <Pressable
                            style={[styles.actionButton, styles.btnForgot]}
                            onPress={() => handleReveal('forgot')}
                        >
                            <Text style={[styles.btnText, styles.textForgot]}>{t('learning.forgot')}</Text>
                        </Pressable>

                        <Pressable
                            style={[styles.actionButton, styles.btnUnsure]}
                            onPress={() => handleReveal('unsure')}
                        >
                            <Text style={[styles.btnText, styles.textUnsure]}>{t('learning.unsure')}</Text>
                        </Pressable>

                        <Pressable
                            style={[styles.actionButton, styles.btnKnow]}
                            onPress={() => handleReveal('know')}
                        >
                            <Text style={[styles.btnText, styles.textKnow]}>{t('learning.know')}</Text>
                        </Pressable>
                    </View>
                ) : (
                    <Pressable style={styles.nextButton} onPress={onNext}>
                        <Text style={styles.nextButtonText}>{t('learning.next')}</Text>
                    </Pressable>
                )}
            </View>
        </View>
    );
};

const styles = StyleSheet.create({
    container: {
        flex: 1,
    },
    scrollView: {
        flex: 1,
    },
    scrollContent: {
        paddingHorizontal: 24,
        paddingTop: 40,
        paddingBottom: 100,
        alignItems: 'center',
    },
    topSection: {
        alignItems: 'center',
        marginBottom: 32,
    },
    thaiWord: {
        fontFamily: Typography.sarabunBold,
        fontSize: 64,
        color: Colors.ink,
        marginBottom: 12,
    },
    phoneticRow: {
        flexDirection: 'row',
        alignItems: 'center',
        gap: 12,
    },
    audioButton: {
        padding: 8,
        backgroundColor: 'rgba(212, 175, 55, 0.1)',
        borderRadius: 20,
    },
    phoneticText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 20,
        color: Colors.taupe,
    },
    contextContainer: {
        width: '100%',
        backgroundColor: Colors.white,
        padding: 20,
        borderRadius: 16,
        borderWidth: 1,
        borderColor: Colors.sand,
        marginBottom: 32,
    },
    contextThai: {
        fontFamily: Typography.sarabunRegular,
        fontSize: 18,
        color: Colors.ink,
        marginBottom: 8,
        lineHeight: 28,
    },
    contextMeaning: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.taupe,
    },
    blurredAreaContainer: {
        width: '100%',
        minHeight: 200,
        borderRadius: 16,
        overflow: 'hidden',
        position: 'relative',
        backgroundColor: Colors.white,
        borderWidth: 1,
        borderColor: Colors.sand,
    },
    blurredContent: {
        padding: 24,
        alignItems: 'center',
    },
    blurOverlay: {
        flex: 1,
        backgroundColor: 'rgba(26, 26, 26, 0.8)', // Dark overlay for better contrast with white text if needed, or match design
    },
    meaningHeader: {
        flexDirection: 'row',
        alignItems: 'center',
        gap: 12,
        marginBottom: 16,
    },
    mainMeaning: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 24,
        color: Colors.ink,
    },
    typeTag: {
        backgroundColor: 'rgba(212, 175, 55, 0.1)',
        paddingHorizontal: 8,
        paddingVertical: 4,
        borderRadius: 6,
    },
    typeText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 12,
        color: Colors.thaiGold,
    },
    definitionText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 16,
        color: Colors.ink,
        textAlign: 'center',
        lineHeight: 24,
    },
    bottomBar: {
        position: 'absolute',
        bottom: 0,
        left: 0,
        right: 0,
        padding: 24,
        backgroundColor: Colors.paper,
        borderTopWidth: 1,
        borderTopColor: Colors.sand,
    },
    buttonGrid: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        gap: 16,
    },
    actionButton: {
        flex: 1,
        paddingVertical: 16,
        borderRadius: 12,
        alignItems: 'center',
        justifyContent: 'center',
    },
    btnForgot: {
        backgroundColor: '#FEF2F2',
        borderWidth: 1,
        borderColor: '#FCA5A5',
    },
    textForgot: {
        color: '#DC2626',
    },
    btnUnsure: {
        backgroundColor: '#FFFBEB',
        borderWidth: 1,
        borderColor: '#FCD34D',
    },
    textUnsure: {
        color: '#D97706',
    },
    btnKnow: {
        backgroundColor: '#ECFDF5',
        borderWidth: 1,
        borderColor: '#6EE7B7',
    },
    textKnow: {
        color: '#059669',
    },
    btnText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
    },
    nextButton: {
        backgroundColor: Colors.ink,
        paddingVertical: 16,
        borderRadius: 12,
        alignItems: 'center',
    },
    nextButtonText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.white,
    },
});
````

## File: src/config/alphabet/alphabetQuestionTypes.ts
````typescript
// src/components/alphabet/alphabetQuestionTypes.ts

export type AlphabetQuestionType =
  | 'soundToLetter'   // å¬éŸ³ â†’ é€‰å­—æ¯
  | 'letterToSound'   // çœ‹å­—æ¯ â†’ é€‰å‘éŸ³
  | 'reading';        // çœ‹éŸ³èŠ‚/è¯ â†’ é€‰è¯»éŸ³ï¼ˆæ‹¼è¯»ï¼‰

export interface AlphabetQuestionOption {
  id: string;
  label: string;        // å±•ç¤ºç»™ç”¨æˆ·çš„æ–‡å­—ï¼ˆå­—æ¯ or å‘éŸ³ï¼‰
  helper?: string;      // å¯é€‰è¾…åŠ©è¯´æ˜ï¼ˆå¦‚ IPA / ä¸­æ–‡æç¤ºï¼‰
}

export interface AlphabetReviewQuestion {
  id: string;
  type: AlphabetQuestionType;
  prompt: string;
  audioUrl?: string;    // å¬éŸ³é¢˜ç”¨
  mainText?: string;    // ä¸»ä½“å±•ç¤ºï¼ˆå­—æ¯/éŸ³èŠ‚/è¯ï¼‰
  options: AlphabetQuestionOption[];
  correctOptionId: string;
  explanation?: string; // å›ç­”åæ˜¾ç¤ºçš„æ‹¼è¯»è§„åˆ™è¯´æ˜
}
````

## File: src/config/alphabet/phonicsRules.config.ts
````typescript
// src/config/alphabet/phonicsRules.config.ts

import type { PhonicsRule, PhonicsRuleId } from '@/src/entities/types/phonicsRule.types';

/**
 * 6è¯¾æ‹¼è¯»è§„åˆ™å®Œæ•´é…ç½®
 * 
 * æ¯è¯¾ä¸€ä¸ªæ‹¼è¯»è§„åˆ™,åœ¨Today Learningé¦–æ¬¡è¿›å…¥æ—¶æ˜¾ç¤º
 * 
 * @version 1.0.0
 * @see PhonicsRuleCard.tsx
 */
export const PHONICS_RULES: Record<PhonicsRuleId, PhonicsRule> = {
  /**
   * Lesson 1: åŸºç¡€æ‹¼è¯» - CVç»“æ„
   */
  rule_1_cv_structure: {
    id: 'rule_1_cv_structure',
    lessonId: 'lesson1',
    title: 'æ‹¼è¯»è§„åˆ™ 1: è¾…éŸ³+å…ƒéŸ³',
    content: [
      'âœ… æ³°è¯­éŸ³èŠ‚ = è¾…éŸ³(C) + å…ƒéŸ³(V)',
      'âœ… å…ƒéŸ³å¯åœ¨è¾…éŸ³å‰/å/ä¸Š/ä¸‹',
      'âœ… ä¾‹: à¸ + à¸² = à¸à¸² [ka:] (ä¹Œé¸¦)',
      '',
      'ğŸ¯ è®°å¿†å£è¯€: å…ˆè¯»è¾…éŸ³,å†è¯»å…ƒéŸ³',
    ],
    interactiveExample: {
      consonant: 'à¸',
      vowel: 'à¸²',
      syllable: 'à¸à¸²',
      pronunciation: 'ka:',
      audioUrl: 'https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/word-ka.mp3',
    },
    duration: 30,
    order: 1,
  },

  /**
   * Lesson 2: å‰ç½®å…ƒéŸ³ç³»ç»Ÿ
   */
  rule_2_leading_vowel: {
    id: 'rule_2_leading_vowel',
    lessonId: 'lesson2',
    title: 'æ‹¼è¯»è§„åˆ™ 2: å‰ç½®å…ƒéŸ³',
    content: [
      'âš ï¸ å†™åœ¨è¾…éŸ³å‰,è¯»åœ¨è¾…éŸ³å',
      '',
      'âœ… à¹€à¸ = [ke:] ä¸æ˜¯ [ek]',
      'âœ… à¹à¸¡ = [mÉ›:] ä¸æ˜¯ [É›m]',
      'âœ… à¹‚à¸£ = [ro:] ä¸æ˜¯ [or]',
      '',
      'ğŸ¯ è®°å¿†å£è¯€: çœ‹åˆ° à¹€ à¹ à¹‚,å…ˆè¯»è¾…éŸ³å†è¯»å…ƒéŸ³',
    ],
    interactiveExample: {
      consonant: 'à¸',
      vowel: 'à¹€',
      syllable: 'à¹€à¸',
      pronunciation: 'ke:',
      audioUrl: 'https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/syllable-ke.mp3',
    },
    duration: 30,
    order: 2,
  },

  /**
   * Lesson 3: å£°è°ƒç³»ç»Ÿå…¥é—¨
   */
  rule_3_tone_basics: {
    id: 'rule_3_tone_basics',
    lessonId: 'lesson3',
    title: 'æ‹¼è¯»è§„åˆ™ 3: å£°è°ƒå…¥é—¨',
    content: [
      'ğŸµ æ³°è¯­5ä¸ªå£°è°ƒ:',
      '  1. ä¸­å¹³è°ƒ Â¯ (å¦‚: à¸à¸² [ka:Â¯])',
      '  2. ä½é™è°ƒ ` (å¦‚: à¸à¹ˆà¸² [kÃ :])',
      '  3. é™è°ƒ Ë† (å¦‚: à¸à¹‰à¸² [kÃ¢:])',
      '  4. é«˜è°ƒ Â´ (å¦‚: à¸à¹Šà¸² [kÃ¡:])',
      '  5. å‡è°ƒ Ë‡ (å¦‚: à¸à¹‹à¸² [kÇ:])',
      '',
      'ğŸ“Œ å£°è°ƒç”±4ä¸ªå› ç´ å†³å®š:',
      '  â€¢ è¾…éŸ³ç±»(é«˜/ä¸­/ä½)',
      '  â€¢ å…ƒéŸ³é•¿çŸ­',
      '  â€¢ å£°è°ƒç¬¦å·(à¹ˆ à¹‰ à¹Š à¹‹)',
      '  â€¢ éŸ³èŠ‚ç±»å‹(Live/Dead)',
    ],
    visualChart: {
      columns: ['è¾…éŸ³ç±»', 'é•¿+æ— ', 'çŸ­+æ— ', 'à¹ˆ', 'à¹‰'],
      rows: [
        ['ä¸­è¾…éŸ³', 'Â¯', '`', '`', 'Ë†'],
        ['é«˜è¾…éŸ³', 'Â´', '`', '`', 'Ë†'],
      ],
      interactive: true,
    },
    duration: 45,
    order: 3,
  },

  /**
   * Lesson 4: è¾…éŸ³ç±»ä¸å£°è°ƒè§„åˆ™
   */
  rule_4_consonant_class_tones: {
    id: 'rule_4_consonant_class_tones',
    lessonId: 'lesson4',
    title: 'æ‹¼è¯»è§„åˆ™ 4: è¾…éŸ³ç±»ä¸å£°è°ƒ',
    content: [
      'ğŸ”‘ æ ¸å¿ƒæ¦‚å¿µ: åŒæ ·çš„å…ƒéŸ³+ç¬¦å·,ä¸åŒè¾…éŸ³ç±» â†’ ä¸åŒå£°è°ƒ',
      '',
      'ä¾‹: à¸² + æ— ç¬¦å·',
      '  â€¢ à¸ + à¸² = à¸à¸² [ä¸­å¹³Â¯] (ä¸­è¾…éŸ³)',
      '  â€¢ à¸‚ + à¸² = à¸‚à¸² [å‡è°ƒÂ´] (é«˜è¾…éŸ³)',
      '  â€¢ à¸„ + à¸² = à¸„à¸² [ä¸­å¹³Â¯] (ä½è¾…éŸ³)',
      '',
      'ğŸ¯ å­¦ä¹ ç­–ç•¥:',
      '  1. å…ˆè®°è¾…éŸ³ç±»(é«˜/ä¸­/ä½)',
      '  2. å†æŸ¥å£°è°ƒè¡¨',
      '  3. å¤šå¬å¤šç»ƒ,å½¢æˆç›´è§‰',
    ],
    visualChart: {
      columns: ['è¾…éŸ³ç±»', 'é•¿+æ— ', 'çŸ­+æ— ', 'à¹ˆ', 'à¹‰', 'à¹Š', 'à¹‹'],
      rows: [
        ['ä¸­è¾…éŸ³', 'Â¯', '`', '`', 'Ë†', 'Â´', 'Ë‡'],
        ['é«˜è¾…éŸ³', 'Â´', '`', '`', 'Ë†', '-', '-'],
        ['ä½è¾…éŸ³', 'Â¯', 'Â´', 'Ë†', 'Â´', '-', '-'],
      ],
      interactive: true,
    },
    duration: 45,
    order: 4,
  },

  /**
   * Lesson 5: å¤åˆå…ƒéŸ³æ‹¼è¯»
   */
  rule_5_compound_vowels: {
    id: 'rule_5_compound_vowels',
    lessonId: 'lesson5',
    title: 'æ‹¼è¯»è§„åˆ™ 5: å¤åˆå…ƒéŸ³',
    content: [
      'ğŸ”— å¤åˆå…ƒéŸ³ = 2-3ä¸ªå…ƒéŸ³ç¬¦å·ç»„åˆ',
      '',
      'âœ… à¹€à¸­à¸µà¸¢ [ia]: à¹€ + à¸µ + à¸¢',
      '   ä¾‹: à¹€à¸¡à¸µà¸¢ [mia] (å¦»å­)',
      '',
      'âœ… à¹€à¸­à¸·à¸­ [É¯a]: à¹€ + à¸· + à¸­',
      '   ä¾‹: à¹€à¸¡à¸·à¸­à¸‡ [mÉ¯aÅ‹] (åŸå¸‚)',
      '',
      'âœ… à¸­à¸±à¸§ [ua]: à¸± + à¸§',
      '   ä¾‹: à¸„à¸§à¸²à¸¢ [khwaËy] (æ°´ç‰›)',
      '',
      'ğŸ“Œ æ‹¼è¯»æŠ€å·§: å…ˆè¯»è¾…éŸ³,å†æ»‘è¿‡æ•´ä¸ªå¤åˆå…ƒéŸ³',
    ],
    interactiveExample: {
      consonant: 'à¸¡',
      vowel: 'à¹€à¸­à¸µà¸¢',
      syllable: 'à¹€à¸¡à¸µà¸¢',
      pronunciation: 'mia',
      audioUrl: 'https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/word-mia.mp3',
    },
    duration: 30,
    order: 5,
  },

  /**
   * Lesson 6: ç‰¹æ®Šè§„åˆ™æ±‡æ€»
   */
  rule_6_special_cases: {
    id: 'rule_6_special_cases',
    lessonId: 'lesson6',
    title: 'æ‹¼è¯»è§„åˆ™ 6: ç‰¹æ®Šè§„åˆ™',
    content: [
      'ğŸ”¸ à¸: ä½œå£°æ¯è¯» [y],ä½œå°¾éŸ³è¯» [n]',
      '   ä¾‹: à¸à¸²à¸•à¸´ [yÃ¢Ët] (äº²æˆš), à¸«à¸à¸´à¸‡ [yÇÅ‹] (å¥³äºº)',
      '',
      'ğŸ”¸ à¸¤/à¸¦: æ¢µæ–‡ä¸“ç”¨,ç°ä»£æ³°è¯­å°‘è§',
      '   ä¾‹: à¸¤à¸”à¸¹ [rÉ¯ÌdÃ¹Ë] (å­£èŠ‚)',
      '',
      'ğŸ”¸ à¸« + ä½è¾…éŸ³: å˜é«˜è°ƒè§„åˆ™',
      '   ä¾‹: à¸«à¸™à¸¹ [nÇ”Ë] = à¸«(é™éŸ³) + à¸™à¸¹ (å˜é«˜è°ƒ)',
      '',
      'ğŸ”¸ à¹„/à¹ƒ: åŒéŸ³ä¸åŒå½¢,à¹ƒä»…28ä¸ªè¯',
      '   ä¾‹: à¹ƒà¸à¸¥à¹‰ [klÃ¢y] (è¿‘), à¹„à¸à¸¥ [klay] (è¿œ)',
    ],
    duration: 40,
    order: 6,
  },
};

/**
 * æ ¹æ®è¯¾ç¨‹IDè·å–æ‹¼è¯»è§„åˆ™
 */
export function getPhonicsRuleByLesson(lessonId: string): PhonicsRule | null {
  const ruleId = `rule_${lessonId.replace('lesson', '')}_` as PhonicsRuleId;
  
  const ruleMap: Record<string, PhonicsRuleId> = {
    lesson1: 'rule_1_cv_structure',
    lesson2: 'rule_2_leading_vowel',
    lesson3: 'rule_3_tone_basics',
    lesson4: 'rule_4_consonant_class_tones',
    lesson5: 'rule_5_compound_vowels',
    lesson6: 'rule_6_special_cases',
  };
  
  const actualRuleId = ruleMap[lessonId];
  return actualRuleId ? PHONICS_RULES[actualRuleId] : null;
}

/**
 * è·å–æ‰€æœ‰æ‹¼è¯»è§„åˆ™(æŒ‰é¡ºåº)
 */
export function getAllPhonicsRules(): PhonicsRule[] {
  return Object.values(PHONICS_RULES).sort((a, b) => a.order - b.order);
}
````

## File: src/config/backend.config.ts
````typescript
// src/config/backend.config.ts

import { BackendType } from './api.endpoints';

/**
 * åç«¯é…ç½®
 * 
 * ğŸ”§ åˆ‡æ¢åç«¯åªéœ€è¦ä¿®æ”¹ CURRENT_BACKEND
 */

// ==================== ğŸ”§ åˆ‡æ¢åç«¯çš„åœ°æ–¹ ====================
export const CURRENT_BACKEND: BackendType = 
  (process.env.EXPO_PUBLIC_BACKEND as BackendType) || 'cloudbase';

// æç¤ºï¼šåœ¨ .env æ–‡ä»¶ä¸­è®¾ç½® EXPO_PUBLIC_BACKEND=cloudbase æˆ– java

// ==================== åç«¯é…ç½® ====================
export const BACKEND_CONFIG = {
  // CloudBase äº‘å‡½æ•°
  cloudbase: {
    name: 'CloudBase_CloudFunction',
    env: process.env.EXPO_PUBLIC_CLOUDBASE_ENV || 
         'cloud1-1gjcyrdd7ab927c6-1387301748',
    region: process.env.EXPO_PUBLIC_CLOUDBASE_REGION || 'ap-shanghai',
    apiBaseUrl: process.env.EXPO_PUBLIC_API_BASE_URL || 
                'https://cloud1-1gjcyrdd7ab927c6-1387301748.ap-shanghai.app.tcloudbase.com',
  },
  
  // Java Spring Boot
  java: {
    name: 'Java_SpringBoot',
    apiBaseUrl: process.env.EXPO_PUBLIC_JAVA_API_URL || 
                'http://localhost:8080',
    // æœªæ¥ç”Ÿäº§ç¯å¢ƒï¼š'https://api.thailearning.com'
  },
};

// ==================== è·å–å½“å‰åç«¯é…ç½® ====================
export function getCurrentBackendConfig() {
  return BACKEND_CONFIG[CURRENT_BACKEND];
}

// ==================== è·å– API åŸºç¡€åœ°å€ ====================
export function getApiBaseUrl(): string {
  return getCurrentBackendConfig().apiBaseUrl;
}

// ==================== è·å–åç«¯åç§° ====================
export function getBackendName(): string {
  return getCurrentBackendConfig().name;
}

// ==================== åˆ¤æ–­æ˜¯å¦ä¸º CloudBase ====================
export function isCloudBase(): boolean {
  return CURRENT_BACKEND === 'cloudbase';
}

// ==================== åˆ¤æ–­æ˜¯å¦ä¸º Java ====================
export function isJava(): boolean {
  return CURRENT_BACKEND === 'java';
}

// ==================== æ‰“å°å½“å‰é…ç½®ï¼ˆå¼€å‘ç”¨ï¼‰====================
export function logBackendInfo() {
  if (__DEV__) {
    console.log('='.repeat(50));
    console.log('ğŸ”§ å½“å‰åç«¯é…ç½®:');
    console.log('åç«¯ç±»å‹:', CURRENT_BACKEND);
    console.log('åç«¯åç§°:', getBackendName());
    console.log('API åœ°å€:', getApiBaseUrl());
    console.log('='.repeat(50));
  }
}
````

## File: src/constants/typography.ts
````typescript
// src/constants/typography.ts
export const Typography = {
    playfairRegular: 'PlayfairDisplay_400Regular',
    playfairBold: 'PlayfairDisplay_700Bold',
    notoSerifRegular: 'NotoSerifSC_400Regular',
    notoSerifBold: 'NotoSerifSC_700Bold',
    sarabunRegular: 'Sarabun_400Regular',
    sarabunBold: 'Sarabun_700Bold',
    // Font sizes
    h1: 32,
    h2: 24,
    h3: 20,
    body: 16,
    caption: 14,
    small: 12,
    // Font weights (as string for fontWeight property)
    regular: '400' as const,
    semibold: '600' as const,
    bold: '700' as const,
  } as const;
````

## File: src/dev/mocks/phonicsRule.mock.ts
````typescript
// src/dev/mocks/phonicsRule.mock.ts

import { PhonicsRule, PhonicsRuleId } from "@/src/entities/types/phonicsRule.types";

/**
 * æ‹¼è¯»è§„åˆ™ Mock å·¥å‚
 * åŒ…å«å¤šç§åœºæ™¯çš„æµ‹è¯•æ•°æ®
 */
export const MOCK_PHONICS_RULES: Record<string, PhonicsRule> = {
    // 1. æ ‡å‡†åœºæ™¯
    standard: {
        id: "mock_rule_standard" as PhonicsRuleId,
        lessonId: "mock_lesson_1",
        title: "æ‹¼è¯»è§„åˆ™ 1: è¾…éŸ³+å…ƒéŸ³",
        content: [
            "âœ… æ³°è¯­éŸ³èŠ‚ = è¾…éŸ³(C) + å…ƒéŸ³(V)",
            "âœ… å…ƒéŸ³å¯åœ¨è¾…éŸ³å‰/å/ä¸Š/ä¸‹",
            "âœ… ä¾‹: à¸ + à¸² = à¸à¸² [ka:] (ä¹Œé¸¦)",
            "",
            "ğŸ¯ è®°å¿†å£è¯€: å…ˆè¯»è¾…éŸ³,å†è¯»å…ƒéŸ³"
        ],
        interactiveExample: {
            consonant: "à¸",
            vowel: "à¸²",
            syllable: "à¸à¸²",
            pronunciation: "ka:",
            audioUrl: "https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/word-ka.mp3"
        },
        duration: 30,
        order: 1
    },

    // 2. è¶…é•¿æ–‡æœ¬åœºæ™¯ (æµ‹è¯• ScrollView)
    long_text: {
        id: "mock_rule_long" as PhonicsRuleId,
        lessonId: "mock_lesson_2",
        title: "éå¸¸é•¿çš„è§„åˆ™æ ‡é¢˜æµ‹è¯•éå¸¸é•¿çš„è§„åˆ™æ ‡é¢˜æµ‹è¯•éå¸¸é•¿çš„è§„åˆ™æ ‡é¢˜æµ‹è¯•",
        content: [
            "âœ… ç¬¬ä¸€è¡Œå†…å®¹",
            "âœ… ç¬¬äºŒè¡Œå†…å®¹éå¸¸éå¸¸é•¿ï¼Œç”¨æ¥æµ‹è¯•å½“æ–‡å­—è¶…è¿‡ä¸€è¡Œæ—¶æ˜¯å¦ä¼šè‡ªåŠ¨æ¢è¡Œï¼Œä»¥åŠå¯¹å¸ƒå±€çš„å½±å“ã€‚",
            "âœ… ç¬¬ä¸‰è¡Œå†…å®¹",
            "",
            "âœ… ä»¥ä¸‹æ˜¯é‡å¤å†…å®¹ï¼Œç”¨äºæ’‘å¼€é«˜åº¦æµ‹è¯•æ»šåŠ¨ï¼š",
            ...Array(20).fill("ğŸ“ é‡å¤çš„æµ‹è¯•æ–‡æœ¬è¡Œï¼Œç”¨äºéªŒè¯ ScrollView çš„æ»šåŠ¨èƒ½åŠ›æ˜¯å¦æ­£å¸¸å·¥ä½œã€‚"),
            "",
            "ğŸ¯ ç»“æŸè¡Œ"
        ],
        interactiveExample: {
            consonant: "à¸",
            vowel: "à¸²",
            syllable: "à¸à¸²",
            pronunciation: "ka:",
            audioUrl: "https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/word-ka.mp3"
        },
        duration: 60,
        order: 2
    },

    // 3. æ— äº¤äº’ç¤ºä¾‹åœºæ™¯
    no_interactive: {
        id: "mock_rule_simple" as PhonicsRuleId,
        lessonId: "mock_lesson_3",
        title: "çº¯æ–‡æœ¬è§„åˆ™",
        content: [
            "è¿™æ˜¯ä¸€ä¸ªæ²¡æœ‰ä¸‹æ–¹äº¤äº’æŒ‰é’®çš„è§„åˆ™ã€‚",
            "ä»…åŒ…å«æ–‡æœ¬è¯´æ˜ã€‚",
            "ç”¨æ¥æµ‹è¯•å¸ƒå±€æ”¶ç¼©æ˜¯å¦æ­£å¸¸ã€‚"
        ],
        duration: 15,
        order: 3
    },

    // 4. å¸¦æœ‰å¤æ‚å›¾è¡¨çš„åœºæ™¯
    with_chart: {
        id: "mock_rule_chart" as PhonicsRuleId,
        lessonId: "mock_lesson_4",
        title: "å£°è°ƒå›¾è¡¨è§„åˆ™",
        content: [
            "è¿™ä¹Ÿæ˜¯ä¹‹å‰å¼•èµ· Crash çš„å¤æ‚æƒ…å†µã€‚",
            "è¯·æ£€æŸ¥å›¾è¡¨æ¸²æŸ“ã€‚"
        ],
        visualChart: {
            columns: ["", "å¹³", "äºŒ", "ä¸‰", "å››", "äº”"],
            rows: [
                ["ä¸­è¾…éŸ³", "-", "\\", "^", "/", "v"],
                ["é«˜è¾…éŸ³", "v", "\\", "^", "(N/A)", "(N/A)"]
            ],
            interactive: true
        },
        duration: 45,
        order: 4
    }
};
````

## File: src/dev/registry.ts
````typescript
// src/dev/registry.ts

export interface PlaygroundComponent {
    id: string;
    name: string;
    category: string;
    variants: {
        id: string;
        name: string;
        mockId: string; // å¯¹åº” Mock æ•°æ®çš„ key
    }[];
}

export const COMPONENT_REGISTRY: PlaygroundComponent[] = [
    {
        id: 'PhonicsRuleCard',
        name: 'Phonics Rule Card',
        category: 'Learning',
        variants: [
            { id: 'standard', name: 'æ ‡å‡†åœºæ™¯', mockId: 'standard' },
            { id: 'long_text', name: 'è¶…é•¿æ–‡æœ¬æµ‹è¯•', mockId: 'long_text' },
            { id: 'no_interactive', name: 'æ— äº¤äº’ç¤ºä¾‹', mockId: 'no_interactive' },
            { id: 'with_chart', name: 'å¸¦å›¾è¡¨', mockId: 'with_chart' },
        ],
    },
    // å°†æ¥å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ›´å¤šç»„ä»¶ï¼Œå¦‚ RecoveryModal, RoundCompletionView ç­‰
];
````

## File: src/entities/types/alphabetGameTypes.ts
````typescript
// src/entities/enum/alphabetGameTypes.ts

/**
 * Alphabet Game Type Enum
 *
 * å®šä¹‰å­—æ¯æ¨¡å—çš„ç»Ÿä¸€é¢˜å‹åè®®
 * æŒ‰ç…§ alphabet-module-spec.md ç¬¬6ç« å’Œ PROJECT_OVERVIEW_SPEC.md 4.3èŠ‚ Phase 2 è¦æ±‚
 *
 * é¢˜å‹åˆ†ä¸ºä¸¤ç±»:
 * - åŸºç¡€é¢˜å‹(LIGHT_GAME_TYPES): ç”¨äºä¸‰æ–°ä¸€å¤(THREE_NEW_ONE_REVIEW)é˜¶æ®µ
 * - è¿›é˜¶é¢˜å‹(ADVANCED_GAME_TYPES): ç”¨äº Final Review é˜¶æ®µ
 */
export enum AlphabetGameType {
  // ===== åŸºç¡€é¢˜å‹ (ç”¨äºä¸‰æ–°ä¸€å¤) =====

  /** å¬éŸ³é€‰å­— - æ’­æ”¾å­—æ¯å‘éŸ³,ç”¨æˆ·ä»é€‰é¡¹ä¸­é€‰æ‹©æ­£ç¡®çš„æ³°æ–‡å­—æ¯ */
  SOUND_TO_LETTER = 'SOUND_TO_LETTER',

  /** çœ‹å­—é€‰éŸ³ - æ˜¾ç¤ºæ³°æ–‡å­—æ¯,ç”¨æˆ·ä»é€‰é¡¹ä¸­é€‰æ‹©æ­£ç¡®çš„å‘éŸ³ */
  LETTER_TO_SOUND = 'LETTER_TO_SOUND',

  // ===== è¿›é˜¶é¢˜å‹ (ç”¨äº Final Review) =====

  /** è¾…éŸ³ç±»åˆ«åˆ¤æ–­ - åˆ¤æ–­å­—æ¯å±äºé«˜/ä¸­/ä½è¾…éŸ³ */
  CONSONANT_CLASS = 'CONSONANT_CLASS',

  /** é¦–è¾…éŸ³åˆ¤æ–­ - åˆ¤æ–­å­—æ¯çš„é¦–è¾…éŸ³å‘éŸ³ */
  INITIAL_SOUND = 'INITIAL_SOUND',

  /** å°¾è¾…éŸ³åˆ¤æ–­ - åˆ¤æ–­å­—æ¯ä½œä¸ºå°¾éŸ³æ—¶çš„å‘éŸ³ */
  FINAL_SOUND = 'FINAL_SOUND',

  /** å£°è°ƒè®¡ç®— - æ ¹æ®è¾…éŸ³ç±»åˆ«+å…ƒéŸ³+å£°è°ƒç¬¦å·è®¡ç®—æœ€ç»ˆå£°è°ƒ (å ä½å®ç°) */
  TONE_CALCULATION = 'TONE_CALCULATION',

  /** æ‹¼è¯»æ•°å­¦ - è¾…éŸ³+å…ƒéŸ³çš„æ‹¼è¯»ç»„åˆç»ƒä¹  (å ä½å®ç°) */
  PHONICS_MATH = 'PHONICS_MATH',
}

/**
 * é¢˜å‹æ˜¾ç¤ºåç§°æ˜ å°„
 */
export const ALPHABET_GAME_TYPE_LABELS: Record<AlphabetGameType, string> = {
  [AlphabetGameType.SOUND_TO_LETTER]: 'å¬éŸ³é€‰å­—',
  [AlphabetGameType.LETTER_TO_SOUND]: 'çœ‹å­—é€‰éŸ³',
  [AlphabetGameType.CONSONANT_CLASS]: 'è¾…éŸ³ç±»åˆ«',
  [AlphabetGameType.INITIAL_SOUND]: 'é¦–éŸ³åˆ¤æ–­',
  [AlphabetGameType.FINAL_SOUND]: 'å°¾éŸ³åˆ¤æ–­',
  [AlphabetGameType.TONE_CALCULATION]: 'å£°è°ƒè®¡ç®—',
  [AlphabetGameType.PHONICS_MATH]: 'æ‹¼è¯»æ•°å­¦',
};

/**
 * é¢˜å‹éš¾åº¦ç­‰çº§ (1-5)
 */
export const ALPHABET_GAME_TYPE_DIFFICULTY: Record<AlphabetGameType, number> = {
  [AlphabetGameType.SOUND_TO_LETTER]: 1,
  [AlphabetGameType.LETTER_TO_SOUND]: 1,
  [AlphabetGameType.CONSONANT_CLASS]: 2,
  [AlphabetGameType.INITIAL_SOUND]: 2,
  [AlphabetGameType.FINAL_SOUND]: 3,
  [AlphabetGameType.TONE_CALCULATION]: 4,
  [AlphabetGameType.PHONICS_MATH]: 4,
};
````

## File: src/entities/types/api.types.ts
````typescript
//src/entities/types/api.types.ts
//ç”¨äºAPIæ¥å£çš„ç±»å‹å®šä¹‰ï¼Œä½¿ API å“åº”ç»Ÿä¸€æ ¼å¼

export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  code?: string;
}

// ==================== è®¤è¯ç›¸å…³ ====================

//ç™»å½•è¯·æ±‚
export interface LoginRequest {
  email: string;
  password: string;
}

//æ³¨å†Œè¯·æ±‚
export interface RegisterRequest {
  email: string;
  password: string;
  displayName: string;
}

//ç™»å½•å“åº”
export interface LoginResponse {
  user: {
    userId: string;
    email: string;
    displayName: string;
    role: string;
    registrationDate: string;
    avatar?: string;
  };
  token: string;
  expiresIn: number;  // Token è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰
}

//æ³¨å†Œå“åº”
export interface RegisterResponse extends LoginResponse { }

//æ›´æ–°ç”¨æˆ·ä¿¡æ¯è¯·æ±‚
export interface UpdateProfileRequest {
  displayName?: string;
  avatar?: string;
  // Add other fields if needed
}

export interface ResetPasswordRequest {
  email: string;
}

export interface ResetPasswordResponse {
  message?: string;
}

// ==================== è¯¾ç¨‹ç›¸å…³ ====================

//è·å–è¯¾ç¨‹åˆ—è¡¨å“åº”
export interface GetCoursesResponse {
  courses: Array<{
    courseId: string;
    name: string;
    nameZh: string;
    description: string;
    level: string;
    isActive: boolean;
  }>;
}

//è·å–è¯¾ç¨‹å†…å®¹è¯·æ±‚
export interface GetCourseContentRequest {
  courseId: string;
  contentType: 'alphabet' | 'vocabulary' | 'sentence' | 'article';
}

//è·å–è¯¾ç¨‹å†…å®¹å“åº”
export interface GetCourseContentResponse {
  content: any[];  // æ ¹æ® contentType è¿”å›ä¸åŒç»“æ„
}

// ==================== å­¦ä¹ ç›¸å…³ ====================

//è·å–è¯æ±‡è¯·æ±‚
export interface GetVocabularyRequest {
  courseId: string;
  difficulty?: string;
}

//è·å–è¯æ±‡å“åº”
export interface GetVocabularyResponse {
  vocabulary: Array<{
    vocabId: string;
    thai: string;
    chinese: string;
    pronunciation: string;
    example: string;
    audioUrl?: string;
    difficulty: string;
  }>;
}

//è®°å½•å­¦ä¹ è¯·æ±‚
export interface RecordLearningRequest {
  contentType: 'alphabet' | 'vocabulary' | 'sentence' | 'article';
  contentId: string;
  isCorrect: boolean;
  score?: number;
}

// ==================== è¿›åº¦ç›¸å…³ ====================

//è·å–è¿›åº¦å“åº”
export interface GetProgressResponse {
  progressId: string;
  userId: string;
  courseId: string;
  currentLevel: string;
  completedAlphabets: number;
  completedVocabulary: number;
  completedSentences: number;
  completedArticles: number;
  totalScore: number;
  studyTime: number;
  streakDays: number;
}

// ==================== å‘éŸ³è¯„ä¼° ====================

//å‘éŸ³è¯„ä¼°è¯·æ±‚
export interface AssessPronunciationRequest {
  audioData: string;  // Base64 ç¼–ç çš„éŸ³é¢‘
  targetText: string;
  language: string;  // 'th' for Thai
}

//å‘éŸ³è¯„ä¼°å“åº”
export interface AssessPronunciationResponse {
  overallScore: number;
  toneScore: number;
  phonemeScore: number;
  fluencyScore: number;
  feedback: string;
  pitchData?: number[];
}

// ==================== å¤ä¹ ç›¸å…³ ====================

//è·å–å¾…å¤ä¹ å“åº”
export interface GetDueReviewsResponse {
  reviews: Array<{
    scheduleId: string;
    contentType: string;
    contentId: string;
    nextReviewDate: string;
  }>;
}

//æ›´æ–°å¤ä¹ è¯·æ±‚
export interface UpdateReviewRequest {
  scheduleId: string;
  quality: number;  // 1-5
}
````

## File: src/entities/types/course.ts
````typescript
export enum Level {
    BEGINNER_A = 'Beginner A',
    BEGINNER_B = 'Beginner B',
    INTERMEDIATE = 'Intermediate',
    ADVANCED = 'Advanced'
}

export interface Course {
    courseId: string;
    name: string;
    nameZh: string;
    level: Level;
    progress: number;
}
````

## File: src/entities/types/learning.ts
````typescript
import { Level } from './course';

export interface ReviewItem {
    id: string;
    char: string;
    phonetic: string;
    type: 'New' | 'Review' | 'Hard';
    dueIn: string;
    meaning?: string;
    category?: string;
}

export interface LearningProgress {
    progressId: string;
    userId: string;
    courseId: string;
    currentLevel: Level;
    completedAlphabets: number;
    completedVocabulary: number;
    completedSentences: number;
    completedArticles: number;
    totalScore: number;
    totalStudyTime: number;
    streakDays: number;
    lastUpdated: Date;
}
````

## File: src/entities/types/phonicsRule.types.ts
````typescript
// src/entities/types/phonicsRule.types.ts

/**
 * æ‹¼è¯»è§„åˆ™ç±»å‹å®šä¹‰
 * 
 * ç”¨äºV3.0è¯¾ç¨‹æ–¹æ¡ˆçš„æ‹¼è¯»è§„åˆ™å¡ç‰‡ç³»ç»Ÿ
 * å¯¹åº”PhonicsRuleCardç»„ä»¶
 * 
 * @version 1.0.0
 * @see thai_letter_curriculum_SRS_integrated.md
 */

import type { QuestionType } from '../enums/QuestionType.enum';

/**
 * æ‹¼è¯»è§„åˆ™ID (å¯¹åº”6è¯¾)
 */
export type PhonicsRuleId = 
  | 'rule_1_cv_structure'
  | 'rule_2_leading_vowel'
  | 'rule_3_tone_basics'
  | 'rule_4_consonant_class_tones'
  | 'rule_5_compound_vowels'
  | 'rule_6_special_cases';

/**
 * æ‹¼è¯»è§„åˆ™å®Œæ•´å®šä¹‰
 */
export interface PhonicsRule {
  /** è§„åˆ™ID */
  id: PhonicsRuleId;
  
  /** å¯¹åº”è¯¾ç¨‹ID */
  lessonId: string;
  
  /** è§„åˆ™æ ‡é¢˜ */
  title: string;
  
  /** è§„åˆ™å†…å®¹(æ•°ç»„,æ¯é¡¹ä¸ºä¸€è¡Œæ–‡æœ¬) */
  content: string[];
  
  /** äº¤äº’å¼ç¤ºä¾‹(å¯é€‰) */
  interactiveExample?: {
    /** è¾…éŸ³ */
    consonant: string;
    /** å…ƒéŸ³ */
    vowel: string;
    /** ç»„åˆåçš„éŸ³èŠ‚ */
    syllable: string;
    /** å‘éŸ³ */
    pronunciation: string;
    /** éŸ³é¢‘URL */
    audioUrl: string;
  };
  
  /** å¯è§†åŒ–å›¾è¡¨(å¯é€‰,ç”¨äºå£°è°ƒè§„åˆ™ç­‰) */
  visualChart?: {
    /** è¡¨å¤´ */
    columns: string[];
    /** æ•°æ®è¡Œ */
    rows: string[][];
    /** æ˜¯å¦å¯äº¤äº’(ç‚¹å‡»æ’­æ”¾éŸ³é¢‘) */
    interactive?: boolean;
  };
  
  /** æ˜¾ç¤ºæ—¶é•¿(ç§’) */
  duration: number;
  
  /** æ’åºåºå· */
  order: number;
}

/**
 * è¯¾ç¨‹å…ƒæ•°æ®(å«æ‹¼è¯»è§„åˆ™å…³è”)
 */
export interface LessonMetadata {
  /** è¯¾ç¨‹ID */
  lessonId: string;
  
  /** è¯¾ç¨‹æ ‡é¢˜ */
  title: string;
  
  /** è¯¾ç¨‹æè¿° */
  description: string;
  
  /** è¾…éŸ³åˆ—è¡¨ */
  consonants: string[];
  
  /** å…ƒéŸ³åˆ—è¡¨ */
  vowels: string[];
  
  /** å£°è°ƒç¬¦å·åˆ—è¡¨ */
  tones: string[];
  
  /** å…³è”çš„æ‹¼è¯»è§„åˆ™ID */
  phonicsRuleId: PhonicsRuleId;
  
  /** æ€»å­—æ¯æ•° */
  totalCount: number;
  
  /** æœ€ä½é€šè¿‡ç‡(0-1) */
  minPassRate: number;
  
  /** Mini Reviewè§¦å‘é—´éš”(æ¯Nä¸ªå­—æ¯) */
  miniReviewInterval: number;
  
  /** æ’åºåºå· */
  order: number;
}

/**
 * Mini Review é¢˜ç›®å®šä¹‰
 */
export interface MiniReviewQuestion {
  /** é¢˜ç›®ID */
  id: string;
  
  /** é¢˜å‹ */
  type: QuestionType;
  
  /** é¢˜å¹² */
  question: string;
  
  /** å‰¯æ ‡é¢˜(å¯é€‰) */
  subtitle?: string;
  
  /** é€‰é¡¹ */
  options: Array<{
    /** é€‰é¡¹æ–‡æœ¬ */
    label: string;
    /** é€‰é¡¹å€¼ */
    value: string;
    /** ç¤ºä¾‹(å¯é€‰) */
    example?: string;
  }>;
  
  /** æ­£ç¡®ç­”æ¡ˆ */
  correct: string;
  
  /** è§£é‡Š(ç­”é¢˜åæ˜¾ç¤º) */
  explanation?: string;
  
  /** éŸ³é¢‘URL(å¯é€‰) */
  audioUrl?: string;
  
  /** å£°å­¦æç¤º(ç”¨äºé€æ°”éŸ³å¯¹æ¯”ç­‰) */
  acousticHint?: {
    /** æ˜¯å¦é€æ°” */
    aspirated?: boolean;
    /** æ˜¯å¦æ¸…éŸ³ */
    voiceless?: boolean;
    /** è¾…éŸ³ç±» */
    class?: 'high' | 'mid' | 'low';
  };
  
  /** éŸ³é«˜å¯è§†åŒ–(ç”¨äºå£°è°ƒé¢˜) */
  pitchVisualization?: {
    /** æ˜¯å¦å¯ç”¨ */
    enable: boolean;
    /** ç­”é¢˜åæ˜¾ç¤º */
    showAfterAnswer: boolean;
    /** éŸ³é«˜æ›²çº¿æ•°æ® */
    curve: number[];
  };
}

/**
 * ä¸‰è½®è¯„ä¼°é…ç½®
 */
export interface RoundConfig {
  /** æ€»è½®æ•° */
  totalRounds: 3;
  
  /** é€šè¿‡ç‡è¦æ±‚(0-1) */
  passRate: 0.90;
  
  /** æ¯è½®æœ€å¤šå…è®¸çš„é”™è¯¯æ¬¡æ•° */
  maxErrors: number;
}

/**
 * ä¸‰è½®è¯„ä¼°çŠ¶æ€
 */
export interface RoundEvaluationState {
  /** å½“å‰è½®æ•°(1/2/3) */
  currentRound: 1 | 2 | 3;
  
  /** æ¯è½®çš„ç»Ÿè®¡ */
  rounds: Array<{
    /** è½®æ¬¡ç¼–å· */
    roundNumber: number;
    /** æ€»é¢˜æ•° */
    totalQuestions: number;
    /** æ­£ç¡®æ•° */
    correctCount: number;
    /** å‡†ç¡®ç‡(0-1) */
    accuracy: number;
    /** æ˜¯å¦é€šè¿‡ */
    passed: boolean;
  }>;
  
  /** æ˜¯å¦å®Œæˆæ‰€æœ‰è½®æ¬¡ */
  allRoundsPassed: boolean;
}

/**
 * getTodayMemories è¿”å›çš„æ‰©å±•æ•°æ®
 * (åç«¯éœ€æ–°å¢æ­¤å­—æ®µ)
 */
export interface TodayMemoriesWithMetadata {
  /** å­—æ¯åˆ—è¡¨ */
  items: any[];
  
  /** ç»Ÿè®¡ä¿¡æ¯ */
  summary: {
    total: number;
    newCount: number;
    reviewCount: number;
    entityType: string;
  };
  
  /** æ–°å¢: è¯¾ç¨‹å…ƒæ•°æ® */
  lessonMetadata?: LessonMetadata;
  
  /** æ–°å¢: æ‹¼è¯»è§„åˆ™ */
  phonicsRule?: PhonicsRule;
}

/**
 * æœ€å°å¯¹ç«‹ç»„(Minimal Pair)å®šä¹‰
 * ç”¨äºé€æ°”éŸ³å¯¹æ¯”é¢˜å‹
 */
export interface MinimalPairGroup {
  /** æ ¸å¿ƒå­—æ¯ */
  target: string;
  
  /** å¯¹æ¯”å­—æ¯ç»„ */
  contrasts: Array<{
    /** å­—æ¯ */
    char: string;
    /** å¯¹æ¯”ç»´åº¦ */
    dimension: 'aspiration' | 'class' | 'voicing';
    /** è¯´æ˜ */
    label: string;
  }>;
}

/**
 * å…ƒéŸ³é•¿çŸ­å¯¹(Vowel Length Pair)å®šä¹‰
 */
export interface VowelLengthPair {
  /** çŸ­å…ƒéŸ³ */
  short: {
    char: string;
    duration: number; // ms
    example: string;
  };
  
  /** é•¿å…ƒéŸ³ */
  long: {
    char: string;
    duration: number; // ms
    example: string;
  };
}
````

## File: src/entities/types/storage.types.ts
````typescript
// src/entities/types/storage.types.ts

export interface StorageDownloadUrlRequest {
  action: 'getDownloadUrl';
  fileId: string;
  maxAge?: number;
}

export interface StorageBatchDownloadUrlRequest {
  action: 'batchGetDownloadUrls';
  fileIds: string[];
  maxAge?: number;
}

export interface StorageFileInfo {
  fileId: string;
  downloadUrl: string | null;
  status: 'success' | 'failed';
  error?: string | null;
}

export interface StorageDownloadUrlResponse {
  fileId: string;
  downloadUrl: string;
  maxAge: number;
  expiresAt: string;
}

export interface StorageBatchDownloadUrlResponse {
  files: StorageFileInfo[];
  summary: {
    total: number;
    success: number;
    failed: number;
  };
  maxAge: number;
  expiresAt: string;
}
````

## File: src/entities/types/test.types.ts
````typescript
// src/entities/types/test.types.ts

export interface TestQuestion {
  questionId: string;
  type: 'multiple_choice' | 'audio_match' | 'sequence';
  content: string;
  options: string[];
  correctAnswer: string;
  explanation: string;
}

export interface AlphabetTest {
  testId: string;
  type: 'skip_test' | 'progress_test';
  difficulty: 'basic' | 'intermediate' | 'advanced';
  questions: TestQuestion[];
  passingScore: number;
  timeLimit: number;
}

export interface TestResult {
  score: number;
  passed: boolean;
  correctCount: number;
  totalQuestions: number;
  results: {
    questionId: string;
    userAnswer: string;
    correctAnswer: string;
    isCorrect: boolean;
    explanation: string;
  }[];
  unlocked: boolean;
  message: string;
}
````

## File: src/entities/types/user.ts
````typescript
export interface User {
    userId: string;
    email: string;
    displayName: string;
    role: 'LEARNER' | 'ADMIN';
    registrationDate: string;
    avatar?: string;
}

export interface LoginRequest {
    email: string;
    password: string;
}

export interface RegisterRequest {
    email: string;
    password: string;
    displayName: string;
}

export interface ResetPasswordRequest {
    email: string;
}
````

## File: src/entities/types/vocabulary.types.ts
````typescript
// src/entities/types/vocabulary.types.ts

/**
 * å•è¯åŸºç¡€ä¿¡æ¯ï¼ˆåŒ¹é…æ•°æ®åº“å®é™…å­—æ®µï¼‰
 */
export interface Vocabulary {
    _id: string;
    vocabularyId: string;        // å¦‚ "BEGINNER_A_7"
    thaiWord: string;            // æ³°è¯­å•è¯ï¼Œå¦‚ "à¸à¸°"
    pronunciation: string;        // å‘éŸ³ï¼Œå¦‚ "gÃ "
    meaning: string;             // ä¸­æ–‡æ„æ€ï¼Œå¦‚ "ä¼°è®¡"
    partOfSpeech: string;        // è¯æ€§ï¼Œå¦‚ "åŠ¨è¯"
    level: string;               // çº§åˆ«ï¼Œå¦‚ "BEGINNER_A"
    lessonNumber: string;        // è¯¾ç¨‹ç¼–å·
    startingLetter: string;      // èµ·å§‹å­—æ¯
    source: string;              // æ¥æºï¼Œå¦‚ "Thai_1"
    audioPath?: string;          // éŸ³é¢‘è·¯å¾„ï¼Œå¦‚ "7.mp3"

    // ä¾‹å¥ï¼ˆåŒ…å«å¤šä¸ªå®ç”¨åœºæ™¯ï¼‰
    exampleSentences?: {
        [key: string]: {
            æ³°è¯­: string;
            å‘éŸ³: string;
            ä¸­æ–‡: string;
        };
    };

    // å¯¹è¯åœºæ™¯
    dialogue?: {
        åœºæ™¯æè¿°: string;
        å¯¹è¯å†…å®¹: {
            [speaker: string]: {
                æ³°è¯­: string;
                ä¸­æ–‡: string;
            };
        };
    };

    // ç”¨æ³•è¯´æ˜
    usage?: {
        è¯­æ³•ç¤ºä¾‹?: {
            ç»“æ„: string;
            è§£é‡Š: string;
            ä½¿ç”¨æŠ€å·§?: string;
        };
        ä¸ä¸­æ–‡å·®å¼‚?: string;
    };

    // å¸¸è§é”™è¯¯
    mistakes?: {
        å‘éŸ³æ˜“é”™ç‚¹?: string;
        ä½¿ç”¨åœºåˆ?: string;
        ç›¸ä¼¼è¯æ±‡åŒºåˆ«?: string;
    };

    // åŒæ ¹è¯
    cognates?: string[];

    // æ—¶é—´æˆ³
    createdAt?: Date | string;
}

/**
 * å•è¯åˆ†ç±»
 */
export type VocabularyCategory =
    | 'daily'      // æ—¥å¸¸ç”¨è¯­
    | 'food'       // é£Ÿç‰©
    | 'travel'     // æ—…æ¸¸
    | 'business'   // å•†åŠ¡
    | 'family'     // å®¶åº­
    | 'number'     // æ•°å­—
    | 'time';      // æ—¶é—´

/**
 * å•è¯å­¦ä¹ çŠ¶æ€
 */
export interface VocabularyLearningState {
    vocabularyId: string;
    thaiWord: string;
    pronunciation: string;
    meaning: string;
    exampleSentences?: Vocabulary['exampleSentences'];
    audioPath?: string;
    // è®°å¿†å¼•æ“ç›¸å…³
    currentAttempts: number;    // å½“å‰å°è¯•æ¬¡æ•°
    requiredAttempts: number;   // éœ€è¦å°è¯•æ¬¡æ•°
    qualityHistory: number[];   // è´¨é‡å†å²
    isCompleted: boolean;       // æ˜¯å¦å®Œæˆ
    timestamp: string;          // æ—¶é—´æˆ³
}

/**
 * ä»Šæ—¥å•è¯å“åº”
 */
export interface TodayVocabularyResponse {
    items: Array<{
        _id: string;
        entity: Vocabulary;
        memoryState: {
            nextReviewDate: string;
            repetitions: number;
            easeFactor: number;
        };
    }>;
    unlockInfo?: {
        vocabularyProgress: number;
        nextModuleUnlocked: boolean;
    };
}

/**
 * æäº¤ç»“æœè¯·æ±‚
 */
export interface SubmitVocabularyResultRequest {
    userId: string;
    vocabularyId: string;
    quality: number;  // 1-5 çš„è´¨é‡è¯„åˆ†
}

/**
 * å•è¯è¿›åº¦
 */
export interface VocabularyProgress {
    masteredCount: number;
    totalCount: number;
    accuracy: number;
    masteredIds: string[];
}
````

## File: src/hooks/useModuleAccess.ts
````typescript
// src/hooks/useModuleAccess.ts

import { useEffect, useState } from 'react';
import { useRouter } from 'expo-router';
import { Alert } from 'react-native';
import { useModuleAccessStore, type ModuleType } from '@/src/stores/moduleAccessStore';
import { useTranslation } from 'react-i18next';

export function useModuleAccess(
  requiredModule: ModuleType
) {
  const router = useRouter();
  const { t } = useTranslation();
  const { checkAccess, userProgress, isLoading } = useModuleAccessStore();
  const [allowed, setAllowed] = useState(false);
  const [checking, setChecking] = useState(true);

  useEffect(() => {
    verifyAccess();
  }, [requiredModule]);

  const verifyAccess = async () => {
    setChecking(true);
    const hasAccess = await checkAccess(requiredModule);
    setAllowed(hasAccess);
    setChecking(false);

    if (!hasAccess && !isLoading) {
      // Optional: Auto-show alert if needed, but usually controlled by UI
      // showAccessDeniedAlert(); 
    }
  };

  const showAccessDeniedAlert = () => {
    if (!userProgress) return;

    const messages: Record<string, string> = {
      word: t('moduleAccess.prerequisite.word'),
      sentence: t('moduleAccess.prerequisite.sentence'),
      article: t('moduleAccess.prerequisite.article'),
    };

    Alert.alert(
      t('moduleAccess.locked'),
      messages[requiredModule] || t('moduleAccess.lockedMessage', { module: requiredModule }),
      [
        {
          text: t('common.cancel'),
          style: 'cancel',
          onPress: () => {
            // Optional: Navigate back
            router.back();
          }
        },
        {
          text: t('moduleAccess.goBack'), // Or "Go to Learning"
          onPress: () => {
            const redirectMap: Record<string, string> = {
              word: '/(tabs)/courses', // Redirect to courses or alphabet
              sentence: '/(tabs)/courses',
              article: '/(tabs)/courses',
            };
            // router.replace(redirectMap[requiredModule] || '/(tabs)/courses');
            router.back();
          },
        },
      ],
      { cancelable: false }
    );
  };

  return {
    allowed,
    loading: checking || isLoading,
    progress: userProgress,
    checkAccess: verifyAccess,
    showAccessDeniedAlert
  };
}
````

## File: src/stores/learningPreferenceStore.ts
````typescript
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';
import type { ModuleType } from './moduleAccessStore';

type DailyLimitMap = Partial<Record<ModuleType, number>>;

interface LearningPreferenceStore {
    dailyLimits: DailyLimitMap;
    setDailyLimit: (module: ModuleType, limit: number) => void;
    hasDailyLimit: (module: ModuleType) => boolean;
}

export const useLearningPreferenceStore = create<LearningPreferenceStore>()(
    persist(
        (set, get) => ({
            dailyLimits: {},
            setDailyLimit: (module, limit) =>
                set((state) => ({
                    dailyLimits: {
                        ...state.dailyLimits,
                        [module]: limit,
                    },
                })),
            hasDailyLimit: (module) => get().dailyLimits[module] !== undefined,
        }),
        {
            name: 'learning-preferences',
            storage: createJSONStorage(() => AsyncStorage),
        }
    )
);
````

## File: src/stores/moduleAccessStore.ts.backup
````
// src/stores/moduleAccessStore.ts

/**
 * æ¨¡å—è®¿é—®æ§åˆ¶ Store
 * 
 * åŠŸèƒ½ï¼š
 * 1. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æŸä¸ªæ¨¡å—
 * 2. ç¼“å­˜è®¿é—®æƒé™ç»“æœ
 * 3. æä¾›å…¨å±€è¿›åº¦æ•°æ®
 */

import { create } from 'zustand';
import { callCloudFunction } from '@/src/utils/apiClient';
import { API_ENDPOINTS } from '@/src/config/api.endpoints';
import { useUserStore } from './userStore';
import { LESSON_METADATA } from '@/src/config/alphabet/lessonMetadata.config';
import AsyncStorage from '@react-native-async-storage/async-storage';


const getCompletedLessonsStorageKey = (userId: string): string =>
    `@alphabet_completed_lessons_${userId}`;



// ==================== ç±»å‹å®šä¹‰ ====================

/**
 * æ¨¡å—ç±»å‹
 * 
 * æ³¨æ„ï¼š
 * - ä¸åç«¯ memory-engine.checkModuleAccess ä¿æŒä¸€è‡´ï¼Œå­—æ¯æ¨¡å—ä½¿ç”¨ 'letter'
 */
export type ModuleType = 'letter' | 'word' | 'sentence' | 'article';

/**
 * ç”¨æˆ·è¿›åº¦æ•°æ®
 */
export interface UserProgress {
    // å­—æ¯å­¦ä¹ è¿›åº¦
    letterProgress: number;           // 0-1 (åç«¯å­˜å‚¨ä¸ºæ¯”ä¾‹å€¼)
    letterCompleted: boolean;         // Added: Whether letter learning is completed
    letterMasteredCount: number;      // å·²æŒæ¡å­—æ¯æ•°
    letterTotalCount: number;         // æ€»å­—æ¯æ•°

    // å•è¯å­¦ä¹ è¿›åº¦
    wordProgress: number;             // 0-100
    wordMasteredCount: number;        // å·²æŒæ¡å•è¯æ•°
    wordTotalCount: number;           // æ€»å•è¯æ•°

    // å¥å­å­¦ä¹ è¿›åº¦
    sentenceProgress: number;         // 0-100
    sentenceMasteredCount: number;    // å·²æŒæ¡å¥å­æ•°
    sentenceTotalCount: number;       // æ€»å¥å­æ•°

    // æ–‡ç« å­¦ä¹ è¿›åº¦
    articleProgress: number;          // 0-100
    articleMasteredCount: number;     // å·²æŒæ¡æ–‡ç« æ•°
    articleTotalCount: number;        // æ€»æ–‡ç« æ•°

    // è§£é”çŠ¶æ€
    wordUnlocked: boolean;            // å•è¯æ¨¡å—æ˜¯å¦è§£é”
    sentenceUnlocked: boolean;        // å¥å­æ¨¡å—æ˜¯å¦è§£é”
    articleUnlocked: boolean;         // æ–‡ç« æ¨¡å—æ˜¯å¦è§£é”

    /**
     * å­—æ¯è¯¾ç¨‹å®Œæˆæƒ…å†µï¼ˆä»…å‰ç«¯ä½¿ç”¨ï¼‰
     * ä¾‹å¦‚: ['lesson1','lesson2',...]
     */
    completedAlphabetLessons?: string[];

    // è®¾ç½®
    dailyLimit?: number;              // æ¯æ—¥å­¦ä¹ æ•°é‡è®¾ç½®
}

/**
 * è®¿é—®æ£€æŸ¥å“åº”
 */
interface CheckAccessResponse {
    allowed: boolean;
    reason?: string;
    requiredProgress?: number;
    currentProgress?: number;
}

/**
 * ç”¨æˆ·è¿›åº¦å“åº”
 */
interface UserProgressResponse {
    progress: UserProgress;
}

// ==================== Store å®šä¹‰ ====================

interface ModuleAccessStore {
    // ===== çŠ¶æ€ =====
    userProgress: UserProgress | null;
    accessCache: Map<ModuleType, boolean>;
    isLoading: boolean;
    error: string | null;

    // ===== æ–¹æ³• =====
    checkAccess: (moduleType: ModuleType) => Promise<boolean>;
    checkAccessLocally: (moduleType: ModuleType) => boolean;
    getUserProgress: () => Promise<void>;
    clearCache: () => void;
    setError: (error: string | null) => void;
    setDailyLimit: (moduleType: ModuleType, limit: number) => void;
    /**
     * æ ‡è®°æŸä¸ªå­—æ¯è¯¾ç¨‹å·²å®Œæˆï¼ˆä»…ç”¨äºå­—æ¯æ¨¡å—è§£é”é“¾è·¯ï¼‰
     */
    markAlphabetLessonCompleted: (lessonId: string) => void;
}

// ==================== é»˜è®¤è¿›åº¦æ•°æ® ====================

const defaultProgress: UserProgress = {
    letterProgress: 0,
    letterCompleted: false,
    letterMasteredCount: 0,
    letterTotalCount: 44,
    wordProgress: 0,
    wordMasteredCount: 0,
    wordTotalCount: 0,
    sentenceProgress: 0,
    sentenceMasteredCount: 0,
    sentenceTotalCount: 0,
    articleProgress: 0,
    articleMasteredCount: 0,
    articleTotalCount: 0,
    wordUnlocked: false,
    sentenceUnlocked: false,
    articleUnlocked: false,
};

// ==================== Store å®ç° ====================

export const useModuleAccessStore = create<ModuleAccessStore>()((set, get) => ({
    // ===== åˆå§‹çŠ¶æ€ =====
    userProgress: null,
    accessCache: new Map<ModuleType, boolean>(),
    isLoading: false,
    error: null,

    // ===== æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™ =====
    /**
     * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æŸä¸ªæ¨¡å—
     * 
     * @param moduleType æ¨¡å—ç±»å‹
     * @returns æ˜¯å¦æœ‰æƒé™è®¿é—®
     */
    checkAccess: async (moduleType: ModuleType): Promise<boolean> => {
        const { accessCache } = get();
        const userId = useUserStore.getState().currentUser?.userId;

        if (!userId) {
            console.warn('âš ï¸ ç”¨æˆ·æœªç™»å½•ï¼Œæ— æ³•æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™');
            return false;
        }

        // 1. æ£€æŸ¥ç¼“å­˜
        if (accessCache.has(moduleType)) {
            const cachedResult = accessCache.get(moduleType);
            console.log(`âœ… ä»ç¼“å­˜è·å– ${moduleType} è®¿é—®æƒé™:`, cachedResult);
            return cachedResult!;
        }

        try {
            set({ isLoading: true, error: null });

            // 2. è°ƒç”¨äº‘å‡½æ•°æ£€æŸ¥æƒé™
            const result = await callCloudFunction<CheckAccessResponse>(
                'checkModuleAccess',
                {
                    userId,
                    moduleType,
                },
                {
                    endpoint: API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase,
                }
            );

            if (result.success && result.data) {
                const allowed = result.data.allowed;

                // 3. ç¼“å­˜ç»“æœ
                const newCache = new Map(accessCache);
                newCache.set(moduleType, allowed);
                set({ accessCache: newCache, isLoading: false });

                console.log(`âœ… ${moduleType} è®¿é—®æƒé™æ£€æŸ¥å®Œæˆ:`, allowed);

                // å¦‚æœä¸å…è®¸ï¼Œè®°å½•åŸå› 
                if (!allowed && result.data.reason) {
                    console.log(`ğŸ“Œ æ‹’ç»åŸå› : ${result.data.reason}`);
                }

                return allowed;
            } else {
                // è¯·æ±‚å¤±è´¥ï¼Œé™çº§å¤„ç†
                console.warn('âš ï¸ äº‘å‡½æ•°è°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°é€»è¾‘åˆ¤æ–­');
                const localAllowed = get().checkAccessLocally(moduleType);

                // ç¼“å­˜æœ¬åœ°åˆ¤æ–­ç»“æœ
                const newCache = new Map(accessCache);
                newCache.set(moduleType, localAllowed);
                set({ accessCache: newCache, isLoading: false });

                return localAllowed;
            }
        } catch (error: any) {
            console.error('âŒ checkAccess error:', error);
            set({ error: error.message || 'æ£€æŸ¥æƒé™å¤±è´¥', isLoading: false });

            // é™çº§åˆ°æœ¬åœ°é€»è¾‘
            const localAllowed = get().checkAccessLocally(moduleType);

            // ç¼“å­˜æœ¬åœ°åˆ¤æ–­ç»“æœ
            const newCache = new Map(get().accessCache);
            newCache.set(moduleType, localAllowed);
            set({ accessCache: newCache });

            return localAllowed;
        }
    },

    // ===== æœ¬åœ°æƒé™æ£€æŸ¥é€»è¾‘ï¼ˆé™çº§æ–¹æ¡ˆï¼‰=====
    /**
     * æœ¬åœ°æƒé™æ£€æŸ¥é€»è¾‘ï¼ˆé™çº§æ–¹æ¡ˆï¼‰
     * 
     * @param moduleType æ¨¡å—ç±»å‹
     * @returns æ˜¯å¦æœ‰æƒé™è®¿é—®
     */
    checkAccessLocally: (moduleType: ModuleType): boolean => {
        const { userProgress } = get();

        if (!userProgress) {
            // å¦‚æœæ²¡æœ‰è¿›åº¦æ•°æ®ï¼Œå…è®¸è®¿é—®å­—æ¯æ¨¡å—ï¼Œå…¶ä»–æ¨¡å—ä¸å…è®¸
            return moduleType === 'letter';
        }

        // ä¸åç«¯ memory-engine.checkModuleAccess çš„æ„å›¾ä¿æŒä¸€è‡´ï¼š
        // - å­—æ¯æ¨¡å—å§‹ç»ˆå¯è®¿é—®
        // - åªè¦ letterCompleted ä¸º trueï¼Œæˆ– letterProgress â‰¥ 0.8ï¼Œæ‰€æœ‰éå­—æ¯æ¨¡å—ç»Ÿä¸€è§£é”
        if (moduleType === 'letter') {
            return true;
        }

        const finishedByTest = !!userProgress.letterCompleted;
        const finishedByProgress = (userProgress.letterProgress ?? 0) >= 0.8;

        return finishedByTest || finishedByProgress;
    },

    // ===== è·å–ç”¨æˆ·è¿›åº¦ =====
    // ===== è·å–ç”¨æˆ·è¿›åº¦ =====
    /**
     * ä»åç«¯è·å–ç”¨æˆ·è¿›åº¦æ•°æ®
     */
    getUserProgress: async (): Promise<void> => {
        const userId = useUserStore.getState().currentUser?.userId;

        if (!userId) {
            console.warn('âš ï¸ ç”¨æˆ·æœªç™»å½•ï¼Œæ— æ³•è·å–è¿›åº¦æ•°æ®');
            set({ userProgress: defaultProgress });
            return;
        }

        try {
            const oldKey = '@alphabet_completed_lessons';
            const oldData = await AsyncStorage.getItem(oldKey);
            if (oldData) {
                await AsyncStorage.removeItem(oldKey);
                console.log('Old key has been delete.');
            }
        } catch (e) {
            console.warn('åˆ é™¤æ—§keyå¤±è´¥ï¼š', e)
        }

        set({ isLoading: true, error: null });

        // Helper to try fetch
        const fetchProgress = async (endpoint: string) => {
            return await callCloudFunction<UserProgressResponse>(
                'getUserProgress',
                { userId, entityType: 'letter' },  // ğŸ”¥ æ·»åŠ  entityType å‚æ•°
                { endpoint }
            );
        };

        try {
            // 1. Try Primary Endpoint (memory-engine)
            let result = await fetchProgress(API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase);

            // 2. Fallback to Legacy Endpoint (learn-vocab) if failed
            if (!result.success) {
                console.warn(`âš ï¸ Primary endpoint failed (${result.error}), trying fallback...`);
                result = await fetchProgress(API_ENDPOINTS.MODULE.CHECK_ACCESS.cloudbase);
            }

            if (result.success && result.data) {
                // ğŸ”¥ Merge with local persisted completed lessons
                let completedAlphabetLessons: string[] = [];
                try {
                    const storageKey = getCompletedLessonsStorageKey(userId)
                    const stored = await AsyncStorage.getItem(storageKey);
                    if (stored) {
                        completedAlphabetLessons = JSON.parse(stored);
                    }
                } catch (e) {
                    console.warn('âš ï¸ Failed to load local completed lessons:', e);
                }

                // If remote has it (unlikely), merge distinct? Or trust local?
                // Rule: Local is the source of truth for this frontend-only field.
                // But if backend sends it, we might want to union. 
                // For now, assume backend sends undefined/empty.
                const remoteCompleted = result.data.progress.completedAlphabetLessons || [];
                const mergedCompleted = Array.from(new Set([...completedAlphabetLessons, ...remoteCompleted]));

                // If local had nothing but remote did (e.g. cloud sync feature added later), we should update local storage too?
                // Yes, harmless to sync back.
                if (mergedCompleted.length > completedAlphabetLessons.length) {
                    const storageKey = getCompletedLessonsStorageKey(userId);
                    void AsyncStorage.setItem(storageKey, JSON.stringify(mergedCompleted));
                }

                set({
                    userProgress: {
                        ...result.data.progress,
                        completedAlphabetLessons: mergedCompleted
                    },
                    isLoading: false,
                });
                console.log('âœ… ç”¨æˆ·è¿›åº¦æ•°æ®å·²æ›´æ–° (Merged):', {
                    ...result.data.progress,
                    completedAlphabetLessons: mergedCompleted
                });
            } else {
                console.warn('âš ï¸ è·å–ç”¨æˆ·è¿›åº¦å¤±è´¥ (Primary & Fallback)ï¼Œä½¿ç”¨é»˜è®¤æ•°æ®');
                // Don't overwrite with default if we have stale data? 
                // Actually, for safety, maybe we should? Or keep stale?
                // Requirements mainly imply getting fresh data. 
                // If failed, we likely shouldn't nuke existing state if it exists, but here we usually start from null/default.
                set({
                    userProgress: defaultProgress,
                    isLoading: false,
                    error: result.error || 'Failed to fetch progress'
                });
            }
        } catch (error: any) {
            console.error('âŒ getUserProgress error:', error);
            set({
                error: error.message || 'è·å–è¿›åº¦å¤±è´¥',
                userProgress: defaultProgress,
                isLoading: false,
            });
        }
    },

    // ===== æ¸…é™¤ç¼“å­˜ =====
    /**
     * æ¸…é™¤è®¿é—®æƒé™ç¼“å­˜
     * ç”¨äºï¼šç”¨æˆ·å®Œæˆå­¦ä¹ åéœ€è¦é‡æ–°æ£€æŸ¥æƒé™
     */
    clearCache: (): void => {
        set({ accessCache: new Map<ModuleType, boolean>() });
        console.log('ğŸ—‘ï¸ è®¿é—®æƒé™ç¼“å­˜å·²æ¸…é™¤');
    },

    // ===== è®¾ç½®é”™è¯¯ =====
    setError: (error: string | null): void => {
        set({ error });
    },

    // ===== æ›´æ–°æ¯æ—¥å­¦ä¹ é‡ï¼ˆå‰ç«¯ç¼“å­˜ï¼‰=====
    setDailyLimit: (moduleType: ModuleType, limit: number) => {
        set((state) => ({
            userProgress: {
                ...(state.userProgress || { ...defaultProgress }),
                dailyLimit: limit,
            },
        }));

        console.log(`ğŸ“Œ å·²æ›´æ–° ${moduleType} dailyLimit ä¸º ${limit}`);
    },

    // ===== æ ‡è®°å­—æ¯è¯¾ç¨‹å®Œæˆï¼ˆå‰ç«¯æœ¬åœ°ï¼‰=====
    markAlphabetLessonCompleted: (lessonId: string) => {
        const totalLessons = Object.keys(LESSON_METADATA).length;
        const coreLessons = 6; // å®Œæˆå‰ 6 è¯¾è§†ä¸ºâ€œæ ¸å¿ƒå­—æ¯å·²å­¦å®Œâ€

        set((state) => {
            const prev = state.userProgress || { ...defaultProgress };

            const prevCompleted = new Set(prev.completedAlphabetLessons ?? []);
            prevCompleted.add(lessonId);
            const completedAlphabetLessons = Array.from(prevCompleted);

            const completedCount = completedAlphabetLessons.length;
            const allLessonsDone = completedCount >= totalLessons;

            // è¿›åº¦ï¼š
            // - å®Œæˆ lesson1-4 è§†ä¸º 0.8
            // - å®Œæˆ lesson1-6 è§†ä¸º 0.9ï¼ˆæ ¸å¿ƒå­—æ¯å…¨éƒ¨å®Œæˆï¼‰
            // - å®Œæˆå…¨éƒ¨ 7 è¯¾è§†ä¸º 1.0ï¼ˆå«ç½•ç”¨/å¤ä½“å­—æ¯ï¼‰
            let nextLetterProgress = prev.letterProgress;
            if (completedCount >= 4 && nextLetterProgress < 0.8) {
                nextLetterProgress = 0.8;
            }
            if (completedCount >= coreLessons && nextLetterProgress < 0.9) {
                nextLetterProgress = 0.9;
            }
            if (completedCount >= totalLessons && nextLetterProgress < 1) {
                nextLetterProgress = 1;
            }

            // å®Œæˆå‰ 6 è¯¾å³è§†ä¸ºæ ¸å¿ƒå­—æ¯å­¦ä¹ å®Œæˆï¼Œ
            // lesson7 ä½œä¸ºè¡¥å……è¯¾ç¨‹ä¸å½±å“å…¶ä»–æ¨¡å—è§£é”
            const coreLessonsDone = completedCount >= coreLessons;
            const nextLetterCompleted =
                prev.letterCompleted || coreLessonsDone;

            const updated: UserProgress = {
                ...prev,
                completedAlphabetLessons,
                letterCompleted: nextLetterCompleted,
                letterProgress: nextLetterProgress,
            };

            // ğŸ”¥ Persist to AsyncStorage (Fire and forget)
            const storageKey = getCompletedLessonsStorageKey(userId);
            AsyncStorage.setItem(storageKey, JSON.stringify(completedAlphabetLessons)).catch(err => {
                console.error('âŒ Failed to persist completed alphabet lessons:', err);
            });

            return {
                userProgress: updated,
                accessCache: allLessonsDone
                    ? new Map<ModuleType, boolean>()
                    : state.accessCache,
            };
        });

        console.log(`âœ… å­—æ¯è¯¾ç¨‹å·²å®Œæˆ: ${lessonId}`);
    },
}));
````

## File: src/stores/storageStore.ts
````typescript
// src/stores/storageStore.ts

import { create } from 'zustand';
import { callCloudFunction } from '@/src/utils/apiClient';
import { API_ENDPOINTS } from '@/src/config/api.endpoints';
import type {
  StorageDownloadUrlResponse,
  StorageBatchDownloadUrlResponse,
} from '@/src/entities/types/storage.types';

interface StorageStoreState {
  isLoading: boolean;
  error: string | null;

  getDownloadUrl: (fileId: string, maxAge?: number) => Promise<string | null>;
  batchGetDownloadUrls: (
    fileIds: string[],
    maxAge?: number,
  ) => Promise<StorageBatchDownloadUrlResponse | null>;
  clearError: () => void;
}

export const useStorageStore = create<StorageStoreState>((set, get) => ({
  isLoading: false,
  error: null,

  getDownloadUrl: async (fileId: string, maxAge: number = 7200) => {
    set({ isLoading: true, error: null });
    try {
      const res = await callCloudFunction<StorageDownloadUrlResponse>(
        'getDownloadUrl',
        {
          action: 'getDownloadUrl',
          fileId,
          maxAge,
        },
        {
          endpoint: API_ENDPOINTS.STORAGE.GET_DOWNLOAD_URL.cloudbase,
        },
      );

      if (!res.success || !res.data) {
        throw new Error(res.error ?? 'è·å–ä¸‹è½½é“¾æ¥å¤±è´¥');
      }

      set({ isLoading: false });
      return res.data.downloadUrl;
    } catch (e: any) {
      console.error('[storageStore.getDownloadUrl] error:', e);
      set({ isLoading: false, error: e?.message ?? 'è·å–ä¸‹è½½é“¾æ¥å¤±è´¥' });
      return null;
    }
  },

  batchGetDownloadUrls: async (
    fileIds: string[],
    maxAge: number = 7200,
  ) => {
    set({ isLoading: true, error: null });

    if (fileIds.length > 50) {
      set({
        isLoading: false,
        error: 'å•æ¬¡æœ€å¤šæ”¯æŒ 50 ä¸ªæ–‡ä»¶',
      });
      return null;
    }

    try {
      const res = await callCloudFunction<StorageBatchDownloadUrlResponse>(
        'batchGetDownloadUrls',
        {
          action: 'batchGetDownloadUrls',
          fileIds,
          maxAge,
        },
        {
          endpoint: API_ENDPOINTS.STORAGE.BATCH_GET_DOWNLOAD_URLS.cloudbase,
        },
      );

      if (!res.success || !res.data) {
        throw new Error(res.error ?? 'æ‰¹é‡è·å–ä¸‹è½½é“¾æ¥å¤±è´¥');
      }

      set({ isLoading: false });
      return res.data;
    } catch (e: any) {
      console.error('[storageStore.batchGetDownloadUrls] error:', e);
      set({ isLoading: false, error: e?.message ?? 'æ‰¹é‡è·å–ä¸‹è½½é“¾æ¥å¤±è´¥' });
      return null;
    }
  },

  clearError: () => set({ error: null }),
}));
````

## File: src/utils/lettersDistractorEngine.ts
````typescript
// src/utils/alphabet/distractorEngine.ts

import type { Letter } from '@/src/entities/types/letter.types';

export interface DistractorOptions {
  count: number;      // å¹²æ‰°é¡¹æ•°é‡
  pool: Letter[];     // å¯ç”¨å­—æ¯æ± ï¼ˆä» store æˆ–çˆ¶ç»„ä»¶ä¼ å…¥ï¼‰
  correct: Letter;    // æ­£ç¡®å­—æ¯
}

/**
 * æŒ‰ä¼˜å…ˆçº§ç”Ÿæˆå¹²æ‰°é¡¹ï¼š
 * 1. ä¸æ­£ç¡®å­—æ¯ class ç›¸åŒï¼ˆé«˜/ä¸­/ä½è¾…éŸ³ï¼‰
 * 2. ä¸æ­£ç¡®å­—æ¯ initialSound ç›¸åŒ
 * 3. å…¶ä½™å­—æ¯
 */
export function generateLetterDistractors(opts: DistractorOptions): Letter[] {
  const { pool, correct, count } = opts;

  if (!pool || pool.length === 0) return [];

  const sameClass = pool.filter(
    (l) => l.class === correct.class && l._id !== correct._id,
  );

  const sameSound = pool.filter(
    (l) => l.initialSound === correct.initialSound && l._id !== correct._id,
  );

  const others = pool.filter((l) => l._id !== correct._id);

  const merged: Letter[] = [...sameClass, ...sameSound, ...others];

  // å»é‡
  const uniqueMap = new Map<string, Letter>();
  merged.forEach((l) => uniqueMap.set(l._id, l));

  const unique = Array.from(uniqueMap.values());

  return unique.slice(0, count);
}
````

## File: src/utils/validation.ts
````typescript
// src/utils/validation.ts
/**
 * Frontend Validation Utilities
 * 
 * Purpose: Centralized validation logic for forms
 * Used by: All form components (Login, Register, etc.)
 * 
 * Philosophy: 
 * - Frontend validation for UX (instant feedback)
 * - Backend validation for security (trust nothing from client)
 */

export interface ValidationResult {
  isValid: boolean;
  error?: string;
}

/**
 * Validate email format
 */
export function validateEmail(email: string): ValidationResult {
  if (!email) {
    return {
      isValid: false,
      error: 'Email is required',
    };
  }

  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    return {
      isValid: false,
      error: 'Please enter a valid email address',
    };
  }

  return { isValid: true };
}

/**
 * Validate password strength
 */
export function validatePassword(password: string): ValidationResult {
  if (!password) {
    return {
      isValid: false,
      error: 'Password is required',
    };
  }

  if (password.length < 6) {
    return {
      isValid: false,
      error: 'Password must be at least 6 characters',
    };
  }

  // Optional: Check for password strength
  // const hasNumber = /\d/.test(password);
  // const hasLetter = /[a-zA-Z]/.test(password);
  // if (!hasNumber || !hasLetter) {
  //   return {
  //     isValid: false,
  //     error: 'Password must contain letters and numbers',
  //   };
  // }

  return { isValid: true };
}

/**
 * Validate display name
 */
export function validateDisplayName(name: string): ValidationResult {
  if (!name) {
    return {
      isValid: false,
      error: 'Display name is required',
    };
  }

  if (name.length < 2) {
    return {
      isValid: false,
      error: 'Display name must be at least 2 characters',
    };
  }

  if (name.length > 50) {
    return {
      isValid: false,
      error: 'Display name must be less than 50 characters',
    };
  }

  return { isValid: true };
}

/**
 * Validate password confirmation
 */
export function validatePasswordMatch(
  password: string,
  confirmPassword: string
): ValidationResult {
  if (password !== confirmPassword) {
    return {
      isValid: false,
      error: 'Passwords do not match',
    };
  }

  return { isValid: true };
}

/**
 * Validate registration form
 */
export function validateRegistrationForm(data: {
  email: string;
  password: string;
  confirmPassword: string;
  displayName: string;
}): ValidationResult {
  // Validate display name
  const nameResult = validateDisplayName(data.displayName);
  if (!nameResult.isValid) return nameResult;

  // Validate email
  const emailResult = validateEmail(data.email);
  if (!emailResult.isValid) return emailResult;

  // Validate password
  const passwordResult = validatePassword(data.password);
  if (!passwordResult.isValid) return passwordResult;

  // Validate password match
  const matchResult = validatePasswordMatch(data.password, data.confirmPassword);
  if (!matchResult.isValid) return matchResult;

  return { isValid: true };
}

/**
 * Validate login form
 */
export function validateLoginForm(data: {
  email: string;
  password: string;
}): ValidationResult {
  // Validate email
  const emailResult = validateEmail(data.email);
  if (!emailResult.isValid) return emailResult;

  // Validate password exists
  if (!data.password) {
    return {
      isValid: false,
      error: 'Password is required',
    };
  }

  return { isValid: true };
}

/**
 * Real-time validation helpers for form inputs
 * Use these with onChange handlers for instant feedback
 */
export const realtimeValidators = {
  email: (email: string): string | undefined => {
    if (!email) return undefined; // Don't show error for empty field
    const result = validateEmail(email);
    return result.isValid ? undefined : result.error;
  },

  password: (password: string): string | undefined => {
    if (!password) return undefined;
    const result = validatePassword(password);
    return result.isValid ? undefined : result.error;
  },

  displayName: (name: string): string | undefined => {
    if (!name) return undefined;
    const result = validateDisplayName(name);
    return result.isValid ? undefined : result.error;
  },

  confirmPassword: (password: string, confirmPassword: string): string | undefined => {
    if (!confirmPassword) return undefined;
    const result = validatePasswordMatch(password, confirmPassword);
    return result.isValid ? undefined : result.error;
  },
};
````

## File: .skip-template
````
2026-01-04T11:03:56.683Z
````

## File: CLAUDE.md
````markdown
# Project Development Rules (Mandatory)

This is an existing, production-oriented project with frozen specifications.
You are NOT working on a greenfield project.

Your primary responsibility is to maintain consistency and prevent structural entropy.

---
## Language Rule (Mandatory)

- All responses MUST be written in **Simplified Chinese**.
- This includes:
  - Explanations
  - Code comments
  - Commit-style summaries
  - Error analysis
- Do NOT switch languages unless explicitly requested.

## 1. Absolute Rules

- Always read and follow all Project Freeze Documents before making any change.
- Treat the current running behavior of the codebase as the source of truth.
- Do NOT design or implement features that are not explicitly requested.

---

## 2. Single Source of Truth

- Every concept must have exactly ONE authoritative definition.
- If multiple definitions exist:
  - Identify which one is currently effective
  - Mark others as deprecated
  - Do NOT create parallel systems

---

## 3. File Creation Rules

Do NOT create new files, enums, configs, or abstractions if:
- A similar concept already exists
- The task can be completed by extending an existing file

File placement rules:
- Constants â†’ src/config/constants.ts
- API endpoints â†’ src/config/api.endpoints.ts
- Enums â†’ src/entities/enums/
- Types / Interfaces â†’ src/entities/types/
- Business logic / generators â†’ src/utils/

---

## 4. Forbidden Behaviors

- Inventing new enums when one already exists
- Duplicating configs between frontend and backend without stating authority
- Implementing future phases not active in the current release
- Refactoring by addition instead of alignment

---

## 5. Documentation Synchronization

Any change that affects:
- behavior
- data flow
- source of truth

MUST be reflected in the Project Freeze Document,
or explicitly noted as a known deviation.

---

## 6. Development Philosophy

Your goal is NOT to make the code perfect.
Your goal is to make it predictable, traceable, and consistent.

When in doubt, do less, not more.

## Mandatory Self-Check

Before writing code, you must silently verify:
- The change complies with all rules above
- No new parallel abstractions are introduced
- The change aligns with the current frozen behavior

If any rule would be violated, you must refuse and explain why.
````

## File: cloudbaserc.json
````json
{
  "envId": "{{env.ENV_ID}}",
  "functionRoot": "./functions",
  "functions": [],
  "ai": {
    "defaultAgent": "{{env.AI_DEFAULT_AGENT}}",
    "agents": {
      "codex": {
        "type": "custom",
        "baseUrl": "{{env.AI_CODEX_BASE_URL}}",
        "apiKey": "{{env.AI_CODEX_API_KEY}}",
        "model": "{{env.AI_CODEX_MODEL}}"
      }
    }
  }
}
````

## File: convert-json-to-jsonl-but-keep-json.js
````javascript
const fs = require('fs');

// âœ… ä½ çš„åŸå§‹é¢˜åº“æ–‡ä»¶ï¼ˆæ•°ç»„æ ¼å¼ï¼‰
const inputFile = './.json';

// âœ… è¯»å–å¹¶è§£æ
const raw = fs.readFileSync(inputFile, 'utf-8');
const data = JSON.parse(raw);

// âœ… è½¬æ¢ä¸º JSON Linesï¼Œä½†ä»ç„¶è¾“å‡ºä¸º .json åç¼€
const output = data.map(item => JSON.stringify(item)).join('\n');

// âœ… è¦†ç›–å†™å›åŸæ–‡ä»¶ï¼ˆåç¼€ä¸å˜ï¼ï¼‰
fs.writeFileSync(inputFile, output, 'utf-8');

console.log('âœ… å·²è½¬æ¢ä¸º JSON Lines æ ¼å¼ï¼ˆåç¼€ä»ä¸º .jsonï¼‰');
console.log('âœ… ç°åœ¨å¯ä»¥ç›´æ¥ä¸Šä¼ åˆ° CloudBase å¯¼å…¥');
````

## File: global.css
````css
/* global.css */
@tailwind base;
@tailwind components;
@tailwind utilities;
````

## File: tailwind.config.js
````javascript
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
    content: [
      "./app/**/*.{js,jsx,ts,tsx}",
      "./src/components/**/*.{js,jsx,ts,tsx}"
    ],
    presets: [require("nativewind/preset")],
    theme: {
      extend: {
        colors: {
          paper: '#FAF9F6',
          ink: '#1A1A1A',
          sand: '#E5E2DB',
          taupe: '#8E8B82',
          thaiGold: '#D4AF37',
          accent: '#B8956A',
        },
      },
    },
    plugins: [],
  }
````

## File: app/(auth)/forgot-password.tsx
````typescript
// app/(auth)/forgot-password.tsx
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { useTranslation } from 'react-i18next';
import Animated, { FadeInDown } from 'react-native-reanimated';
import { Ionicons } from '@expo/vector-icons';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { LanguageSwitcher } from '@/src/components/common/LanguageSwitcher';
import { useUserStore } from '@/src/stores/userStore';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

export default function ForgotPasswordScreen() {
  const { t } = useTranslation();
  const router = useRouter();
  const { requestPasswordReset, isLoading, error, clearError } = useUserStore();

  const [email, setEmail] = useState('');
  const [isEmailSent, setIsEmailSent] = useState(false);

  // Clear error when component unmounts
  useEffect(() => {
    return () => {
      clearError();
    };
  }, []);

  // Show error alert if error changes
  useEffect(() => {
    if (error) {
      Alert.alert(t('common.error'), error);
    }
  }, [error]);

  const handleResetPassword = async () => {
    // Validate email
    if (!email) {
      Alert.alert(t('common.error'), 'Please enter your email address');
      return;
    }

    // Email format validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      Alert.alert(t('common.error'), 'Please enter a valid email address');
      return;
    }

    // Call password reset action
    const success = await requestPasswordReset({ email: email.toLowerCase().trim() });

    if (success) {
      setIsEmailSent(true);
    }
  };

  const handleBackToLogin = () => {
    router.back();
  };

  // If email sent successfully, show success screen
  if (isEmailSent) {
    return (
      <SafeAreaView style={styles.container}>
        <ThaiPatternBackground opacity={0.08} />

        <View style={styles.languageSwitcherContainer}>
          <LanguageSwitcher />
        </View>

        <View style={styles.content}>
          <Animated.View
            entering={FadeInDown.delay(100).duration(500)}
            style={styles.successSection}
          >
            <View style={styles.iconContainer}>
              <Ionicons name="mail-outline" size={64} color={Colors.thaiGold} />
            </View>

            <Text style={styles.successTitle}>Check Your Email</Text>
            <Text style={styles.successMessage}>
              If an account exists for {email}, you will receive password reset instructions shortly.
            </Text>

            <Text style={styles.infoText}>
              Didn't receive the email? Check your spam folder or try again.
            </Text>

            <Pressable style={styles.backButton} onPress={handleBackToLogin}>
              <Text style={styles.backButtonText}>Back to Login</Text>
            </Pressable>

            <Pressable
              style={styles.resendButton}
              onPress={() => {
                setIsEmailSent(false);
                setEmail('');
              }}
            >
              <Text style={styles.resendButtonText}>Try Another Email</Text>
            </Pressable>
          </Animated.View>
        </View>
      </SafeAreaView>
    );
  }

  // Default screen - email input
  return (
    <SafeAreaView style={styles.container}>
      <ThaiPatternBackground opacity={0.08} />

      <View style={styles.languageSwitcherContainer}>
        <LanguageSwitcher />
      </View>

      {/* Back Button */}
      <Pressable style={styles.headerBackButton} onPress={handleBackToLogin}>
        <Ionicons name="arrow-back" size={24} color={Colors.ink} />
      </Pressable>

      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <View style={styles.content}>
          {/* Header */}
          <Animated.View
            entering={FadeInDown.delay(100).duration(500)}
            style={styles.headerSection}
          >
            <View style={styles.iconContainer}>
              <Ionicons name="lock-closed-outline" size={64} color={Colors.thaiGold} />
            </View>
            <Text style={styles.title}>Forgot Password?</Text>
            <Text style={styles.subtitle}>
              Enter your email address and we'll send you instructions to reset your password.
            </Text>
          </Animated.View>

          {/* Form */}
          <Animated.View
            entering={FadeInDown.delay(200).duration(500)}
            style={styles.formSection}
          >
            <View style={styles.inputContainer}>
              <Text style={styles.label}>{t('auth.email')}</Text>
              <TextInput
                style={styles.input}
                placeholder={t('auth.emailPlaceholder')}
                placeholderTextColor={Colors.taupe}
                value={email}
                onChangeText={setEmail}
                keyboardType="email-address"
                autoCapitalize="none"
                autoCorrect={false}
                editable={!isLoading}
              />
            </View>

            <Pressable
              style={[styles.resetButton, isLoading && styles.resetButtonDisabled]}
              onPress={handleResetPassword}
              disabled={isLoading}
            >
              <Text style={styles.resetButtonText}>
                {isLoading ? t('common.loading') : 'Send Reset Link'}
              </Text>
            </Pressable>

            <Pressable
              style={styles.backTextButton}
              onPress={handleBackToLogin}
              disabled={isLoading}
            >
              <Ionicons name="arrow-back" size={16} color={Colors.thaiGold} />
              <Text style={styles.backTextButtonText}>Back to Login</Text>
            </Pressable>
          </Animated.View>
        </View>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.paper,
  },
  languageSwitcherContainer: {
    position: 'absolute',
    top: 60,
    right: 24,
    zIndex: 10,
  },
  headerBackButton: {
    position: 'absolute',
    top: 60,
    left: 24,
    zIndex: 10,
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: Colors.white,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  keyboardView: {
    flex: 1,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    paddingHorizontal: 32,
  },
  headerSection: {
    alignItems: 'center',
    marginBottom: 48,
  },
  iconContainer: {
    width: 120,
    height: 120,
    borderRadius: 60,
    backgroundColor: Colors.white,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  title: {
    fontFamily: Typography.playfairBold,
    fontSize: 28,
    color: Colors.ink,
    marginBottom: 12,
    textAlign: 'center',
  },
  subtitle: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.taupe,
    textAlign: 'center',
    lineHeight: 24,
    paddingHorizontal: 20,
  },
  formSection: {
    width: '100%',
  },
  inputContainer: {
    marginBottom: 24,
  },
  label: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.ink,
    marginBottom: 8,
  },
  input: {
    fontFamily: Typography.notoSerifRegular,
    height: 56,
    backgroundColor: Colors.white,
    borderWidth: 1,
    borderColor: Colors.sand,
    borderRadius: 16,
    paddingHorizontal: 20,
    fontSize: 16,
    color: Colors.ink,
  },
  resetButton: {
    height: 56,
    backgroundColor: Colors.ink,
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  resetButtonDisabled: {
    opacity: 0.6,
  },
  resetButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
    fontWeight: '600',
  },
  backTextButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 24,
    gap: 8,
  },
  backTextButtonText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.thaiGold,
  },
  // Success screen styles
  successSection: {
    alignItems: 'center',
  },
  successTitle: {
    fontFamily: Typography.playfairBold,
    fontSize: 28,
    color: Colors.ink,
    marginBottom: 16,
    textAlign: 'center',
  },
  successMessage: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.ink,
    textAlign: 'center',
    lineHeight: 24,
    marginBottom: 24,
    paddingHorizontal: 20,
  },
  infoText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
    textAlign: 'center',
    lineHeight: 20,
    marginBottom: 32,
    paddingHorizontal: 20,
  },
  backButton: {
    width: '100%',
    height: 56,
    backgroundColor: Colors.ink,
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  backButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
    fontWeight: '600',
  },
  resendButton: {
    width: '100%',
    height: 56,
    backgroundColor: Colors.white,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: Colors.sand,
    alignItems: 'center',
    justifyContent: 'center',
  },
  resendButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.ink,
    fontWeight: '600',
  },
});
````

## File: app/(auth)/register.tsx
````typescript
// app/(auth)/register.tsx
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  Pressable,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { useTranslation } from 'react-i18next';
import Animated, { FadeInDown } from 'react-native-reanimated';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { LanguageSwitcher } from '@/src/components/common/LanguageSwitcher';
import { useUserStore } from '@/src/stores/userStore';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { validateRegistrationForm } from '@/src/utils/validation';


export default function RegisterScreen() {
  const { t } = useTranslation();
  const router = useRouter();
  const { register, isLoading, error, clearError } = useUserStore();
  const [displayName, setDisplayName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPwd, setConfirmPwd] = useState('');

  // æ¸…ç†é”™è¯¯
  useEffect(() => {
    return () => clearError();
  }, []);

  // æ˜¾ç¤ºé”™è¯¯æç¤º
  useEffect(() => {
    if (error) {
      Alert.alert(t('common.error'), error);
    }
  }, [error]);

  const handleRegister = async () => {

    const validation = validateRegistrationForm({
      email,
      password,
      confirmPassword: confirmPwd,
      displayName
    });
    // éªŒè¯æ ¼å¼æ˜¯å¦æ­£ç¡®
    if (!validation.isValid) {
      Alert.alert('Error', validation.error);
      return; // é˜»æ­¢å‘é€è¯·æ±‚
    }

    const success = await register({
      displayName: displayName.trim(),
      email: email.toLowerCase().trim(),
      password,
    })

     if (success) {
      Alert.alert(
        t('auth.registerSuccess'),
        'Your account has been created successfully!',
        [
          {
            text: 'OK',
            onPress: () => router.replace('/(auth)/login'),
          },
        ]
      );
    }


  };

  return (
    <SafeAreaView style={styles.container}>

      {/* èƒŒæ™¯ */}
      <ThaiPatternBackground opacity={0.08} />

      {/* è¯­è¨€é€‰æ‹©å™¨ */}
      <View style={styles.languageSwitcherContainer}>
        <LanguageSwitcher />
      </View>

      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <View style={styles.content}>
          {/* Logo & Title */}
          <Animated.View
            entering={FadeInDown.delay(100).duration(500)}
            style={styles.headerSection}
          >
            <Text style={styles.logo}>à¸Šà¸²</Text>
            <Text style={styles.title}>{t('auth.title')}</Text>
            <Text style={styles.subtitle}>{t('auth.register')}</Text>
          </Animated.View>

          {/* Register Form */}
          <Animated.View
            entering={FadeInDown.delay(200).duration(500)}
            style={styles.formSection}
          >
            <View style={styles.inputContainer}>
              <Text style={styles.label}>{t('auth.displayName') || 'Display Name'}</Text>
              <TextInput
                style={styles.input}
                placeholder={t('auth.displayNamePlaceholder') || 'Enter your name'}
                placeholderTextColor={Colors.taupe}
                value={displayName}
                onChangeText={setDisplayName}
              />
            </View>

            <View style={styles.inputContainer}>
              <Text style={styles.label}>{t('auth.email')}</Text>
              <TextInput
                style={styles.input}
                placeholder={t('auth.emailPlaceholder')}
                placeholderTextColor={Colors.taupe}
                value={email}
                onChangeText={setEmail}
                keyboardType="email-address"
                autoCapitalize="none"
                autoCorrect={false}
              />
            </View>

            <View style={styles.inputContainer}>
              <Text style={styles.label}>{t('auth.password')}</Text>
              <TextInput
                style={styles.input}
                placeholder={t('auth.passwordPlaceholder')}
                placeholderTextColor={Colors.taupe}
                value={password}
                onChangeText={setPassword}
                secureTextEntry
                autoCapitalize="none"
              />
            </View>

            <View style={styles.inputContainer}>
              <Text style={styles.label}>{t('auth.confirmPassword') || 'Confirm Password'}</Text>
              <TextInput
                style={styles.input}
                placeholder={t('auth.confirmPasswordPlaceholder') || 'Re-enter your password'}
                placeholderTextColor={Colors.taupe}
                value={confirmPwd}
                onChangeText={setConfirmPwd}
                secureTextEntry
                autoCapitalize="none"
              />
            </View>

            <Pressable
              style={[styles.loginButton, isLoading && styles.loginButtonDisabled]}
              onPress={handleRegister}
              disabled={isLoading}
            >
              <Text style={styles.loginButtonText}>
                {isLoading ? t('common.loading') : t('auth.register')}
              </Text>
            </Pressable>

            <View style={styles.registerSection}>
              <Text style={styles.registerText}>{t('auth.alreadyHaveAccount') || 'Already have an account?'}</Text>
              <Pressable onPress={() => router.replace('/(auth)/login')}>
                <Text style={styles.registerLink}>{t('auth.login')}</Text>
              </Pressable>
            </View>
          </Animated.View>
        </View>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.paper,
  },
  languageSwitcherContainer: {
    position: 'absolute',
    top: 60,
    right: 24,
    zIndex: 10,
  },
  keyboardView: {
    flex: 1,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    paddingHorizontal: 32,
  },
  headerSection: {
    alignItems: 'center',
    marginBottom: 48,
  },
  logo: {
    fontFamily: Typography.sarabunBold,
    fontSize: 72,
    color: Colors.thaiGold,
    marginBottom: 8,
  },
  title: {
    fontFamily: Typography.playfairBold,
    fontSize: 28,
    color: Colors.ink,
    marginBottom: 4,
  },
  subtitle: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.taupe,
  },
  formSection: {
    width: '100%',
  },
  inputContainer: {
    marginBottom: 20,
  },
  label: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.ink,
    marginBottom: 8,
  },
  input: {
    fontFamily: Typography.notoSerifRegular,
    height: 56,
    backgroundColor: Colors.white,
    borderWidth: 1,
    borderColor: Colors.sand,
    borderRadius: 16,
    paddingHorizontal: 20,
    fontSize: 16,
    color: Colors.ink,
  },
  loginButton: {
    height: 56,
    backgroundColor: Colors.ink,
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  loginButtonDisabled: {
    opacity: 0.6,
  },
  loginButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
    fontWeight: '600',
  },
  registerSection: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 24,
    gap: 8,
  },
  registerText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  registerLink: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    color: Colors.thaiGold,
    fontWeight: '600',
  },
});
````

## File: app/learning/setup.tsx
````typescript
import React, { useMemo, useState } from 'react';
import { View, Text, StyleSheet, Pressable } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter, useLocalSearchParams } from 'expo-router';
import Slider from '@react-native-community/slider';
import { useTranslation } from 'react-i18next';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { useLearningPreferenceStore } from '@/src/stores/learningPreferenceStore';
import { useModuleAccessStore, type ModuleType } from '@/src/stores/moduleAccessStore';
import { useVocabularyStore } from '@/src/stores/vocabularyStore';

export default function DailyLimitSetupScreen() {
    const { t } = useTranslation();
    const router = useRouter();
    const params = useLocalSearchParams();
    const moduleParam = typeof params.module === 'string' ? params.module : 'word';
    const moduleType: ModuleType = moduleParam === 'letter' ? 'letter' : 'word';
    const courseSource = typeof params.source === 'string' ? params.source : undefined;

    const { dailyLimits, setDailyLimit } = useLearningPreferenceStore();
    const { setDailyLimit: setProgressDailyLimit } = useModuleAccessStore();
    const { startCourse } = useVocabularyStore();

    const initialLimit = useMemo(() => dailyLimits[moduleType] || 20, [dailyLimits, moduleType]);
    const [limit, setLimit] = useState(initialLimit);

    const handleConfirm = async () => {
        setDailyLimit(moduleType, limit);
        setProgressDailyLimit(moduleType, limit);

        if (courseSource) {
            await startCourse(courseSource);
        }

        router.replace({
            pathname: '/learning',
            params: {
                module: moduleType,
                source: courseSource,
            },
        });
    };

    return (
        <SafeAreaView style={styles.container}>
            <ThaiPatternBackground opacity={0.1} />
            <View style={styles.header}>
                <Text style={styles.title}>{t('learning.setupTitle', 'ä»Šæ—¥å­¦ä¹ è®¡åˆ’')}</Text>
                <Text style={styles.subtitle}>
                    {moduleType === 'letter'
                        ? t('learning.setupSubtitle', 'é€‰æ‹©ä»Šå¤©è¦å­¦ä¹ /å¤ä¹ çš„å­—æ¯æ•°é‡')
                        : t('learning.setupSubtitleWords', 'é€‰æ‹©ä»Šå¤©è¦å­¦ä¹ /å¤ä¹ çš„å•è¯æ•°é‡')}
                </Text>
            </View>

            <View style={styles.card}>
                <Text style={styles.limitValue}>{limit}</Text>
                <Slider
                    style={styles.slider}
                    minimumValue={5}
                    maximumValue={500}
                    step={5}
                    value={limit}
                    onValueChange={(value) => setLimit(Math.round(value))}
                    minimumTrackTintColor={Colors.thaiGold}
                    maximumTrackTintColor={Colors.sand}
                    thumbTintColor={Colors.ink}
                />
                <View style={styles.limitLabels}>
                    <Text style={styles.limitLabel}>5</Text>
                    <Text style={styles.limitLabel}>500</Text>
                </View>

                <Pressable style={styles.startButton} onPress={handleConfirm}>
                    <Text style={styles.startButtonText}>{t('learning.start', 'å¼€å§‹å­¦ä¹ ')}</Text>
                </Pressable>
            </View>
        </SafeAreaView>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: Colors.paper,
        paddingHorizontal: 24,
        paddingTop: 24,
    },
    header: {
        marginBottom: 24,
        gap: 8,
    },
    title: {
        fontFamily: Typography.playfairBold,
        fontSize: 26,
        color: Colors.ink,
    },
    subtitle: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.taupe,
        lineHeight: 20,
    },
    card: {
        backgroundColor: Colors.white,
        borderRadius: 20,
        padding: 24,
        borderWidth: 1,
        borderColor: Colors.sand,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.05,
        shadowRadius: 10,
        elevation: 4,
    },
    limitValue: {
        fontFamily: Typography.playfairBold,
        fontSize: 42,
        color: Colors.ink,
        textAlign: 'center',
        marginBottom: 12,
    },
    slider: {
        width: '100%',
        height: 40,
    },
    limitLabels: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        marginTop: -8,
        marginBottom: 24,
    },
    limitLabel: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 12,
        color: Colors.taupe,
    },
    startButton: {
        backgroundColor: Colors.ink,
        paddingVertical: 14,
        borderRadius: 14,
        alignItems: 'center',
    },
    startButtonText: {
        color: Colors.white,
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
    },
});
````

## File: cloudbase/functions/alphabet/handlers/passLetterTest.js
````javascript
const { createResponse } = require('../utils/response');
/**
 * æ ‡è®°å­—æ¯æµ‹è¯•é€šè¿‡
 * @param {Object} db - æ•°æ®åº“å®ä¾‹
 * @param {Object} data - è¯·æ±‚æ•°æ® { userId }
 */
// âœ… è®°å½•å­—æ¯æµ‹è¯•é€šè¿‡çŠ¶æ€
async function passLetterTest(db, data) {
    const { userId } = data || {};

    if (!userId) {
        return createResponse(false, null, 'userId å‚æ•°ç¼ºå¤±', 'INVALID_PARAMS');
    }

    const now = new Date().toISOString();

    try {
        const updateResult = await db.collection('user_progress')
            .where({ userId })
            .update({
                data: {
                    letterCompleted: true,
                    letterProgress: 1,
                    updatedAt: now
                }
            });
        // 2. å¦‚æœ update è¿”å› 0ï¼ˆè®°å½•ä¸å­˜åœ¨ï¼‰ï¼Œåˆ™ add
        if (updateResult.stats.updated === 0) {
            console.log(`[passLetterTest] è®°å½•ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ›å»º...`);
            await db.collection('user_progress').add({
                data: {
                    userId,
                    letterCompleted: true,
                    letterProgress: 1,
                    letterMasteredCount: 0,
                    letterTotalCount: 44,
                    wordProgress: 0,
                    wordMasteredCount: 0,
                    wordTotalCount: 0,
                    sentenceProgress: 0,
                    sentenceMasteredCount: 0,
                    sentenceTotalCount: 0,
                    articleProgress: 0,
                    articleMasteredCount: 0,
                    articleTotalCount: 0,
                    wordUnlocked: false,
                    sentenceUnlocked: false,
                    articleUnlocked: false,
                    createdAt: now,
                    updatedAt: now
                }
            });
        }

        return createResponse(true, {
            letterCompleted: true,
            letterProgress: 1,
        }, 'å­—æ¯æµ‹è¯•é€šè¿‡ï¼Œæ‰€æœ‰æ¨¡å—å·²è§£é”')
    } catch (error) {
        console.error('[passLetterTest] å†™å…¥è¿›åº¦å¤±è´¥ï¼š', error);
        return createResponse(false, null, 'å†™å…¥è¿›åº¦å¤±è´¥', 'DB_ERROR');
    }
}

module.exports = passLetterTest;
````

## File: cloudbase/functions/alphabet/utils/memoryEngine.js
````javascript
/**
 * alphabet/utils/memoryEngine.js
 *
 * è¯´æ˜ï¼š
 *  - æ—©æœŸ alphabet æ¨¡å—å†…å¤åˆ¶äº†ä¸€ä»½è®°å¿†å¼•æ“å®ç°ï¼Œå’Œ memory-engine ä¸‹çš„ utils/memoryEngine åŸºæœ¬é‡å¤ã€‚
 *  - ä¸ºé¿å…é€»è¾‘åˆ†å‰ï¼Œè¿™é‡Œæ”¹ä¸ºç›´æ¥å¤ç”¨ç»Ÿä¸€è®°å¿†å¼•æ“çš„å®ç°ã€‚
 */

module.exports = require('../memory-engine/utils/memoryEngine');
````

## File: cloudbase/functions/alphabet/utils/response.js
````javascript
/**
 * å“åº”æ ¼å¼åŒ–æ¨¡å—
 * 
 * ç»Ÿä¸€ API å“åº”æ ¼å¼
 * ä¸å‰ç«¯ ApiResponse<T> ç±»å‹å®šä¹‰ä¿æŒä¸€è‡´
 */

'use strict';

const { ErrorCodes, ERROR_MESSAGES } = require('./constants');

/**
 * åˆ›å»ºæ ‡å‡†åŒ– API å“åº”
 * 
 * å¯¹åº”å‰ç«¯ç±»å‹:
 * interface ApiResponse<T> {
 *   success: boolean;
 *   data?: T;
 *   message?: string;
 *   errorCode?: string;
 *   timestamp: string;
 * }
 * 
 * @param {boolean} success - æ˜¯å¦æˆåŠŸ
 * @param {Object} data - è¿”å›æ•°æ®
 * @param {string} message - æç¤ºæ¶ˆæ¯
 * @param {string} errorCode - é”™è¯¯ç 
 * @returns {Object} æ ‡å‡†åŒ–å“åº”å¯¹è±¡
 */
function createResponse(success, data = null, message = '', errorCode = null) {
  return {
    success,
    data,
    message,
    errorCode,
    timestamp: new Date().toISOString(),
  };
}

/**
 * åˆ›å»ºæˆåŠŸå“åº”
 * 
 * @param {Object} data - è¿”å›æ•°æ®
 * @param {string} message - æˆåŠŸæ¶ˆæ¯
 * @returns {Object} æˆåŠŸå“åº”å¯¹è±¡
 */
function successResponse(data, message = 'æ“ä½œæˆåŠŸ') {
  return createResponse(true, data, message, null);
}

/**
 * åˆ›å»ºé”™è¯¯å“åº”
 * 
 * @param {string} errorCode - é”™è¯¯ç  (æ¥è‡ª ErrorCodes)
 * @param {string} customMessage - è‡ªå®šä¹‰æ¶ˆæ¯ (å¯é€‰)
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function errorResponse(errorCode, customMessage = null) {
  const message = customMessage || ERROR_MESSAGES[errorCode] || 'æœªçŸ¥é”™è¯¯';
  return createResponse(false, null, message, errorCode);
}

/**
 * åˆ›å»ºå‚æ•°é”™è¯¯å“åº”
 * 
 * @param {string} detail - é”™è¯¯è¯¦æƒ…
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function invalidParamsResponse(detail) {
  return errorResponse(ErrorCodes.INVALID_PARAMS, detail);
}

/**
 * åˆ›å»ºç”¨æˆ·ä¸å­˜åœ¨å“åº”
 * 
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function userNotFoundResponse() {
  return errorResponse(ErrorCodes.USER_NOT_FOUND);
}

/**
 * åˆ›å»ºè¯æ±‡ä¸å­˜åœ¨å“åº”
 * 
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function vocabularyNotFoundResponse() {
  return errorResponse(ErrorCodes.VOCABULARY_NOT_FOUND);
}

/**
 * åˆ›å»ºæœåŠ¡å™¨é”™è¯¯å“åº”
 * 
 * @param {Error} error - é”™è¯¯å¯¹è±¡
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function serverErrorResponse(error) {
  // ç”Ÿäº§ç¯å¢ƒä¸æš´éœ²é”™è¯¯è¯¦æƒ…
  const message = process.env.NODE_ENV === 'development' 
    ? `æœåŠ¡å™¨é”™è¯¯: ${error.message}`
    : ERROR_MESSAGES.SERVER_ERROR;
  
  return errorResponse(ErrorCodes.SERVER_ERROR, message);
}

module.exports = {
  createResponse,
  successResponse,
  errorResponse,
  invalidParamsResponse,
  userNotFoundResponse,
  vocabularyNotFoundResponse,
  serverErrorResponse,
};
````

## File: cloudbase/functions/shared/package.json
````json
{
  "name": "@thai-app/shared",
  "version": "1.0.0",
  "description": "Shared utilities for CloudBase cloud functions",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "cloudbase",
    "shared",
    "utilities"
  ],
  "author": "Liang JianYu",
  "license": "MIT",
  "dependencies": {
    "wx-server-sdk": "~2.6.3"
  }
}
````

## File: cloudbase/functions/user-login/index.js
````javascript
// functions/user-login/index.js
const cloud = require('wx-server-sdk');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';
const JWT_EXPIRES_IN = '7d';

exports.main = async (event, context) => {
  try {
    // Parse request body if coming from HTTP trigger
    let requestData = event;
    if (typeof event.body === 'string') {
      try {
        requestData = JSON.parse(event.body);
      } catch (e) {
        return {
          success: false,
          error: 'Invalid JSON in request body',
          code: 'INVALID_JSON'
        };
      }
    } else if (event.body && typeof event.body === 'object') {
      requestData = event.body;
    }

    const { email, password } = requestData;

    // ===== Validation =====
    if (!email || !password) {
      return {
        success: false,
        error: 'Email and password are required',
        code: 'INVALID_INPUT'
      };
    }

    // ===== Find user by email =====
    const userResult = await db.collection('users')
      .where({
        email: email.toLowerCase()
      })
      .get();

    if (userResult.data.length === 0) {
      return {
        success: false,
        error: 'Invalid email or password',
        code: 'INVALID_CREDENTIALS'
      };
    }

    const user = userResult.data[0];

    // ===== Verify password =====
    const isPasswordValid = await bcrypt.compare(password, user.passwordHash);

    if (!isPasswordValid) {
      return {
        success: false,
        error: 'Invalid email or password',
        code: 'INVALID_CREDENTIALS'
      };
    }

    // ===== Check if account is active =====
    if (!user.isActive) {
      return {
        success: false,
        error: 'Account is deactivated',
        code: 'ACCOUNT_DEACTIVATED'
      };
    }

    // ===== Update last login =====
    await db.collection('users')
      .doc(user._id)
      .update({
        data: {
          lastLogin: new Date().toISOString()
        }
      });

    // ===== Generate JWT token =====
    const token = jwt.sign(
      {
        userId: user.userId,
        email: user.email,
        role: user.role
      },
      JWT_SECRET,
      { expiresIn: JWT_EXPIRES_IN }
    );

    // ===== Return user data (exclude password hash and _id) =====
    const { passwordHash, _id, ...userResponse } = user;

    return {
      success: true,
      data: {
        user: userResponse,
        token,
        expiresIn: 604800
      }
    };

  } catch (error) {
    console.error('Login error:', error);
    return {
      success: false,
      error: 'Login failed',
      code: 'SERVER_ERROR'
    };
  }
};
````

## File: cloudbase/functions/user-login/package.json
````json
{
  "name": "user-login",
  "version": "1.0.0",
  "description": "User login cloud function",
  "main": "index.js",
  "dependencies": {
    "wx-server-sdk": "~2.6.3",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2"
  }
}
````

## File: cloudbase/functions/user-reset-password/index.js
````javascript
// functions/user-reset-password/index.js
const cloud = require('wx-server-sdk');
const crypto = require('crypto');

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();

exports.main = async (event, context) => {
  try {
    // Parse request body if coming from HTTP trigger
    let requestData = event;
    if (typeof event.body === 'string') {
      try {
        requestData = JSON.parse(event.body);
      } catch (e) {
        return {
          success: false,
          error: 'Invalid JSON in request body',
          code: 'INVALID_JSON'
        };
      }
    } else if (event.body && typeof event.body === 'object') {
      requestData = event.body;
    }

    const { email } = requestData;

    // ===== Validation =====
    if (!email) {
      return {
        success: false,
        error: 'Email is required',
        code: 'INVALID_INPUT'
      };
    }

    // ===== Find user =====
    const userResult = await db.collection('users')
      .where({
        email: email.toLowerCase()
      })
      .get();

    // For security, always return success even if user not found
    if (userResult.data.length === 0) {
      return {
        success: true,
        data: {
          message: 'If this email is registered, you will receive password reset instructions.'
        }
      };
    }

    const user = userResult.data[0];

    // ===== Generate reset token =====
    const resetToken = crypto.randomBytes(32).toString('hex');
    const resetTokenHash = crypto
      .createHash('sha256')
      .update(resetToken)
      .digest('hex');

    const resetTokenExpiry = new Date(Date.now() + 3600000); // 1 hour from now

    // ===== Save reset token =====
    await db.collection('users')
      .doc(user._id)
      .update({
        data: {
          resetToken: resetTokenHash,
          resetTokenExpiry: resetTokenExpiry.toISOString()
        }
      });

    // ===== Send email (pseudo-code) =====
    // In production, integrate with email service like SendGrid, AWS SES, etc.
    const resetLink = `https://your-app.com/reset-password?token=${resetToken}`;
    
    // TODO: Implement actual email sending
    console.log(`Password reset link for ${email}: ${resetLink}`);
    
    // Placeholder for email service integration:
    // await sendEmail({
    //   to: email,
    //   subject: 'Password Reset Request',
    //   body: `Click this link to reset your password: ${resetLink}`
    // });

    return {
      success: true,
      data: {
        message: 'If this email is registered, you will receive password reset instructions.'
      }
    };

  } catch (error) {
    console.error('Password reset error:', error);
    return {
      success: false,
      error: 'Password reset request failed',
      code: 'SERVER_ERROR'
    };
  }
};
````

## File: cloudbase/functions/user-update-profile/index.js
````javascript
// functions/user-update-profile/index.js
const cloud = require('wx-server-sdk');

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();

// Middleware to verify JWT token (simplified)
function verifyToken(event) {
  // In production, verify the JWT token from Authorization header
  // For now, we'll trust the userId from the request
  return event.userId;
}

exports.main = async (event, context) => {
  try {
    // Parse request body if coming from HTTP trigger
    let requestData = event;
    if (typeof event.body === 'string') {
      try {
        requestData = JSON.parse(event.body);
      } catch (e) {
        return {
          success: false,
          error: 'Invalid JSON in request body',
          code: 'INVALID_JSON'
        };
      }
    } else if (event.body && typeof event.body === 'object') {
      requestData = event.body;
    }

    // ===== Verify authentication =====
    const userId = verifyToken(requestData);
    if (!userId) {
      return {
        success: false,
        error: 'Unauthorized',
        code: 'UNAUTHORIZED'
      };
    }

    const { displayName, avatar, preferences } = requestData;

    // ===== Build update object =====
    const updateData = {};
    
    // ===== Validate display name =====
    if (displayName !== undefined) {
      if (displayName.length < 2 || displayName.length > 10) {
        return {
          success: false,
          error: 'Display name must be 2-10 characters',
          code: 'INVALID_DISPLAY_NAME'
        };
      }
      updateData.displayName = displayName;
    }

    // ===== Validate avatar =====
    if (avatar !== undefined) {
      updateData.avatar = avatar;
    }

    // ===== Validate preferences =====
    if (preferences !== undefined) {
      updateData.preferences = preferences;
    }

    if (Object.keys(updateData).length === 0) {
      return {
        success: false,
        error: 'No fields to update',
        code: 'INVALID_INPUT'
      };
    }

    updateData.updatedAt = new Date().toISOString();

    // ===== Update user =====
    const result = await db.collection('users')
      .where({
        userId: userId
      })
      .update({
        data: updateData
      });

    if (result.stats.updated === 0) {
      return {
        success: false,
        error: 'User not found',
        code: 'USER_NOT_FOUND'
      };
    }

    // ===== Get updated user =====
    const userResult = await db.collection('users')
      .where({
        userId: userId
      })
      .get();

    const { passwordHash, _id, ...userResponse } = userResult.data[0];

    return {
      success: true,
      data: userResponse
    };

  } catch (error) {
    console.error('Profile update error:', error);
    return {
      success: false,
      error: 'Profile update failed',
      code: 'SERVER_ERROR'
    };
  }
};
````

## File: cloudbase/test-comprehensive.sh
````bash
#!/bin/bash

echo "======================================"
echo "å®Œæ•´ä¿®å¤: Node.js ç‰ˆæœ¬ + ç¬¦å·é“¾æ¥"
echo "======================================"
echo ""

cd ~/LearnOnThailand/ThaiLearningApp/cloudbase/functions

# 1. ä¿®å¤ shared çš„ Node.js ç‰ˆæœ¬
echo "1ï¸âƒ£ ä¿®å¤ shared æ¨¡å—..."
cd shared
node -e "
const fs = require('fs');
const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
pkg.engines = { node: '>=16.0.0' };
if (!pkg.dependencies) pkg.dependencies = {};
pkg.dependencies['wx-server-sdk'] = '~2.6.3';
fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
console.log('âœ… shared/package.json å·²æ›´æ–°');
"
npm install --production
cd ..

# 2. ä¿®å¤æ¯ä¸ªäº‘å‡½æ•°
for func in alphabet learn-vocab memory-engine; do
  echo ""
  echo "2ï¸âƒ£ å¤„ç† $func..."
  
  cd $func
  
  # æ›´æ–° package.json
  node -e "
  const fs = require('fs');
  const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
  pkg.engines = { node: '18.20.0' };
  fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
  console.log('  âœ… package.json å·²æ›´æ–°');
  "
  
  # åˆ é™¤ç¬¦å·é“¾æ¥,å¤åˆ¶çœŸå®æ–‡ä»¶
  rm -rf node_modules/@thai-app
  mkdir -p node_modules/@thai-app/shared
  cp -r ../shared/*.js node_modules/@thai-app/shared/
  cp ../shared/package.json node_modules/@thai-app/shared/
  cp -r ../shared/node_modules node_modules/@thai-app/shared/ 2>/dev/null || true
  
  echo "  âœ… shared å·²å¤åˆ¶ä¸ºçœŸå®æ–‡ä»¶"
  
  cd ..
done

echo ""
echo "======================================"
echo "3ï¸âƒ£ éªŒè¯é…ç½®..."
echo "======================================"
cd memory-engine
node -e "
try {
  console.log('Node ç‰ˆæœ¬:', process.version);
  const shared = require('@thai-app/shared');
  console.log('âœ… shared æ¨¡å—åŠ è½½æˆåŠŸ');
  console.log('å¯¼å‡º:', Object.keys(shared));
} catch(err) {
  console.error('âŒ', err.message);
  process.exit(1);
}
"
cd ..

echo ""
echo "======================================"
echo "âœ… ä¿®å¤å®Œæˆ! ç°åœ¨é‡æ–°éƒ¨ç½²:"
echo "======================================"
echo "tcb fn deploy memory-engine --runtime Nodejs18.20"
echo "tcb fn deploy alphabet --runtime Nodejs18.20"
echo "tcb fn deploy learn-vocab --runtime Nodejs18.20"
````

## File: docs/project-freeze/backend-memory-engine-spec.md
````markdown
# åç«¯ç»Ÿä¸€è®°å¿†å¼•æ“ä¸æ¨¡å—è§£é”è§„æ ¼è¯´æ˜ï¼ˆBackend Memory Engine Spec, Freeze V2.0.1ï¼‰

> ç›®å½•ï¼š`docs/project-freeze/backend-memory-engine-spec.md`  
> èŒƒå›´ï¼š`cloudbase/functions/memory-engine`ã€`cloudbase/functions/learn-vocab` ä¸­ä¸è®°å¿†/è¿›åº¦ç›¸å…³çš„å…¨éƒ¨é€»è¾‘ + æ•°æ®åº“æ ¸å¿ƒé›†åˆã€‚  
> ç›®æ ‡ï¼šç»Ÿä¸€æè¿°åç«¯å¦‚ä½•è°ƒåº¦å¤ä¹ é˜Ÿåˆ—ï¼ˆSMâ€‘2ï¼‰ã€å¦‚ä½•æ§åˆ¶æ¨¡å—è§£é”ï¼Œå¹¶ä¸å‰ç«¯çš„ Alphabet / Vocabulary æ¨¡å—è§„æ ¼å¯¹é½ï¼Œé¿å…å‰åç«¯è¯­ä¹‰ä¸ä¸€è‡´ã€‚

---

## 1. äº‘å‡½æ•°ä¸æ¨¡å—æ€»è§ˆ

### 1.1 memory-engine äº‘å‡½æ•°

**è·¯å¾„**ï¼š`cloudbase/functions/memory-engine`  
**å…¥å£**ï¼š`index.js`  
**è§¦å‘æ–¹å¼**ï¼šHTTP è§¦å‘å™¨ï¼Œç»Ÿä¸€è·¯ç”±å­—æ®µï¼š

```js
// è¯·æ±‚ä½“
{
  action: 'getTodayMemories' | 'submitMemoryResult' | 'submitRoundEvaluation'
        | 'checkModuleAccess' | 'getUserProgress' | 'getAlphabetLessons',
  data: { ... }
}
```

**ä¸»è¦ Actionï¼ˆç°æœ‰ + è§„åˆ’ä¸­çš„æœ€å°é›†åˆï¼‰ï¼š**

- `getTodayMemories`ï¼šç»Ÿä¸€è·å–â€œä»Šæ—¥å­¦ä¹ å†…å®¹â€ï¼ˆå­—æ¯/å•è¯/å¥å­ï¼‰ã€‚  
- `submitMemoryResult`ï¼šç»Ÿä¸€æäº¤å­¦ä¹ ç»“æœï¼Œ**æ”¯æŒå•æ¡å’Œæ‰¹é‡**ã€‚  
- `submitRoundEvaluation`ï¼šå­—æ¯æ¨¡å—ä¸“ç”¨ä¸‰è½®è¯„ä¼°å†™å…¥ `user_alphabet_progress`ã€‚  
- `checkModuleAccess`ï¼šæ£€æŸ¥æ¨¡å—è®¿é—®æƒé™ï¼ˆå­—æ¯å§‹ç»ˆæ”¾è¡Œï¼›å…¶ä»–æ¨¡å—éœ€å®Œæˆä¸€å®šå­—æ¯è¿›åº¦ï¼‰ã€‚  
- `getUserProgress`ï¼šè¿”å› `user_progress` ä¸­çš„å…¨å±€è¿›åº¦ã€‚  
- `getAlphabetLessons`ï¼šè¿”å›å­—æ¯è¯¾ç¨‹é…ç½®ã€‚  
- `registerStudySession`ï¼ˆ**å»ºè®®æ–°å¢ï¼Œæ”¯æŒå‰ç«¯è®°å½•å­¦ä¹ æ—¶é•¿ä¸æ‰“å¡**ï¼‰ï¼š  
  - ç”±å‰ç«¯å­¦ä¹ æ¨¡å—æˆ–å£³å±‚åœ¨ä¸€æ¬¡å­¦ä¹ ç»“æŸæ—¶è°ƒç”¨ï¼›  
  - ç”¨äºæ›´æ–° `user_progress.totalStudyDays / streakDays / lastStudyDate` ä»¥åŠ `LearningStore` éœ€è¦çš„æ€»å­¦ä¹ åˆ†é’Ÿæ•°ï¼ˆå¯æ–°å¢ `totalStudyMinutes` å­—æ®µï¼‰ã€‚

### 1.2 learn-vocab äº‘å‡½æ•°

**è·¯å¾„**ï¼š`cloudbase/functions/learn-vocab`  
**ä½œç”¨**ï¼šæ‰¿è½½**è¯æ±‡ä¸“ç”¨ API**ï¼ˆä¼ ç»Ÿè¯æ±‡æ¨¡å—ï¼‰ï¼ŒåŒ…æ‹¬ï¼š

- `getTodayWords` / `updateMastery` / `toggleSkipWord` / `getVocabularyDetail`  
- `getReviewStatistics` / `getVocabularyList` / `getSkippedWords`

> æ³¨æ„ï¼š`getTodayMemories` / `submitMemoryResult` ç­‰**å·²ç»è¿ç§»è‡³ `memory-engine`**ã€‚learn-vocab æ–‡æ¡£ä»ç„¶æœ‰æ•ˆï¼Œä½†åœ¨é¡¹ç›®å†»ç»“ä¸­ï¼Œè¯æ±‡æ¨¡å—ä¼˜å…ˆä½¿ç”¨ `memory-engine + vocabulary` ç»„åˆï¼ˆè¯¦è§ `vocabulary-module-spec.md`ï¼‰ã€‚

### 1.3 æ ¸å¿ƒæ•°æ®åº“é›†åˆ

é‡è¦é›†åˆè§ `docs/database_schema.md`ï¼Œä¸ memory-engine ç›´æ¥ç›¸å…³çš„æœ‰ï¼š

- `memory_status`ï¼šç»Ÿä¸€è®°å¿†çŠ¶æ€ï¼ˆå­—æ¯/å•è¯/å¥å­ï¼‰ï¼›  
- `user_progress`ï¼šæ•´ä½“æ¨¡å—è§£é”çŠ¶æ€ï¼›  
- `user_alphabet_progress`ï¼šå­—æ¯æ¨¡å—è¯¾ç¨‹çº§è¿›åº¦ï¼ˆå«ä¸‰è½®è¯„ä¼°ï¼‰ï¼›  
- `letters` / `vocabulary` / `sentences`ï¼šå®ä½“å†…å®¹è¡¨ã€‚

---

## 2. ç»Ÿä¸€è®°å¿†å¼•æ“æ ¸å¿ƒé€»è¾‘ï¼ˆmemoryEngine.js + sm2.jsï¼‰

### 2.1 createMemoryRecord / getOrCreateMemory

æ–‡ä»¶ï¼š`cloudbase/functions/memory-engine/utils/memoryEngine.js`

- `createMemoryRecord(db, userId, entityType, entityId, isLocked = false)`ï¼š
  - åœ¨ `memory_status` ä¸­æ’å…¥ä¸€æ¡æ–°çš„è®°å½•ï¼š
    - `masteryLevel: 0.0`  
    - `reviewStage: 0`  
    - `easinessFactor: 2.5`  
    - `intervalDays: 1`  
    - `nextReviewAt`: 1 å¤©åï¼ˆè‹¥ `isLocked === false`ï¼‰ã€‚  
- è‹¥æ’å…¥å› å”¯ä¸€ç´¢å¼•å¤±è´¥ï¼ˆé‡å¤ keyï¼‰ï¼Œä¼šé€€å›åˆ° `where({ userId, entityType, entityId }).get()` å¹¶è¿”å›å·²æœ‰è®°å½•ã€‚

- `getOrCreateMemory(db, userId, entityType, entityId, isLocked = false)`ï¼š
  - å…ˆ `where` æŸ¥è¯¢ï¼Œå¦‚æœå­˜åœ¨åˆ™è¿”å›ç¬¬ä¸€æ¡ï¼›  
  - å¦åˆ™è°ƒç”¨ `createMemoryRecord`ã€‚

### 2.2 updateMemoryAfterReviewï¼ˆSMâ€‘2 æ›´æ–°ï¼‰

`updateMemoryAfterReview(db, userId, entityType, entityId, quality)`ï¼š

- å…¥å‚ `quality` ä¸ºä¸­æ–‡å­—ç¬¦ä¸²ï¼š`'é™Œç”Ÿ' | 'æ¨¡ç³Š' | 'è®°å¾—'`ã€‚  
- æ­¥éª¤ï¼š
  1. é€šè¿‡ `getOrCreateMemory` å–å¾— `memory_status` è®°å½•ã€‚  
  2. ä½¿ç”¨ `calculateSM2Optimized(mastery, memory.intervalDays, memory.easinessFactor, memory.reviewStage)` è®¡ç®—ï¼š  
     - `interval`ï¼ˆä¸‹æ¬¡é—´éš”å¤©æ•°ï¼‰ï¼›  
     - `easinessFactor`ï¼ˆæ–°çš„ EFï¼‰ï¼›  
     - `repetitions`ï¼ˆæ–°çš„ reviewStageï¼‰ã€‚  
  3. æ ¹æ®è´¨é‡è°ƒæ•´ `masteryLevel`ï¼š
     - `è®°å¾—`ï¼š`+0.15`ï¼Œä¸Šé™ `1.0`ï¼›  
     - `æ¨¡ç³Š`ï¼š`+0.05`ï¼Œä¸‹é™ `0.0`ï¼›  
     - `é™Œç”Ÿ`ï¼š`-0.2`ï¼Œä¸‹é™ `0.0`ã€‚  
  4. æ›´æ–°è®¡æ•°ï¼š
     - `streakCorrect`ï¼šè®°å¾—åˆ™ `+1`ï¼Œå¦åˆ™ `0`ï¼›  
     - `correctCount` / `wrongCount`ï¼šåˆ†åˆ«åœ¨è®°å¾— / é™Œç”Ÿæ—¶è‡ªå¢ã€‚  
  5. è®¡ç®— `nextReviewAt = now + intervalDays`ã€‚  
  6. ç”¨ `update({ data: updateData })` å†™å› `memory_status`ã€‚

è¿”å›ç»™è°ƒç”¨æ–¹çš„ç»“æ„ï¼ˆè¢« `submitMemoryResult` åŒ…è£…ï¼‰ï¼š

```js
{
  entityType,
  entityId,
  quality,        // 'é™Œç”Ÿ'/'æ¨¡ç³Š'/'è®°å¾—'
  memoryState: {  // æ›´æ–°åçš„å…³é”®å­—æ®µ
    masteryLevel,
    reviewStage,
    easinessFactor,
    intervalDays,
    nextReviewAt,
    correctCount,
    wrongCount,
    streakCorrect,
  }
}
```

### 2.3 SMâ€‘2 ä¼˜åŒ–ç®—æ³•ï¼ˆsm2.jsï¼‰

`calculateSM2Optimized(mastery, currentInterval, easinessFactor, reviewCount)`ï¼š

- `mastery` åŒæ ·ä½¿ç”¨ `'é™Œç”Ÿ'/'æ¨¡ç³Š'/'è®°å¾—'`ï¼›å†…éƒ¨å…ˆæ˜ å°„åˆ° **Quality**ï¼ˆ1/3/5ï¼‰ã€‚  
- ç®—æ³•è¦ç‚¹ï¼š

1. **é™Œç”Ÿï¼ˆquality < 3ï¼‰**  
   - è§†ä¸ºâ€œå®Œå…¨å¿˜è®°â€ï¼š  
     - `interval = 1`ï¼›  
     - `easinessFactor -= 0.2`ï¼ˆä¸ä½äº `1.3`ï¼‰ï¼›  
     - æ ‡è®° `shouldResetCount = true`ã€‚

2. **æ¨¡ç³Šï¼ˆquality === 3ï¼‰**  
   - ç¼©çŸ­é—´éš”ï¼ŒåŠ å¼ºå¤ä¹ ï¼š  
     - `interval = currentInterval * FUZZY_MULTIPLIERï¼ˆâ‰ˆ0.8ï¼‰`ï¼Œè‡³å°‘ 1 å¤©ï¼›  
     - `easinessFactor -= 0.1`ï¼Œä¸ä½äº `1.3`ã€‚

3. **è®°å¾—ï¼ˆquality > 3ï¼‰**  
   - è‹¥ `reviewCount < EARLY_INTERVALS.length`ï¼Œä½¿ç”¨æ—©æœŸå›ºå®šé—´éš”ï¼š`[1,2,4,7,14]`ï¼›  
   - å¦åˆ™ `interval = round(currentInterval * EF)`ã€‚  
   - æŒ‰æ ‡å‡† SMâ€‘2 å…¬å¼æ›´æ–° EFï¼Œå¹¶é™åˆ¶åœ¨åˆç†åŒºé—´ã€‚

è¿”å›ï¼š

```js
{
  interval,           // ç”¨äº memory_status.intervalDays
  easinessFactor,     // ç”¨äº memory_status.easinessFactor
  repetitions,        // ç”¨äº memory_status.reviewStage
  nextInterval, nextEasinessFactor, nextReviewDate, shouldResetCount
}
```

### 2.4 ä»Šæ—¥å¾…å¤ä¹ å®ä½“ï¼ˆgetTodayReviewEntitiesï¼‰

`getTodayReviewEntities(db, userId, entityType, limit)`ï¼š

- æŸ¥è¯¢æ¡ä»¶ï¼š

```js
where({
  userId,
  entityType,
  isLocked: false,
  nextReviewAt: db.command.lte(new Date())
})
.orderBy('nextReviewAt', 'asc')
.limit(limit)
```

- è¿”å› `memory_status` æ–‡æ¡£æ•°ç»„ï¼Œåç»­ç”± `getTodayMemories` æ‹¼ä¸Šå®ä½“è¯¦æƒ…ã€‚

---

## 3. getTodayMemories è¡Œä¸ºï¼ˆè¯¾ç¨‹æ¨¡å¼ + SRS æ¨¡å¼ï¼‰

æ–‡ä»¶ï¼š`cloudbase/functions/memory-engine/handlers/getTodayMemories.js`

### 3.1 å…¥å£å‚æ•°

```ts
{
  userId: string;
  entityType: 'letter' | 'word' | 'sentence';
  limit?: number;          // é»˜è®¤ 30
  includeNew?: boolean;    // é»˜è®¤ true
  lessonId?: string;       // å­—æ¯è¯¾ç¨‹æ¨¡å¼ä¸‹ä½¿ç”¨
}
```

### 3.2 æ­¥éª¤æ¦‚è§ˆ

1. **æ‡’åˆå§‹åŒ–**ï¼š
   - `entityType === 'letter'` â†’ `ensureUserAlphabetProgress`ï¼ˆæ’å…¥ `user_alphabet_progress` å ä½è®°å½•ï¼‰ï¼›  
   - `entityType === 'word'` â†’ `ensureUserVocabularyProgress`ï¼ˆæ’å…¥ `user_vocabulary_progress` å ä½è®°å½•ï¼‰ã€‚  

2. **æ¨¡å—è®¿é—®æ£€æŸ¥**ï¼š`checkModuleAccess(db, userId, entityType)`ï¼š
   - å­—æ¯æ¨¡å—ï¼šæ°¸è¿œå…è®¸è®¿é—®ï¼›å¿…è¦æ—¶è‡ªåŠ¨è°ƒç”¨ `initUserProgress` åˆ›å»º `user_progress`ã€‚  
   - å…¶ä»–æ¨¡å—ï¼šè¦æ±‚ `letterCompleted === true` æˆ– `letterProgress >= 0.8`ï¼Œå¦åˆ™è¿”å› `MODULE_LOCKED`ã€‚  
   - æ”¯æŒ `FORCE_UNLOCK` ç¯å¢ƒå˜é‡å¼ºåˆ¶æ”¾è¡Œï¼›`userId === 'test-user'` ç›´æ¥æ”¾è¡Œã€‚

3. **æ¯æ—¥å­¦ä¹ é‡ï¼ˆlimitï¼‰å¤„ç†**ï¼š
   - è‹¥åç«¯ `user_progress.dailyLimit` å­˜åœ¨ï¼Œåˆ™è¦†ç›–å‰ç«¯ä¼ å…¥çš„ `limit`ï¼›  
   - `entityType === 'letter'` æ—¶ï¼Œå§‹ç»ˆä»¥æœåŠ¡å™¨é…ç½®ä¸ºå‡†ï¼ˆå¿½ç•¥å‰ç«¯åŠ¨æ€è°ƒæ•´ï¼‰ã€‚  
   - å¯¹å…¶ä»–å®ä½“ï¼Œè‹¥å‰ç«¯ä¼ å…¥ limit ä¸å­˜é‡ä¸åŒï¼Œä¼šåŒæ—¶æ›´æ–° `user_progress.dailyLimit`ã€‚

4. **è·å–ä»Šæ—¥å¤ä¹ å®ä½“ï¼ˆæ—§ + æ–°ï¼‰**ï¼š
   - æ—§å®ä½“ï¼š`getTodayReviewEntities(db, userId, entityType, effectiveLimit)`ï¼›  
   - æ–°å®ä½“ï¼ˆ`includeNew === true` ä¸”å¤ä¹ ä¸è¶³ `effectiveLimit`ï¼‰ï¼š
     - `letter + lessonId`ï¼šä» `letters` ä¸­æŒ‰ `curriculumLessonIds: db.command.in([lessonId])` å–å‡ºè¯¾ç¨‹ä¸­å‰©ä½™æ‰€æœ‰å­—æ¯ï¼ˆé™ 200ï¼‰ï¼Œ**ä¸å†æŒ‰ limit æˆªæ–­**ï¼›  
     - å…¶ä»–æƒ…å†µï¼šä»å¯¹åº”é›†åˆï¼ˆ`vocabulary` ç­‰ï¼‰æŒ‰ `lessonNumber` ä¸ `_id` æ’åºï¼Œå– `remainingSlots` æ¡ã€‚
   - å¯¹æ¯ä¸ªæ–°å®ä½“è°ƒç”¨ `getOrCreateMemory(..., isLocked = false)` ç”Ÿæˆ `memory_status` è®°å½•ã€‚

5. **æ•´åˆé˜Ÿåˆ—ï¼ˆ3 æ–° 1 å¤ä¹ ï¼‰**ï¼š
   - å†å²å¤ä¹ ï¼š`allMemories = [...reviewMemories]`ï¼›  
   - æ–°å†…å®¹ï¼š

```js
for i in 0..newMemories.length-1:
  allMemories.push(newMemories[i]);
  if ((i + 1) % 3 === 0) {
    allMemories.push(newMemories[i - 2]); // å¤ä¹ æœ¬ç»„ä¸‰å­—ä¸­çš„ç¬¬1ä¸ª
  }
```

> è¿™æ˜¯ä¸€ç§â€œä¼šè¯å†…å°å¤ä¹ â€å®ç°ï¼Œå‰ç«¯å¯ä»¥é€‰æ‹©æ˜¯å¦æŒ‰è¯¥é˜Ÿåˆ—ç›´æ¥å‡ºé¢˜ï¼Œæˆ–åœ¨è‡ªå·±çš„ Flow ä¸­ç”¨ä½œå‚è€ƒã€‚

6. **æ‹¼æ¥å®ä½“è¯¦æƒ…**ï¼š
   - æ”¶é›† `entityIds`ï¼Œä»å¯¹åº”é›†åˆï¼ˆ`letters`/`vocabulary` ç­‰ï¼‰æŸ¥è¯¢ï¼›  
   - ä¸ºæ¯ä¸ª memory è®°å½•è¡¥ä¸Š `entity` å­—æ®µä¸ `memoryState`ï¼š

```js
memoryState: {
  masteryLevel,
  reviewStage,
  correctCount,
  wrongCount,
  streakCorrect,
  nextReviewAt,
  isNew: memory.reviewStage === 0
}
```

7. **å­—æ¯è¯¾ç¨‹å…ƒæ•°æ®**ï¼ˆä»… `entityType === 'letter'`ï¼‰ï¼š
   - è‡ªåŠ¨æ¨å¯¼ `resolvedLessonId`ï¼ˆä¼˜å…ˆ `params.lessonId`ï¼Œé€€åŒ–ä¸ºå®ä½“ä¸Šçš„ `curriculumLessonIds[0] / lessonId / lessonNumber`ï¼‰ï¼›  
   - é€šè¿‡ `getLessonMetadataFromDb` ä¸ `getPhonicsRuleByLessonFromDb` è¿”å› `lessonMetadata` ä¸ `phonicsRule`ã€‚

8. **å“åº”ç»“æ„ï¼š**

```ts
{
  items: Array<Letter | Vocabulary & { memoryState }>,
  summary: {
    total: number;
    reviewCount: number;
    newCount: number;
    entityType: 'letter' | 'word' | 'sentence';
  },
  lessonMetadata?: LessonMetadata;   // ä»…å­—æ¯
  phonicsRule?: PhonicsRule | null; // ä»…å­—æ¯
}
```

### 3.3 è¯¾ç¨‹æ¨¡å¼ vs çº¯ SRS æ¨¡å¼

- **å­—æ¯æ¨¡å—ï¼ˆè¯¾ç¨‹æ¨¡å¼ï¼‰**ï¼š
  - æ¨èå‰ç«¯åœ¨è°ƒç”¨ `getTodayMemories` æ—¶å§‹ç»ˆæºå¸¦ `lessonId`ï¼›  
  - åç«¯å¯¹æ–°å­—æ¯â€œä¸å†æŒ‰ limit æˆªæ–­â€ï¼Œè€Œæ˜¯ä¸€æ¬¡æ€§æˆæƒæ•´è¯¾å­—æ¯ï¼›  
  - `reviewMemories` ä»ç”± SMâ€‘2 å†³å®šæ˜¯å¦æœ‰â€œè·¨å¤©å¤ä¹ â€ï¼Œä½†åœ¨é¡¹ç›®å†»ç»“è®¾è®¡ä¸­ï¼Œå‰ç«¯å¯ä»¥é€‰æ‹©**å¿½ç•¥**è¿™éƒ¨åˆ†ï¼Œåªç”¨ `memoryState` åšéš¾åº¦å‚è€ƒï¼Œå°†çœŸæ­£çš„è¯¾ç¨‹é˜Ÿåˆ—é€»è¾‘æ”¾åˆ°å‰ç«¯ï¼ˆè¯¦è§ `alphabet-module-spec.md` ç¬¬ 11 ç« ï¼‰ã€‚

- **è¯æ±‡æ¨¡å—ï¼ˆçº¯ SRS æ¨¡å¼ï¼‰**ï¼š
  - å‰ç«¯ä¸ä¼  `lessonId`ï¼Œåªä¼  `entityType: 'word'`ï¼Œç”± `getTodayReviewEntities` + æ–°è¯é€»è¾‘å…±åŒå†³å®šä»Šæ—¥é˜Ÿåˆ—ï¼›  
  - è¯æ±‡æ¨¡å—çš„è¯¦ç»†è¡Œä¸ºç”± `learn-vocab` çš„ `getTodayWords` / `updateMastery` + `vocabulary-module-spec.md` å®šä¹‰ã€‚

---

## 4. submitMemoryResult è¡Œä¸ºï¼ˆå•æ¡ + æ‰¹é‡ï¼‰

æ–‡ä»¶ï¼š`cloudbase/functions/memory-engine/handlers/submitMemoryResult.js`

### 4.1 æ¥å£å½¢æ€

æ”¯æŒä¸¤ç§ç”¨æ³•ï¼š

1. **å•æ¡æäº¤ï¼ˆæ—§ç‰ˆå…¼å®¹ï¼‰**

```json
{
  "action": "submitMemoryResult",
  "data": {
    "userId": "u_xxx",
    "entityType": "letter",
    "entityId": "TH_C_01",
    "quality": "è®°å¾—"
  }
}
```

2. **æ‰¹é‡æäº¤ï¼ˆæ¨èï¼‰**

```json
{
  "action": "submitMemoryResult",
  "data": {
    "userId": "u_xxx",
    "results": [
      { "entityType": "letter", "entityId": "TH_C_01", "quality": "è®°å¾—" },
      { "entityType": "letter", "entityId": "TH_C_02", "quality": "æ¨¡ç³Š" }
    ]
  }
}
```

### 4.2 è¡Œä¸º

- ç»Ÿä¸€æŠŠå‚æ•°è½¬æ¢ä¸º `items[]` æ•°ç»„ï¼›  
- é€æ¡è°ƒç”¨ `updateMemoryAfterReview(db, userId, entityType, entityId, quality)`ï¼›  
- èšåˆç»“æœåä½¿ç”¨ `createResponse(true, { updatedMemories }, 'æäº¤å­¦ä¹ ç»“æœæˆåŠŸ')` è¿”å›ã€‚

> ä¸å‰ç«¯ Spec å¯¹é½ï¼š  
> - **Alphabet æ¨¡å—**ï¼šæ¨èåœ¨æ¯ä¸ª Round ç»“æŸåï¼Œå°†â€œæœ¬è½®å‡ºç°è¿‡çš„å­—æ¯ + è®¡ç®—å¥½çš„ `quality`â€æ‰“åŒ…æˆ `results[]` ä¸€æ¬¡æäº¤ã€‚  
> - **Vocabulary æ¨¡å—**ï¼šæ¨èåœ¨ä¸€æ¬¡ä¼šè¯ç»“æŸåï¼Œå¯¹ä»Šæ—¥å‡ºç°è¿‡çš„æ‰€æœ‰å•è¯èšåˆä¸º `results[]` ä¸€æ¬¡æäº¤ï¼Œæˆ–ä½¿ç”¨ learn-vocab çš„ `updateMastery`ï¼ˆäºŒé€‰ä¸€ï¼Œä¿æŒä¸€è‡´å³å¯ï¼‰ã€‚

---

## 5. å­¦ä¹ ä¼šè¯ç™»è®°ï¼ˆregisterStudySessionï¼Œè§„åˆ’ä¸­ï¼‰

> ä¸ºäº†è®©å‰ç«¯ `LearningStore` æ‹¥æœ‰å¯é çš„æ•°æ®æ¥æºï¼ŒåŒæ—¶ä¸åœ¨å„æ¨¡å—ä¸­é‡å¤è®¡ç®—â€œæ‰“å¡å¤©æ•° / æ€»å­¦ä¹ æ—¶é•¿â€ï¼Œå»ºè®®åœ¨ `memory-engine` ä¸­æ–°å¢ `registerStudySession` Actionã€‚  
> è¯¥ Action çš„é€»è¾‘è¶³å¤Ÿç®€å•ï¼Œä¸æ¶‰åŠ SRSï¼Œåªæ›´æ–° `user_progress` ä¸­çš„ç»Ÿè®¡å­—æ®µã€‚

### 5.1 Action è®¾è®¡

è¯·æ±‚ï¼š

```ts
// action: 'registerStudySession'
interface RegisterStudySessionRequest {
  userId: string;
  module: 'letter' | 'word' | 'sentence' | 'article';
  minutes: number;              // æœ¬æ¬¡å­¦ä¹ æ—¶é•¿ï¼ˆå‘ä¸‹å–æ•´çš„åˆ†é’Ÿæ•°ï¼‰
  finishedLessonId?: string;    // è‹¥æœ¬æ¬¡å®Œæˆäº†æŸè¯¾ï¼Œå¯é€‰ä¼ å…¥ lessonId
  date?: string;                // å¯é€‰ï¼ŒISO æ—¥æœŸï¼›ç¼ºçœåˆ™ä½¿ç”¨æœåŠ¡å™¨å½“å¤©
}
```

è¡Œä¸ºï¼š

- æŒ‰ `userId` æŸ¥æ‰¾ `user_progress`ï¼›è‹¥ä¸å­˜åœ¨åˆ™å…ˆèµ° `initUserProgress`ï¼›  
- è®¡ç®—å½“å¤©æ˜¯å¦é¦–æ¬¡å­¦ä¹ ï¼š
  - è‹¥ `lastStudyDate` ä¸º null æˆ–æ—©äºå½“æ—¥ï¼Œåˆ™ `totalStudyDays += 1`ï¼Œ`streakDays` æŒ‰å¤©æ•°æ˜¯å¦è¿ç»­é€’å¢æˆ–é‡ç½®ï¼›  
  - æ›´æ–° `lastStudyDate = today`ã€‚  
- å¢åŠ æ–°çš„å­—æ®µï¼ˆå»ºè®®ï¼‰ï¼š

```ts
user_progress.totalStudyMinutes += minutes;
```

- è‹¥ `finishedLessonId` å­˜åœ¨ï¼Œå¯é€‰æ›´æ–°å¯¹åº”æ¨¡å—è¿›åº¦ï¼ˆä¾‹å¦‚å­—æ¯è¯¾å®Œæˆæ•°ï¼‰ï¼Œå…·ä½“ç»†èŠ‚ç”±å„æ¨¡å—åœ¨å‰ç«¯å¤„ç†ã€‚

å“åº”ï¼š

```ts
interface RegisterStudySessionResponse {
  userId: string;
  totalStudyDays: number;
  streakDays: number;
  lastStudyDate: string;
  totalStudyMinutes?: number;
}
```

å‰ç«¯ä½¿ç”¨æ–¹å¼ï¼š

- å„å­¦ä¹ æ¨¡å—åœ¨ä¸€æ¬¡â€œæ­£å¼å­¦ä¹ ç»“æŸâ€æ—¶è°ƒç”¨ï¼š

```ts
await callCloudFunction('memory-engine', {
  action: 'registerStudySession',
  data: {
    userId,
    module: 'letter',        // æˆ– 'word' ...
    minutes: sessionMinutes,
    finishedLessonId,
  },
});
```

- `LearningStore.registerStudySession` å¯åœ¨å†…éƒ¨è°ƒç”¨æ­¤ Actionï¼Œå¹¶åŒæ­¥æ›´æ–°æœ¬åœ°ä»ªè¡¨ç›˜ç»Ÿè®¡ã€‚

---

## 6. æ¨¡å—è§£é”é€»è¾‘ï¼ˆcheckModuleAccessï¼‰

æ–‡ä»¶ï¼š`cloudbase/functions/memory-engine/utils/memoryEngine.js` ä¸­çš„ `checkModuleAccess`

### 5.1 ç‰¹æ®Šæ”¾è¡Œä¸åˆå§‹åŒ–

- `userId === 'test-user'`ï¼šç›´æ¥æ”¾è¡Œä»»æ„æ¨¡å—ï¼Œè¿”å›ä¸€ä»½æœ€å°è¿›åº¦å¯¹è±¡ï¼Œåªç”¨äºæœ¬åœ°å¼€å‘ã€‚  
- æœªæ‰¾åˆ° `user_progress`ï¼š
  - è‹¥ `FORCE_UNLOCK === 'true'`ï¼šæ”¾è¡Œæ‰€æœ‰æ¨¡å—ï¼›  
  - è‹¥ `moduleType === 'letter'`ï¼šè‡ªåŠ¨è°ƒç”¨ `initUserProgress`ï¼Œåˆå§‹åŒ–ä¸ºï¼š

```js
{
  letterCompleted: false,
  letterProgress: 0,
  wordUnlocked: false,
  wordProgress: 0,
  sentenceUnlocked: false,
  sentenceProgress: 0,
  articleUnlocked: false,
  currentStage: 'letter',
  ...
}
```

  - å…¶ä»–æ¨¡å—ï¼šè¿”å› `USER_PROGRESS_NOT_FOUND`ã€‚

### 5.2 æ­£å¸¸åˆ¤æ–­

- è‹¥è®¾ç½®äº† `FORCE_UNLOCK`ï¼šç›´æ¥æ”¾è¡Œæ‰€æœ‰æ¨¡å—ï¼Œå¹¶å°†å¯¹åº” `*Unlocked` å­—æ®µè§†ä¸º trueã€‚  
- å­—æ¯æ¨¡å—ï¼šæ°¸è¿œå…è®¸è®¿é—®ï¼ˆç”¨äºè¡¥è¯¾æˆ–å›é¡¾ï¼‰ã€‚  
- å…¶ä»–æ¨¡å—ï¼ˆè¯æ±‡/å¥å­/æ–‡ç« ï¼‰ï¼šä½¿ç”¨ç»Ÿä¸€è§„åˆ™ï¼š
  - è‹¥ `letterCompleted === true` â†’ æ”¾è¡Œï¼›  
  - å¦åˆ™è‹¥ `letterProgress >= 0.8` â†’ æ”¾è¡Œï¼›  
  - å¦åˆ™è¿”å› `MODULE_LOCKED`ï¼Œé™„å¸¦å½“å‰ `letterProgress` ç™¾åˆ†æ¯”ã€‚

> ä¸å‰ç«¯å¯¹é½ï¼š  
> - Courses é¡µåœ¨å±•ç¤ºè¯æ±‡è¯¾ç¨‹æ—¶ï¼Œå¯ä»¥æ ¹æ® `getUserProgress` / `moduleAccessStore` åˆ¤æ–­æ˜¯å¦å±•ç¤ºé”å›¾æ ‡ã€‚  
> - ç”¨æˆ·å³ä½¿å®Œæˆäº†å­—æ¯è¯¾ç¨‹ï¼Œä»å¯éšæ—¶è¿”å›å­—æ¯æ¨¡å—ç»§ç»­ç»ƒä¹ ï¼›åç«¯ä¸ä¼šç¦æ­¢ã€‚

---

## 6. å¤šæ¨¡å—åˆ‡æ¢ä¸æ··åˆå¤ä¹ çš„çº¦å®š

> ç›®å‰åç«¯çš„è®¾è®¡**æ²¡æœ‰ç›´æ¥æ”¯æŒâ€œæ··åˆå­—æ¯ + å•è¯â€çš„ getTodayMemories é˜Ÿåˆ—**ï¼Œæ‰€æœ‰è°ƒç”¨éƒ½ä»¥ `entityType` ä¸ºç²’åº¦ã€‚  
> å¦‚æœæœªæ¥éœ€è¦â€œç»¼åˆå¤ä¹ â€é¡µé¢ï¼Œå¯ä»¥åœ¨å‰ç«¯æŒ‰ä»¥ä¸‹çº¦å®šç»„åˆè°ƒç”¨ã€‚

### 6.1 ç°çŠ¶ï¼šæŒ‰å®ä½“ç±»å‹ç‹¬ç«‹è°ƒåº¦

- `getTodayMemories` æ¯æ¬¡åªæ¥å—ä¸€ä¸ª `entityType`ï¼š`letter` æˆ– `word`ã€‚  
- Alphabet æ¨¡å—ï¼šå»ºè®®å§‹ç»ˆåœ¨è¯¾ç¨‹å†…éƒ¨ä½¿ç”¨æœ¬åœ°é˜Ÿåˆ— + `submitMemoryResult`ï¼›  
- Vocabulary æ¨¡å—ï¼šå¯ä»¥é€‰æ‹©ä½¿ç”¨ `memory-engine`ï¼ˆ`entityType: 'word'`ï¼‰ï¼Œæˆ–æ²¿ç”¨ `learn-vocab` çš„ `getTodayWords`ã€‚

### 6.2 ç”¨æˆ·åœ¨æ¨¡å—é—´åå¤åˆ‡æ¢æ—¶çš„è¡Œä¸º

1. ç”¨æˆ·å®Œæˆ Alphabet æŸä¸€è¯¾çš„ä¸‰è½®å­¦ä¹  â†’ å‰ç«¯èšåˆè´¨é‡åè°ƒç”¨ `submitMemoryResult`ï¼ˆletterï¼‰ï¼Œå¹¶åœ¨ `user_alphabet_progress` ä¸­è®°å½• Round3 é€šè¿‡ç»“æœ â†’ åç«¯ `user_progress.letterCompleted` æˆ– `letterProgress` è¢«æ›´æ–°ï¼ˆç”±åç»­ä»»åŠ¡å®ç°ï¼‰ã€‚  
2. å½“ `checkModuleAccess('word')` è¿”å› allowed æ—¶ï¼Œç”¨æˆ·å¯ä»¥è¿›å…¥è¯æ±‡æ¨¡å—å­¦ä¹ ã€‚  
3. è‹¥ç”¨æˆ·å†æ¬¡è¿”å›å­—æ¯æ¨¡å—ï¼š
   - `checkModuleAccess('letter')` æ°¸è¿œå…è®¸ï¼›  
   - è‹¥å‰ç«¯ä»è°ƒç”¨ `getTodayMemories(letter, { includeNew:true })`ï¼Œåç«¯ä¼šæŒ‰ SMâ€‘2 æ—¶é—´è°ƒåº¦åˆ°æœŸçš„å­—æ¯ + å‘ç°æ–°å­—æ¯æ—¶åˆ›å»ºæ–° `memory_status`ï¼›  
   - é¡¹ç›®å†»ç»“æ–¹æ¡ˆä¸­ï¼Œæ¨èï¼š**å­—æ¯è¯¾ç¨‹å†…ä¸å†ä¾èµ– `getTodayMemories` çš„é˜Ÿåˆ—ï¼Œè€Œæ˜¯ä»¥ lessonId + æœ¬åœ° session ä¸ºä¸»ï¼Œ`memory_status` åªå­˜å‚¨è´¨é‡ç»“æœ**ã€‚

### 6.3 æœªæ¥çš„â€œæ··åˆå¤ä¹ â€é¡µé¢ï¼ˆå»ºè®®ï¼‰

è‹¥æœªæ¥è¦å®ç°â€œæ¯æ—¥ç»¼åˆå¤ä¹ é¡µé¢ï¼ˆå­—æ¯ + å•è¯ï¼‰â€ï¼Œå¯ä»¥å‰ç«¯æŒ‰ä»¥ä¸‹æ–¹å¼å®ç°ï¼Œè€Œæ— éœ€æ”¹åŠ¨åç«¯ï¼š

1. åˆ†åˆ«è°ƒç”¨ï¼š

```ts
const letters = await getTodayMemories({ userId, entityType: 'letter', limit: L, includeNew: false });
const words   = await getTodayMemories({ userId, entityType: 'word',   limit: W, includeNew: false });
```

2. åœ¨å‰ç«¯æ ¹æ®éœ€è¦äº¤é”™ `letters.items` ä¸ `words.items`ï¼Œç”Ÿæˆç»¼åˆé˜Ÿåˆ—ï¼›  
3. æ¯é“é¢˜ç»“æŸåå°†ç»“æœè®°å…¥æœ¬åœ° `perLetterStats` / `perWordStats`ï¼›  
4. åœ¨ä¼šè¯ç»“æŸæ—¶ï¼Œå°†ä¸¤ç±»å®ä½“åˆ†åˆ«æ‰“åŒ…ä¸ºï¼š

```ts
submitMemoryResult({
  userId,
  results: [
    { entityType: 'letter', entityId, quality },
    { entityType: 'word',   entityId, quality },
    ...
  ]
});
```

åç«¯æ— éœ€å…³å¿ƒé¢˜ç›®æ˜¯åœ¨å“ªä¸ªé¡µé¢å®Œæˆçš„ï¼Œåªè¦ `entityType` ä¸ `entityId` ä¸€è‡´å³å¯ã€‚

---

## 7. ä¸å‰ç«¯ Spec çš„ä¸€è‡´æ€§è¯´æ˜

### 7.1 å­—æ¯æ¨¡å—

- å‰ç«¯ Specï¼ˆ`alphabet-module-spec.md` ç¬¬ 11 ç« ï¼‰ä¸­å®šä¹‰çš„ï¼š
  - â€œæŒ‰å­—æ¯ Ã— è½®æ¬¡èšåˆè´¨é‡ï¼ˆFORGET/FUZZY/KNOWï¼‰â€ï¼›  
  - â€œåœ¨ Round ç»“æŸæ—¶ç»Ÿä¸€è°ƒç”¨ `submitMemoryResult`ï¼ˆæ‰¹é‡ï¼‰â€ï¼›  
  - â€œå­—æ¯è¯¾ç¨‹å†…çš„é˜Ÿåˆ—ç”±å‰ç«¯è´Ÿè´£ï¼Œ`getTodayMemories` åªä½œä¸ºè¯¾ç¨‹åˆå§‹åŒ–è¾…åŠ©â€ï¼›  
 è¿™äº›è¡Œä¸ºä¸åç«¯ç°æœ‰æ¥å£å®Œå…¨å…¼å®¹ï¼Œå¹¶å»ºè®®ä½¿ç”¨ **æ‰¹é‡ results[] æäº¤**ã€‚

### 7.2 è¯æ±‡æ¨¡å—

- è¯æ±‡æ¨¡å—å¯ä»¥é€‰æ‹©ä¸¤æ¡è·¯ï¼š
  1. ç»§ç»­ä½¿ç”¨ `learn-vocab.getTodayWords + updateMastery`ï¼ˆå®Œå…¨ç‹¬ç«‹äº memory-engineï¼‰ï¼›  
  2. é€æ­¥è¿ç§»åˆ° `memory-engine.getTodayMemories(entityType:'word') + submitMemoryResult`ã€‚  

- é¡¹ç›®å†»ç»“ä¸­ï¼Œ`vocabulary-module-spec.md` é‡‡ç”¨çš„è®¾è®¡æ˜¯ï¼š
  - ä½¿ç”¨ `learn-vocab.getTodayWords` è·å–å½“æ—¥å•è¯åˆ—è¡¨ï¼ˆå› ä¸ºå·²æœ‰å®Œå–„å­—æ®µä¸ UI éœ€æ±‚ï¼‰ï¼›  
  - ä½†åœ¨å‰ç«¯å†…éƒ¨ä¹Ÿå¯ä»¥ä½¿ç”¨ memory-engine çš„ `submitMemoryResult` è¿›è¡Œç»Ÿä¸€ SMâ€‘2 è°ƒåº¦â€”â€”åªè¦å°† `mastery` æ˜ å°„ä¸º `'é™Œç”Ÿ'/'æ¨¡ç³Š'/'è®°å¾—'` å³å¯ã€‚

> å…³é”®è¦æ±‚ï¼š  
> - ä¸è®ºé‡‡ç”¨å“ªæ¡è·¯ï¼Œ**åŒä¸€ä¸ªå•è¯çš„é•¿æœŸå¤ä¹ çŠ¶æ€åªèƒ½ç”±ä¸€å¥—è¡¨å†³å®š**ï¼ˆ`user_vocabulary_progress` æˆ– `memory_status`ï¼‰ï¼Œé¿å…åŒæºç«äº‰ï¼›  
> - è‹¥æœªæ¥å®Œå…¨è¿ç§»åˆ° `memory_status`ï¼Œåˆ™ `user_vocabulary_progress` å¯ä»¥é€æ­¥é€€åŒ–ä¸ºç»Ÿè®¡è¡¨ã€‚

---

æœ¬è§„æ ¼æ–‡æ¡£å†»ç»“äº†åç«¯ç»Ÿä¸€è®°å¿†å¼•æ“ä¸æ¨¡å—è§£é”çš„**çœŸå®è¡Œä¸º**ï¼Œå¹¶æ˜ç¡®äº†ä¸å‰ç«¯ Alphabet / Vocabulary æ¨¡å—çš„å¥‘çº¦ä¸æ‰©å±•æ–¹å¼ã€‚  
åç»­å¦‚éœ€ä¿®æ”¹ memory-engine / learn-vocab çš„é€»è¾‘ï¼Œå¿…é¡»åŒæ­¥æ›´æ–°æœ¬æ–‡ä»¶åŠç›¸åº”å‰ç«¯ Specï¼Œä¿æŒâ€œå‰åç«¯å•ä¸€çœŸç›¸â€ã€‚***
````

## File: docs/project-freeze/database_schema.md
````markdown
# æ•°æ®åº“ç»“æ„è¯´æ˜æ–‡æ¡£ï¼ˆV2.1.0ï¼‰

æœ¬æ–‡æ¡£åŸºäº `assets/data/Final_DB_Data` ä¸­ç”± `local_cleaner_v3.py` è„šæœ¬æ¸…æ´—åçš„å®é™…æ•°æ®ç»“æ„æ•´ç†ã€‚  
å¦‚æ— ç‰¹åˆ«è¯´æ˜ï¼Œæ‰€æœ‰æ—¶é—´å­—æ®µå‡ä¸º ISO å­—ç¬¦ä¸²æˆ– CloudBase å†…éƒ¨çš„ `Date` å¯¹è±¡ã€‚

**æ ¸å¿ƒå˜æ›´ï¼ˆç›¸å¯¹ V2.0.1ï¼‰ï¼š**

- ä¸»é”®ç­–ç•¥ï¼š`_id` ä¸ `vocabularyId` é‡‡ç”¨ `{source}_{OriginalID}` ç»„åˆï¼ˆå¦‚ `BaseThai_1_7`ï¼‰ï¼Œå½»åº•è§£å†³ä¸åŒæ•™æé—´ ID å†²çªé—®é¢˜ã€‚  
- éŸ³é¢‘é€»è¾‘ï¼š`audioPath` ä»…å­˜å‚¨æ–‡ä»¶åï¼ˆå¦‚ `7.mp3`ï¼‰ï¼Œå‰ç«¯éœ€ç»“åˆ `source` å­—æ®µæ‹¼æ¥äº‘å­˜å‚¨è·¯å¾„ã€‚  
- å¯Œåª’ä½“ç»“æ„ï¼šä¾‹å¥ã€å¯¹è¯ã€åŒæºè¯ç­‰å­—æ®µå†…éƒ¨å·²æ³¨å…¥å¯¹åº”çš„ `audioPath`ï¼Œå‰ç«¯å¯ç›´æ¥ä½¿ç”¨ã€‚

---

## 1. æ ¸å¿ƒé›†åˆ (Collections)

> ä»¥ä¸‹å­—æ®µä¸ºå½“å‰ä»£ç ä¸­**å®é™…ä½¿ç”¨å’Œå†™å…¥**çš„å­—æ®µï¼Œè‹¥æœªæ¥éœ€è¦æ–°å¢å­—æ®µï¼Œè¯·åŒæ­¥æ›´æ–°æœ¬è¡¨ã€‚

### 1.1 Users (ç”¨æˆ·è¡¨)
**é›†åˆå**: `users`
**ç”¨é€”**: å­˜å‚¨ç”¨æˆ·åŸºæœ¬ä¿¡æ¯ã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | è®°å½•ID | è‡ªåŠ¨ç”Ÿæˆ |
| `userId` | String | ç”¨æˆ·å”¯ä¸€æ ‡è¯† | æ ¸å¿ƒç´¢å¼•å­—æ®µ |
| `nickname` | String | æ˜µç§° | |
| `avatarUrl` | String | å¤´åƒåœ°å€ | |
| `createdAt` | Date | åˆ›å»ºæ—¶é—´ | |

### 1.2 Vocabulary (è¯æ±‡è¡¨)
**é›†åˆå**: `vocabulary`  
**ç”¨é€”**: å­˜å‚¨ã€ŠåŸºç¡€æ³°è¯­ã€‹ç³»åˆ—æ•™æå•è¯ï¼ŒåŒ…å«è¯¦ç»†çš„å¯Œæ–‡æœ¬åŠéŸ³é¢‘ä¿¡æ¯ã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | å…¨å±€å”¯ä¸€ä¸»é”® | æ ¼å¼ï¼š`{source}_{OriginalID}`ï¼Œä¾‹ï¼š`"BaseThai_1_7"` |
| `vocabularyId` | String | ä¸šåŠ¡ ID | ä¸ `_id` ä¿æŒä¸€è‡´ï¼Œç”¨äºå‰ç«¯é€»è¾‘ |
| `source` | String | ä¹¦å/æ¥æº | å¯¹åº”äº‘å­˜å‚¨æ–‡ä»¶å¤¹åï¼Œå¦‚ `"BaseThai_1"`ã€`"BaseThai_2"` |
| `level` | String | éš¾åº¦ç­‰çº§ | ä¾‹å¦‚ `"A1"`, `"A2"`, `"B1"` |
| `lessonNumber` | String | è¯¾ç¨‹ç¼–å· | ä¾‹å¦‚ `"1"`, `"15.3"`ï¼ˆå­—ç¬¦ä¸²ï¼‰ |
| `thaiWord` | String | æ³°è¯­å•è¯ | ä¾‹å¦‚ `"à¸à¸°"` |
| `meaning` | String | ä¸­æ–‡å«ä¹‰ | ä¾‹å¦‚ `"ä¼°è®¡"` |
| `startingLetter` | String | æ³°è¯­é¦–å­—æ¯ | ä¾‹å¦‚ `"à¸"` |
| `pronunciation` | String | å‘éŸ³/éŸ³æ ‡ | ä¾‹å¦‚ `"gÃ "` |
| `partOfSpeech` | String | è¯æ€§ | ä¾‹å¦‚ `"åè¯"` |
| `audioPath` | String | å•è¯ä¸»éŸ³é¢‘æ–‡ä»¶å | ä¾‹å¦‚ `"7.mp3"`ã€‚æ‰€æœ‰è¯æ±‡éŸ³é¢‘ç»Ÿä¸€å­˜æ”¾åœ¨ COS æ ¹ç›®å½• `BaseThai_Audio/` ä¸‹ï¼Œä»¥ä¹¦å `source` ä½œä¸ºå­ç›®å½•å‰ç¼€ï¼š`BaseThai_Audio/{source}_Audio/{audioPath}`ï¼Œå…¶ä¸­ `source` å¦‚ `"BaseThai_1"`ã€`"BaseThai_2"` ç­‰ã€‚ |
| `exampleSentences` | Object | ä¾‹å¥é›†åˆ | Map ç»“æ„ï¼Œè¯¦è§ä¸‹æ–‡ |
| `dialogue` | Object | å¯¹è¯åœºæ™¯ | åŒ…å«åœºæ™¯æè¿°åŠå¯¹è¯å†…å®¹ï¼Œè¯¦è§ä¸‹æ–‡ |
| `cognates` | Array\<Object\> | åŒæºè¯/ç›¸å…³è¯ | ç»“æ„è§ä¸‹æ–‡ |
| `mistakes` | Object | å¸¸è§é”™è¯¯/æ˜“é”™ç‚¹ | åŒ…å«å‘éŸ³æ˜“é”™ç‚¹ã€ç›¸ä¼¼è¯åŒºåˆ«ã€ä½¿ç”¨åœºåˆç­‰ |
| `usage` | Object | ç”¨æ³•è¯´æ˜ | åŒ…å«è¯­æ³•ç¤ºä¾‹ã€ä¸ä¸­æ–‡å·®å¼‚ç­‰ |
| `analysis` | Object | åŸå§‹åˆ†ææ•°æ® | ä¿ç•™åŸå§‹æ¸…æ´—è„šæœ¬è¾“å‡ºï¼Œç”¨äº debug/å¤‡ä»½ |
| `createdAt` | Date\|String | åˆ›å»ºæ—¶é—´ | |

#### 1.2.1 `exampleSentences` å­—æ®µç»“æ„

- ç±»å‹ï¼š`Record<string, { æ³°è¯­: string; ä¸­æ–‡: string; å‘éŸ³: string; audioPath: string }>`  
- Keyï¼šåœºæ™¯åï¼ˆä¾‹å¦‚ `"å®ç”¨åœºæ™¯1"`ã€`"å®ç”¨åœºæ™¯2"`ï¼‰ã€‚  
- Value ç¤ºä¾‹ï¼š

```json
{
  "å®ç”¨åœºæ™¯1": {
    "æ³°è¯­": "à¸‰à¸±à¸™à¸à¸´à¸™à¸™à¹‰à¸³à¸¡à¸°à¸¥à¸°à¸à¸­à¸—à¸¸à¸à¸§à¸±à¸™",
    "ä¸­æ–‡": "æˆ‘æ¯å¤©å–æœ¨ç“œæ±",
    "å‘éŸ³": "chÇn gin nÃ¡am mÃ¡-lÃ -kÉ”ÌŒÉ” tÃ»u-kÃºu-wan",
    "audioPath": "207_sen_å®ç”¨åœºæ™¯1.mp3"
  }
}
```

> å‰ç«¯æ’­æ”¾ä¾‹å¥éŸ³é¢‘æ—¶åº”ç›´æ¥ä½¿ç”¨ `exampleSentences[key].audioPath`ï¼Œå¹¶æŒ‰ `BaseThai_Audio/{source}_Audio/{audioPath}` æ‹¼æ¥å®Œæ•´è·¯å¾„ã€‚å…¶ä¸­ï¼š
> - `source` ä¸ `vocabulary.source` ä¸€è‡´ï¼ˆå¦‚ `"BaseThai_1"`ï¼‰ï¼›  
> - `audioPath` ä¸ºè¯¥ä¾‹å¥åœ¨å¯¹åº” `{source}_Audio` ç›®å½•ä¸­çš„æ–‡ä»¶åæˆ–ç›¸å¯¹è·¯å¾„ã€‚

#### 1.2.2 `dialogue` å­—æ®µç»“æ„

- ç±»å‹ï¼š

```ts
{
  "åœºæ™¯æè¿°": string;
  "å¯¹è¯å†…å®¹": {
    [role: string]: {
      æ³°è¯­: string;
      ä¸­æ–‡?: string;
      audioPath: string;
    };
  };
}
```

- ç¤ºä¾‹ï¼š

```json
{
  "åœºæ™¯æè¿°": "åœ¨æ°´æœæ‘Šå‰é¡¾å®¢ä¸æ‘Šä¸»è®¨è®ºè´­ä¹°æœ¨ç“œ",
  "å¯¹è¯å†…å®¹": {
    "A": {
      "æ³°è¯­": "à¸à¸µà¹ˆà¸„à¸£à¸±à¸š à¸¡à¸°à¸¥à¸°à¸à¸­à¸­à¸±à¸™à¸™à¸µà¹‰à¸ªà¸¸à¸à¸¢à¸±à¸‡à¸„à¸£à¸±à¸š?",
      "ä¸­æ–‡": "å¤§å“¥ï¼Œè¿™ä¸ªæœ¨ç“œç†Ÿäº†å—ï¼Ÿ",
      "audioPath": "207_dia_A.mp3"
    },
    "B": {
      "æ³°è¯­": "à¸¢à¸±à¸‡à¸„à¸£à¸±à¸š à¹à¸•à¹ˆà¸–à¹‰à¸²à¸­à¸¢à¸²à¸à¸à¸´à¸™à¹€à¸›à¸£à¸µà¹‰à¸¢à¸§à¹† à¹ƒà¸Šà¹‰à¹„à¸”à¹‰à¹€à¸¥à¸¢",
      "ä¸­æ–‡": "è¿˜æ²¡ç†Ÿé€ï¼Œä½†å¦‚æœä½ æƒ³åƒé…¸ä¸€ç‚¹çš„ï¼Œè¿™ä¸ªæ­£åˆé€‚",
      "audioPath": "207_dia_B.mp3"
    }
  }
}
```

#### 1.2.3 `cognates` å­—æ®µç»“æ„

- ç±»å‹ï¼š`Array<{ text: string; audioPath: string }>`  
- ç¤ºä¾‹ï¼š

```json
[
  {
    "text": "à¸™à¹‰à¸³à¸¡à¸°à¸¥à¸°à¸à¸­ (nÃ¡am mÃ¡-lÃ -kÉ”ÌŒÉ”) - æœ¨ç“œæ±",
    "audioPath": "207_cog_1.mp3"
  },
  {
    "text": "à¸ªà¹‰à¸¡à¸•à¸³à¸¡à¸°à¸¥à¸°à¸à¸­ (sÃ´m dtÃ m mÃ¡-lÃ -kÉ”ÌŒÉ”) - æœ¨ç“œæ²™æ‹‰",
    "audioPath": "207_cog_2.mp3"
  }
]
```

#### 1.2.4 `analysis` å­—æ®µç»“æ„ï¼ˆä¿ç•™ç”¨ï¼‰

- è¯¥å­—æ®µå®Œæ•´ä¿ç•™ local_cleaner è„šæœ¬ç”Ÿæˆçš„åŸå§‹åˆ†æï¼š

```ts
interface Analysis {
  pronunciation: string;
  part_of_speech: string;
  letter_pron_analysis?: string;
  phonetic_association?: {
    æ‹†åˆ†?: string;
    è®°å¿†å¥?: string;
  };
  cognates?: string[];
  example_sentences?: Record<string, { æ³°è¯­: string; ä¸­æ–‡: string; å‘éŸ³: string }>;
  example_dialogue?: {
    åœºæ™¯æè¿°: string;
    å¯¹è¯å†…å®¹: Record<string, { æ³°è¯­: string; ä¸­æ–‡: string }>;
  };
  common_mistakes?: Record<string, string>;
  usage_details?: {
    è¯­æ³•ç¤ºä¾‹?: { ç»“æ„: string; è§£é‡Š: string; ä½¿ç”¨æŠ€å·§?: string };
    ä¸ä¸­æ–‡å·®å¼‚?: string;
  };
  mistakes?: Record<string, string>;
  usage?: {
    è¯­æ³•ç¤ºä¾‹?: { ç»“æ„: string; è§£é‡Š: string; ä½¿ç”¨æŠ€å·§?: string };
    ä¸ä¸­æ–‡å·®å¼‚?: string;
  };
}
```

> å‰ç«¯ä¸šåŠ¡åº”ä¼˜å…ˆä½¿ç”¨é¡¶å±‚çš„ `exampleSentences` / `dialogue` / `mistakes` / `usage` å­—æ®µï¼›`analysis` ä¸»è¦ç”¨äºè°ƒè¯•ä¸ä»¥åç”Ÿæˆ AI å†…å®¹ã€‚

### 1.3 User Vocabulary Progress (ç”¨æˆ·å•è¯è¿›åº¦è¡¨)

**é›†åˆå**: `user_vocabulary_progress`  
**ç”¨é€”**: è®°å½•ç”¨æˆ·å¯¹æ¯ä¸ªå•è¯çš„å­¦ä¹ çŠ¶æ€ï¼ˆæ—§ç‰ˆè¯æ±‡ SRS å¼•æ“ï¼‰ã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | è®°å½•ID | è‡ªåŠ¨ç”Ÿæˆ |
| `userId` | String | ç”¨æˆ·ID | ç´¢å¼• |
| `vocabularyId` | String | å•è¯ID | å…³è” `vocabulary._id`ï¼Œä¾‹å¦‚ `BaseThai_1_7` |
| `mastery` | String\|null | æŒæ¡ç¨‹åº¦ | `'UNFAMILIAR'`, `'FUZZY'`, `'REMEMBERED'` æˆ– `null` |
| `nextReviewDate` | Date\|null | ä¸‹æ¬¡å¤ä¹ æ—¶é—´ | `getTodayWords` ç”¨äºç­›é€‰ä»Šæ—¥å¤ä¹  |
| `intervalDays` | Number | é—´éš”å¤©æ•° | |
| `easinessFactor` | Number | æ˜“è®°ç³»æ•° | é»˜è®¤ 2.5 |
| `reviewCount` | Number | å¤ä¹ æ¬¡æ•° | |
| `createdAt` | Date | åˆ›å»ºæ—¶é—´ | |
| `updatedAt` | Date | æ›´æ–°æ—¶é—´ | |

### 1.4 Letters (å­—æ¯è¡¨)
**é›†åˆå**: `letters`  
**ç”¨é€”**: å­˜å‚¨æ³°è¯­å­—æ¯ã€å…ƒéŸ³ã€å£°è°ƒç¬¦å·åŠå…¶éŸ³é¢‘ä¸è¯¾ç¨‹ä¿¡æ¯ã€‚

> è¯¦ç»†å­—æ®µå®šä¹‰è¯·å‚è€ƒ `src/entities/types/letter.types.ts` ä¸ `assets/courses/letters_final.enriched.json`ã€‚  
> æ­¤å¤„ä¿æŒç®€è¦è¯´æ˜ï¼ˆä¸»è¦ç”¨äºç†è§£ä¸å…¶ä»–é›†åˆçš„å…³ç³»ï¼‰ã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | å­—æ¯ID | å¦‚ `TH_C_01` |
| `type` | String | ç±»å‹ | `'consonant' \| 'vowel' \| 'tone'` |
| `thaiChar` | String | æ³°æ–‡å­—æ¯/å…ƒéŸ³/å£°è°ƒå­—ç¬¦ | å¦‚ `"à¸"` |
| `nameThai` | String | æ³°æ–‡åç§° | å¦‚ `"à¹„à¸à¹ˆ"` |
| `nameEnglish` | String | è‹±æ–‡åç§° | å¦‚ `"ko kai"` |
| `initialSound` | String | é¦–è¾…éŸ³è¯»éŸ³ | å¦‚ `"k"`ï¼ˆå¯ä¸ºç©ºï¼Œå¯¹å…ƒéŸ³/å£°è°ƒï¼‰ |
| `finalSound` | String | æ”¶å°¾è¾…éŸ³è¯»éŸ³ | å¦‚ `"k"` |
| `class` | String\|null | è¾…éŸ³ç±» | `'mid'`, `'high'`, `'low'`ï¼Œå…ƒéŸ³/å£°è°ƒä¸º `null` |
| `audioPath` | String | æ—§ç‰ˆéŸ³é¢‘è·¯å¾„ | æ–°ç‰ˆä¼˜å…ˆä½¿ç”¨ `*SoundUrl` |
| `exampleWord` | String | ç¤ºä¾‹å•è¯ | å¦‚ `"à¹„à¸à¹ˆ"` |
| `exampleMeaning` | String | ç¤ºä¾‹å«ä¹‰ | å¦‚ `"é¸¡"` |
| `strokeCount` | Number | ç¬”ç”»æ•° | é¢„ç•™ |
| `learningLevel` | String | å­¦ä¹ çº§åˆ« | `'BEGINNER' \| 'INTERMEDIATE' \| 'ADVANCED'` |
| `lessonNumber` | Number | æ—§è¯¾ç¨‹ç¼–å· | ä¸æ–°ç‰ˆ `lessonId` å¹¶å­˜ |
| `category` | String | åˆ†ç±» | å¦‚ `'mid_consonant'`, `'vowel'`, `'tone'` |
| `subCategory` | String | å­ç±»åˆ« | å¦‚ `'lesson1_mid'` |
| `keyboardKey` | String\|undefined | é”®ç›˜å¯¹åº”æŒ‰é”® | ç”¨äºè¾“å…¥ç»ƒä¹  |
| `fullSound` | String\|undefined | å®Œæ•´å‘éŸ³ key | å¦‚ `"consonant-ko-kai"` |
| `fullSoundUrl` | String\|undefined | å®Œæ•´å‘éŸ³éŸ³é¢‘ key | æ˜ å°„åˆ° COS `/alphabet/{key}.mp3` |
| `syllableSoundName` | String\|undefined | éŸ³èŠ‚æ ¸å¿ƒå‘éŸ³åç§° | å¦‚ `"k"` |
| `syllableSound` | String\|undefined | éŸ³èŠ‚å‘éŸ³ key | å¦‚ `"sound-k"` |
| `syllableSoundUrl` | String\|undefined | éŸ³èŠ‚éŸ³é¢‘ key | |
| `endSyllableSoundName` | String\|undefined | å°¾éŸ³èŠ‚åç§° | |
| `endSyllableSound` | String\|undefined | å°¾éŸ³èŠ‚å‘éŸ³ key | |
| `endSyllableSoundUrl` | String\|undefined | å°¾éŸ³èŠ‚éŸ³é¢‘ key | |
| `letterNamePronunciation` | String\|undefined | å­—æ¯åç§°å‘éŸ³æ–‡æœ¬ | å¦‚ `"kayá¿¯"` |
| `letterPronunciationUrl` | String\|undefined | å­—æ¯åç§°å‘éŸ³éŸ³é¢‘ key | å¦‚ `"word-kay"` |
| `letterImageUrl` | String\|undefined | å­—æ¯æ’å›¾ URL | é¢„ç•™ |
| `description` | String\|undefined | è¯´æ˜ | |
| `curriculumLessonIds` | String[]\|undefined | æ‰€å±è¯¾ç¨‹ ID åˆ—è¡¨ | å¦‚ `["lesson1"]` |
| `curriculumLessonOrders` | Number[]\|undefined | å„è¯¾ç¨‹ä¸­çš„æ’åº | |
| `primaryCurriculumLessonId` | String\|undefined | ä¸»è¯¾ç¨‹ ID | å¦‚ `"lesson1"` |
| `primaryCurriculumLessonOrder` | Number\|undefined | ä¸»è¯¾ç¨‹ä¸­çš„æ’åº | |
| `createdAt` | String | åˆ›å»ºæ—¶é—´ | |


### 1.5 Sentences (å¥å­è¡¨)
**é›†åˆå**: `sentences` (æ¨æµ‹)
**ç”¨é€”**: å­˜å‚¨ä¾‹å¥æ•°æ®ã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | å¥å­ID | |
| `thai` | String | æ³°è¯­å¥å­ | |
| `chinese` | String | ä¸­æ–‡ç¿»è¯‘ | |

### 1.6 Letter Test Bank (å­—æ¯é¢˜åº“)
**é›†åˆå**: `letter_test_bank`
**ç”¨é€”**: å­˜å‚¨å­—æ¯æµ‹è¯•é¢˜ç›®ã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | é¢˜ç›®ID | |
| `question` | String | é¢˜ç›®å†…å®¹ | |
| `options` | Array | é€‰é¡¹åˆ—è¡¨ | |
| `answer` | String | æ­£ç¡®ç­”æ¡ˆ | |

### 1.7 memory_status (ç»Ÿä¸€è®°å¿†çŠ¶æ€è¡¨)
**é›†åˆå**: `memory_status`  
**ç”¨é€”**: ç»Ÿä¸€ SRS å¼•æ“æ ¸å¿ƒè¡¨ï¼Œè®°å½•ç”¨æˆ·å¯¹ä»»æ„å®ä½“ï¼ˆå­—æ¯/å•è¯/å¥å­ç­‰ï¼‰çš„è®°å¿†çŠ¶æ€ã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | è®°å½•ID | è‡ªåŠ¨ç”Ÿæˆ |
| `userId` | String | ç”¨æˆ·ID | ç´¢å¼• |
| `entityType` | String | å®ä½“ç±»å‹ | `'letter'`ã€`'word'` ç­‰ |
| `entityId` | String | å®ä½“ID | å…³è” `letters._id` / `vocabulary._id` ç­‰ï¼Œä¾‹å¦‚ `BaseThai_1_7` |
| `masteryLevel` | Number | æŒæ¡åº¦ | 0.0â€“1.0 |
| `reviewStage` | Number | å¤ä¹ é˜¶æ®µ | ç­‰ä»·äº SMâ€‘2 repetitions |
| `easinessFactor` | Number | æ˜“è®°ç³»æ•° | åˆå§‹ 2.5 |
| `intervalDays` | Number | é—´éš”å¤©æ•° | ä¸‹ä¸€æ¬¡å¤ä¹ é—´éš”ï¼ˆå¤©ï¼‰ |
| `lastReviewAt` | String\|null | ä¸Šæ¬¡å¤ä¹ æ—¶é—´ | ISO å­—ç¬¦ä¸² |
| `nextReviewAt` | String\|null | ä¸‹æ¬¡å¤ä¹ æ—¶é—´ | ç”¨äºç­›é€‰ä»Šæ—¥å¤ä¹ é˜Ÿåˆ— |
| `correctCount` | Number | ç´¯è®¡ç­”å¯¹æ¬¡æ•° | |
| `wrongCount` | Number | ç´¯è®¡ç­”é”™æ¬¡æ•° | |
| `streakCorrect` | Number | è¿ç»­ç­”å¯¹æ¬¡æ•° | |
| `isLocked` | Boolean | æ˜¯å¦é”å®š | é”å®šæ—¶ä¸å®‰æ’å¤ä¹  |
| `createdAt` | String | åˆ›å»ºæ—¶é—´ | |
| `updatedAt` | String | æœ€è¿‘æ›´æ–°æ—¶é—´ | |

### 1.8 user_progress (ç”¨æˆ·æ€»è¿›åº¦è¡¨)
**é›†åˆå**: `user_progress`  
**ç”¨é€”**: è®°å½•ç”¨æˆ·åœ¨å„æ¨¡å—ï¼ˆå­—æ¯/å•è¯/å¥å­/æ–‡ç« ï¼‰çš„æ•´ä½“å®Œæˆåº¦ä¸è§£é”çŠ¶æ€ã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | è®°å½•ID | |
| `userId` | String | ç”¨æˆ·ID | å”¯ä¸€ç´¢å¼• |
| `letterCompleted` | Boolean | æ˜¯å¦å®Œæˆå­—æ¯æ¨¡å— | è§£é”åç»­æ¨¡å—çš„ç¡¬æ¡ä»¶ |
| `letterProgress` | Number | å­—æ¯æ¨¡å—æ•´ä½“è¿›åº¦ | 0.0â€“1.0 |
| `wordUnlocked` | Boolean | å•è¯æ¨¡å—æ˜¯å¦è§£é” | |
| `wordProgress` | Number | å•è¯æ¨¡å—æ•´ä½“è¿›åº¦ | 0.0â€“1.0 |
| `sentenceUnlocked` | Boolean | å¥å­æ¨¡å—æ˜¯å¦è§£é” | |
| `sentenceProgress` | Number | å¥å­æ¨¡å—æ•´ä½“è¿›åº¦ | |
| `articleUnlocked` | Boolean | æ–‡ç« æ¨¡å—æ˜¯å¦è§£é” | |
| `articleProgress` | Number\|undefined | æ–‡ç« æ¨¡å—æ•´ä½“è¿›åº¦ | æ—§è®°å½•å¯èƒ½æ— æ­¤å­—æ®µ |
| `currentStage` | String | å½“å‰å­¦ä¹ é˜¶æ®µ | `'letter' \| 'word' \| 'sentence' \| 'article'` |
| `totalStudyDays` | Number | æ€»å­¦ä¹ å¤©æ•° | |
| `streakDays` | Number | è¿ç»­å­¦ä¹ å¤©æ•° | |
| `lastStudyDate` | String\|null | æœ€è¿‘å­¦ä¹ æ—¥æœŸ | |
| `createdAt` | Date | åˆ›å»ºæ—¶é—´ | |
| `updatedAt` | Date | æœ€è¿‘æ›´æ–°æ—¶é—´ | |

### 1.9 user_alphabet_progress (ç”¨æˆ·å­—æ¯æ¨¡å—è¿›åº¦è¡¨)
**é›†åˆå**: `user_alphabet_progress`  
**ç”¨é€”**: è®°å½•ç”¨æˆ·åœ¨ **å­—æ¯è¯¾ç¨‹æ¨¡å—** çš„æ•´ä½“è¿›åº¦ä¸ä¸‰è½®è¯„ä¼°ç»“æœã€‚

| å­—æ®µå | ç±»å‹ | æè¿° | å¤‡æ³¨ |
| :--- | :--- | :--- | :--- |
| `_id` | String | è®°å½•ID | |
| `userId` | String | ç”¨æˆ·ID | å”¯ä¸€ç´¢å¼• |
| `letterProgress` | Number | å­—æ¯è¯¾ç¨‹æ•´ä½“è¿›åº¦ | 0.0â€“1.0ï¼Œè¯¾ç¨‹/è½®æ¬¡å®Œæˆåæ›´æ–° |
| `letterCompleted` | Boolean | æ˜¯å¦å®Œæˆå…¨éƒ¨å­—æ¯è¯¾ç¨‹ | å®Œæˆåå¯è§£é”å…¨éƒ¨æ¨¡å— |
| `completedLessons` | String[] | å·²å®Œæˆè¯¾ç¨‹IDåˆ—è¡¨ | å¦‚ `["lesson1","lesson2"]` |
| `masteredLetterCount` | Number | å·²æŒæ¡å­—æ¯æ•°é‡ | |
| `totalLetterCount` | Number | å­—æ¯æ€»æ•° | å½“å‰çº¦ 80 |
| `currentRound` | Number | æœ€è¿‘ä¸€è½®è¯„ä¼°è½®æ¬¡ | 1ã€2 æˆ– 3 |
| `roundHistory` | Array\<Object\> | å„è½®è¯„ä¼°è®°å½• | è§ä¸‹è¡¨ |
| `createdAt` | String | åˆ›å»ºæ—¶é—´ | |
| `updatedAt` | String | æœ€è¿‘æ›´æ–°æ—¶é—´ | |

`roundHistory` å­ç»“æ„ï¼š

| å­—æ®µå | ç±»å‹ | æè¿° |
| :--- | :--- | :--- |
| `lessonId` | String | å¯¹åº”è¯¾ç¨‹ IDï¼Œå¦‚ `lesson1` |
| `roundNumber` | Number | è½®æ¬¡ï¼ˆ1/2/3ï¼‰ |
| `totalQuestions` | Number | æœ¬è½®æ€»é¢˜æ•° |
| `correctCount` | Number | ç­”å¯¹é¢˜æ•° |
| `accuracy` | Number | æ­£ç¡®ç‡ï¼ˆ0.0â€“1.0ï¼‰ |
| `passed` | Boolean | æ˜¯å¦é€šè¿‡ï¼ˆâ‰¥ 0.9ï¼‰ |
| `updatedAt` | String | æäº¤æ—¶é—´ |

---

## 2. å…³è”å…³ç³»

- **ç”¨æˆ· -> å•è¯è¿›åº¦**  
  `users.userId` â†’ `user_vocabulary_progress.userId`
- **å•è¯è¿›åº¦ -> å•è¯**  
  `user_vocabulary_progress.vocabularyId` â†’ `vocabulary._id`
- **ç”¨æˆ· -> ç»Ÿä¸€è®°å¿†çŠ¶æ€**  
  `users.userId` â†’ `memory_status.userId`
- **è®°å¿†çŠ¶æ€ -> å®ä½“**  
  `memory_status.entityId` â†’ `letters._id` / `vocabulary._id` / å…¶ä»–å®ä½“é›†åˆ `_id`
- **ç”¨æˆ· -> æ€»è¿›åº¦**  
  `users.userId` â†’ `user_progress.userId`
- **ç”¨æˆ· -> å­—æ¯æ¨¡å—è¿›åº¦**  
  `users.userId` â†’ `user_alphabet_progress.userId`

---

## 3. ç´¢å¼•é…ç½® (Index Configuration)

> ä»¥ä¸‹ç´¢å¼•éœ€è¦åœ¨ CloudBase æ§åˆ¶å°ä¸­ä¸º `vocabulary` é›†åˆæ‰‹åŠ¨åˆ›å»ºï¼Œåç§°ä»…ä½œå‚è€ƒã€‚

| ç´¢å¼•åç§° | å­—æ®µå®šä¹‰ | å”¯ä¸€æ€§ | ç”¨é€” |
| :--- | :--- | :--- | :--- |
| `unique_id` | `{ "vocabularyId": 1 }` | âœ… | ç¡®ä¿å•è¯ ID å”¯ä¸€ï¼Œé˜²æ­¢é‡å¤å¯¼å…¥ |
| `book_lesson` | `{ "source": 1, "lessonNumber": 1, "_id": 1 }` | âŒ | æ ¸å¿ƒæŸ¥è¯¢ï¼šæŒ‰æ•™æå’Œè¯¾æ¬¡åŠ è½½å•è¯åˆ—è¡¨ |
| `search_thai` | `{ "thaiWord": 1 }` | âŒ | æŒ‰æ³°è¯­å•è¯æœç´¢ |
| `search_meaning` | `{ "meaning": 1 }` | âŒ | æŒ‰ä¸­æ–‡å«ä¹‰æœç´¢ |
| `level_filter` | `{ "level": 1 }` | âŒ | æŒ‰éš¾åº¦ç­‰çº§è·¨ä¹¦ç­›é€‰ |

---

## 4. å‰ç«¯èµ„æºè·¯å¾„æ‹¼æ¥æŒ‡å—

> éŸ³é¢‘æ–‡ä»¶æŒ‰æ•™æå­˜æ”¾åœ¨äº‘å­˜å‚¨ `/audio/{source}/` ç›®å½•ä¸‹ï¼Œæ•°æ®åº“ä»…è®°å½•æ–‡ä»¶åéƒ¨åˆ†ã€‚

æ‹¼æ¥å…¬å¼ç¤ºä¾‹ï¼š

```ts
const CLOUD_ROOT = 'cloud://<env-id>.tcloudbaseapp.com'; // äº‘ç¯å¢ƒæ ¹è·¯å¾„
const fullPath = `${CLOUD_ROOT}/audio/${word.source}/${word.audioPath}`;
```

- `word.source`ï¼šå¦‚ `"BaseThai_1"`ï¼›  
- `word.audioPath`ï¼šå¦‚ `"207.mp3"`ã€`"207_sen_å®ç”¨åœºæ™¯1.mp3"` ç­‰ï¼›  
- ä¾‹å¥ã€å¯¹è¯ã€åŒæºè¯ä¸­çš„ `audioPath` åŒæ ·éµå¾ª `{source}/{audioPath}` è§„åˆ™ã€‚

> æ³¨æ„ï¼šè¯·ç¡®ä¿äº‘å­˜å‚¨ä¸­çš„æ–‡ä»¶å¤¹åç§°ä¸ `source` å­—æ®µå®Œå…¨ä¸€è‡´ï¼ˆå¤§å°å†™æ•æ„Ÿï¼‰ï¼Œå¦åˆ™ä¼šå¯¼è‡´éŸ³é¢‘æ— æ³•æ­£ç¡®åŠ è½½ã€‚

---

## 3. è¡¥å……è¯´æ˜

- å®é™…ç´¢å¼•é…ç½®å¯åœ¨ CloudBase æ§åˆ¶å°ä¸­æŸ¥çœ‹å’Œç®¡ç†ï¼›  
- è‹¥æ–°å¢å­—æ®µæˆ–é›†åˆï¼Œè¯·åŒæ­¥æ›´æ–°æœ¬æ–‡ä»¶ï¼Œä»¥é¿å…å‰åç«¯è®¤çŸ¥ä¸ä¸€è‡´ã€‚
````

## File: docs/project-freeze/vocabulary-module-spec.md
````markdown
# è¯æ±‡æ¨¡å—æœ€ç»ˆè§„æ ¼è¯´æ˜ï¼ˆVocabulary Module Spec, Freeze Draftï¼‰

> ç›®å½•ï¼š`docs/project-freeze/vocabulary-module-spec.md`  
> é€‚ç”¨èŒƒå›´ï¼š**è¯æ±‡å­¦ä¹ å‰ç«¯ + `vocabulary` äº‘å‡½æ•° + ç»Ÿä¸€è®°å¿†é€»è¾‘ï¼ˆSMâ€‘2ï¼‰**  
> ç›®æ ‡ï¼šå†»ç»“è¯æ±‡æ¨¡å—çš„èŒè´£è¾¹ç•Œã€æµç¨‹ã€é¢˜å‹ä¸è®°å¿†ç­–ç•¥ï¼Œè®©åç»­å¼€å‘åªéœ€æŒ‰æœ¬æ–‡æ¡£å®ç°å³å¯ã€‚

---

## 1. æ¨¡å—å®šä½ä¸è¾¹ç•Œ

### 1.1 æ¨¡å—èŒè´£

è¯æ±‡æ¨¡å—è´Ÿè´£ï¼š

- æä¾›åŸºäºè¯¾ç¨‹çš„**æ³°è¯­å•è¯ç²¾è®² + å¤ä¹ å­¦ä¹ ä½“éªŒ**ï¼›  
- ä½¿ç”¨ `vocabulary` äº‘å‡½æ•°ä¸­çš„ SMâ€‘2 è®°å¿†å¼•æ“ç®¡ç†**é•¿æœŸå¤ä¹ è®¡åˆ’**ï¼›  
- åœ¨å‰ç«¯å®ç°**å½“æ—¥å­¦ä¹ è„šæœ¬ + é”™é¢˜ç»Ÿè®¡ + è´¨é‡èšåˆ**ï¼Œé¿å…é«˜é¢‘ç½‘ç»œè¯·æ±‚ï¼›  
- ä¸ Courses æ¨¡å— & LearningStore ååŒï¼Œè®°å½•ç”¨æˆ·å½“å‰å•è¯è¯¾ç¨‹ã€å­¦ä¹ æ—¶é•¿ä¸æ‰“å¡ä¿¡æ¯ã€‚

### 1.2 ä¸å…¶ä»–æ¨¡å—çš„å…³ç³»

- ä¸ **Courses æ¨¡å—**ï¼š
  - Courses é¡µè´Ÿè´£å±•ç¤ºâ€œåŸºç¡€æ³°è¯­ 1/2/3 â€¦â€ç­‰å•è¯è¯¾ç¨‹ï¼›
  - ç‚¹å‡»æŸä¸ªå•è¯è¯¾ç¨‹å¡ç‰‡åï¼Œå¯¼èˆªåˆ° `app/learning/index.tsx?module=word&source=COURSE_ID`ï¼›
  - Courses ä¸å…³å¿ƒå…·ä½“é¢˜å‹å’Œè®°å¿†é€»è¾‘ã€‚

- ä¸ **LearningStoreï¼ˆå…¨å±€å­¦ä¹ çŠ¶æ€ï¼‰**ï¼š
  - è®°å½• `currentCourseId`ã€`streakDays`ã€`totalStudyMinutes` ç­‰å…¨å±€ä¿¡æ¯ï¼›
  - è¯æ±‡æ¨¡å—åœ¨ä¼šè¯å¼€å§‹/ç»“æŸæ—¶è°ƒç”¨ `learningStore.registerStudySession` è®°å½•ä¸€æ¡å­¦ä¹ ä¼šè¯ã€‚

- ä¸ **Alphabet æ¨¡å— / memory-engine**ï¼š
  - Alphabet æ¨¡å—è´Ÿè´£â€œå­—æ¯è¯¾ç¨‹çº§è®­ç»ƒâ€ï¼Œå†…ç½®ä¸‰è½®æœºåˆ¶ï¼›  
  - è¯æ±‡æ¨¡å—è´Ÿè´£â€œé•¿æœŸè¯æ±‡ SRSâ€ï¼Œä½¿ç”¨ `vocabulary` äº‘å‡½æ•°ç»´æŠ¤ `learningStatus`ï¼›  
  - è¯¾ç¨‹çº§è§£é”ï¼ˆä¾‹å¦‚â€œå¿…é¡»å®Œæˆå­—æ¯è¯¾ç¨‹åæ‰èƒ½å­¦ä¹ è¯æ±‡â€ï¼‰ç”± `moduleAccessStore` æ§åˆ¶ã€‚

---

## 2. ç›¸å…³ä»£ç æ–‡ä»¶ä¸è°ƒç”¨æ ˆ

### 2.1 å‰ç«¯è·¯ç”±ä¸é¡µé¢

- `app/(tabs)/courses.tsx`
  - å±•ç¤ºå…¨éƒ¨è¯¾ç¨‹åˆ—è¡¨ï¼›
  - å¯¹ `category === 'vocabulary'` çš„è¯¾ç¨‹ä½¿ç”¨ `CourseCard` æ¸²æŸ“ï¼›
  - ç‚¹å‡»åï¼š`router.push('/learning?module=word&source=' + course.source)`ï¼›
  - åŒæ—¶è°ƒç”¨ `learningStore.setCurrentCourse(course.source)`ã€‚

- `app/learning/index.tsx`
  - ç»Ÿä¸€å­¦ä¹ å…¥å£ï¼›é€šè¿‡ query å‚æ•° `module` å†³å®šæ˜¯å­—æ¯æ¨¡å—è¿˜æ˜¯è¯æ±‡æ¨¡å—ï¼š
    - `module=word` â†’ è¯æ±‡å­¦ä¹ ä¼šè¯ï¼ˆWordSessionï¼‰ï¼›
    - `module=letter` â†’ å­—æ¯å­¦ä¹ ä¼šè¯ï¼ˆAlphabetSessionï¼‰ã€‚  
  - å½“å‰å®ç°ä»æœ‰å¤§é‡ mock æ•°æ®ï¼Œæœ¬è§„èŒƒå®šä¹‰çš„ä¸º**ç›®æ ‡è¡Œä¸º**ã€‚

### 2.2 ç»„ä»¶å±‚

- `src/components/learning/NewWordView.tsx`
  - å±•ç¤ºå•è¯çš„â€œç²¾è®²å¡ç‰‡â€ï¼ŒåŒ…å«ï¼š
    - æ³°è¯­è¯å½¢ + å‘éŸ³ + è¯æ€§ï¼›
    - åŸºç¡€é‡Šä¹‰ã€è”æƒ³æ‹†åˆ†ã€è®°å¿†æç¤ºï¼›
    - ä¾‹å¥ã€å¯¹è¯ç¤ºä¾‹ã€ç”¨æ³•è¯¦è§£ã€å¸¸è§é”™è¯¯ã€ç›¸ä¼¼è¯å¯¹æ¯”ç­‰ Tabã€‚
  - ç”±è¯æ±‡å­¦ä¹ å¼•æ“åœ¨â€œæ–°è¯è®²è§£é˜¶æ®µâ€ä½¿ç”¨ã€‚

- `src/components/learning/ReviewWordView.tsx`
  - ç°æœ‰ç‰ˆæœ¬ä¸»è¦å±•ç¤ºâ€œå¡ç‰‡ + ä¸‰ä¸ªè´¨é‡æŒ‰é’®ï¼ˆå¿˜è®°/æ¨¡ç³Š/è®°å¾—ï¼‰â€ï¼›  
  - å†»ç»“ç‰ˆç›®æ ‡ï¼š
    - é‡æ„ä¸ºâ€œé¢˜å‹å®¹å™¨â€ï¼Œæ”¯æŒ 4 ç§é€‰æ‹©é¢˜ + 2 ç§æ‹¼å†™é¢˜ï¼ˆè§ 4.1ï¼‰ï¼›  
    - æ¯é“é¢˜åªè´Ÿè´£ï¼š
      - æ¸²æŸ“é¢˜å¹² + é€‰é¡¹/è¾“å…¥æ¡†ï¼›  
      - å°† `isCorrect` / `questionType` å›è°ƒç»™ä¸Šå±‚ã€‚

### 2.3 Store ä¸ Hook

- `src/stores/vocabularyStore.ts`
  - ç›®å‰ï¼šæ··åˆäº†æ—§ç‰ˆ `memory-engine` æ€è·¯ä¸æœ¬åœ°è¿›åº¦é€»è¾‘ã€‚  
  - å†»ç»“ç›®æ ‡ï¼šå°†å…¶é‡æ„ä¸º**è¯æ±‡ä¼šè¯æ€»æ§ Store**ï¼š
    - ç»´æŠ¤ `VocabularySessionState`ï¼ˆè§ 3.3ï¼‰ï¼›  
    - æš´éœ²ï¼š
      - `initializeSession(userId, source)`ï¼šåˆå§‹åŒ– / æ¢å¤ä¼šè¯ï¼›  
      - `answerQuestion(vocabularyId, isCorrect, questionType)`ï¼šè®°å½•ä¸€æ¬¡ç­”é¢˜ï¼›  
      - `revealHint(vocabularyId)`ï¼šç”¨æˆ·æŸ¥çœ‹æç¤º/ç­”æ¡ˆï¼›  
      - `finishSession()`ï¼šç»“æŸä»Šæ—¥å­¦ä¹ å¹¶æäº¤åˆ†æ•°ï¼›  
      - `skipReviewAndLearnNew()`ï¼šè·³è¿‡â€œä»Šæ—¥å¤ä¹ ï¼Œç›´æ¥å­¦æ–°è¯â€ï¼›  
      - `resetCourseProgress(source)`ï¼šæ¸…ç©ºæŸè¯¾ç¨‹çš„æœ¬åœ°/è¿œç«¯è¿›åº¦ã€‚

- `src/stores/learningPreferenceStore.ts`
  - æä¾›ç”¨æˆ·è®¾å®šçš„æ¯æ—¥å•è¯å­¦ä¹ ä¸Šé™ï¼š`dailyLimits.word`ï¼›  
  - è¯æ±‡æ¨¡å—é€šè¿‡å®ƒå†³å®šå½“æ—¥æœ€å¤šå­¦ä¹ /å¤ä¹ å¤šå°‘ä¸ªå•è¯ã€‚

- `src/stores/learningStore.ts`ï¼ˆè§„åˆ’ä¸­ï¼‰
  - è®°å½•å½“å‰è¯¾ç¨‹ã€å­¦ä¹ æ—¶é•¿ã€æ‰“å¡å¤©æ•°ç­‰å…¨å±€ä¿¡æ¯ï¼›  
  - è¯æ±‡ä¼šè¯å¼€å§‹/ç»“æŸæ—¶è°ƒç”¨ï¼š
    - `registerStudySession({ module: 'word', courseSource, durationMinutes })`ã€‚

### 2.4 äº‘å‡½æ•°ä¸åç«¯

- `cloudbase/functions/vocabulary/index.js`
  - å¤š Action äº‘å‡½æ•°ï¼Œè‡³å°‘åŒ…å«ï¼š
    - `getTodayWords`ï¼šè¿”å›ä»Šæ—¥éœ€è¦å­¦ä¹ /å¤ä¹ çš„å•è¯åˆ—è¡¨ï¼›  
    - `updateMastery`ï¼šæ ¹æ®æŒæ¡ç¨‹åº¦æ›´æ–° SMâ€‘2 è®°å¿†çŠ¶æ€ï¼›  
    - `getVocabularyDetail`ï¼šè·å–å•è¯ç²¾è®²å¡ç‰‡å†…å®¹ï¼›  
    - `getReviewStatistics`ï¼šè¿”å›æ•´ä½“è¿›åº¦ç»Ÿè®¡ã€‚  
  - å‚ç…§ `docs/08-Vocabulary-API-Documentation.md`ã€‚

---

## 3. ä¼šè¯å±‚è®¾è®¡ï¼šä»Šæ—¥å­¦ä¹  / å¤ä¹ æµç¨‹

### 3.1 åŸºæœ¬åŸåˆ™

- **ç»Ÿä¸€å…¥å£**ï¼šæ¯æ¬¡è¿›å…¥ `/learning?module=word&source=XXX` éƒ½å¯åŠ¨ä¸€æ¬¡â€œè¯æ±‡å­¦ä¹ ä¼šè¯â€ï¼›  
- **å…ˆå¤ä¹ åæ–°å­¦**ï¼šä¼˜å…ˆå¤„ç† `getTodayWords` è¿”å›çš„å¤ä¹ é¡¹ï¼Œå†åˆ†é…æ–°è¯ï¼›  
- **ä¼šè¯å†…å¤šé¢˜å‹**ï¼šåŒä¸€ä¸ªå•è¯åœ¨ä¸€æ¬¡ä¼šè¯ä¸­å¯ä»¥å‡ºç°å¤šé“é¢˜ï¼Œä½†æœ€ç»ˆåªäº§ç”Ÿä¸€æ¬¡è´¨é‡å€¼ï¼›  
- **å¤±è´¥è¡¥æ•‘**ï¼šæ¯ä¸ªå•è¯è‡³å°‘å‡ºç°ä¸€æ¬¡ç­”å¯¹è®°å½•æ‰ç®—â€œæœ¬æ¬¡ä¼šè¯é€šè¿‡â€ï¼›å¦åˆ™è®°ä¸º `é™Œç”Ÿ`ã€‚

### 3.2 å½“æ—¥ç›®æ ‡ä¸é˜Ÿåˆ—æ„å»º

1. è¯»å–ç”¨æˆ·è®¾å®šï¼š`dailyLimit = learningPreferenceStore.dailyLimits.word`ï¼ˆé»˜è®¤ 20ï¼‰ã€‚  
2. è°ƒç”¨äº‘å‡½æ•°ï¼š

```ts
callCloudFunction<GetTodayWordsResponse>('vocabulary', {
  action: 'getTodayWords',
  data: {
    userId,
    limit: dailyLimit,
    level: courseLevel,        // å¯é€‰ï¼šç”± courseSource å†³å®š
  },
});
```

3. äº‘å‡½æ•°è¿”å›ï¼š

```ts
{
  words: TodayWordItem[];
  summary: {
    reviewCount: number;
    newCount: number;
  };
}
```

4. å‰ç«¯é˜Ÿåˆ—åˆ’åˆ†ï¼š

- `reviewWords` = `words.filter(w => w.learningStatus?.isReview)`ï¼›  
- `newWords`    = `words.filter(w => w.learningStatus?.isNew)`ï¼›  
- å¯ä»¥æ ¹æ® `dailyLimit` åšå†æ¬¡è£å‰ªï¼ˆä¾‹å¦‚â€œè‡³å°‘ä¸€åŠæ˜¯å¤ä¹ è¯â€ï¼‰ã€‚

### 3.3 VocabularySessionStateï¼ˆå»ºè®®ï¼‰

```ts
export type VocabularyQuestionType =
  | 'THAI_TO_CN_4CHOICE'      // çœ‹æ³°è¯­é€‰ä¸­æ–‡
  | 'CN_TO_THAI_4CHOICE'      // çœ‹ä¸­æ–‡é€‰æ³°è¯­
  | 'AUDIO_TO_THAI_4CHOICE'   // å¬éŸ³é€‰æ³°è¯­
  | 'AUDIO_TO_CN_4CHOICE'     // å¬éŸ³é€‰ä¸­æ–‡
  | 'SPELL_THAI_FROM_CN'      // çœ‹ä¸­æ–‡æ‹¼å†™æ³°è¯­
  | 'SPELL_THAI_FROM_AUDIO';  // å¬éŸ³æ‹¼å†™æ³°è¯­

export interface VocabularyQuestionRecord {
  vocabularyId: string;
  questionType: VocabularyQuestionType;
  isCorrect: boolean;
  usedHint: boolean;
}

export interface VocabularyPerWordStats {
  attempts: number;
  wrongCount: number;
  usedHint: boolean;
  questionTypes: VocabularyQuestionType[];
}

export interface VocabularySessionState {
  userId: string;
  courseSource: string;           // ä¾‹å¦‚ 'BASIC_THAI_1'
  dateKey: string;                // 'YYYY-MM-DD'

  reviewQueue: string[];          // vocabularyId[]
  newQueue: string[];             // vocabularyId[]
  currentIndex: number;
  mode: 'REVIEW' | 'LEARN_NEW';

  perWordStats: Record<string, VocabularyPerWordStats>;

   // ç®€å•æœ¬åœ°é”™é¢˜æœ¬ï¼ˆä¾›ä¼šè¯å†…å¤ä¹ ä¸ AI ä½¿ç”¨ï¼‰
   wrongWordIds: string[];        // å½“æ—¥æ›¾ç»ç­”é”™è¿‡çš„å•è¯ IDï¼ˆæŒ‰é¦–æ¬¡å‡ºé”™é¡ºåºå»é‡ï¼‰
   wrongRecords: VocabularyQuestionRecord[]; // è¯¦ç»†é”™é¢˜è®°å½•ï¼Œå¯é€‰ä¼ ç»™ AI

  // æ˜¯å¦å·²æäº¤åˆ°åç«¯
  submitted: boolean;
}
```

æŒä¹…åŒ–ï¼š

- ä½¿ç”¨ `persist` + AsyncStorageï¼Œkey å»ºè®®ä¸ºï¼š`vocabulary-session:${userId}:${courseSource}:${dateKey}`ã€‚  
- è‹¥ç”¨æˆ·ä¸­é€”é€€å‡ºï¼Œå†æ¬¡è¿›å…¥åŒä¸€è¯¾ç¨‹ã€åŒä¸€å¤©æ—¶ï¼Œä¼˜å…ˆæ¢å¤è¯¥ Sessionã€‚

---

## 4. é¢˜å‹ä¸å®‰æ’ç­–ç•¥

### 4.1 å¯å®ç°çš„ 6 ç§é¢˜å‹

1. `THAI_TO_CN_4CHOICE`ï¼š**çœ‹æ³°è¯­é€‰ä¸­æ–‡**ï¼ˆ4 é€‰ 1ï¼‰ã€‚  
2. `CN_TO_THAI_4CHOICE`ï¼š**çœ‹ä¸­æ–‡é€‰æ³°è¯­**ï¼ˆ4 é€‰ 1ï¼‰ã€‚  
3. `AUDIO_TO_THAI_4CHOICE`ï¼š**å¬éŸ³é€‰æ³°è¯­**ï¼ˆ4 é€‰ 1ï¼‰ã€‚  
4. `AUDIO_TO_CN_4CHOICE`ï¼š**å¬éŸ³é€‰ä¸­æ–‡**ï¼ˆ4 é€‰ 1ï¼‰ã€‚  
5. `SPELL_THAI_FROM_CN`ï¼šçœ‹ä¸­æ–‡ï¼Œç”¨æˆ·ä½¿ç”¨ç³»ç»Ÿé”®ç›˜**è¾“å…¥æ³°è¯­æ‹¼å†™**ã€‚  
6. `SPELL_THAI_FROM_AUDIO`ï¼šå¬éŸ³ï¼Œç”¨æˆ·è¾“å…¥æ³°è¯­æ‹¼å†™ã€‚

> è¿‘ä¼¼è¯å¹²æ‰°é¢˜æš‚ä¸åœ¨æœ¬ç‰ˆæœ¬å®ç°ï¼›å¹²æ‰°é¡¹ä¼˜å…ˆä»**åŒè¯¾ç¨‹ã€åŒè¯æ€§**å•è¯ä¸­éšæœºæŠ½å–ã€‚

### 4.2 ä¼šè¯ä¸­çš„é¢˜å‹é¡ºåºï¼ˆMVPï¼‰

ç›®æ ‡ç‰ˆæœ¬ï¼ˆ2 ä¸ªæœˆå†…å¯å®Œæˆï¼‰é‡‡ç”¨**è½»é‡ä¼˜å…ˆ**ç­–ç•¥ï¼š

- å¯¹äº**å¤ä¹ è¯**ï¼š
  - é»˜è®¤å®‰æ’ 1â€“2 é“é¢˜ï¼š
    - ç¬¬ä¸€é“ï¼š`THAI_TO_CN_4CHOICE` æˆ– `CN_TO_THAI_4CHOICE`ï¼›  
    - ç¬¬äºŒé“ï¼ˆå¯é€‰ï¼Œé«˜æŒæ¡åº¦æ—¶ï¼‰ï¼š`AUDIO_TO_THAI_4CHOICE` æˆ– `AUDIO_TO_CN_4CHOICE`ã€‚  
- å¯¹äº**æ–°è¯**ï¼š
  - å…ˆå±•ç¤º `NewWordView` è®²è§£å¡ï¼›  
  - ç´§è·Ÿä¸€é¢˜ï¼š`CN_TO_THAI_4CHOICE`ï¼ˆå·©å›ºå½¢ä¹‰å¯¹åº”ï¼‰ï¼›  
  - å½“è¯¥è¯åœ¨æœªæ¥å¤ä¹ é˜¶æ®µæŒæ¡åº¦è¾ƒé«˜æ—¶ï¼Œæ‰å¼•å…¥æ‹¼å†™é¢˜ã€‚

æ‹¼å†™é¢˜ï¼ˆ5/6ï¼‰æš‚è§„åˆ’ä¸º**åç»­è¿­ä»£**ï¼Œå½“å‰è§„æ ¼åªè¦æ±‚é¢„ç•™ç±»å‹ä¸æ•°æ®ç»“æ„ã€‚

### 4.3 é¢˜å‹ä¸è´¨é‡è¯„åˆ†å…³ç³»

- æ¯é“é¢˜ç»“æŸåï¼ŒStore åªè®°å½•ï¼š

```ts
answerQuestion(vocabularyId, isCorrect, questionType, { usedHint });
```

- ä¼šè¯ç»“æŸæ—¶ï¼Œå¯¹æ¯ä¸ªå•è¯èšåˆï¼š

```ts
type MasteryLevel = 'é™Œç”Ÿ' | 'æ¨¡ç³Š' | 'è®°å¾—';

function computeMasteryFromStats(stats: VocabularyPerWordStats): MasteryLevel {
  if (stats.wrongCount === 0 && !stats.usedHint) return 'è®°å¾—';
  if (stats.wrongCount <= 1) return 'æ¨¡ç³Š';
  return 'é™Œç”Ÿ';
}
```

### 4.4 æœ¬åœ°é”™é¢˜æœ¬ä¸ AI ååŒï¼ˆMVPï¼‰

> ç›®æ ‡ï¼šåœ¨ä¸å¢åŠ é¢å¤–æ•°æ®åº“é›†åˆçš„å‰æä¸‹ï¼Œä¸º AI æ¨¡å—æä¾›â€œä»Šæ—¥é”™è¯åˆ—è¡¨â€ï¼Œç”¨äºç”Ÿæˆé¢å¤–ç»ƒä¹ æˆ–å¾®é˜…è¯»å†…å®¹ã€‚

- åœ¨ `VocabularySessionState` ä¸­ï¼Œä½¿ç”¨ `wrongWordIds` å’Œ `wrongRecords` ä¿å­˜**å½“æ—¥ä¼šè¯å†…çš„é”™é¢˜**ï¼š
  - æ¯å½“ `answerQuestion` æ”¶åˆ° `isCorrect === false` æ—¶ï¼š

    ```ts
    if (!state.wrongWordIds.includes(vocabularyId)) {
      state.wrongWordIds.push(vocabularyId);
    }
    state.wrongRecords.push({ vocabularyId, questionType, isCorrect: false, usedHint });
    ```

  - è¿™äº›æ•°æ®ä»…ä¿å­˜åœ¨å‰ç«¯ Store / AsyncStorage ä¸­ï¼Œç”¨äºï¼š
    - ä¼šè¯å†…éƒ¨çš„â€œé”™é¢˜å†ç»ƒâ€ç¯èŠ‚ï¼›  
    - åœ¨ç”¨æˆ·ä¸»åŠ¨ç‚¹å‡»â€œAI å¼ºåŒ–ç»ƒä¹ â€æ—¶ï¼Œä½œä¸ºå‚æ•°ä¼ ç»™ `ai-engine`ã€‚

- ä¸ AI æ¨¡å—çš„ååŒè°ƒç”¨ç¤ºä¾‹ï¼š

  ```ts
  const { wrongWordIds, courseSource } = useVocabularyStore.getState().session;

  await callCloudFunction('ai-engine', {
    action: 'generateWeaknessVocabulary',
    data: {
      userId,
      topN: 5,
      // å¯é€‰ï¼šå°†æœ¬åœ°é”™é¢˜åˆ—è¡¨ä¼ å…¥ï¼ŒAI ä¼˜å…ˆä½¿ç”¨è¿™äº› ID ç”Ÿæˆå†…å®¹
      focusVocabularyIds: wrongWordIds,
      source: courseSource,
    },
  });
  ```

- è®¾è®¡çº¦æŸï¼š
  - ä¸åœ¨åç«¯æ–°å¢â€œé”™é¢˜æœ¬é›†åˆâ€ï¼Œé•¿æœŸå¼±é¡¹ç”± `memory_status` / `user_vocabulary_progress` ç®¡ç†ï¼›  
  - æœ¬åœ°é”™é¢˜æœ¬åªè´Ÿè´£**å½“æ—¥ä¸´æ—¶é”™è¯¯**ï¼Œç”¨äº AI ç”Ÿæˆæ›´å¤šä¾‹å¥ / å¾®é˜…è¯»æˆ–é¢å¤–é€‰æ‹©é¢˜ç´ æã€‚

---

## 5. ä¸ `vocabulary` äº‘å‡½æ•°çš„äº’åŠ¨

> âš ï¸ å­—æ®µå¯¹é½è¯´æ˜ï¼š  
> - åç«¯ `vocabulary` é›†åˆå·²æ›´æ–°ä¸º**å¯Œç»“æ„å­—æ®µ**ï¼ˆè§ `docs/database_schema.md` 1.2 ä¸ `src/entities/types/vocabulary.types.ts`ï¼‰ï¼›  
> - `getTodayWords`ã€`getVocabularyDetail` ç­‰æ¥å£è¿”å›çš„å­—æ®µå¿…é¡»è‡³å°‘è¦†ç›–ï¼š
>   `_id / vocabularyId / thaiWord / meaning / pronunciation / partOfSpeech / level / lessonNumber / startingLetter / source / audioPath`  
>   ä»¥åŠ `exampleSentences / dialogue / usage / mistakes / cognates` ä¸­ç”¨åˆ°çš„å­å­—æ®µï¼›  
> - è‹¥å®é™…é›†åˆå­—æ®µå‘ç”Ÿå˜åŒ–ï¼Œå¿…é¡»**å…ˆæ›´æ–° `vocabulary.types.ts` å’Œ `database_schema.md`ï¼Œå†åŒæ­¥ä¿®æ”¹æœ¬ Spec å’Œ 08-Vocabulary-API æ–‡æ¡£**ã€‚

### 5.1 è·å–ä»Šæ—¥å•è¯ï¼šgetTodayWords

åœ¨ `initializeSession` ä¸­ï¼š

```ts
const response = await callCloudFunction<ApiResponse<GetTodayWordsResponse>>(
  'vocabulary',
  {
    action: 'getTodayWords',
    data: {
      userId,
      limit: dailyLimit,
      level: courseLevel,
    },
  },
);
```

- è‹¥å‘ç°å­˜åœ¨æœªæäº¤çš„æœ¬åœ° Sessionï¼ˆç›¸åŒ userId + courseSource + dateKey ä¸” `submitted === false`ï¼‰ï¼Œä¼˜å…ˆæ¢å¤æœ¬åœ°çŠ¶æ€ï¼Œ**ä¸é‡å¤è¯·æ±‚**ï¼›  
- æ–°çš„ä¸€å¤©æˆ–é¦–æ¬¡è¿›å…¥æ—¶æ‰è°ƒç”¨ `getTodayWords`ã€‚

### 5.2 æäº¤æŒæ¡ç¨‹åº¦ï¼šupdateMasteryï¼ˆèšåˆæäº¤ï¼‰

åœ¨ `finishSession()` ä¸­ï¼š

```ts
async function finishSession() {
  const { userId, courseSource, perWordStats } = getState().session;

  const entries = Object.entries(perWordStats);

  for (const [vocabularyId, stats] of entries) {
    const mastery = computeMasteryFromStats(stats); // é™Œç”Ÿ/æ¨¡ç³Š/è®°å¾—

    await callCloudFunction('vocabulary', {
      action: 'updateMastery',
      data: {
        userId,
        vocabularyId,
        mastery,
      },
    });
  }

  // æ ‡è®° submittedï¼Œé¿å…é‡å¤æäº¤
  setState((prev) => ({
    ...prev,
    session: { ...prev.session, submitted: true },
  }));
}
```

æ³¨æ„ï¼š

- æ¯ä¸ªå•è¯åœ¨ä¸€æ¬¡ä¼šè¯å†…**ä»…æäº¤ä¸€æ¬¡ mastery**ï¼›  
- å†æ¬¡è¿›å…¥æ—¶ï¼Œå¦‚ä»åœ¨åŒä¸€å¤©ä¸” Session å·²æäº¤ï¼Œåˆ™ä½¿ç”¨æ–°çš„ `getTodayWords` ç»“æœå¼€å§‹ä¸‹ä¸€è½®ï¼ˆé€šå¸¸ä¸ä¼šå‘ç”Ÿï¼‰ã€‚

---

## 6. å…¸å‹ç”¨ä¾‹ä¸ç«¯åˆ°ç«¯æ—¶åº

### 6.1 ä» Courses è¿›å…¥è¯æ±‡å­¦ä¹ 

```text
ç”¨æˆ·
  â”‚ ç‚¹å‡»â€œåŸºç¡€æ³°è¯­ 1â€è¯¾ç¨‹å¡ç‰‡
  â–¼
app/(tabs)/courses.tsx
  â”‚ è°ƒç”¨ learningStore.setCurrentCourse('BASIC_THAI_1')
  â”‚ router.push('/learning?module=word&source=BASIC_THAI_1')
  â–¼
app/learning/index.tsxï¼ˆWordSessionï¼‰
  â”‚ è¯»å– query.module='word', source='BASIC_THAI_1'
  â”‚ è°ƒç”¨ vocabularyStore.initializeSession(userId, source)
  â–¼
vocabularyStore.initializeSession
  â”‚ æ£€æŸ¥æœ¬åœ°æ˜¯å¦å­˜åœ¨æœªæäº¤ Sessionï¼ˆåŒ userId+source+dateï¼‰
  â”œâ”€ æœ‰ â†’ ç›´æ¥æ¢å¤ VocabularySessionStateï¼ˆä¸è°ƒåç«¯ï¼‰
  â””â”€ æ—  â†’ è°ƒç”¨ vocabulary.getTodayWords â†’ æ„å»º reviewQueue/newQueue
  â–¼
WordSession
  â”‚ æ ¹æ®å½“å‰é˜Ÿåˆ—æ¸²æŸ“ï¼š
  â”œâ”€ review item â†’ ReviewWordView + é€‰æ‹©é¢˜
  â””â”€ new item    â†’ NewWordViewï¼ˆè®²è§£ï¼‰â†’ ReviewWordViewï¼ˆè½»é‡é€‰æ‹©é¢˜ï¼‰
```

### 6.2 åšé¢˜ã€è®°å½•ä¸æäº¤

```text
ReviewWordView / æ‹¼å†™ç»„ä»¶
  â”‚ ç”¨æˆ·ç­”é¢˜ â†’ onResult({ isCorrect, questionType, usedHint })
  â–¼
WordSession
  â”‚ è°ƒç”¨ vocabularyStore.answerQuestion(vocabularyId, isCorrect, questionType, usedHint)
  â–¼
vocabularyStore.answerQuestion
  â”‚ æ›´æ–° session.perWordStats[vocabularyId]
  â”‚ æŒ‰é˜Ÿåˆ—è§„åˆ™é€‰æ‹©ä¸‹ä¸€ä¸ªå•è¯
  â–¼
WordSession
  â”‚ é˜Ÿåˆ—å…¨éƒ¨å®Œæˆ â†’ æ˜¾ç¤ºâ€œæœ¬æ¬¡å­¦ä¹ å®Œæˆâ€é¡µ
  â”‚ ç”¨æˆ·ç‚¹å‡»â€œç»“æŸä»Šå¤©å­¦ä¹ â€
  â–¼
vocabularyStore.finishSession
  â”‚ å¯¹æ‰€æœ‰ perWordStats è®¡ç®— masteryï¼ˆé™Œç”Ÿ/æ¨¡ç³Š/è®°å¾—ï¼‰
  â”‚ ä¸ºæ¯ä¸ªå•è¯è°ƒç”¨ vocabulary.updateMasteryï¼ˆä¸€æ¬¡ä¼šè¯åªæäº¤ä¸€æ¬¡ï¼‰
  â”‚ æ ‡è®° session.submitted = true
  â–¼
å­¦ä¹ ç»“æŸ
  â”‚ è°ƒç”¨ learningStore.registerStudySession({ module:'word', courseSource, durationMinutes })
  â”‚ è·³è½¬å›é¦–é¡µæˆ– Courses é¡µ
```

---

## 7. ä»»åŠ¡åˆ—è¡¨ä¸é‡Œç¨‹ç¢‘ï¼ˆè¯æ±‡æ¨¡å—ï¼‰

> ç›®æ ‡ï¼šåœ¨å‰©ä½™çº¦ 2 ä¸ªæœˆçš„å‘¨æœŸå†…ï¼Œå®Œæˆä¸€ä¸ª**å¯ä¸Šçº¿çš„æœ€å°å¯ç”¨è¯æ±‡æ¨¡å—**ã€‚

### 7.1 P0ï¼šæ¥å…¥ `vocabulary` äº‘å‡½æ•°åŸºç¡€èƒ½åŠ›ï¼ˆçº¦ 1 å‘¨ï¼‰

- [ ] å°† `vocabularyStore.initSession` ä»æ—§çš„ memory-engine é€»è¾‘åˆ‡æ¢ä¸º `vocabulary.getTodayWords`ã€‚  
- [ ] å¢åŠ  `vocabularyStore.finishSession`ï¼Œè°ƒç”¨ `updateMastery` æäº¤ç»“æœã€‚  
- [ ] åœ¨ `app/learning/index.tsx` ä¸­ç§»é™¤ mock æ•°æ®ï¼Œæ”¹ä¸ºä½¿ç”¨ `vocabularyStore` æä¾›çš„å½“å‰å•è¯ã€‚

### 7.2 P1ï¼šå®ç° VocabularySessionState ä¸ä¼šè¯æ¢å¤ï¼ˆçº¦ 1â€“2 å‘¨ï¼‰

- [ ] å®šä¹‰å¹¶å®ç° `VocabularySessionState`ã€`perWordStats` ä¸æŒä¹…åŒ–é€»è¾‘ã€‚  
- [ ] å®ç° `answerQuestion` / `skipReviewAndLearnNew` / `resetCourseProgress` ç­‰æ ¸å¿ƒ APIã€‚  
- [ ] æ‰‹å·¥æµ‹è¯•ï¼šåœ¨å¤ä¹ é˜¶æ®µã€æ–°è¯è®²è§£é˜¶æ®µã€é”™é¢˜é˜¶æ®µä¸­é€”é€€å‡ºï¼Œé‡æ–°è¿›å…¥åèƒ½å¤Ÿæ¢å¤ã€‚

### 7.3 P2ï¼šé¢˜å‹å®¹å™¨ä¸ 4 ç§é€‰æ‹©é¢˜ï¼ˆçº¦ 2 å‘¨ï¼‰

- [ ] é‡æ„ `ReviewWordView`ï¼Œæ‹†æˆï¼šé¢˜ç›®å®¹å™¨ + å…·ä½“é¢˜å‹ rendererã€‚  
- [ ] å®ç° 4 ç§é€‰æ‹©é¢˜ï¼ˆä¸å«æ‹¼å†™é¢˜ï¼‰ï¼Œæ”¯æŒä¼ å…¥å¹²æ‰°é¡¹ã€‚  
- [ ] å®ç°ç®€å•å¹²æ‰°é¡¹ç”Ÿæˆå™¨ï¼šä»åŒè¯¾ç¨‹ + åŒè¯æ€§ä¸­éšæœºé€‰ 3 ä¸ªã€‚  
- [ ] å°† `WordSession` æ”¹ä¸ºæ ¹æ® `learningStatus` ä¸ `perWordStats` é€‰æ‹©é¢˜å‹ã€‚

### 7.4 P3ï¼šæ‹¼å†™é¢˜ï¼ˆå¯é€‰ï¼Œçº¦ 2 å‘¨ï¼‰

- [ ] å®ç° `SPELL_THAI_FROM_CN` ä¸ `SPELL_THAI_FROM_AUDIO` é¢˜å‹ç»„ä»¶ã€‚  
- [ ] ä½¿ç”¨ç³»ç»Ÿé”®ç›˜è¾“å…¥æ³°è¯­ï¼Œä¸åšæ¨¡ç³ŠåŒ¹é…ï¼Œåªæ¥å—**å®Œå…¨ä¸€è‡´**çš„è¯å½¢ã€‚  
- [ ] å°†æ‹¼å†™é¢˜ä»…ç”¨äºé«˜æŒæ¡åº¦å•è¯ï¼Œä»¥å‡å°‘ç”¨æˆ·è´Ÿæ‹…ã€‚

### 7.5 P4ï¼šç»Ÿè®¡ä¸ä¼˜åŒ–ï¼ˆçº¦ 1 å‘¨ï¼‰

- [ ] é›†æˆ `getReviewStatistics`ï¼Œåœ¨ Courses æˆ–ä¸ªäººä¸­å¿ƒå±•ç¤ºæ•´ä½“æŒæ¡ç‡ã€‚  
- [ ] ä¸º `vocabulary` äº‘å‡½æ•°å¢åŠ å¿…è¦æ—¥å¿—ï¼ˆuserIdã€vocabularyIdã€masteryã€sourceï¼‰ã€‚  
- [ ] åœ¨ `docs/project-freeze/README.md` ä¸­æ ‡è®°è¯æ±‡æ¨¡å—ä¸ºâ€œå·²å†»ç»“æ¶æ„â€ã€‚

---

æœ¬è§„æ ¼æ–‡æ¡£å®šä¹‰äº†è¯æ±‡æ¨¡å—ä»è·¯ç”±ã€ç»„ä»¶ã€Storeã€äº‘å‡½æ•°åˆ°è®°å¿†ç®—æ³•çš„å®Œæ•´é“¾è·¯ï¼Œå¹¶ç»™å‡ºäº†**æŒ‰å•è¯èšåˆè´¨é‡ + æ‰¹é‡æäº¤**çš„æœ€ç»ˆæ–¹æ¡ˆã€‚  
åç»­æ‰€æœ‰å…³äºè¯æ±‡çš„ UI/é¢˜å‹/AI æ‹“å±•ï¼ˆä¾‹å¦‚ AI ä¾‹å¥ç”Ÿæˆã€å¼±é¡¹å¼ºåŒ–ï¼‰éƒ½å¿…é¡»å»ºç«‹åœ¨æœ¬è§„æ ¼ä¹‹ä¸Šï¼Œä¸å¾—å†å¼•å…¥ç¬¬äºŒå¥—è®°å¿† / é˜Ÿåˆ—ç³»ç»Ÿã€‚***
````

## File: src/components/common/Button.tsx
````typescript
// src/components/common/Button.tsx
import React from 'react';
import { 
  TouchableOpacity,   // å¯ç‚¹å‡»ç»„ä»¶
  Text,               // æ–‡æœ¬ç»„ä»¶
  StyleSheet,         // æ ·å¼è¡¨
  ActivityIndicator,  // åŠ è½½åŠ¨ç”»
  ViewStyle,          // æ ·å¼ç±»å‹
  TextStyle           // æ–‡æœ¬æ ·å¼ç±»å‹
} from 'react-native';

// ã€æ¥å£ã€‘å®šä¹‰ç»„ä»¶æ¥æ”¶çš„å±æ€§
interface ButtonProps {
  title: string;                              // æŒ‰é’®æ–‡å­—
  onPress: () => void;                        // ç‚¹å‡»äº‹ä»¶
  loading?: boolean;                          // æ˜¯å¦åŠ è½½ä¸­(å¯é€‰)
  disabled?: boolean;                         // æ˜¯å¦ç¦ç”¨(å¯é€‰)
  variant?: 'primary' | 'secondary';          // æ ·å¼å˜ä½“(å¯é€‰)
  style?: ViewStyle;                          // è‡ªå®šä¹‰æ ·å¼(å¯é€‰)
}

// ã€ç»„ä»¶ã€‘Button
export default function Button({ 
  title, 
  onPress, 
  loading = false,      // é»˜è®¤å€¼
  disabled = false, 
  variant = 'primary',
  style
}: ButtonProps) {
  return (
    <TouchableOpacity 
      style={[  // ã€æ•°ç»„æ ·å¼ã€‘åé¢çš„ä¼šè¦†ç›–å‰é¢çš„
        styles.button,                                  // åŸºç¡€æ ·å¼
        variant === 'secondary' && styles.buttonSecondary,  // æ¬¡è¦æŒ‰é’®æ ·å¼
        disabled && styles.buttonDisabled,              // ç¦ç”¨æ ·å¼
        style  // è‡ªå®šä¹‰æ ·å¼(æœ€é«˜ä¼˜å…ˆçº§)
      ]}
      onPress={onPress}
      disabled={disabled || loading}  // åŠ è½½æ—¶ä¹Ÿç¦ç”¨
      activeOpacity={0.7}  // ç‚¹å‡»æ—¶é€æ˜åº¦
    >
      {loading ? (
        <ActivityIndicator color={variant === 'primary' ? '#fff' : '#4A90E2'} />
      ) : (
        <Text style={[
          styles.buttonText,
          variant === 'secondary' && styles.buttonTextSecondary
        ]}>
          {title}
        </Text>
      )}
    </TouchableOpacity>
  );
}

// ã€æ ·å¼è¡¨ã€‘
const styles = StyleSheet.create({
  button: {
    backgroundColor: '#4A90E2',  // è“è‰²èƒŒæ™¯
    paddingVertical: 15,         // ä¸Šä¸‹å†…è¾¹è·
    borderRadius: 8,             // åœ†è§’
    alignItems: 'center',        // æ°´å¹³å±…ä¸­
  },
  buttonSecondary: {
    backgroundColor: '#fff',     // ç™½è‰²èƒŒæ™¯
    borderWidth: 1,              // è¾¹æ¡†å®½åº¦
    borderColor: '#4A90E2',      // è¾¹æ¡†é¢œè‰²
  },
  buttonDisabled: {
    opacity: 0.5,                // åŠé€æ˜
  },
  buttonText: {
    color: '#fff',               // ç™½è‰²æ–‡å­—
    fontSize: 16,
    fontWeight: '600',           // åŠ ç²—
  },
  buttonTextSecondary: {
    color: '#4A90E2',            // è“è‰²æ–‡å­—
  },
});
````

## File: src/components/common/GlassCard.tsx
````typescript
// src/components/common/GlassCard.tsx
import React from 'react';
import { View, StyleSheet, ViewStyle } from 'react-native';

interface GlassCardProps {
  children: React.ReactNode;
  style?: ViewStyle | ViewStyle[];
}

export const GlassCard: React.FC<GlassCardProps> = ({ children, style }) => {
  return (
    <View style={[styles.card, style]}>
      {children}
    </View>
  );
};

const styles = StyleSheet.create({
  card: {
    backgroundColor: 'rgba(255, 255, 255, 0.85)',
    borderRadius: 16,
    padding: 20,
    borderWidth: 1,
    borderColor: 'rgba(229, 226, 219, 0.8)',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 12,
    elevation: 5,
  },
});
````

## File: src/components/courses/CourseCard.tsx
````typescript
import React from 'react';
import { View, Text, StyleSheet, Pressable, Image, ImageSourcePropType } from 'react-native';
import { useTranslation } from 'react-i18next';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

export interface CourseCardData {
    id: string;
    source: string;
    title: string;
    description: string;
    level: string;
    imageSource: ImageSourcePropType;
    category: string;
    lessons: number;
}

interface CourseCardProps {
    course: CourseCardData;
    isCurrent: boolean;
    onStart: () => void;
    onCardPress?: () => void;
    progress?: {
        completed: number;
        total: number;
    };
    isLocked?: boolean; // Added: Locked state prop
}

export function CourseCard({
    course,
    isCurrent,
    onStart,
    onCardPress,
    progress,
    isLocked = false, // Default to unlocked
}: CourseCardProps) {
    const { t } = useTranslation();

    const progressPercent = progress && progress.total > 0
        ? Math.min(100, Math.round((progress.completed / progress.total) * 100))
        : null;

    return (
        <Pressable
            key={course.id}
            style={[
                styles.card,
                (isCurrent && !isLocked) && styles.activeCard,
                // Removed: isLocked && styles.lockedCard (User requested normal look)
            ]}
            onPress={isLocked ? undefined : (onCardPress || onStart)} // Still disable press if locked
            disabled={isLocked}
        >
            <Image
                source={course.imageSource}
                style={styles.image} // Removed: isLocked && styles.lockedImage
            />
            <View style={styles.info}>
                <View style={styles.header}>
                    <Text style={styles.title} numberOfLines={1}>
                        {course.title}
                    </Text>
                    {!isLocked && (
                        <View style={styles.levelBadge}>
                            <Text style={styles.levelText}>{course.level}</Text>
                        </View>
                    )}
                </View>

                <Text style={styles.description} numberOfLines={2}>
                    {course.description}
                </Text>

                <View style={styles.footer}>
                    {/* Meta Info (Hidden or dimmed when locked) */}
                    <View style={styles.metaColumn}>
                        {!isLocked && (
                            progressPercent !== null ? (
                                <>
                                    <View style={styles.progressBar}>
                                        <View style={[styles.progressFill, { width: `${progressPercent}%` }]} />
                                    </View>
                                    <Text style={styles.metaText}>
                                        {progress?.completed}/{progress?.total} ({progressPercent}%)
                                    </Text>
                                </>
                            ) : (
                                <Text style={styles.metaText}>{course.lessons} è¯¾æ—¶</Text>
                            )
                        )}
                    </View>

                    <Pressable
                        style={[
                            styles.startBtn,
                            isCurrent && styles.activeStartBtn,
                            isLocked && styles.lockedBtn // Locked button style
                        ]}
                        onPress={(e) => {
                            if (isLocked) return;
                            e.stopPropagation();
                            onStart();
                        }}
                        disabled={isLocked}
                    >
                        <Text style={[
                            styles.startBtnText,
                            isCurrent && styles.activeStartBtnText,
                            isLocked && styles.lockedBtnText // Locked text style
                        ]}>
                            {isLocked
                                ? t('courses.locked', 'æœªè§£é”')
                                : (isCurrent ? t('courses.continue', 'ç»§ç»­å­¦ä¹ ') : t('courses.startBtnText', 'å¼€å§‹å­¦ä¹ '))
                            }
                        </Text>
                    </Pressable>
                </View>
            </View>
        </Pressable>
    );
}

const styles = StyleSheet.create({
    card: {
        flexDirection: 'row',
        backgroundColor: Colors.white,
        borderRadius: 16,
        overflow: 'hidden',
        borderWidth: 1,
        borderColor: Colors.sand,
        height: 136,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.05,
        shadowRadius: 8,
        elevation: 3,
    },
    activeCard: {
        borderColor: Colors.thaiGold,
        borderWidth: 2,
        backgroundColor: '#FFFCF5',
    },
    lockedCard: {
        backgroundColor: '#F5F5F5',
        borderColor: '#E0E0E0',
        elevation: 0,
        shadowOpacity: 0,
    },
    image: {
        width: 110,
        height: '100%',
        resizeMode: 'cover',
    },
    lockedImage: {
        opacity: 0.5,
        tintColor: 'gray', // Grayscale effect
    },
    info: {
        flex: 1,
        padding: 12,
        justifyContent: 'space-between',
        gap: 8,
    },
    header: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'flex-start',
        gap: 8,
    },
    title: {
        flex: 1,
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.ink,
    },
    lockedText: {
        color: '#A0A0A0',
    },
    levelBadge: {
        paddingHorizontal: 6,
        paddingVertical: 2,
        backgroundColor: 'rgba(212, 175, 55, 0.1)',
        borderRadius: 4,
        borderWidth: 1,
        borderColor: 'rgba(212, 175, 55, 0.3)',
    },
    levelText: {
        fontSize: 10,
        color: Colors.thaiGold,
        fontFamily: Typography.notoSerifRegular,
    },
    description: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 12,
        color: Colors.taupe,
        lineHeight: 16,
    },
    footer: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        gap: 12,
    },
    metaColumn: {
        flex: 1,
        gap: 6,
    },
    metaText: {
        fontSize: 11,
        color: Colors.taupe,
        fontFamily: Typography.notoSerifRegular,
    },
    progressBar: {
        height: 6,
        backgroundColor: '#F0F0F0',
        borderRadius: 3,
        overflow: 'hidden',
    },
    progressFill: {
        height: '100%',
        backgroundColor: Colors.thaiGold,
        borderRadius: 3,
    },
    startBtn: {
        paddingHorizontal: 14,
        paddingVertical: 10,
        backgroundColor: Colors.ink,
        borderRadius: 12,
    },
    activeStartBtn: {
        backgroundColor: Colors.thaiGold,
    },
    lockedBtn: {
        backgroundColor: '#E0E0E0',
    },
    startBtnText: {
        fontSize: 12,
        color: Colors.white,
        fontFamily: Typography.notoSerifRegular,
    },
    activeStartBtnText: {
        color: Colors.white,
        fontWeight: '600',
    },
    lockedBtnText: {
        color: '#9E9E9E',
    },
});
````

## File: src/components/courses/CourseSelectionModal.tsx
````typescript
import React from 'react';
import { View, Text, StyleSheet, Modal, Pressable } from 'react-native';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { useTranslation } from 'react-i18next';

interface CourseSelectionModalProps {
    visible: boolean;
    courseTitle: string;
    onConfirm: () => void;
    onCancel: () => void;
}

export function CourseSelectionModal({
    visible,
    courseTitle,
    onConfirm,
    onCancel,
}: CourseSelectionModalProps) {
    const { t } = useTranslation();

    return (
        <Modal
            visible={visible}
            transparent
            animationType="fade"
            onRequestClose={onCancel}
        >
            <View style={styles.overlay}>
                <View style={styles.modalContainer}>
                    <Text style={styles.title}>{t('courses.switchCourseTitle', 'Switch Course?')}</Text>
                    <Text style={styles.message}>
                        {t('courses.switchCourseMessage', 'åˆ‡æ¢åˆ° {{course}} ä¼šå…ˆä¿å­˜å½“å‰è¯¾ç¨‹çš„è¿›åº¦ï¼Œå†å¼€å§‹æ–°çš„è¯¾ç¨‹ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ', { course: courseTitle })}
                    </Text>

                    <View style={styles.buttonContainer}>
                        <Pressable style={[styles.button, styles.cancelButton]} onPress={onCancel}>
                            <Text style={styles.cancelButtonText}>{t('common.cancel', 'Cancel')}</Text>
                        </Pressable>
                        <Pressable style={[styles.button, styles.confirmButton]} onPress={onConfirm}>
                            <Text style={styles.confirmButtonText}>{t('common.confirm', 'Confirm')}</Text>
                        </Pressable>
                    </View>
                </View>
            </View>
        </Modal>
    );
}

const styles = StyleSheet.create({
    overlay: {
        flex: 1,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        justifyContent: 'center',
        alignItems: 'center',
        padding: 24,
    },
    modalContainer: {
        backgroundColor: Colors.white,
        borderRadius: 20,
        padding: 24,
        width: '100%',
        maxWidth: 340,
        alignItems: 'center',
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.1,
        shadowRadius: 12,
        elevation: 5,
    },
    title: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 20,
        color: Colors.ink,
        marginBottom: 12,
        textAlign: 'center',
    },
    message: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.taupe,
        textAlign: 'center',
        marginBottom: 24,
        lineHeight: 20,
    },
    buttonContainer: {
        flexDirection: 'row',
        gap: 12,
        width: '100%',
    },
    button: {
        flex: 1,
        height: 44,
        borderRadius: 12,
        justifyContent: 'center',
        alignItems: 'center',
    },
    cancelButton: {
        backgroundColor: Colors.paper,
        borderWidth: 1,
        borderColor: Colors.sand,
    },
    confirmButton: {
        backgroundColor: Colors.thaiGold,
    },
    cancelButtonText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 14,
        color: Colors.taupe,
    },
    confirmButtonText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 14,
        color: Colors.white,
    },
});
````

## File: src/components/learning/alphabet/PhonicsRuleCard.tsx
````typescript
// src/components/learning/alphabet/PhonicsRuleCard.tsx

import React, { useState, useEffect, useCallback, useRef } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  ScrollView,
  Pressable,
  ActivityIndicator,
} from 'react-native';
import { Audio } from 'expo-av';
import { X } from 'lucide-react-native';

import type { PhonicsRule } from '@/src/entities/types/phonicsRule.types';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

// ==================== Props æ¥å£ ====================

interface PhonicsRuleCardProps {
  /** æ‹¼è¯»è§„åˆ™æ•°æ® */
  rule: PhonicsRule;

  /** å®Œæˆå›è°ƒ(å€’è®¡æ—¶ç»“æŸæˆ–ç”¨æˆ·ç‚¹å‡»ç»§ç»­) */
  onComplete: () => void;

  /** æ˜¯å¦æ˜¾ç¤ºå…³é—­æŒ‰é’®(å¯é€‰,é»˜è®¤false) */
  showCloseButton?: boolean;

  /** å…³é—­å›è°ƒ(å¯é€‰) */
  onClose?: () => void;
}

// ==================== ä¸»ç»„ä»¶ ====================

export function PhonicsRuleCard({ rule, onComplete, showCloseButton = false, onClose, }: PhonicsRuleCardProps) {
  const [timeLeft, setTimeLeft] = useState(rule.duration);
  const [isPlaying, setIsPlaying] = useState(false);
  const soundRef = useRef<Audio.Sound | null>(null);

  // ===== å€’è®¡æ—¶é€»è¾‘ =====
  useEffect(() => {
    if (timeLeft <= 0) {
      onComplete();
      return;
    }

    const timer = setInterval(() => {
      setTimeLeft((prev) => prev - 1);
    }, 1000);

    return () => clearInterval(timer);
  }, [timeLeft, onComplete]);

  // ===== éŸ³é¢‘æ’­æ”¾ =====
  const handlePlayExample = useCallback(async () => {
    console.log('ğŸ‘† [PhonicsRuleCard] Interactive Example Clicked');
    console.log('ğŸ“Š [PhonicsRuleCard] Data:', rule.interactiveExample);
    console.log('ğŸ”— [PhonicsRuleCard] Source Rule:', { id: rule.id, title: rule.title, lessonId: rule.lessonId });

    if (!rule.interactiveExample?.audioUrl) {
      console.warn('âš ï¸ [PhonicsRuleCard] No audioUrl found in interactiveExample');
      return;
    }

    try {
      setIsPlaying(true);

      // å¦‚æœå·²æœ‰éŸ³é¢‘å®ä¾‹,ç›´æ¥é‡æ’­
      if (soundRef.current) {
        await soundRef.current.replayAsync();
        setIsPlaying(false);
        return;
      }

      // åˆ›å»ºæ–°éŸ³é¢‘å®ä¾‹
      const { sound } = await Audio.Sound.createAsync(
        { uri: rule.interactiveExample.audioUrl },
        { shouldPlay: true }
      );

      soundRef.current = sound;

      // ç›‘å¬æ’­æ”¾å®Œæˆ
      sound.setOnPlaybackStatusUpdate((status) => {
        if (status.isLoaded && status.didJustFinish) {
          setIsPlaying(false);
        }
      });
    } catch (error) {
      console.warn('[PhonicsRuleCard] æ’­æ”¾éŸ³é¢‘å¤±è´¥:', error);
      setIsPlaying(false);
    }
  }, [rule.interactiveExample]);

  // ===== æ¸…ç†éŸ³é¢‘èµ„æº =====
  useEffect(() => {
    return () => {
      if (soundRef.current) {
        soundRef.current.unloadAsync().catch(() => { });
        soundRef.current = null;
      }
    };
  }, []);

  // ===== æ¸²æŸ“å¯è§†åŒ–å›¾è¡¨ =====
  const renderVisualChart = () => {
    if (!rule.visualChart) return null;

    return (
      <View style={styles.chartContainer}>
        <Text style={styles.chartTitle}>å£°è°ƒè§„åˆ™è¡¨</Text>

        {/* è¡¨å¤´ */}
        <View style={styles.chartRow}>
          {rule.visualChart.columns.map((col, index) => (
            <View
              key={index}
              style={[
                styles.chartCell,
                styles.chartHeaderCell,
                index === 0 && styles.chartFirstColumn,
              ]}
            >
              <Text style={styles.chartHeaderText}>{col}</Text>
            </View>
          ))}
        </View>

        {/* æ•°æ®è¡Œ */}
        {rule.visualChart.rows.map((row, rowIndex) => (
          <View key={rowIndex} style={styles.chartRow}>
            {row.map((cell, cellIndex) => {
              const isFirstColumn = cellIndex === 0;
              const isInteractive = rule.visualChart?.interactive && !isFirstColumn;

              return (
                <Pressable
                  key={cellIndex}
                  style={[
                    styles.chartCell,
                    isFirstColumn && styles.chartFirstColumn,
                    isInteractive && styles.chartInteractiveCell,
                  ]}
                  disabled={!isInteractive}
                  onPress={() => {
                    if (isInteractive) {
                      // æœªæ¥å¯æ‰©å±•:ç‚¹å‡»å•å…ƒæ ¼æ’­æ”¾å¯¹åº”å£°è°ƒç¤ºä¾‹
                      console.log('Play tone example:', row[0], cell);
                    }
                  }}
                >
                  <Text
                    style={[
                      styles.chartCellText,
                      isFirstColumn && styles.chartFirstColumnText,
                      !isFirstColumn && styles.chartToneText,
                    ]}
                  >
                    {cell}
                  </Text>
                </Pressable>
              );
            })}
          </View>
        ))}
      </View>
    );
  };

  return (
    <View style={styles.overlay}>
      <View style={styles.card}>
        {/* å…³é—­æŒ‰é’® */}
        {showCloseButton && (
          <TouchableOpacity
            style={styles.closeButton}
            onPress={onClose}
            accessibilityRole="button"
            accessibilityLabel="å…³é—­è§„åˆ™å¡ç‰‡"
          >
            <X size={24} color={Colors.taupe} />
          </TouchableOpacity>
        )}

        {/* å€’è®¡æ—¶æ˜¾ç¤º */}
        <View style={styles.timerContainer}>
          <Text style={styles.timerText}>{timeLeft}ç§’</Text>
        </View>

        <ScrollView
          style={styles.scrollView}
          contentContainerStyle={styles.scrollContent}
          showsVerticalScrollIndicator={true}
        >
          {/* æ ‡é¢˜ */}
          <Text style={styles.title}>{rule.title}</Text>

          {/* è§„åˆ™å†…å®¹ */}
          <View style={styles.contentContainer}>
            {rule.content.map((line, index) => (
              <Text
                key={index}
                style={[
                  styles.contentLine,
                  line === '' && styles.emptyLine,
                ]}
              >
                {line}
              </Text>
            ))}
          </View>

          {/* äº¤äº’å¼ç¤ºä¾‹ */}
          {rule.interactiveExample && (
            <View style={styles.exampleContainer}>
              <Text style={styles.exampleLabel}>ğŸ“Œ äº¤äº’ç¤ºä¾‹</Text>
              <Pressable
                style={styles.exampleButton}
                onPress={handlePlayExample}
                disabled={isPlaying}
                accessibilityRole="button"
                accessibilityLabel={`æ’­æ”¾ç¤ºä¾‹: ${rule.interactiveExample.syllable}`}
              >
                {isPlaying ? (
                  <ActivityIndicator size="small" color={Colors.white} />
                ) : (
                  <>
                    <View style={styles.exampleParts}>
                      <Text style={styles.exampleConsonant}>
                        {rule.interactiveExample.consonant}
                      </Text>
                      <Text style={styles.examplePlus}>+</Text>
                      <Text style={styles.exampleVowel}>
                        {rule.interactiveExample.vowel}
                      </Text>
                      <Text style={styles.exampleEquals}>=</Text>
                      <Text style={styles.exampleSyllable}>
                        {rule.interactiveExample.syllable}
                      </Text>
                    </View>
                    <Text style={styles.examplePronunciation}>
                      [{rule.interactiveExample.pronunciation}]
                    </Text>
                  </>
                )}
              </Pressable>
            </View>
          )}

          {/* å¯è§†åŒ–å›¾è¡¨ */}
          {renderVisualChart()}
        </ScrollView>

        {/* ç»§ç»­æŒ‰é’® */}
        <TouchableOpacity
          style={styles.continueButton}
          onPress={onComplete}
          accessibilityRole="button"
          accessibilityLabel="æ˜ç™½äº†,ç»§ç»­å­¦ä¹ "
        >
          <Text style={styles.continueText}>æ˜ç™½äº†,ç»§ç»­å­¦ä¹  â†’</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}

// ==================== æ ·å¼ ====================

const styles = StyleSheet.create({
  overlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 1000,
  },
  card: {
    width: '90%',
    maxWidth: 500,
    maxHeight: '85%',
    backgroundColor: Colors.white,
    borderRadius: 16,
    padding: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 12,
    elevation: 10,
  },
  closeButton: {
    position: 'absolute',
    top: 16,
    right: 16,
    zIndex: 10,
    padding: 8,
  },
  timerContainer: {
    alignItems: 'flex-end',
    marginBottom: 12,
  },
  timerText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  scrollView: {
    flexGrow: 0,
  },
  scrollContent: {
    paddingBottom: 16,
  },
  title: {
    fontFamily: Typography.playfairBold,
    fontSize: 22,
    color: Colors.thaiGold,
    marginBottom: 20,
    textAlign: 'center',
  },
  contentContainer: {
    marginBottom: 20,
  },
  contentLine: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    lineHeight: 24,
    color: Colors.ink,
    marginBottom: 4,
  },
  emptyLine: {
    height: 8,
  },
  exampleContainer: {
    backgroundColor: '#F5F5F5',
    borderRadius: 12,
    padding: 16,
    marginBottom: 20,
  },
  exampleLabel: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
    marginBottom: 12,
  },
  exampleButton: {
    backgroundColor: Colors.thaiGold,
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    minHeight: 60,
    justifyContent: 'center',
  },
  exampleParts: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  exampleConsonant: {
    fontFamily: Typography.playfairBold,
    fontSize: 32,
    color: Colors.white,
  },
  examplePlus: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 24,
    color: 'rgba(255, 255, 255, 0.7)',
    marginHorizontal: 8,
  },
  exampleVowel: {
    fontFamily: Typography.playfairBold,
    fontSize: 32,
    color: Colors.white,
  },
  exampleEquals: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 24,
    color: 'rgba(255, 255, 255, 0.7)',
    marginHorizontal: 8,
  },
  exampleSyllable: {
    fontFamily: Typography.playfairBold,
    fontSize: 36,
    color: Colors.white,
  },
  examplePronunciation: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.9)',
  },
  chartContainer: {
    marginBottom: 20,
    borderWidth: 1,
    borderColor: Colors.sand,
    borderRadius: 8,
    overflow: 'hidden',
  },
  chartTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.ink,
    padding: 12,
    backgroundColor: '#F5F5F5',
    textAlign: 'center',
  },
  chartRow: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: Colors.sand,
  },
  chartCell: {
    flex: 1,
    padding: 12,
    justifyContent: 'center',
    alignItems: 'center',
    minHeight: 48,
  },
  chartHeaderCell: {
    backgroundColor: '#FFF9E6',
  },
  chartFirstColumn: {
    backgroundColor: '#F5F5F5',
    flex: 1.2,
  },
  chartInteractiveCell: {
    backgroundColor: '#F0F8FF',
  },
  chartHeaderText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    color: Colors.ink,
    textAlign: 'center',
  },
  chartCellText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.ink,
    textAlign: 'center',
  },
  chartFirstColumnText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    color: Colors.thaiGold,
  },
  chartToneText: {
    fontFamily: Typography.playfairBold,
    fontSize: 24,
    color: Colors.ink,
  },
  continueButton: {
    backgroundColor: Colors.thaiGold,
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    marginTop: 16,
  },
  continueText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
  },
});
````

## File: src/components/learning/ModuleLockedScreen.tsx
````typescript
// src/components/learning/ModuleLockedScreen.tsx

/**
 * æ¨¡å—é”å®šç•Œé¢
 * 
 * åŠŸèƒ½ï¼š
 * 1. æ˜¾ç¤ºæ¨¡å—è¢«é”å®šçš„æç¤º
 * 2. æ˜¾ç¤ºå½“å‰è¿›åº¦å’Œè§£é”è¦æ±‚
 * 3. æä¾›è¿”å›æŒ‰é’®
 */

import React from 'react';
import { View, Text, StyleSheet, Pressable } from 'react-native';
import { useTranslation } from 'react-i18next';
import { useRouter } from 'expo-router';
import { Lock, ArrowLeft } from 'lucide-react-native';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { useModuleAccessStore, type ModuleType } from '@/src/stores/moduleAccessStore';

// ==================== ç±»å‹å®šä¹‰ ====================

interface ModuleLockedScreenProps {
    moduleType: ModuleType;
}

// ==================== è¾…åŠ©å‡½æ•° ====================

/**
 * è·å–æ¨¡å—çš„æ˜¾ç¤ºåç§°
 */
const getModuleName = (moduleType: ModuleType, t: any): string => {
    const moduleNames: Record<ModuleType, string> = {
        letter: t('modules.alphabet'),
        word: t('modules.word'),
        sentence: t('modules.sentence'),
        article: t('modules.article'),
    };
    return moduleNames[moduleType];
};

/**
 * è·å–é”å®šåŸå› å’Œè§£é”è¦æ±‚
 */
const getUnlockRequirement = (
    moduleType: ModuleType,
    userProgress: any,
    t: any
): { prerequisite: string; currentProgress: number; requiredProgress: number } => {
    if (!userProgress) {
        return {
            prerequisite: t('moduleAccess.noProgress'),
            currentProgress: 0,
            requiredProgress: 95,
        };
    }

    switch (moduleType) {
        case 'word':
            return {
                prerequisite: t('moduleAccess.prerequisite.word'),
                // åç«¯ letterProgress ä¸º 0-1ï¼Œå±•ç¤ºæ—¶è½¬ä¸º 0-100
                currentProgress: (userProgress.letterProgress || 0) * 100,
                requiredProgress: 80,
            };
        case 'sentence':
            return {
                prerequisite: t('moduleAccess.prerequisite.sentence'),
                currentProgress: userProgress.wordProgress || 0,
                requiredProgress: 80,
            };
        case 'article':
            return {
                prerequisite: t('moduleAccess.prerequisite.article'),
                currentProgress: userProgress.sentenceProgress || 0,
                requiredProgress: 80,
            };
        default:
            return {
                prerequisite: t('moduleAccess.unknownModule'),
                currentProgress: 0,
                requiredProgress: 100,
            };
    }
};

// ==================== ç»„ä»¶ ====================

export default function ModuleLockedScreen({ moduleType }: ModuleLockedScreenProps) {
    const { t } = useTranslation();
    const router = useRouter();
    const { userProgress } = useModuleAccessStore();

    const moduleName = getModuleName(moduleType, t);
    const { prerequisite, currentProgress, requiredProgress } = getUnlockRequirement(
        moduleType,
        userProgress,
        t
    );

    const progressPercentage = Math.min(currentProgress, requiredProgress);

    const handleBack = () => {
        router.back();
    };

    return (
        <View style={styles.container}>
            {/* é”å®šå›¾æ ‡ */}
            <View style={styles.iconContainer}>
                <View style={styles.iconCircle}>
                    <Lock size={64} color={Colors.taupe} strokeWidth={1.5} />
                </View>
            </View>

            {/* æ ‡é¢˜ */}
            <Text style={styles.title}>{t('moduleAccess.locked')}</Text>

            {/* æç¤ºæ–‡å­— */}
            <Text style={styles.message}>
                {t('moduleAccess.lockedMessage', { module: moduleName })}
            </Text>

            {/* å‰ç½®è¦æ±‚ */}
            <View style={styles.requirementCard}>
                <Text style={styles.requirementTitle}>{t('moduleAccess.requirement')}</Text>
                <Text style={styles.requirementText}>{prerequisite}</Text>
            </View>

            {/* è¿›åº¦æ¡ */}
            <View style={styles.progressContainer}>
                <View style={styles.progressHeader}>
                    <Text style={styles.progressLabel}>{t('moduleAccess.currentProgress')}</Text>
                    <Text style={styles.progressValue}>
                        {currentProgress}% / {requiredProgress}%
                    </Text>
                </View>

                <View style={styles.progressBarContainer}>
                    <View style={styles.progressBarBackground}>
                        <View
                            style={[
                                styles.progressBarFill,
                                {
                                    width: `${(progressPercentage / requiredProgress) * 100}%`,
                                },
                            ]}
                        />
                    </View>
                </View>

                {/* è¿›åº¦æç¤º */}
                {currentProgress < requiredProgress ? (
                    <Text style={styles.progressHint}>
                        {t('moduleAccess.remainingProgress', {
                            remaining: requiredProgress - currentProgress,
                        })}
                    </Text>
                ) : (
                    <Text style={styles.progressComplete}>
                        {t('moduleAccess.progressComplete')}
                    </Text>
                )}
            </View>

            {/* è¿”å›æŒ‰é’® */}
            <Pressable style={styles.backButton} onPress={handleBack}>
                <ArrowLeft size={20} color={Colors.white} />
                <Text style={styles.backButtonText}>{t('moduleAccess.goBack')}</Text>
            </Pressable>
        </View>
    );
}

// ==================== æ ·å¼ ====================

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: Colors.paper,
        paddingHorizontal: 24,
        paddingTop: 80,
        paddingBottom: 40,
        alignItems: 'center',
    },
    iconContainer: {
        marginBottom: 32,
    },
    iconCircle: {
        width: 120,
        height: 120,
        borderRadius: 60,
        backgroundColor: Colors.sand,
        alignItems: 'center',
        justifyContent: 'center',
        borderWidth: 2,
        borderColor: Colors.taupe,
        opacity: 0.8,
    },
    title: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 28,
        color: Colors.ink,
        marginBottom: 12,
        textAlign: 'center',
    },
    message: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 16,
        color: Colors.taupe,
        textAlign: 'center',
        marginBottom: 32,
        lineHeight: 24,
    },
    requirementCard: {
        width: '100%',
        backgroundColor: Colors.white,
        borderRadius: 16,
        padding: 20,
        marginBottom: 32,
        borderWidth: 1,
        borderColor: Colors.sand,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.05,
        shadowRadius: 8,
        elevation: 2,
    },
    requirementTitle: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 14,
        color: Colors.thaiGold,
        marginBottom: 8,
        textTransform: 'uppercase',
        letterSpacing: 0.5,
    },
    requirementText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 16,
        color: Colors.ink,
        lineHeight: 24,
    },
    progressContainer: {
        width: '100%',
        marginBottom: 40,
    },
    progressHeader: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: 12,
    },
    progressLabel: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.taupe,
    },
    progressValue: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 14,
        color: Colors.ink,
    },
    progressBarContainer: {
        marginBottom: 8,
    },
    progressBarBackground: {
        width: '100%',
        height: 12,
        backgroundColor: Colors.sand,
        borderRadius: 6,
        overflow: 'hidden',
    },
    progressBarFill: {
        height: '100%',
        backgroundColor: Colors.thaiGold,
        borderRadius: 6,
    },
    progressHint: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 13,
        color: Colors.taupe,
        fontStyle: 'italic',
    },
    progressComplete: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 13,
        color: Colors.thaiGold,
    },
    backButton: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: Colors.ink,
        paddingHorizontal: 32,
        paddingVertical: 16,
        borderRadius: 12,
        gap: 8,
        shadowColor: Colors.thaiGold,
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.2,
        shadowRadius: 8,
        elevation: 4,
    },
    backButtonText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.white,
    },
});
````

## File: src/config/alphabet/alphabetQuestionGenerator.ts
````typescript
// src/components/alphabet/alphabetQuestionGenerator.ts

import { AlphabetLearningState } from '@/src/stores/alphabetStore';
import {
  AlphabetQuestionType,
  AlphabetReviewQuestion,
  AlphabetQuestionOption,
} from '@/src/config/alphabet/alphabetQuestionTypes';

// å¯é€‰ï¼šè®©å¤–å±‚æ§åˆ¶é¢˜å‹æ¯”ä¾‹
export interface QuestionGenerationOptions {
  preferredType?: AlphabetQuestionType;
  // é¢˜ç›® ID å‰ç¼€ï¼Œæ–¹ä¾¿è°ƒè¯• / æ—¥å¿—
  idPrefix?: string;
  // é€‰é¡¹æ•°é‡ï¼ˆ3~6 æ¯”è¾ƒåˆç†ï¼‰
  optionCount?: number;
}

export interface QuestionGenerationContext {
  current: AlphabetLearningState;          // å½“å‰è¦å¤ä¹ çš„å­—æ¯
  pool: AlphabetLearningState[];          // ä»Šæ—¥ session çš„æ‰€æœ‰å­—æ¯
  options?: QuestionGenerationOptions;
}

// å·¥å…·å‡½æ•°ï¼šä»æ•°ç»„ä¸­å–éšæœºè‹¥å¹²ä¸ªä¸åŒå…ƒç´ 
function pickRandomDistinct<T>(items: T[], count: number, exclude?: T): T[] {
  const pool = exclude ? items.filter((i) => i !== exclude) : [...items];
  const result: T[] = [];
  const max = Math.min(count, pool.length);

  while (result.length < max && pool.length > 0) {
    const index = Math.floor(Math.random() * pool.length);
    const [picked] = pool.splice(index, 1);
    result.push(picked);
  }

  return result;
}

// å†³å®šé¢˜å‹ï¼šå¦‚æœå¤–å±‚ä¸ä¼ ï¼Œå°±åšä¸€ä¸ªç®€å•è½®ç›˜ï¼ˆä¸åšå¤æ‚ stage é€»è¾‘ï¼‰
function decideQuestionType(
  preferredType?: AlphabetQuestionType,
): AlphabetQuestionType {
  if (preferredType) return preferredType;

  const r = Math.random();
  if (r < 0.33) return 'soundToLetter';
  if (r < 0.66) return 'letterToSound';
  return 'reading';
}

// æ„é€ é€‰é¡¹ï¼šå­—æ¯â†’é€‰é¡¹å¯¹è±¡
function buildLetterOptions(
  correct: AlphabetLearningState,
  distractors: AlphabetLearningState[],
): AlphabetQuestionOption[] {
  const all = [correct, ...distractors];
  return all.map((letter, idx) => ({
    id: letter._id ?? letter.thaiChar ?? String(idx),
    label: letter.thaiChar,
  }));
}

// æ„é€ é€‰é¡¹ï¼šå‘éŸ³â†’é€‰é¡¹å¯¹è±¡ï¼ˆä½¿ç”¨ syllableSoundName / initialSound / pronunciationï¼‰
function buildSoundOptions(
  correct: AlphabetLearningState,
  distractors: AlphabetLearningState[],
): AlphabetQuestionOption[] {
  const getSoundLabel = (item: AlphabetLearningState): string => {
    return (
      item.syllableSoundName ||
      item.initialSound ||
      item.pronunciation ||
      item.thaiChar
    );
  };

  const all = [correct, ...distractors];
  return all.map((item, idx) => ({
    id: item._id ?? `${getSoundLabel(item)}-${idx}`,
    label: getSoundLabel(item),
  }));
}

// è½»é‡è§£é‡Šæ–‡æ¡ˆï¼ˆä¸å®ç°å®Œæ•´è§„åˆ™ï¼Œåªåšå‹å¥½æç¤ºï¼‰
function buildPhonicsExplanation(
  questionType: AlphabetQuestionType,
  current: AlphabetLearningState,
): string | undefined {
  const baseChar = current.thaiChar;
  const example = current.example;

  if (questionType === 'soundToLetter') {
    return example
      ? `ä½ å¬åˆ°çš„å‘éŸ³æ¥è‡ªå­—æ¯ã€Œ${baseChar}ã€åŠå…¶åœ¨å•è¯ã€Œ${example}ã€ä¸­çš„è¯»æ³•ã€‚`
      : `ä½ å¬åˆ°çš„å‘éŸ³æ¥è‡ªå­—æ¯ã€Œ${baseChar}ã€çš„è¯»éŸ³ã€‚`;
  }

  if (questionType === 'letterToSound') {
    return `æ³¨æ„å­—æ¯ã€Œ${baseChar}ã€çš„èµ·å§‹éŸ³ï¼ˆinitial soundï¼‰ï¼Œåœ¨ä¸åŒå…ƒéŸ³ç»„åˆä¸­ä¼šä¿æŒç›¸åŒçš„è¾…éŸ³éŸ³å€¼ã€‚`;
  }

  if (questionType === 'reading') {
    return example
      ? `å°è¯•å°†å•è¯æ‹†æˆã€Œè¾…éŸ³ + å…ƒéŸ³ã€å†åˆæˆå‘éŸ³ï¼Œä¾‹å¦‚ï¼š${example}ã€‚`
      : `å°è¯•åœ¨è„‘ä¸­å…ˆè¯»å‡ºè¾…éŸ³ï¼Œå†åŠ ä¸Šå…ƒéŸ³ï¼Œæœ€ååˆæˆä¸€ä¸ªæ•´ä½“éŸ³èŠ‚ã€‚`;
  }

  return undefined;
}

// ğŸ‘‡ æ ¸å¿ƒå¯¼å‡ºå‡½æ•°ï¼šæ ¹æ®å½“å‰å­—æ¯ + ä»Šæ—¥å­—æ¯æ± ç”Ÿæˆä¸€é“é¢˜
export function generateAlphabetQuestion(
  ctx: QuestionGenerationContext,
): AlphabetReviewQuestion {
  const { current, pool, options } = ctx;
  const {
    preferredType,
    idPrefix = 'qa',
    optionCount = 4,
  } = options || {};
  const type = decideQuestionType(preferredType);

  // ä¸ºäº†é¿å…æ‹¿ä¸åˆ°å­—æ®µæ—¶å´©æ‰ï¼Œåšä¸€äº›å…œåº•
  const mainChar = current.thaiChar ?? '';
  const example = current.example ?? '';
  // ç»Ÿä¸€ä¼˜å…ˆä½¿ç”¨ AlphabetLearningState ä¸­å·²ç»è§£æå¥½çš„ audioUrl
  const audioUrl =
    current.audioUrl ||
    current.syllableSoundUrl ||
    current.letterPronunciationUrl ||
    current.audioPath;

  const distractorCount = Math.max(optionCount - 1, 1);
  const otherLetters = pool.filter((l) => l !== current);

  let question: AlphabetReviewQuestion;

  if (type === 'soundToLetter') {
    // å¬éŸ³ â†’ é€‰å­—æ¯
    const distractors = pickRandomDistinct(otherLetters, distractorCount);
    const optionsArr = buildLetterOptions(current, distractors);

    question = {
      id: `${idPrefix}-sound-${current._id ?? mainChar}`,
      type: 'soundToLetter',
      prompt: 'å¬å‘éŸ³ï¼Œé€‰æ‹©å¯¹åº”çš„æ³°æ–‡å­—æ¯ã€‚',
      audioUrl: audioUrl,
      options: optionsArr,
      correctOptionId: optionsArr[0].id, // ç¬¬ä¸€ä¸ªæ˜¯æ­£ç¡®é¡¹ï¼ˆbuildLetterOptions ä¿è¯ï¼‰
      explanation: buildPhonicsExplanation('soundToLetter', current),
    };
  } else if (type === 'letterToSound') {
    // çœ‹å­—æ¯ â†’ é€‰å‘éŸ³
    const distractors = pickRandomDistinct(otherLetters, distractorCount);
    const optionsArr = buildSoundOptions(current, distractors);

    question = {
      id: `${idPrefix}-letter-${current._id ?? mainChar}`,
      type: 'letterToSound',
      prompt: 'è§‚å¯Ÿè¿™ä¸ªå­—æ¯ï¼Œé€‰æ‹©å®ƒçš„è¯»éŸ³ã€‚',
      mainText: mainChar,
      options: optionsArr,
      correctOptionId: optionsArr[0].id,
      explanation: buildPhonicsExplanation('letterToSound', current),
    };
  } else {
    // readingï¼šæ‹¼è¯»é¢˜ï¼ˆå°½é‡ä½¿ç”¨ä¾‹è¯ï¼Œä¸ç”Ÿæˆæ–°éŸ³èŠ‚ï¼‰
    const distractors = pickRandomDistinct(otherLetters, distractorCount);
    const optionsArr = buildSoundOptions(current, distractors);

    question = {
      id: `${idPrefix}-reading-${current._id ?? mainChar}`,
      type: 'reading',
      prompt: example
        ? 'å°è¯•è¯»å‡ºè¿™ä¸ªè¯çš„å‘éŸ³ã€‚'
        : 'å°è¯•è¯»å‡ºè¿™ä¸ªéŸ³èŠ‚/å­—æ¯çš„å‘éŸ³ã€‚',
      mainText: example || mainChar,
      audioUrl: audioUrl,
      options: optionsArr,
      correctOptionId: optionsArr[0].id,
      explanation: buildPhonicsExplanation('reading', current),
    };
  }

  // æ‰“ä¹±é€‰é¡¹é¡ºåºï¼ˆé¿å…æ­£ç¡®é¡¹ä¸€ç›´åœ¨ç¬¬ä¸€ä½ï¼‰
  const shuffledOptions = [...question.options];
  for (let i = shuffledOptions.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffledOptions[i], shuffledOptions[j]] = [
      shuffledOptions[j],
      shuffledOptions[i],
    ];
  }

  // æ‰¾åˆ°æ‰“ä¹±åæ­£ç¡®é€‰é¡¹çš„ id
  const correct = question.options[0];
  const correctInShuffled = shuffledOptions.find(
    (opt) => opt.id === correct.id,
  )!;
  question.options = shuffledOptions;
  question.correctOptionId = correctInShuffled.id;

  return question;
}
````

## File: src/config/alphabet/lettersSequence.ts
````typescript
// LetterSequence.ts
// æ··åˆå¼æœ€ä¼˜æ³°è¯­å­—æ¯å­¦ä¹ åºåˆ—ï¼ˆè¾…éŸ³ + å…ƒéŸ³ + å£°è°ƒï¼‰
// âœ… è¦†ç›–ï¼š44 ä¸ªè¾…éŸ³ + 32 ä¸ªå…ƒéŸ³ + 4 ä¸ªå£°è°ƒï¼ˆå…± 80 ä¸ªï¼‰
// âœ… å·²å¯¹ç…§ letters_final.jsonï¼Œç¡®è®¤æ— é—æ¼ã€æ— å¤šä½™ã€æ— é‡å¤

/**
 * å­—æ¯å­¦ä¹ æœ€ä¼˜é¡ºåºï¼ˆä»…åŒ…å«æ•°æ®åº“å®é™…å­˜åœ¨çš„ thaiCharï¼‰
 * ä¿®å¤ç‚¹ï¼š
 * - åˆ é™¤ tone marksï¼ˆà¹ˆà¹‰à¹Šà¹‹ï¼‰
 * - åˆ é™¤æ•°æ®åº“ä¸å­˜åœ¨çš„å¤åˆå…ƒéŸ³ï¼ˆà¹€à¸­à¸° à¹à¸­à¸° à¹‚à¸­à¸° ç­‰ï¼‰
 * - åˆ é™¤ à¸¤ à¸¤à¹… à¸¦ à¸¦à¹… à¸ƒ à¸…ï¼ˆæ•°æ®åº“ä¸­ä¸å­˜åœ¨ï¼‰
 * - ä¿ç•™è¾…éŸ³ + åŸºç¡€å…ƒéŸ³
 */

export const LETTER_SEQUENCE: readonly string[] = [
  // ------------------------------------------
  // Stage 1 â€” åŸºç¡€æ‹¼è¯»èƒ½åŠ›ï¼ˆè¾…éŸ³ + åŸºç¡€å…ƒéŸ³ï¼‰
  // ------------------------------------------
  "à¸", "à¸™", "à¸¡", "à¸›", "à¸•", "à¸š", "à¸„", "à¸‡", "à¸­",
  "à¸°", "à¸²", "à¸´", "à¸µ", "à¸¸", "à¸¹",

  // ------------------------------------------
  // Stage 2 â€” æ‰©å±•æ‹¼è¯»ï¼ˆå‰ç½®å…ƒéŸ³ + é«˜é¢‘è¾…éŸ³ï¼‰
  // ------------------------------------------
  "à¸”", "à¸—", "à¸", "à¸Ÿ", "à¸¢", "à¸§", "à¸¥", "à¸£",
  "à¹€", "à¹", "à¹‚", "à¹„", "à¹ƒ",

  // ------------------------------------------
  // Stage 3 â€” é€æ°”å¯¹æ¯” + ç‰¹æ®Šè¯»éŸ³
  // ------------------------------------------
  "à¸‚", "à¸Š", "à¸‹", "à¸ˆ", "à¸‰", "à¸œ", "à¸", "à¸®",
  "à¸·", // é•¿å…ƒéŸ³æ‰©å±•

  // ------------------------------------------
  // Stage 4 â€” é«˜é¢‘è¾…éŸ³æ‰©å±•
  // ------------------------------------------
  "à¸–", "à¸˜", "à¸ ", "à¸¨", "à¸©", "à¸ª", "à¸«", "à¸", "à¸", "à¸",

  // ------------------------------------------
  // Stage 5 â€” å¤æ‚è¾…éŸ³ä¸å°‘é‡ç‰¹æ®Šç»„åˆï¼ˆä»…ä¿ç•™æ•°æ®åº“å­˜åœ¨ï¼‰
  // ------------------------------------------
  "à¸‘", "à¸’", "à¸†", "à¸", "à¸Œ", "à¸“", "à¸¬",
];

/**
 * é¢„ç”Ÿæˆå­—ç¬¦ â†’ æ’åºåºå·æ˜ å°„
 */
export const LETTER_INDEX_MAP = new Map<string, number>(
  LETTER_SEQUENCE.map((char, index) => [char, index]),
);

/**
 * æŒ‰æœ€ä¼˜é¡ºåºæ’åºï¼ˆitems å¿…é¡»æœ‰ thaiChar å­—æ®µï¼‰
 */
export function sortByLetterSequence<T extends { thaiChar: string }>(
  items: T[],
): T[] {
  return [...items].sort((a, b) => {
    const ia = LETTER_INDEX_MAP.get(a.thaiChar) ?? Number.MAX_SAFE_INTEGER;
    const ib = LETTER_INDEX_MAP.get(b.thaiChar) ?? Number.MAX_SAFE_INTEGER;
    return ia - ib;
  });
}

/**
 * å°† sequence æŒ‰ Lesson åˆ†ç»„ï¼ˆ5 è¯¾ï¼‰
 * ä¾› AlphabetCoursesScreen ä¸ Lesson orchestrator ä½¿ç”¨
 */
export const SEQUENCE_LESSONS = {
  lesson1: LETTER_SEQUENCE.slice(0, 15),
  lesson2: LETTER_SEQUENCE.slice(15, 15 + 12),
  lesson3: LETTER_SEQUENCE.slice(27, 27 + 9),
  lesson4: LETTER_SEQUENCE.slice(36, 36 + 9),
  lesson5: LETTER_SEQUENCE.slice(45),
};
````

## File: src/constants/colors.ts
````typescript
// src/constants/colors.ts
export const Colors = {
    paper: '#FAF9F6',
    ink: '#1A1A1A',
    sand: '#E5E2DB',
    taupe: '#8E8B82',
    thaiGold: '#D4AF37',
    accent: '#B8956A',
    white: '#FFFFFF',
    glassWhite: 'rgba(255, 255, 255, 0.85)',
    error: '#DC2626',
    red: {
      50: '#FEF2F2',
      600: '#DC2626',
    },
     success: '#2A9D8F',
  } as const;
````

## File: src/entities/enums/QualityScore.enum.ts
````typescript
// src/entities/enums/QualityScore.enum.ts

export enum QualityButton {
  KNOW = 'è®°å¾—',
  FUZZY = 'æ¨¡ç³Š',
  FORGET = 'é™Œç”Ÿ',
}

export const QUALITY_SCORE_MAP: Record<QualityButton, number> = {
  [QualityButton.KNOW]: 5,
  [QualityButton.FUZZY]: 3,
  [QualityButton.FORGET]: 1,
};

export const ATTEMPTS_INCREMENT_MAP: Record<QualityButton, number> = {
  [QualityButton.KNOW]: 3,
  [QualityButton.FUZZY]: 1,
  [QualityButton.FORGET]: 2,
};
````

## File: src/entities/enums/QuestionType.enum.ts
````typescript
// src/entities/enums/QuestionType.enum.ts

/**
 * å­—æ¯å¤ä¹ é¢˜å‹æšä¸¾
 * 
 * åŸºäºæ³°è¯­è¯­éŸ³å­¦ä¼˜åŒ–çš„12ç§é¢˜å‹ç³»ç»Ÿ
 * åŒ…å«é€æ°”éŸ³å¯¹æ¯”ã€å…ƒéŸ³é•¿çŸ­å¯¹æ¯”ã€å£°è°ƒå¬è¾¨ç­‰æ ¸å¿ƒè®­ç»ƒ
 * 
 * @version 3.0.0
 * @see lettersQuestionGenerator.ts
 */
export enum QuestionType {
    // ===== åŸºç¡€é¢˜å‹(Lesson 1-2) =====
    /** å¬éŸ³é€‰å­—æ¯ */
    SOUND_TO_LETTER = 'sound-to-letter',
    /** çœ‹å­—æ¯é€‰å‘éŸ³ */
    LETTER_TO_SOUND = 'letter-to-sound',

    // ===== æ‹¼è¯»é¢˜å‹(Lesson 2-3) =====
    /** æ‹¼è¯»ç»„åˆ: è¾…éŸ³+å…ƒéŸ³ */
    SYLLABLE = 'syllable',
    /** éŸ³ç´ åˆ†ç¦»: å‘éŸ³â†’è¾…éŸ³ */
    REVERSE_SYLLABLE = 'reverse-syllable',
    /** ç¼ºå­—å¡«ç©º */
    MISSING_LETTER = 'missing-letter',

    // ===== ğŸ”´ æ ¸å¿ƒå¯¹æ¯”é¢˜å‹(Lesson 2-4) =====
    /** é€æ°”éŸ³å¯¹æ¯”(æœ€å°å¯¹ç«‹ç»„è®­ç»ƒ) - à¸/à¸‚/à¸„ */
    ASPIRATED_CONTRAST = 'aspirated-contrast',
    /** å…ƒéŸ³é•¿çŸ­å¯¹æ¯” - à¸²/à¸° */
    VOWEL_LENGTH_CONTRAST = 'vowel-length-contrast',

    // ===== è¿›é˜¶é¢˜å‹(Lesson 3-5) =====
    /** å°¾è¾…éŸ³è§„åˆ™ */
    FINAL_CONSONANT = 'final-consonant',
    /** å£°è°ƒå¬è¾¨(å«éŸ³é«˜å¯è§†åŒ–) */
    TONE_PERCEPTION = 'tone-perception',

    // ===== é«˜çº§é¢˜å‹(Lesson 4-6) =====
    /** è¾…éŸ³åˆ†ç±»(é«˜/ä¸­/ä½) */
    CLASS_CHOICE = 'class-choice',
    /** å­—æ¯åç§°è¯†åˆ« */
    LETTER_NAME = 'letter-name',
    /** é¦–éŸ³åˆ¤æ–­ */
    INITIAL_SOUND = 'initial-sound',
}

/**
 * é¢˜å‹æ˜¾ç¤ºåç§°æ˜ å°„
 */
export const QUESTION_TYPE_LABELS: Record<QuestionType, string> = {
    [QuestionType.SOUND_TO_LETTER]: 'å¬éŸ³é€‰å­—æ¯',
    [QuestionType.LETTER_TO_SOUND]: 'çœ‹å­—æ¯é€‰å‘éŸ³',
    [QuestionType.SYLLABLE]: 'æ‹¼è¯»ç»„åˆ',
    [QuestionType.REVERSE_SYLLABLE]: 'éŸ³ç´ åˆ†ç¦»',
    [QuestionType.MISSING_LETTER]: 'ç¼ºå­—å¡«ç©º',
    [QuestionType.ASPIRATED_CONTRAST]: 'é€æ°”éŸ³å¯¹æ¯”',
    [QuestionType.VOWEL_LENGTH_CONTRAST]: 'å…ƒéŸ³é•¿çŸ­å¯¹æ¯”',
    [QuestionType.FINAL_CONSONANT]: 'å°¾éŸ³è§„åˆ™',
    [QuestionType.TONE_PERCEPTION]: 'å£°è°ƒå¬è¾¨',
    [QuestionType.CLASS_CHOICE]: 'è¾…éŸ³åˆ†ç±»',
    [QuestionType.LETTER_NAME]: 'å­—æ¯åç§°',
    [QuestionType.INITIAL_SOUND]: 'é¦–éŸ³åˆ¤æ–­',
};

/**
 * é¢˜å‹éš¾åº¦ç­‰çº§(1-5)
 */
export const QUESTION_TYPE_DIFFICULTY: Record<QuestionType, 1 | 2 | 3 | 4 | 5> = {
    [QuestionType.SOUND_TO_LETTER]: 1,
    [QuestionType.LETTER_TO_SOUND]: 1,
    [QuestionType.SYLLABLE]: 2,
    [QuestionType.REVERSE_SYLLABLE]: 3,
    [QuestionType.MISSING_LETTER]: 2,
    [QuestionType.ASPIRATED_CONTRAST]: 3,
    [QuestionType.VOWEL_LENGTH_CONTRAST]: 2,
    [QuestionType.FINAL_CONSONANT]: 4,
    [QuestionType.TONE_PERCEPTION]: 4,
    [QuestionType.CLASS_CHOICE]: 3,
    [QuestionType.LETTER_NAME]: 2,
    [QuestionType.INITIAL_SOUND]: 2,
};

/**
 * éŸ³é¢‘éœ€æ±‚ç±»å‹å®šä¹‰
 */
export type AudioRequirementType =
    | 'letter'        // å•å­—æ¯å‘éŸ³
    | 'syllable'      // éŸ³èŠ‚å‘éŸ³
    | 'minimal-pair'  // æœ€å°å¯¹ç«‹ç»„(éœ€åŠ¨æ€ç”Ÿæˆ)
    | 'tone-set';     // 5ä¸ªå£°è°ƒå˜ä½“(éœ€TTSç”Ÿæˆ)

/**
 * é¢˜å‹æ‰€éœ€çš„éŸ³é¢‘ç±»å‹
 */
export const QUESTION_TYPE_AUDIO_REQUIREMENTS: Record<
    QuestionType,
    AudioRequirementType
> = {
    [QuestionType.SOUND_TO_LETTER]: 'letter',
    [QuestionType.LETTER_TO_SOUND]: 'letter',
    [QuestionType.SYLLABLE]: 'syllable',
    [QuestionType.REVERSE_SYLLABLE]: 'syllable',
    [QuestionType.MISSING_LETTER]: 'syllable',
    [QuestionType.ASPIRATED_CONTRAST]: 'minimal-pair',
    [QuestionType.VOWEL_LENGTH_CONTRAST]: 'minimal-pair',
    [QuestionType.FINAL_CONSONANT]: 'syllable',
    [QuestionType.TONE_PERCEPTION]: 'tone-set',
    [QuestionType.CLASS_CHOICE]: 'letter',
    [QuestionType.LETTER_NAME]: 'letter',
    [QuestionType.INITIAL_SOUND]: 'letter',
};

/**
 * æ ¹æ®è¯¾ç¨‹é˜¶æ®µè·å–æ¨èé¢˜å‹æƒé‡
 * 
 * @param lessonId - è¯¾ç¨‹ID (lesson1-lesson6)
 * @returns é¢˜å‹æƒé‡æ˜ å°„ (æƒé‡æ€»å’Œä¸º1)
 */
export function getQuestionTypeWeights(
    lessonId: string
): Partial<Record<QuestionType, number>> {
    switch (lessonId) {
        case 'lesson1':
            // åŸºç¡€å¬è¾¨+æ‹¼è¯»
            return {
                [QuestionType.SOUND_TO_LETTER]: 0.4,
                [QuestionType.LETTER_TO_SOUND]: 0.4,
                [QuestionType.SYLLABLE]: 0.2,
            };

        case 'lesson2':
            // å¼•å…¥å…ƒéŸ³é•¿çŸ­å¯¹æ¯”
            return {
                [QuestionType.SOUND_TO_LETTER]: 0.25,
                [QuestionType.SYLLABLE]: 0.3,
                [QuestionType.VOWEL_LENGTH_CONTRAST]: 0.25,
                [QuestionType.REVERSE_SYLLABLE]: 0.2,
            };

        case 'lesson3':
            // ğŸ”´ é‡ç‚¹:é€æ°”éŸ³å¯¹æ¯”è®­ç»ƒ
            return {
                [QuestionType.ASPIRATED_CONTRAST]: 0.35,
                [QuestionType.SYLLABLE]: 0.25,
                [QuestionType.MISSING_LETTER]: 0.2,
                [QuestionType.VOWEL_LENGTH_CONTRAST]: 0.2,
            };

        case 'lesson4':
            // ğŸ”´ é‡ç‚¹:å£°è°ƒç³»ç»Ÿè®­ç»ƒ
            return {
                [QuestionType.TONE_PERCEPTION]: 0.4,
                [QuestionType.CLASS_CHOICE]: 0.25,
                [QuestionType.ASPIRATED_CONTRAST]: 0.2,
                [QuestionType.FINAL_CONSONANT]: 0.15,
            };

        case 'lesson5':
            // ç»¼åˆå¤ä¹ ,å£°è°ƒä¸ºä¸»
            return {
                [QuestionType.TONE_PERCEPTION]: 0.3,
                [QuestionType.CLASS_CHOICE]: 0.2,
                [QuestionType.REVERSE_SYLLABLE]: 0.25,
                [QuestionType.LETTER_NAME]: 0.15,
                [QuestionType.ASPIRATED_CONTRAST]: 0.1,
            };

        case 'lesson6':
            // å…¨é¢˜å‹ç»¼åˆæµ‹è¯•
            return {
                [QuestionType.SOUND_TO_LETTER]: 0.1,
                [QuestionType.ASPIRATED_CONTRAST]: 0.15,
                [QuestionType.VOWEL_LENGTH_CONTRAST]: 0.15,
                [QuestionType.SYLLABLE]: 0.15,
                [QuestionType.TONE_PERCEPTION]: 0.25,
                [QuestionType.CLASS_CHOICE]: 0.1,
                [QuestionType.LETTER_NAME]: 0.1,
            };

        default:
            // é»˜è®¤å‡åŒ€åˆ†å¸ƒ(åŸºç¡€é¢˜)
            return {
                [QuestionType.SOUND_TO_LETTER]: 0.33,
                [QuestionType.LETTER_TO_SOUND]: 0.33,
                [QuestionType.SYLLABLE]: 0.34,
            };
    }
}

/**
 * æ ¹æ®æƒé‡éšæœºé€‰æ‹©é¢˜å‹
 * 
 * @param weights - é¢˜å‹æƒé‡æ˜ å°„
 * @returns é€‰ä¸­çš„é¢˜å‹
 */
export function selectQuestionTypeByWeight(
    weights: Partial<Record<QuestionType, number>>
): QuestionType {
    const types = Object.keys(weights) as QuestionType[];
    const weightValues = types.map(t => weights[t] || 0);

    // è®¡ç®—ç´¯ç§¯æƒé‡
    const cumulativeWeights: number[] = [];
    let sum = 0;
    for (const weight of weightValues) {
        sum += weight;
        cumulativeWeights.push(sum);
    }

    // éšæœºé€‰æ‹©
    const random = Math.random() * sum;
    const index = cumulativeWeights.findIndex(w => random <= w);

    return types[index] || types[0];
}

/**
 * è·å–é¢˜å‹å›¾æ ‡(ç”¨äºUIæ˜¾ç¤º)
 */
export const QUESTION_TYPE_ICONS: Record<QuestionType, string> = {
    [QuestionType.SOUND_TO_LETTER]: 'ğŸ”Š',
    [QuestionType.LETTER_TO_SOUND]: 'ğŸ‘ï¸',
    [QuestionType.SYLLABLE]: 'ğŸ”¤',
    [QuestionType.REVERSE_SYLLABLE]: 'ğŸ”„',
    [QuestionType.MISSING_LETTER]: 'â“',
    [QuestionType.ASPIRATED_CONTRAST]: 'ğŸ’¨',
    [QuestionType.VOWEL_LENGTH_CONTRAST]: 'â±ï¸',
    [QuestionType.FINAL_CONSONANT]: 'ğŸ”š',
    [QuestionType.TONE_PERCEPTION]: 'ğŸµ',
    [QuestionType.CLASS_CHOICE]: 'ğŸ“Š',
    [QuestionType.LETTER_NAME]: 'ğŸ“',
    [QuestionType.INITIAL_SOUND]: 'ğŸ‘‚',
};
````

## File: src/entities/types/entities.ts
````typescript
export * from './user';
export * from './course';
export * from './learning';
````

## File: src/entities/types/memory.types.ts
````typescript
// src/entities/types/memory.types.ts

export interface MemoryStatus {
  userId: string;
  entityType: 'letter' | 'word' | 'sentence';
  entityId: string;
  masteryLevel: number;
  reviewStage: number;
  easinessFactor: number;
  intervalDays: number;
  nextReviewAt: string;
  correctCount: number;
  wrongCount: number;
  streakCorrect: number;
  isLocked: boolean;
}

export interface UnlockInfo {
  unlocked: boolean;
  stage?: 'word' | 'sentence' | 'article';
  message: string;
  letterProgress: number; // 0-1 æ¯”ä¾‹å€¼
}
````

## File: src/stores/languageStore.ts
````typescript
// src/stores/languageStore.ts
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';
import i18n from '@/src/i18n';

export type Language = 'zh' | 'en';

interface LanguageState {
  currentLanguage: Language;
  changeLanguage: (lang: Language) => Promise<void>;
}

export const useLanguageStore = create<LanguageState>()(
  persist(
    (set) => ({
      currentLanguage: 'zh',
      changeLanguage: async (lang: Language) => {
        try {
          await i18n.changeLanguage(lang);
          set({ currentLanguage: lang });
        } catch (error) {
          console.error('Failed to change language:', error);
        }
      },
    }),
    {
      name: 'language-storage',
      storage: createJSONStorage(() => AsyncStorage),
    }
  )
);
````

## File: src/stores/learningStore.ts
````typescript
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Course, LearningProgress, Level } from '../entities/types/entities';

interface LearningState {
  currentCourse: Course | null;
  progress: LearningProgress | null;
  completedContent: string[];
  
  setCourse: (course: Course) => void;
  updateProgress: (contentType: string, score: number) => void;
  getCompletionRate: () => number;
  resetLearning: () => void;
}

export const useLearningStore = create<LearningState>()(
  persist(
    (set, get) => ({
      currentCourse: null,
      progress: null,
      completedContent: [],

      setCourse: (course: Course) => {
        set({ currentCourse: course });
        
        if (!get().progress) {
          const newProgress: LearningProgress = {
            progressId: 'progress_' + Date.now(),
            userId: 'user_1',
            courseId: course.courseId,
            currentLevel: Level.BEGINNER_A,
            completedAlphabets: 30,
            completedVocabulary: 150,
            completedSentences: 20,
            completedArticles: 5,
            totalScore: 0,
            totalStudyTime: 1200,
            streakDays: 7,
            lastUpdated: new Date(),
          };
          set({ progress: newProgress });
        }
      },

      updateProgress: (contentType: string, score: number) => {
        const progress = get().progress;
        if (!progress) return;

        const updatedProgress = { ...progress };
        
        switch (contentType) {
          case 'alphabet':
            updatedProgress.completedAlphabets += 1;
            break;
          case 'vocabulary':
            updatedProgress.completedVocabulary += 1;
            break;
          case 'sentence':
            updatedProgress.completedSentences += 1;
            break;
          case 'article':
            updatedProgress.completedArticles += 1;
            break;
        }
        
        updatedProgress.totalScore += score;
        updatedProgress.lastUpdated = new Date();
        
        set({ progress: updatedProgress });
      },

      getCompletionRate: () => {
        const progress = get().progress;
        if (!progress) return 0;
        
        const total = 76 + 500 + 100 + 20;
        const completed = 
          progress.completedAlphabets +
          progress.completedVocabulary +
          progress.completedSentences +
          progress.completedArticles;
        
        return (completed / total) * 100;
      },

      resetLearning: () => {
        set({
          currentCourse: null,
          progress: null,
          completedContent: [],
        });
      },
    }),
    {
      name: 'learning-storage',
      storage: createJSONStorage(() => AsyncStorage),
    }
  )
);
````

## File: src/utils/alphabet/buildAlphabetQueue.ts
````typescript
// å‰ç«¯æƒå¨é˜Ÿåˆ—æ„å»ºå™¨ï¼ˆé¦–å‘å†»ç»“ç‰ˆï¼‰
// ä»…æŒ‰è¯¾ç¨‹å†…ä¸‰æ–°ä¸€å¤ + mini-review + final-review ç”Ÿæˆ deterministic é˜Ÿåˆ—

import type {
  AlphabetLearningMode,
  AlphabetLearningState,
  AlphabetQueueItem,
  AlphabetQueueSource,
} from '@/src/stores/alphabetStore';

interface BuildAlphabetQueueParams {
  lessonLetters: AlphabetLearningState[];
  round: number;
  mode: AlphabetLearningMode;
  previousRoundLetters?: AlphabetLearningState[];
}

const MINI_REVIEW_CHUNK = 3;

export function buildAlphabetQueue(
  params: BuildAlphabetQueueParams
): AlphabetQueueItem[] {
  const { lessonLetters, round, mode, previousRoundLetters = [] } = params;
  const queue: AlphabetQueueItem[] = [];

  const pushWithSource = (item: AlphabetLearningState, source: AlphabetQueueSource) => {
    queue.push({
      ...item,
      source,
      round,
    });
  };

  const previousLetters = mode === 'learning' ? previousRoundLetters : [];

  // Phase 1: ä¸Šä¸€è½®å¤ä¹ 
  // ğŸ”¥ TODO-03: ç»Ÿä¸€ä½¿ç”¨ 'previous-review' è€Œä¸æ˜¯ 'previous-round-review'
  previousLetters.forEach((letter) => pushWithSource(letter, 'previous-review'));

  // Phase 2: ä»Šæ—¥å­¦ä¹  + mini-review (ä¸‰æ–°ä¸€å¤)
  for (let i = 0; i < lessonLetters.length; i += 1) {
    const letter = lessonLetters[i];
    // ğŸ”¥ TODO-03: ç»Ÿä¸€ä½¿ç”¨ 'new-learning' è€Œä¸æ˜¯ 'new'
    pushWithSource(letter, 'new-learning');

    const hasCompletedChunk = (i + 1) % MINI_REVIEW_CHUNK === 0;
    if (hasCompletedChunk) {
      const chunkStart = i + 1 - MINI_REVIEW_CHUNK;
      const chunk = lessonLetters.slice(chunkStart, i + 1);
      chunk.forEach((l) => pushWithSource(l, 'mini-review'));
    }
  }

  // Phase 3: æ€»å¤ä¹ ï¼ˆæœ¬è½®å…¨éƒ¨å­—æ¯ï¼‰
  lessonLetters.forEach((letter) => pushWithSource(letter, 'final-review'));

  return queue;
}
````

## File: src/utils/alphabetQuestionTypeAssigner.ts
````typescript
// src/utils/alphabetQuestionTypeAssigner.ts

/**
 * Alphabet Question Type Assigner
 *
 * é¢˜å‹åˆ†é…å™¨ - æ ¹æ®å­¦ä¹ é˜¶æ®µ(Phase)åˆ†é…åˆé€‚çš„é¢˜å‹
 * æŒ‰ç…§ alphabet-module-spec.md ç¬¬6ç« è¦æ±‚å®ç°
 *
 * æ ¸å¿ƒç­–ç•¥:
 * - ä¸‰æ–°ä¸€å¤é˜¶æ®µ: ä½¿ç”¨è½»é‡é¢˜å‹(å¬éŸ³é€‰å­—ã€çœ‹å­—é€‰éŸ³)
 * - Final Review é˜¶æ®µ: ä½¿ç”¨æ•´åˆé¢˜å‹(è¾…éŸ³ç±»åˆ«ã€é¦–éŸ³ã€å°¾éŸ³ã€å£°è°ƒã€æ‹¼è¯»)
 */

import { AlphabetGameType } from '@/src/entities/types/alphabetGameTypes';

/**
 * ä¸‰æ–°ä¸€å¤é˜¶æ®µä½¿ç”¨çš„è½»é‡é¢˜å‹
 *
 * è¿™äº›é¢˜å‹ä¸“æ³¨äºåŸºç¡€çš„å­—æ¯è¯†åˆ«,ä¸æ¶‰åŠå¤æ‚çš„è¯­éŸ³å­¦è§„åˆ™
 */
export const LIGHT_GAME_TYPES: AlphabetGameType[] = [
  AlphabetGameType.SOUND_TO_LETTER,
  AlphabetGameType.LETTER_TO_SOUND,
];

/**
 * Final Review é˜¶æ®µä½¿ç”¨çš„æ•´åˆé¢˜å‹
 *
 * è¿™äº›é¢˜å‹è¦æ±‚å­¦ç”Ÿç»¼åˆè¿ç”¨è¾…éŸ³ç±»åˆ«ã€å‘éŸ³è§„åˆ™ç­‰çŸ¥è¯†
 */
export const ADVANCED_GAME_TYPES: AlphabetGameType[] = [
  AlphabetGameType.CONSONANT_CLASS,
  AlphabetGameType.INITIAL_SOUND,
  AlphabetGameType.FINAL_SOUND,
  AlphabetGameType.TONE_CALCULATION,
  AlphabetGameType.PHONICS_MATH,
];

/**
 * å­¦ä¹ é˜¶æ®µç±»å‹
 */
export type LearningPhase = 'THREE_NEW_ONE_REVIEW' | 'FINAL_REVIEW';

/**
 * æ ¹æ®å­¦ä¹ é˜¶æ®µåˆ†é…é¢˜å‹
 *
 * @param phase - å­¦ä¹ é˜¶æ®µ ('THREE_NEW_ONE_REVIEW' æˆ– 'FINAL_REVIEW')
 * @returns éšæœºé€‰æ‹©çš„é¢˜å‹
 *
 * @example
 * // ä¸‰æ–°ä¸€å¤é˜¶æ®µ
 * const gameType = assignGameTypeForPhase('THREE_NEW_ONE_REVIEW');
 * // è¿”å› SOUND_TO_LETTER æˆ– LETTER_TO_SOUND
 *
 * @example
 * // Final Review é˜¶æ®µ
 * const gameType = assignGameTypeForPhase('FINAL_REVIEW');
 * // è¿”å› CONSONANT_CLASS, INITIAL_SOUND, FINAL_SOUND, TONE_CALCULATION, æˆ– PHONICS_MATH
 */
export function assignGameTypeForPhase(
  phase: LearningPhase
): AlphabetGameType {
  const pool =
    phase === 'THREE_NEW_ONE_REVIEW' ? LIGHT_GAME_TYPES : ADVANCED_GAME_TYPES;

  // ä»é¢˜å‹æ± ä¸­éšæœºé€‰æ‹©
  return pool[Math.floor(Math.random() * pool.length)];
}

/**
 * æ ¹æ®å­¦ä¹ é˜¶æ®µå’Œæƒé‡åˆ†é…é¢˜å‹
 *
 * @param phase - å­¦ä¹ é˜¶æ®µ
 * @param weights - å¯é€‰çš„é¢˜å‹æƒé‡æ˜ å°„,ç”¨äºå¾®è°ƒé¢˜å‹åˆ†å¸ƒ
 * @returns æ ¹æ®æƒé‡éšæœºé€‰æ‹©çš„é¢˜å‹
 *
 * @example
 * // æŒ‡å®šæƒé‡: 70% SOUND_TO_LETTER, 30% LETTER_TO_SOUND
 * const gameType = assignGameTypeWithWeights('THREE_NEW_ONE_REVIEW', {
 *   [AlphabetGameType.SOUND_TO_LETTER]: 0.7,
 *   [AlphabetGameType.LETTER_TO_SOUND]: 0.3,
 * });
 */
export function assignGameTypeWithWeights(
  phase: LearningPhase,
  weights?: Partial<Record<AlphabetGameType, number>>
): AlphabetGameType {
  // å¦‚æœæ²¡æœ‰æä¾›æƒé‡,ä½¿ç”¨é»˜è®¤å‡åŒ€åˆ†å¸ƒ
  if (!weights || Object.keys(weights).length === 0) {
    return assignGameTypeForPhase(phase);
  }

  const pool =
    phase === 'THREE_NEW_ONE_REVIEW' ? LIGHT_GAME_TYPES : ADVANCED_GAME_TYPES;

  // åªä¿ç•™å±äºå½“å‰é˜¶æ®µé¢˜å‹æ± çš„æƒé‡
  const filteredWeights: Record<AlphabetGameType, number> = {} as any;
  let totalWeight = 0;

  for (const gameType of pool) {
    const weight = weights[gameType] ?? 1; // é»˜è®¤æƒé‡ä¸º 1
    filteredWeights[gameType] = weight;
    totalWeight += weight;
  }

  // å½’ä¸€åŒ–æƒé‡å¹¶æ ¹æ®éšæœºæ•°é€‰æ‹©
  const random = Math.random() * totalWeight;
  let cumulativeWeight = 0;

  for (const gameType of pool) {
    cumulativeWeight += filteredWeights[gameType];
    if (random <= cumulativeWeight) {
      return gameType;
    }
  }

  // å…œåº•: è¿”å›æ± ä¸­ç¬¬ä¸€ä¸ªé¢˜å‹
  return pool[0];
}
````

## File: src/utils/ModuleGuard.tsx
````typescript
// src/utils/ModuleGuard.tsx

/**
 * æ¨¡å—è®¿é—®å®ˆå«ç»„ä»¶
 * 
 * åŠŸèƒ½ï¼š
 * 1. åœ¨è¿›å…¥å­¦ä¹ é¡µé¢å‰æ£€æŸ¥æƒé™
 * 2. æ˜¾ç¤ºåŠ è½½çŠ¶æ€
 * 3. æƒé™ä¸è¶³æ—¶æ˜¾ç¤ºé”å®šé¡µé¢
 */

import React, { useEffect, useState } from 'react';
import { View, ActivityIndicator, StyleSheet } from 'react-native';
import { useModuleAccessStore, type ModuleType } from '@/src/stores/moduleAccessStore';
import ModuleLockedScreen from '@/src/components/learning/ModuleLockedScreen';

// ==================== ç±»å‹å®šä¹‰ ====================

interface ModuleGuardProps {
    moduleType: ModuleType;
    children: React.ReactNode;
}

// ==================== ç»„ä»¶ ====================

/**
 * æ¨¡å—è®¿é—®å®ˆå«
 * 
 * @param moduleType æ¨¡å—ç±»å‹
 * @param children å­ç»„ä»¶ï¼ˆå­¦ä¹ é¡µé¢ï¼‰
 */
export default function ModuleGuard({ moduleType, children }: ModuleGuardProps) {
    const { checkAccess, getUserProgress } = useModuleAccessStore();
    const [hasAccess, setHasAccess] = useState<boolean | null>(null);
    const [isChecking, setIsChecking] = useState(true);

    useEffect(() => {
        const checkModuleAccess = async () => {
            try {
                setIsChecking(true);

                // å…ˆè·å–ç”¨æˆ·è¿›åº¦æ•°æ®
                await getUserProgress();

                // æ£€æŸ¥è®¿é—®æƒé™
                const allowed = await checkAccess(moduleType);
                setHasAccess(allowed);
            } catch (error) {
                console.error('âŒ ModuleGuard: æƒé™æ£€æŸ¥å¤±è´¥', error);
                // å¦‚æœæ£€æŸ¥å¤±è´¥ï¼Œé»˜è®¤ä¸å…è®¸è®¿é—®ï¼ˆé™¤äº†å­—æ¯æ¨¡å—ï¼‰
                setHasAccess(moduleType === 'letter');
            } finally {
                setIsChecking(false);
            }
        };

        checkModuleAccess();
    }, [moduleType]);

    // ===== åŠ è½½çŠ¶æ€ =====
    if (isChecking || hasAccess === null) {
        return (
            <View style={styles.loadingContainer}>
                <ActivityIndicator size="large" color="#4A90E2" />
            </View>
        );
    }

    // ===== æƒé™ä¸è¶³ =====
    if (!hasAccess) {
        return <ModuleLockedScreen moduleType={moduleType} />;
    }

    // ===== æƒé™é€šè¿‡ï¼Œæ¸²æŸ“å­ç»„ä»¶ =====
    return <>{children}</>;
}

// ==================== æ ·å¼ ====================

const styles = StyleSheet.create({
    loadingContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: '#F5F9FF',
    },
});
````

## File: .nvmrc
````
20.19.4
````

## File: .claude/settings.local.json
````json
{
  "permissions": {
    "allow": [
      "Bash(cat:*)",
      "Bash(npx tsc:*)",
      "Bash(grep:*)"
    ],
    "deny": [],
    "ask": []
  }
}
````

## File: app/(auth)/_layout.tsx
````typescript
// app/(auth)/_layout.tsx
import { Stack } from 'expo-router';
import { useEffect } from 'react';
import { useRouter } from 'expo-router';
import { useUserStore } from '@/src/stores/userStore';

export default function AuthLayout() {
  const router = useRouter();
  const { isAuthenticated } = useUserStore();

  useEffect(() => {
    if (isAuthenticated) {
      router.replace('/(tabs)');
    }
  }, [isAuthenticated]);

  return (
    <Stack screenOptions={{ headerShown: false }}>
      <Stack.Screen name="login" />
      <Stack.Screen name="register" />
    </Stack>
  );
}
````

## File: cloudbase/functions/alphabet/handlers/getLetterTest.js
````javascript
// âœ… è·å–å›ºå®šå­—æ¯æµ‹è¯•é¢˜
const { createResponse } = require('../utils/response');

async function getLetterTest(db) {
    const res = await db.collection('letter_test_bank')
        .limit(20) // ä½ è¯´æ˜¯å›ºå®šé¢˜ï¼Œä¸éœ€è¦éšæœº
        .get();

    return createResponse(true, {
        total: res.data.length,
        questions: res.data
    }, 'è·å–å­—æ¯æµ‹è¯•é¢˜æˆåŠŸ');
}

module.exports = getLetterTest;
````

## File: cloudbase/functions/alphabet/utils/constants.js
````javascript
/**
 * å¸¸é‡å®šä¹‰æ¨¡å—
 * 
 * ä¸å‰ç«¯ src/config/constants.ts ä¿æŒä¸€è‡´çš„è®¾è®¡é£æ ¼
 * é›†ä¸­ç®¡ç†æ‰€æœ‰äº‘å‡½æ•°å¸¸é‡
 */

'use strict';

// ==================== æ•°æ®åº“é›†åˆåç§° ====================
// ä¸å‰ç«¯ COLLECTIONS ä¿æŒä¸€è‡´
const COLLECTIONS = {
  USERS: 'users',
  VOCABULARY: 'vocabulary',
  USER_VOCABULARY_PROGRESS: 'user_vocabulary_progress',
  LETTERS: 'letters',
  USER_ALPHABET_PROGRESS: 'user_alphabet_progress',
  LETTER_TEST_BANK: 'letter_test_bank',
  COURSES: 'courses',
  LESSONS: 'lessons',
  PROGRESS: 'progress',
};

// ==================== æŒæ¡ç¨‹åº¦ ====================
// ä½¿ç”¨ä¸­æ–‡å€¼ï¼Œä¾¿äºå‰ç«¯ç›´æ¥æ˜¾ç¤º
const MasteryLevel = Object.freeze({
  UNFAMILIAR: 'é™Œç”Ÿ',
  FUZZY: 'æ¨¡ç³Š',
  REMEMBERED: 'è®°å¾—',
});

// ==================== å­¦ä¹ ç­‰çº§ ====================
// ä¸å‰ç«¯ LEVELS ä¿æŒä¸€è‡´
const LEVELS = Object.freeze({
  BEGINNER_A: 'BEGINNER_A',
  BEGINNER_B: 'BEGINNER_B',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED',
});

// ==================== SM-2 ç®—æ³•å‚æ•° ====================
// ä¼˜åŒ–ç‰ˆå‚æ•°ï¼ŒåŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿
const SM2_PARAMS = Object.freeze({
  INITIAL_EASINESS_FACTOR: 2.5,   // åˆå§‹ç®€æ˜“åº¦
  MIN_EASINESS_FACTOR: 1.3,       // æœ€å°ç®€æ˜“åº¦
  MAX_INTERVAL_DAYS: 180,         // æœ€å¤§é—´éš”ï¼ˆå¤©ï¼‰
  FUZZY_MULTIPLIER: 0.8,          // "æ¨¡ç³Š"æ—¶é—´éš”ç¼©çŸ­æ¯”ä¾‹
});

// ==================== æ—©æœŸå¤ä¹ é—´éš”åºåˆ— ====================
// åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–: 1â†’2â†’4â†’7â†’14 å¤©
const EARLY_INTERVALS = Object.freeze([1, 2, 4, 7, 14]);

// ==================== æ¯æ—¥å­¦ä¹ é…ç½® ====================
const DAILY_LEARNING_CONFIG = Object.freeze({
  MAX_NEW_WORDS: 10,              // æ¯æ—¥æ–°è¯ä¸Šé™
  MAX_REVIEW_WORDS: 20,           // æ¯æ—¥å¤ä¹ ä¸Šé™
  TOTAL_WORDS_LIMIT: 30,          // æ¯æ—¥æ€»è¯æ•°ä¸Šé™
});

// ==================== é”™è¯¯ç  ====================
// ç»Ÿä¸€é”™è¯¯ç å®šä¹‰
const ErrorCodes = Object.freeze({
  SUCCESS: 'SUCCESS',
  USER_NOT_FOUND: 'USER_NOT_FOUND',
  VOCABULARY_NOT_FOUND: 'VOCABULARY_NOT_FOUND',
  INVALID_PARAMS: 'INVALID_PARAMS',
  INVALID_MASTERY: 'INVALID_MASTERY',
  UNKNOWN_ACTION: 'UNKNOWN_ACTION',
  SERVER_ERROR: 'SERVER_ERROR',
});

// ==================== é”™è¯¯æ¶ˆæ¯ ====================
// ä¸å‰ç«¯ ERROR_MESSAGES é£æ ¼ä¸€è‡´
const ERROR_MESSAGES = Object.freeze({
  USER_NOT_FOUND: 'ç”¨æˆ·ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥ç”¨æˆ·IDæˆ–é‡æ–°ç™»å½•',
  VOCABULARY_NOT_FOUND: 'è¯æ±‡ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥è¯æ±‡ID',
  INVALID_PARAMS: 'å‚æ•°æ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥è¾“å…¥',
  INVALID_MASTERY: 'æ— æ•ˆçš„æŒæ¡ç¨‹åº¦ï¼Œå…è®¸å€¼: é™Œç”Ÿ/æ¨¡ç³Š/è®°å¾—',
  UNKNOWN_ACTION: 'æœªçŸ¥æ“ä½œç±»å‹',
  SERVER_ERROR: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•',
});

// ==================== æ”¯æŒçš„ Actions ====================
const SUPPORTED_ACTIONS = Object.freeze([
  'getTodayWords',
  'updateMastery',
  'toggleSkipWord',
  'getVocabularyDetail',
  'getReviewStatistics',
  'getVocabularyList',
  'getSkippedWords',
  'getLetterTest',
  'submitLetterTest',
  'passLetterTest',
  'getTodayMemories',
  'submitMemoryResult',
  'checkModuleAccess',
  'getUserProgress'
]);

module.exports = {
  // é›†åˆ
  COLLECTIONS,

  // æšä¸¾
  MasteryLevel,
  LEVELS,
  ErrorCodes,

  // ç®—æ³•å‚æ•°
  SM2_PARAMS,
  EARLY_INTERVALS,

  // é…ç½®
  DAILY_LEARNING_CONFIG,

  // æ¶ˆæ¯
  ERROR_MESSAGES,
  SUPPORTED_ACTIONS,
};
````

## File: cloudbase/functions/alphabet/package.json
````json
{
  "name": "alphabet",
  "version": "1.0.0",
  "description": "Alphabet learning function",
  "main": "index.js",
  "dependencies": {
    "wx-server-sdk": "latest"
  },
  "engines": {
    "node": "18.20.0"
  }
}
````

## File: cloudbase/functions/learn-vocab/utils/constants.js
````javascript
/**
 * å¸¸é‡å®šä¹‰æ¨¡å—
 * 
 * ä¸å‰ç«¯ src/config/constants.ts ä¿æŒä¸€è‡´çš„è®¾è®¡é£æ ¼
 * é›†ä¸­ç®¡ç†æ‰€æœ‰äº‘å‡½æ•°å¸¸é‡
 */

'use strict';

// ==================== æ•°æ®åº“é›†åˆåç§° ====================
// ä¸å‰ç«¯ COLLECTIONS ä¿æŒä¸€è‡´
const COLLECTIONS = {
  USERS: 'users',
  VOCABULARY: 'vocabulary',
  USER_VOCABULARY_PROGRESS: 'user_vocabulary_progress',
  LETTERS: 'letters',
  USER_ALPHABET_PROGRESS: 'user_alphabet_progress',
  LETTER_TEST_BANK: 'letter_test_bank',
  COURSES: 'courses',
  LESSONS: 'lessons',
  PROGRESS: 'progress',
};

// ==================== æŒæ¡ç¨‹åº¦ ====================
// ä½¿ç”¨ä¸­æ–‡å€¼ï¼Œä¾¿äºå‰ç«¯ç›´æ¥æ˜¾ç¤º
const MasteryLevel = Object.freeze({
  UNFAMILIAR: 'é™Œç”Ÿ',
  FUZZY: 'æ¨¡ç³Š',
  REMEMBERED: 'è®°å¾—',
});

// ==================== å­¦ä¹ ç­‰çº§ ====================
// ä¸å‰ç«¯ LEVELS ä¿æŒä¸€è‡´
const LEVELS = Object.freeze({
  BEGINNER_A: 'BEGINNER_A',
  BEGINNER_B: 'BEGINNER_B',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED',
});

// ==================== SM-2 ç®—æ³•å‚æ•° ====================
// ä¼˜åŒ–ç‰ˆå‚æ•°ï¼ŒåŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿
const SM2_PARAMS = Object.freeze({
  INITIAL_EASINESS_FACTOR: 2.5,   // åˆå§‹ç®€æ˜“åº¦
  MIN_EASINESS_FACTOR: 1.3,       // æœ€å°ç®€æ˜“åº¦
  MAX_INTERVAL_DAYS: 180,         // æœ€å¤§é—´éš”ï¼ˆå¤©ï¼‰
  FUZZY_MULTIPLIER: 0.8,          // "æ¨¡ç³Š"æ—¶é—´éš”ç¼©çŸ­æ¯”ä¾‹
});

// ==================== æ—©æœŸå¤ä¹ é—´éš”åºåˆ— ====================
// åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–: 1â†’2â†’4â†’7â†’14 å¤©
const EARLY_INTERVALS = Object.freeze([1, 2, 4, 7, 14]);

// ==================== æ¯æ—¥å­¦ä¹ é…ç½® ====================
const DAILY_LEARNING_CONFIG = Object.freeze({
  MAX_NEW_WORDS: 10,              // æ¯æ—¥æ–°è¯ä¸Šé™
  MAX_REVIEW_WORDS: 20,           // æ¯æ—¥å¤ä¹ ä¸Šé™
  TOTAL_WORDS_LIMIT: 30,          // æ¯æ—¥æ€»è¯æ•°ä¸Šé™
});

// ==================== é”™è¯¯ç  ====================
// ç»Ÿä¸€é”™è¯¯ç å®šä¹‰
const ErrorCodes = Object.freeze({
  SUCCESS: 'SUCCESS',
  USER_NOT_FOUND: 'USER_NOT_FOUND',
  VOCABULARY_NOT_FOUND: 'VOCABULARY_NOT_FOUND',
  INVALID_PARAMS: 'INVALID_PARAMS',
  INVALID_MASTERY: 'INVALID_MASTERY',
  UNKNOWN_ACTION: 'UNKNOWN_ACTION',
  SERVER_ERROR: 'SERVER_ERROR',
});

// ==================== é”™è¯¯æ¶ˆæ¯ ====================
// ä¸å‰ç«¯ ERROR_MESSAGES é£æ ¼ä¸€è‡´
const ERROR_MESSAGES = Object.freeze({
  USER_NOT_FOUND: 'ç”¨æˆ·ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥ç”¨æˆ·IDæˆ–é‡æ–°ç™»å½•',
  VOCABULARY_NOT_FOUND: 'è¯æ±‡ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥è¯æ±‡ID',
  INVALID_PARAMS: 'å‚æ•°æ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥è¾“å…¥',
  INVALID_MASTERY: 'æ— æ•ˆçš„æŒæ¡ç¨‹åº¦ï¼Œå…è®¸å€¼: é™Œç”Ÿ/æ¨¡ç³Š/è®°å¾—',
  UNKNOWN_ACTION: 'æœªçŸ¥æ“ä½œç±»å‹',
  SERVER_ERROR: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•',
});

// ==================== æ”¯æŒçš„ Actions ====================
const SUPPORTED_ACTIONS = Object.freeze([
  'getTodayWords',
  'updateMastery',
  'toggleSkipWord',
  'getVocabularyDetail',
  'getReviewStatistics',
  'getVocabularyList',
  'getSkippedWords',
  'getLetterTest',
  'submitLetterTest',
  'passLetterTest',
  'getTodayMemories',
  'submitMemoryResult',
  'checkModuleAccess',
  'getUserProgress'
]);

module.exports = {
  // é›†åˆ
  COLLECTIONS,

  // æšä¸¾
  MasteryLevel,
  LEVELS,
  ErrorCodes,

  // ç®—æ³•å‚æ•°
  SM2_PARAMS,
  EARLY_INTERVALS,

  // é…ç½®
  DAILY_LEARNING_CONFIG,

  // æ¶ˆæ¯
  ERROR_MESSAGES,
  SUPPORTED_ACTIONS,
};
````

## File: cloudbase/functions/learn-vocab/utils/database.js
````javascript
const cloud = require('wx-server-sdk');

cloud.init({
    env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();
const _ = db.command;

const collections = {
    users: db.collection('users'),
    vocabulary: db.collection('vocabulary'),
    letters: db.collection('letters'),
    sentences: db.collection('sentences'),
    memory_status: db.collection('memory_status'),
    user_progress: db.collection('user_progress'),
    user_vocabulary_progress: db.collection('user_vocabulary_progress')
};

module.exports = {
    db,
    _,
    userCollection: collections.users,
    vocabularyCollection: collections.vocabulary,
    letterCollection: collections.letters,
    sentenceCollection: collections.sentences,
    memoryStatusCollection: collections.memory_status,
    userProgressCollection: collections.user_progress,
    progressCollection: collections.user_vocabulary_progress,
    collections
};
````

## File: cloudbase/functions/learn-vocab/utils/response.js
````javascript
/**
 * å“åº”æ ¼å¼åŒ–æ¨¡å—
 * 
 * ç»Ÿä¸€ API å“åº”æ ¼å¼
 * ä¸å‰ç«¯ ApiResponse<T> ç±»å‹å®šä¹‰ä¿æŒä¸€è‡´
 */

'use strict';

const { ErrorCodes, ERROR_MESSAGES } = require('./constants');

/**
 * åˆ›å»ºæ ‡å‡†åŒ– API å“åº”
 * 
 * å¯¹åº”å‰ç«¯ç±»å‹:
 * interface ApiResponse<T> {
 *   success: boolean;
 *   data?: T;
 *   message?: string;
 *   errorCode?: string;
 *   timestamp: string;
 * }
 * 
 * @param {boolean} success - æ˜¯å¦æˆåŠŸ
 * @param {Object} data - è¿”å›æ•°æ®
 * @param {string} message - æç¤ºæ¶ˆæ¯
 * @param {string} errorCode - é”™è¯¯ç 
 * @returns {Object} æ ‡å‡†åŒ–å“åº”å¯¹è±¡
 */
function createResponse(success, data = null, message = '', errorCode = null) {
  return {
    success,
    data,
    message,
    errorCode,
    timestamp: new Date().toISOString(),
  };
}

/**
 * åˆ›å»ºæˆåŠŸå“åº”
 * 
 * @param {Object} data - è¿”å›æ•°æ®
 * @param {string} message - æˆåŠŸæ¶ˆæ¯
 * @returns {Object} æˆåŠŸå“åº”å¯¹è±¡
 */
function successResponse(data, message = 'æ“ä½œæˆåŠŸ') {
  return createResponse(true, data, message, null);
}

/**
 * åˆ›å»ºé”™è¯¯å“åº”
 * 
 * @param {string} errorCode - é”™è¯¯ç  (æ¥è‡ª ErrorCodes)
 * @param {string} customMessage - è‡ªå®šä¹‰æ¶ˆæ¯ (å¯é€‰)
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function errorResponse(errorCode, customMessage = null) {
  const message = customMessage || ERROR_MESSAGES[errorCode] || 'æœªçŸ¥é”™è¯¯';
  return createResponse(false, null, message, errorCode);
}

/**
 * åˆ›å»ºå‚æ•°é”™è¯¯å“åº”
 * 
 * @param {string} detail - é”™è¯¯è¯¦æƒ…
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function invalidParamsResponse(detail) {
  return errorResponse(ErrorCodes.INVALID_PARAMS, detail);
}

/**
 * åˆ›å»ºç”¨æˆ·ä¸å­˜åœ¨å“åº”
 * 
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function userNotFoundResponse() {
  return errorResponse(ErrorCodes.USER_NOT_FOUND);
}

/**
 * åˆ›å»ºè¯æ±‡ä¸å­˜åœ¨å“åº”
 * 
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function vocabularyNotFoundResponse() {
  return errorResponse(ErrorCodes.VOCABULARY_NOT_FOUND);
}

/**
 * åˆ›å»ºæœåŠ¡å™¨é”™è¯¯å“åº”
 * 
 * @param {Error} error - é”™è¯¯å¯¹è±¡
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function serverErrorResponse(error) {
  // ç”Ÿäº§ç¯å¢ƒä¸æš´éœ²é”™è¯¯è¯¦æƒ…
  const message = process.env.NODE_ENV === 'development' 
    ? `æœåŠ¡å™¨é”™è¯¯: ${error.message}`
    : ERROR_MESSAGES.SERVER_ERROR;
  
  return errorResponse(ErrorCodes.SERVER_ERROR, message);
}

module.exports = {
  createResponse,
  successResponse,
  errorResponse,
  invalidParamsResponse,
  userNotFoundResponse,
  vocabularyNotFoundResponse,
  serverErrorResponse,
};
````

## File: cloudbase/functions/learn-vocab/package.json
````json
{
  "name": "learn-vocab",
  "version": "1.2.0",
  "description": "Thai Learning App - è¯æ±‡å­¦ä¹ äº‘å‡½æ•° (æ¨¡å—åŒ–ç‰ˆæœ¬)",
  "main": "index.js",
  "scripts": {
    "deploy": "tcb fn deploy learn-vocab",
    "logs": "tcb fn log learn-vocab",
    "test": "tcb fn invoke learn-vocab --data '{\"action\":\"getVocabularyList\",\"data\":{\"limit\":3}}'",
    "test:today": "tcb fn invoke learn-vocab --data '{\"action\":\"getTodayWords\",\"data\":{\"userId\":\"test\",\"limit\":5}}'",
    "test:stats": "tcb fn invoke learn-vocab --data '{\"action\":\"getReviewStatistics\",\"data\":{\"userId\":\"test\"}}'"
  },
  "dependencies": {
    "wx-server-sdk": "~2.6.3"
  },
  "author": "Liang JianYu",
  "license": "MIT",
  "keywords": [
    "thai",
    "language-learning",
    "vocabulary",
    "cloudbase",
    "sm2-algorithm",
    "spaced-repetition",
    "modular"
  ],
  "engines": {
    "node": "18.20.0"
  }
}
````

## File: cloudbase/functions/memory-engine/handlers/submitRoundEvaluation.js
````javascript
'use strict';

/**
 * æäº¤å­—æ¯æ¨¡å—çš„ä¸‰è½®è¯„ä¼°ç»“æœï¼ˆæ¯è½®ä¸€ä¸ªæ€»åˆ†ï¼‰
 *
 * è®¾è®¡ç›®æ ‡ï¼š
 * - å­—æ¯ç”¨æˆ·å‰ç«¯åªæœ‰â€œå¯¹/é”™â€æŒ‰é’®ï¼Œä¸é€‰æ‹© AGAIN/HARD/GOOD/EASYï¼›
 * - æ¯è½®ç»“æŸæ—¶å‰ç«¯è®¡ç®—æ•´ä½“æ­£ç¡®ç‡ accuracyï¼Œå¹¶ä¸Šä¼ åˆ°æ­¤ handlerï¼Œ
 *   ä»…ç”¨äºè®°å½•åˆ° user_alphabet_progress.roundHistoryï¼Œä¸æ”¹å˜ SM-2 è®°å¿†ç®—æ³•ï¼›
 * - è¿™æ ·å¯ä»¥åœ¨ä¸ä¿®æ”¹ updateMemoryAfterReview çš„å‰æä¸‹ï¼Œä¿ç•™è½®æ¬¡çº§åˆ«çš„ç»Ÿè®¡æ•°æ®ã€‚
 */

const { createResponse } = require('../utils/response');

/**
 * @param {Object} db     - cloud.database()
 * @param {Object} params - { userId, entityType, lessonId, roundNumber, totalQuestions, correctCount, accuracy }
 */
async function submitRoundEvaluation(db, params) {
  const {
    userId,
    entityType,
    lessonId,
    roundNumber,
    totalQuestions,
    correctCount,
    accuracy,
  } = params || {};

  if (!userId || !entityType || !lessonId || !roundNumber) {
    return createResponse(
      false,
      null,
      'ç¼ºå°‘å¿…å¡«å‚æ•°: userId, entityType, lessonId, roundNumber',
      'INVALID_PARAMS',
    );
  }

  if (entityType !== 'letter') {
    return createResponse(
      false,
      null,
      'submitRoundEvaluation ç›®å‰ä»…æ”¯æŒ entityType = letter',
      'INVALID_ENTITY_TYPE',
    );
  }

  const total = typeof totalQuestions === 'number' ? totalQuestions : 0;
  const correct = typeof correctCount === 'number' ? correctCount : 0;
  const acc = typeof accuracy === 'number' && !Number.isNaN(accuracy)
    ? accuracy
    : total > 0
      ? correct / total
      : 0;

  const passed = acc >= 0.9;
  const now = new Date().toISOString();

  const col = db.collection('user_alphabet_progress');

  try {
    const existing = await col.where({ userId }).limit(1).get();

    const roundEntry = {
      lessonId,
      roundNumber,
      totalQuestions: total,
      correctCount: correct,
      accuracy: acc,
      passed,
      updatedAt: now,
    };

    if (!existing.data || existing.data.length === 0) {
      // ğŸ”¥ ä¿®æ­£ï¼šé¦–æ¬¡åˆ›å»ºæ—¶çš„ nextRound è®¡ç®—ï¼ˆé˜²æ­¢è·¨è¯¾æ±¡æŸ“ï¼‰
      const nextRound = passed
        ? (roundNumber < 3 ? roundNumber + 1 : 1)
        : 1;

      // ğŸ”¥ P0-B: é¦–æ¬¡åˆ›å»ºæ—¶ä¹Ÿè¦åˆ¤å®š completedLessons
      const initialCompletedLessons = (passed && roundNumber === 3 && lessonId)
        ? [lessonId]
        : [];

      console.log(`ğŸ” [P0-B-init] roundNumber: ${roundNumber}, passed: ${passed}, lessonId: ${lessonId || 'N/A'}, initialCompleted: [${initialCompletedLessons.join(',')}], nextRound: ${nextRound}`);

      // æ²¡æœ‰è¿›åº¦è®°å½•æ—¶ï¼Œæ’å…¥ä¸€æ¡å¸¦æœ‰ roundHistory çš„é»˜è®¤è®°å½•
      await col.add({
        data: {
          userId,
          letterProgress: 0.0,
          letterCompleted: false,
          completedLessons: initialCompletedLessons, // ğŸ”¥ P0-B: åˆå§‹å€¼
          masteredLetterCount: 0,
          totalLetterCount: 80,
          currentRound: nextRound, // ğŸ”¥ ä½¿ç”¨ä¿®æ­£åçš„ nextRound
          roundHistory: [roundEntry],
          createdAt: now,
          updatedAt: now,
        },
      });
    } else {
      const doc = existing.data[0];
      const docId = doc._id;
      const history = Array.isArray(doc.roundHistory) ? doc.roundHistory : [];

      // æ›¿æ¢åŒä¸€ lessonId + roundNumber çš„æ—§è®°å½•
      const filtered = history.filter(
        (r) => !(r.lessonId === lessonId && r.roundNumber === roundNumber),
      );
      filtered.push(roundEntry);

      // ğŸ”¥ P0-B: Round3 passed æ—¶å†™å…¥ completedLessons
      let updatedCompletedLessons = Array.isArray(doc.completedLessons)
        ? [...doc.completedLessons]
        : [];

      const completedLessonsBefore = [...updatedCompletedLessons];

      if (passed && roundNumber === 3 && lessonId) {
        if (!updatedCompletedLessons.includes(lessonId)) {
          updatedCompletedLessons.push(lessonId);
        }
      }

      console.log(`ğŸ” [P0-B] roundNumber: ${roundNumber}, passed: ${passed}, lessonId: ${lessonId || 'N/A'}, completedBefore: [${completedLessonsBefore.join(',')}], completedAfter: [${updatedCompletedLessons.join(',')}]`);

      // ğŸ”¥ ä¿®æ­£ï¼šnextRound é‡ç½®é˜²æ­¢è·¨è¯¾æ±¡æŸ“
      const nextRound = passed
        ? (roundNumber < 3 ? roundNumber + 1 : 1)
        : 1;

      await col.doc(docId).update({
        data: {
          currentRound: nextRound,
          roundHistory: filtered,
          completedLessons: updatedCompletedLessons, // ğŸ”¥ P0-B: å†™å…¥ completedLessons
          updatedAt: now,
        },
      });
    }

    return createResponse(true, { round: roundEntry }, 'æäº¤è½®æ¬¡è¯„ä¼°æˆåŠŸ');
  } catch (err) {
    console.error('[submitRoundEvaluation] error:', err);
    return createResponse(
      false,
      null,
      err.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      'SERVER_ERROR',
    );
  }
}

module.exports = submitRoundEvaluation;
````

## File: cloudbase/functions/memory-engine/utils/constants.js
````javascript
/**
 * å¸¸é‡å®šä¹‰æ¨¡å—
 * 
 * ä¸å‰ç«¯ src/config/constants.ts ä¿æŒä¸€è‡´çš„è®¾è®¡é£æ ¼
 * é›†ä¸­ç®¡ç†æ‰€æœ‰äº‘å‡½æ•°å¸¸é‡
 */

'use strict';

// ==================== æ•°æ®åº“é›†åˆåç§° ====================
// ä¸å‰ç«¯ COLLECTIONS ä¿æŒä¸€è‡´
const COLLECTIONS = {
  USERS: 'users',
  VOCABULARY: 'vocabulary',
  USER_VOCABULARY_PROGRESS: 'user_vocabulary_progress',
  LETTERS: 'letters',
  USER_ALPHABET_PROGRESS: 'user_alphabet_progress',
  LETTER_TEST_BANK: 'letter_test_bank',
  COURSES: 'courses',
  LESSONS: 'lessons',
  PROGRESS: 'progress',
};

// ==================== æŒæ¡ç¨‹åº¦ ====================
// ä½¿ç”¨ä¸­æ–‡å€¼ï¼Œä¾¿äºå‰ç«¯ç›´æ¥æ˜¾ç¤º
const MasteryLevel = Object.freeze({
  UNFAMILIAR: 'é™Œç”Ÿ',
  FUZZY: 'æ¨¡ç³Š',
  REMEMBERED: 'è®°å¾—',
});

// ==================== å­¦ä¹ ç­‰çº§ ====================
// ä¸å‰ç«¯ LEVELS ä¿æŒä¸€è‡´
const LEVELS = Object.freeze({
  BEGINNER_A: 'BEGINNER_A',
  BEGINNER_B: 'BEGINNER_B',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED',
});

// ==================== SM-2 ç®—æ³•å‚æ•° ====================
// ä¼˜åŒ–ç‰ˆå‚æ•°ï¼ŒåŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿
const SM2_PARAMS = Object.freeze({
  INITIAL_EASINESS_FACTOR: 2.5,   // åˆå§‹ç®€æ˜“åº¦
  MIN_EASINESS_FACTOR: 1.3,       // æœ€å°ç®€æ˜“åº¦
  MAX_INTERVAL_DAYS: 180,         // æœ€å¤§é—´éš”ï¼ˆå¤©ï¼‰
  FUZZY_MULTIPLIER: 0.8,          // "æ¨¡ç³Š"æ—¶é—´éš”ç¼©çŸ­æ¯”ä¾‹
});

// ==================== æ—©æœŸå¤ä¹ é—´éš”åºåˆ— ====================
// åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–: 1â†’2â†’4â†’7â†’14 å¤©
const EARLY_INTERVALS = Object.freeze([1, 2, 4, 7, 14]);

// ==================== æ¯æ—¥å­¦ä¹ é…ç½® ====================
const DAILY_LEARNING_CONFIG = Object.freeze({
  MAX_NEW_WORDS: 10,              // æ¯æ—¥æ–°è¯ä¸Šé™
  MAX_REVIEW_WORDS: 20,           // æ¯æ—¥å¤ä¹ ä¸Šé™
  TOTAL_WORDS_LIMIT: 30,          // æ¯æ—¥æ€»è¯æ•°ä¸Šé™
});

// ==================== é”™è¯¯ç  ====================
// ç»Ÿä¸€é”™è¯¯ç å®šä¹‰
const ErrorCodes = Object.freeze({
  SUCCESS: 'SUCCESS',
  USER_NOT_FOUND: 'USER_NOT_FOUND',
  VOCABULARY_NOT_FOUND: 'VOCABULARY_NOT_FOUND',
  INVALID_PARAMS: 'INVALID_PARAMS',
  INVALID_MASTERY: 'INVALID_MASTERY',
  UNKNOWN_ACTION: 'UNKNOWN_ACTION',
  SERVER_ERROR: 'SERVER_ERROR',
});

// ==================== é”™è¯¯æ¶ˆæ¯ ====================
// ä¸å‰ç«¯ ERROR_MESSAGES é£æ ¼ä¸€è‡´
const ERROR_MESSAGES = Object.freeze({
  USER_NOT_FOUND: 'ç”¨æˆ·ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥ç”¨æˆ·IDæˆ–é‡æ–°ç™»å½•',
  VOCABULARY_NOT_FOUND: 'è¯æ±‡ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥è¯æ±‡ID',
  INVALID_PARAMS: 'å‚æ•°æ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥è¾“å…¥',
  INVALID_MASTERY: 'æ— æ•ˆçš„æŒæ¡ç¨‹åº¦ï¼Œå…è®¸å€¼: é™Œç”Ÿ/æ¨¡ç³Š/è®°å¾—',
  UNKNOWN_ACTION: 'æœªçŸ¥æ“ä½œç±»å‹',
  SERVER_ERROR: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•',
});

// ==================== æ”¯æŒçš„ Actions ====================
const SUPPORTED_ACTIONS = Object.freeze([
  'getTodayWords',
  'updateMastery',
  'toggleSkipWord',
  'getVocabularyDetail',
  'getReviewStatistics',
  'getVocabularyList',
  'getSkippedWords',
  'getLetterTest',
  'submitLetterTest',
  'passLetterTest',
  'getTodayMemories',
  'submitMemoryResult',
  'submitRoundEvaluation',
  'checkModuleAccess',
  'getUserProgress',
  'getAlphabetLessons',
]);

module.exports = {
  // é›†åˆ
  COLLECTIONS,

  // æšä¸¾
  MasteryLevel,
  LEVELS,
  ErrorCodes,

  // ç®—æ³•å‚æ•°
  SM2_PARAMS,
  EARLY_INTERVALS,

  // é…ç½®
  DAILY_LEARNING_CONFIG,

  // æ¶ˆæ¯
  ERROR_MESSAGES,
  SUPPORTED_ACTIONS,
};
````

## File: cloudbase/functions/memory-engine/utils/database.js
````javascript
const cloud = require('wx-server-sdk');

cloud.init({
    env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();
const _ = db.command;

const collections = {
    users: db.collection('users'),
    vocabulary: db.collection('vocabulary'),
    letters: db.collection('letters'),
    sentences: db.collection('sentences'),
    memory_status: db.collection('memory_status'),
    user_progress: db.collection('user_progress'),
    user_vocabulary_progress: db.collection('user_vocabulary_progress')
};

module.exports = {
    db,
    _,
    userCollection: collections.users,
    vocabularyCollection: collections.vocabulary,
    letterCollection: collections.letters,
    sentenceCollection: collections.sentences,
    memoryStatusCollection: collections.memory_status,
    userProgressCollection: collections.user_progress,
    progressCollection: collections.user_vocabulary_progress,
    collections
};
````

## File: cloudbase/functions/memory-engine/utils/response.js
````javascript
/**
 * å“åº”æ ¼å¼åŒ–æ¨¡å—
 * 
 * ç»Ÿä¸€ API å“åº”æ ¼å¼
 * ä¸å‰ç«¯ ApiResponse<T> ç±»å‹å®šä¹‰ä¿æŒä¸€è‡´
 */

'use strict';

const { ErrorCodes, ERROR_MESSAGES } = require('./constants');

/**
 * åˆ›å»ºæ ‡å‡†åŒ– API å“åº”
 * 
 * å¯¹åº”å‰ç«¯ç±»å‹:
 * interface ApiResponse<T> {
 *   success: boolean;
 *   data?: T;
 *   message?: string;
 *   errorCode?: string;
 *   timestamp: string;
 * }
 * 
 * @param {boolean} success - æ˜¯å¦æˆåŠŸ
 * @param {Object} data - è¿”å›æ•°æ®
 * @param {string} message - æç¤ºæ¶ˆæ¯
 * @param {string} errorCode - é”™è¯¯ç 
 * @returns {Object} æ ‡å‡†åŒ–å“åº”å¯¹è±¡
 */
function createResponse(success, data = null, message = '', errorCode = null) {
  return {
    success,
    data,
    message,
    errorCode,
    timestamp: new Date().toISOString(),
  };
}

/**
 * åˆ›å»ºæˆåŠŸå“åº”
 * 
 * @param {Object} data - è¿”å›æ•°æ®
 * @param {string} message - æˆåŠŸæ¶ˆæ¯
 * @returns {Object} æˆåŠŸå“åº”å¯¹è±¡
 */
function successResponse(data, message = 'æ“ä½œæˆåŠŸ') {
  return createResponse(true, data, message, null);
}

/**
 * åˆ›å»ºé”™è¯¯å“åº”
 * 
 * @param {string} errorCode - é”™è¯¯ç  (æ¥è‡ª ErrorCodes)
 * @param {string} customMessage - è‡ªå®šä¹‰æ¶ˆæ¯ (å¯é€‰)
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function errorResponse(errorCode, customMessage = null) {
  const message = customMessage || ERROR_MESSAGES[errorCode] || 'æœªçŸ¥é”™è¯¯';
  return createResponse(false, null, message, errorCode);
}

/**
 * åˆ›å»ºå‚æ•°é”™è¯¯å“åº”
 * 
 * @param {string} detail - é”™è¯¯è¯¦æƒ…
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function invalidParamsResponse(detail) {
  return errorResponse(ErrorCodes.INVALID_PARAMS, detail);
}

/**
 * åˆ›å»ºç”¨æˆ·ä¸å­˜åœ¨å“åº”
 * 
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function userNotFoundResponse() {
  return errorResponse(ErrorCodes.USER_NOT_FOUND);
}

/**
 * åˆ›å»ºè¯æ±‡ä¸å­˜åœ¨å“åº”
 * 
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function vocabularyNotFoundResponse() {
  return errorResponse(ErrorCodes.VOCABULARY_NOT_FOUND);
}

/**
 * åˆ›å»ºæœåŠ¡å™¨é”™è¯¯å“åº”
 * 
 * @param {Error} error - é”™è¯¯å¯¹è±¡
 * @returns {Object} é”™è¯¯å“åº”å¯¹è±¡
 */
function serverErrorResponse(error) {
  // ç”Ÿäº§ç¯å¢ƒä¸æš´éœ²é”™è¯¯è¯¦æƒ…
  const message = process.env.NODE_ENV === 'development' 
    ? `æœåŠ¡å™¨é”™è¯¯: ${error.message}`
    : ERROR_MESSAGES.SERVER_ERROR;
  
  return errorResponse(ErrorCodes.SERVER_ERROR, message);
}

module.exports = {
  createResponse,
  successResponse,
  errorResponse,
  invalidParamsResponse,
  userNotFoundResponse,
  vocabularyNotFoundResponse,
  serverErrorResponse,
};
````

## File: cloudbase/functions/memory-engine/utils/sm2.js
````javascript
/**
 * SM-2 é—´éš”é‡å¤ç®—æ³•æ¨¡å—ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
 * 
 * åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–:
 * - æ—©æœŸå¤ä¹ é—´éš”æ›´å¯†é›†: 1â†’2â†’4â†’7â†’14 å¤©
 * - "æ¨¡ç³Š"çŠ¶æ€ç¼©çŸ­é—´éš”è€Œéç»´æŒä¸å˜
 * - "é™Œç”Ÿ"çŠ¶æ€é‡ç½®å¤ä¹ è¿›åº¦
 * 
 * ç®—æ³•è®ºæ–‡: https://www.supermemo.com/en/archives1990-2015/english/ol/sm2
 */

'use strict';

const { MasteryLevel, SM2_PARAMS, EARLY_INTERVALS } = require('./constants');

/**
 * å°†æŒæ¡ç¨‹åº¦æ˜ å°„åˆ° SM-2 Quality å€¼
 * 
 * SM-2 Quality å®šä¹‰:
 * 0 - å®Œå…¨ä¸è®°å¾—
 * 1 - é”™è¯¯å›ç­”ï¼Œä½†çœ‹åˆ°æ­£ç¡®ç­”æ¡ˆåæƒ³èµ·
 * 2 - é”™è¯¯å›ç­”ï¼Œæ­£ç¡®ç­”æ¡ˆçœ‹èµ·æ¥å¾ˆç†Ÿæ‚‰
 * 3 - æ­£ç¡®å›ç­”ï¼Œä½†å›°éš¾è¾ƒå¤§
 * 4 - æ­£ç¡®å›ç­”ï¼Œæœ‰äº›çŠ¹è±«
 * 5 - æ­£ç¡®å›ç­”ï¼Œæ¯«æ— å›°éš¾
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦
 * @returns {number} Qualityå€¼ (1-5)
 */
function masteryToQuality(mastery) {
    switch (mastery) {
        case MasteryLevel.UNFAMILIAR:
            return 1;  // å®Œå…¨ä¸è®°å¾—
        case MasteryLevel.FUZZY:
            return 3;  // æœ‰å°è±¡ä½†ä¸ç¡®å®š
        case MasteryLevel.REMEMBERED:
            return 5;  // å®Œå…¨è®°å¾—
        default:
            return 1;
    }
}

/**
 * è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸï¼ˆä¼˜åŒ–ç‰ˆ SM-2 ç®—æ³•ï¼‰
 * 
 * æ”¹è¿›ç‚¹:
 * 1. æ—©æœŸé˜¶æ®µï¼ˆå‰5æ¬¡ï¼‰ä½¿ç”¨å›ºå®šçš„æ¸è¿›é—´éš” [1,2,4,7,14]
 * 2. "æ¨¡ç³Š"æ—¶ç¼©çŸ­é—´éš”è€Œéç»´æŒä¸å˜
 * 3. "é™Œç”Ÿ"æ—¶å®Œå…¨é‡ç½®å¤ä¹ è¿›åº¦
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦: å¿˜è®°/æ¨¡ç³Š/è®¤è¯†
 * @param {number} currentInterval - å½“å‰å¤ä¹ é—´éš”ï¼ˆå¤©ï¼‰
 * @param {number} easinessFactor - ç®€æ˜“åº¦å› å­ï¼ˆ1.3-2.5+ï¼‰
 * @param {number} reviewCount - å·²å¤ä¹ æ¬¡æ•°
 * @returns {Object} ç®—æ³•è®¡ç®—ç»“æœ
 * 
 * @example
 * const result = calculateSM2Optimized('è®¤è¯†', 2, 2.5, 1);
 * // {
 * //   nextInterval: 4,
 * //   nextEasinessFactor: 2.6,
 * //   nextReviewDate: "2025-12-01T10:00:00Z",
 * //   shouldResetCount: false
 * // }
 * */
function calculateSM2Optimized(
    mastery,
    currentInterval = 1,
    easinessFactor = SM2_PARAMS.INITIAL_EASINESS_FACTOR,
    reviewCount = 0
) {
    let nextInterval = currentInterval;
    let nextEF = easinessFactor;
    let shouldResetCount = false;

    const quality = masteryToQuality(mastery);

    // ==================== æ ¸å¿ƒç®—æ³•é€»è¾‘ ====================

    if (quality < 3) {
        // ========== å¿˜è®°: å®Œå…¨é‡ç½® ==========
        // ç”¨æˆ·å®Œå…¨ä¸è®°å¾—ï¼Œéœ€è¦ä»å¤´å¼€å§‹å­¦ä¹ 
        nextInterval = 1;
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF - 0.2);
        shouldResetCount = true;

    } else if (quality === 3) {
        // ========== æ¨¡ç³Š: ç¼©çŸ­é—´éš”ï¼ŒåŠ å¼ºå¤ä¹  ==========
        // æ”¹è¿›: ä¸æ˜¯ç»´æŒä¸å˜ï¼Œè€Œæ˜¯ç¼©çŸ­20%
        nextInterval = Math.max(1, Math.round(currentInterval * SM2_PARAMS.FUZZY_MULTIPLIER));
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF - 0.1);

    } else {
        // ========== è®°å¾—: ä½¿ç”¨ä¼˜åŒ–çš„é—´éš”åºåˆ— ==========
        if (reviewCount < EARLY_INTERVALS.length) {
            // æ—©æœŸé˜¶æ®µ: ä½¿ç”¨é¢„å®šä¹‰çš„æ¸è¿›é—´éš”
            // è¿™æ˜¯å…³é”®æ”¹è¿›: 1â†’2â†’4â†’7â†’14 è€ŒéåŸç‰ˆçš„ 1â†’6
            nextInterval = EARLY_INTERVALS[reviewCount];
        } else {
            // åæœŸé˜¶æ®µ: ä½¿ç”¨ EF è®¡ç®—æŒ‡æ•°å¢é•¿
            nextInterval = Math.round(currentInterval * nextEF);
        }

        // æé«˜ç®€æ˜“åº¦ (æ ‡å‡† SM-2 å…¬å¼)
        nextEF = nextEF + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF);
    }

    // é™åˆ¶æœ€å¤§é—´éš”
    nextInterval = Math.min(nextInterval, SM2_PARAMS.MAX_INTERVAL_DAYS);

    // è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸ
    const nextReviewDate = new Date();
    nextReviewDate.setDate(nextReviewDate.getDate() + nextInterval);

    // è®¡ç®—æ–°çš„å¤ä¹ æ¬¡æ•°
    const newRepetitions = shouldResetCount ? 0 : reviewCount + 1;

    return {
        // === å…¼å®¹ memoryEngine.js çš„æ—§æ¥å£ ===
        interval: nextInterval,
        easinessFactor: parseFloat(nextEF.toFixed(2)),
        repetitions: newRepetitions,

        // === æ–°æ¥å£ï¼ˆä¿ç•™ä¾›æœªæ¥ä½¿ç”¨ï¼‰===
        nextInterval,
        nextEasinessFactor: parseFloat(nextEF.toFixed(2)),
        nextReviewDate: nextReviewDate.toISOString(),
        shouldResetCount,
    };
}

/**
 * ç”Ÿæˆé¢„è®¡å¤ä¹ æ—¶é—´çº¿
 * 
 * ç”¨äºå‰ç«¯å±•ç¤ºæœªæ¥çš„å¤ä¹ è®¡åˆ’
 * 
 * @param {number} currentReviewCount - å½“å‰å¤ä¹ æ¬¡æ•°
 * @param {number} maxItems - è¿”å›çš„æ—¶é—´çº¿é¡¹æ•° (é»˜è®¤5)
 * @returns {Array} æœªæ¥å¤ä¹ è®¡åˆ’
 * 
 * @example
 * generateReviewTimeline(2);
 * // [
 * //   { reviewNumber: 3, intervalDays: 4 },
 * //   { reviewNumber: 4, intervalDays: 7 },
 * //   { reviewNumber: 5, intervalDays: 14 },
 * //   ...
 * // ]
 */
function generateReviewTimeline(currentReviewCount, maxItems = 5) {
    const timeline = [];
    let interval = 1;
    let ef = SM2_PARAMS.INITIAL_EASINESS_FACTOR;

    for (let i = currentReviewCount; i < currentReviewCount + maxItems; i++) {
        if (i < EARLY_INTERVALS.length) {
            interval = EARLY_INTERVALS[i];
        } else {
            interval = Math.round(interval * ef);
        }
        interval = Math.min(interval, SM2_PARAMS.MAX_INTERVAL_DAYS);

        timeline.push({
            reviewNumber: i + 1,
            intervalDays: interval,
        });
    }

    return timeline;
}

/**
 * è·å–ä»Šå¤©çš„æ—¶é—´èŒƒå›´ (UTC)
 * 
 * @returns {Object} { startOfDay, endOfDay, timestamp }
 */
function getTodayRange() {
    const now = new Date();
    const startOfDay = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate(),
        0, 0, 0, 0
    ));
    const endOfDay = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate() + 1,
        0, 0, 0, 0
    ));

    return {
        startOfDay: startOfDay.toISOString(),
        endOfDay: endOfDay.toISOString(),
        timestamp: now.toISOString(),
    };
}

/**
 * è·å–ç®—æ³•ä¿¡æ¯ (ç”¨äºå‰ç«¯å±•ç¤º)
 * 
 * @returns {Object} ç®—æ³•å…ƒä¿¡æ¯
 */
function getAlgorithmInfo() {
    return {
        name: 'Optimized SM-2',
        version: '1.1.0',
        earlyIntervals: EARLY_INTERVALS,
        maxInterval: SM2_PARAMS.MAX_INTERVAL_DAYS,
        description: 'åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–çš„é—´éš”é‡å¤ç®—æ³•',
    };
}

module.exports = {
    calculateSM2Optimized,
    generateReviewTimeline,
    getTodayRange,
    getAlgorithmInfo,
    masteryToQuality,
};
````

## File: cloudbase/functions/memory-engine/utils/validators.js
````javascript
/**
 * å‚æ•°éªŒè¯æ¨¡å—
 * 
 * ç”¨æˆ·ã€è¯æ±‡éªŒè¯åŠé€šç”¨éªŒè¯å·¥å…·
 */

'use strict';

const { userCollection, vocabularyCollection } = require('./database');
const { MasteryLevel } = require('./constants');

/**
 * éªŒè¯ç”¨æˆ·æ˜¯å¦å­˜åœ¨
 * 
 * @param {string} userId - ç”¨æˆ·ID
 * @returns {Promise<Object|null>} ç”¨æˆ·å¯¹è±¡æˆ– null
 */
async function validateUser(userId) {
    if (!userId || typeof userId !== 'string') {
        return null;
    }

    try {
        const { data } = await userCollection
            .where({ userId })
            .limit(1)
            .get();

        return data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('[validateUser] Error:', error);
        return null;
    }
}

/**
 * éªŒè¯è¯æ±‡æ˜¯å¦å­˜åœ¨
 * 
 * @param {string} vocabularyId - è¯æ±‡ID
 * @returns {Promise<Object|null>} è¯æ±‡å¯¹è±¡æˆ– null
 */
async function validateVocabulary(vocabularyId) {
    if (!vocabularyId || typeof vocabularyId !== 'string') {
        return null;
    }

    try {
        const { data } = await vocabularyCollection
            .where({ vocabularyId })
            .limit(1)
            .get();

        return data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('[validateVocabulary] Error:', error);
        return null;
    }
}

/**
 * éªŒè¯æŒæ¡ç¨‹åº¦æ˜¯å¦æœ‰æ•ˆ
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦
 * @returns {boolean} æ˜¯å¦æœ‰æ•ˆ
 */
function isValidMastery(mastery) {
    const validValues = Object.values(MasteryLevel);
    return validValues.includes(mastery);
}

/**
 * éªŒè¯å¹¶è§„èŒƒåŒ–åˆ†é¡µå‚æ•°
 * 
 * @param {number} limit - é™åˆ¶æ•°é‡
 * @param {number} offset - åç§»é‡
 * @param {number} maxLimit - æœ€å¤§é™åˆ¶ (é»˜è®¤100)
 * @returns {Object} éªŒè¯åçš„åˆ†é¡µå‚æ•°
 */
function validatePagination(limit, offset, maxLimit = 100) {
    return {
        limit: Math.min(Math.max(1, parseInt(limit) || 20), maxLimit),
        offset: Math.max(0, parseInt(offset) || 0),
    };
}

/**
 * éªŒè¯å¿…å¡«å­—ç¬¦ä¸²å‚æ•°
 * 
 * @param {string} value - å‚æ•°å€¼
 * @param {string} name - å‚æ•°å (ç”¨äºé”™è¯¯æ¶ˆæ¯)
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateRequiredString(value, name) {
    if (!value || typeof value !== 'string' || value.trim() === '') {
        return {
            valid: false,
            error: `${name} æ˜¯å¿…å¡«å‚æ•°ä¸”ä¸èƒ½ä¸ºç©º`,
        };
    }
    return { valid: true };
}

/**
 * éªŒè¯å¸ƒå°”å‚æ•°
 * 
 * @param {any} value - å‚æ•°å€¼
 * @param {string} name - å‚æ•°å
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateBoolean(value, name) {
    if (typeof value !== 'boolean') {
        return {
            valid: false,
            error: `${name} å¿…é¡»æ˜¯å¸ƒå°”å€¼`,
        };
    }
    return { valid: true };
}
/**
 * é€šç”¨å‚æ•°éªŒè¯å‡½æ•°
 * 
 * @param {Object} params - éœ€è¦éªŒè¯çš„å‚æ•°å¯¹è±¡
 * @param {Array<string>} requiredFields - å¿…éœ€å­—æ®µåˆ—è¡¨
 * @returns {Object} { isValid: boolean, message?: string }
 */
function validateParams(params, requiredFields) {
    const missing = [];

    for (const field of requiredFields) {
        if (params[field] === undefined || params[field] === null || params[field] === '') {
            missing.push(field);
        }
    }

    if (missing.length > 0) {
        return {
            isValid: false,
            message: `ç¼ºå°‘å¿…å¡«å‚æ•°: ${missing.join(', ')}`
        };
    }

    return { isValid: true };
}

module.exports = {
    validateUser,
    validateVocabulary,
    isValidMastery,
    validatePagination,
    validateRequiredString,
    validateBoolean,
    validateParams,
};
````

## File: cloudbase/functions/memory-engine/package.json
````json
{
  "name": "memory-engine",
  "version": "1.0.0",
  "description": "Unified Memory Engine Cloud Function",
  "main": "index.js",
  "scripts": {
    "deploy": "tcb fn deploy memory-engine",
    "logs": "tcb fn log memory-engine",
    "test": "tcb fn invoke memory-engine --data '{\"action\":\"checkModuleAccess\",\"data\":{\"userId\":\"test\"}}'"
  },
  "dependencies": {
    "wx-server-sdk": "~2.6.3"
  },
  "author": "Liang JianYu",
  "license": "MIT",
  "engines": {
    "node": "18.20.0"
  }
}
````

## File: cloudbase/test-all-apis.sh
````bash
#!/bin/bash

MEMORY_ENGINE_URL="https://cloud1-1gjcyrdd7ab927c6-1387301748.ap-shanghai.app.tcloudbase.com/memory-engine"
LEARN_VOCAB_URL="https://cloud1-1gjcyrdd7ab927c6-1387301748.ap-shanghai.app.tcloudbase.com/learn-vocab"
USER_ID="u_1764867682959_dwqxjcjoo"

echo "======================================"
echo "Thai Learning App - æ­£ç¡®çš„ API æµ‹è¯•"
echo "======================================"
echo ""

# ============ memory-engine æµ‹è¯• ============
echo "ğŸ“¦ memory-engine äº‘å‡½æ•°æµ‹è¯•"
echo "========================================="
echo ""

echo "1ï¸âƒ£ submitMemoryResult (âœ… æ­£ç¡®ç«¯ç‚¹)"
curl -s -X POST "$MEMORY_ENGINE_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"submitMemoryResult\",
    \"data\": {
      \"userId\": \"$USER_ID\",
      \"results\": [{
        \"entityType\": \"letter\",
        \"entityId\": \"TH_C_02\",
        \"quality\": \"æ¨¡ç³Š\"
      }]
    }
  }" | jq .
echo ""
echo ""

echo "2ï¸âƒ£ getTodayMemories (âœ… æ­£ç¡®ç«¯ç‚¹)"
curl -s -X POST "$MEMORY_ENGINE_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"getTodayMemories\",
    \"data\": {
      \"userId\": \"$USER_ID\",
      \"entityType\": \"letter\",
      \"limit\": 20
    }
  }" | jq .
echo ""
echo ""

# ============ learn-vocab æµ‹è¯• ============
echo "ğŸ“š learn-vocab äº‘å‡½æ•°æµ‹è¯•"
echo "========================================="
echo ""

echo "3ï¸âƒ£ getTodayWords"
curl -s -X POST "$LEARN_VOCAB_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"getTodayWords\",
    \"data\": {
      \"userId\": \"$USER_ID\",
      \"limit\": 20,
      \"offset\": 0
    }
  }" | jq .
echo ""
echo ""

echo "4ï¸âƒ£ getReviewStatistics"
curl -s -X POST "$LEARN_VOCAB_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"getReviewStatistics\",
    \"data\": {
      \"userId\": \"$USER_ID\"
    }
  }" | jq .
echo ""
echo ""

echo "5ï¸âƒ£ getVocabularyList"
curl -s -X POST "$LEARN_VOCAB_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"getVocabularyList\",
    \"data\": {
      \"limit\": 5,
      \"offset\": 0
    }
  }" | jq .
echo ""
echo ""

echo "6ï¸âƒ£ getVocabularyDetail"
curl -s -X POST "$LEARN_VOCAB_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"getVocabularyDetail\",
    \"data\": {
      \"userId\": \"$USER_ID\",
      \"vocabularyId\": \"BEGINNER_A_7\"
    }
  }" | jq .
echo ""
echo ""

echo "7ï¸âƒ£ updateMastery"
curl -s -X POST "$LEARN_VOCAB_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"updateMastery\",
    \"data\": {
      \"userId\": \"$USER_ID\",
      \"vocabularyId\": \"BEGINNER_A_7\",
      \"mastery\": \"è®°å¾—\"
    }
  }" | jq .
echo ""
echo ""

echo "8ï¸âƒ£ toggleSkipWord"
curl -s -X POST "$LEARN_VOCAB_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"toggleSkipWord\",
    \"data\": {
      \"userId\": \"$USER_ID\",
      \"vocabularyId\": \"BEGINNER_A_7\",
      \"skipped\": true
    }
  }" | jq .
echo ""
echo ""

echo "9ï¸âƒ£ getSkippedWords"
curl -s -X POST "$LEARN_VOCAB_URL" \
  -H 'Content-Type: application/json' \
  -d "{
    \"action\": \"getSkippedWords\",
    \"data\": {
      \"userId\": \"$USER_ID\",
      \"limit\": 10,
      \"offset\": 0
    }
  }" | jq .
echo ""
echo ""

echo "======================================"
echo "âœ… æµ‹è¯•å®Œæˆ!"
echo "======================================"
````

## File: docs/project-freeze/ai-module-spec.md
````markdown
# AI æ¨¡å—è½»é‡è§„æ ¼è¯´æ˜ï¼ˆAI Module Spec, Liteï¼‰

> ç›®å½•ï¼š`docs/project-freeze/ai-module-spec.md`  
> èŒƒå›´ï¼š**AI è¾…åŠ©èƒ½åŠ›è®¾è®¡ï¼Œé¦–å‘ç‰ˆæœ¬ä»¥ Lite / MVP å½¢å¼çœŸæ­£æ¥å…¥æ ¸å¿ƒ 4 ä¸ª Action**ã€‚  
> ç›®æ ‡ï¼šåœ¨ä¸é˜»å¡å½“å‰ 2 ä¸ªæœˆä¸Šçº¿ç›®æ ‡çš„å‰æä¸‹ï¼Œå†»ç»“ AI æ¨¡å—çš„æ¥å£ä¸è¾¹ç•Œï¼Œç¡®ä¿é¦–å‘ç‰ˆæœ¬å…·å¤‡åŸºç¡€ AI èƒ½åŠ›ï¼ŒåŒæ—¶ä¸ºåç»­ç‰ˆæœ¬ä¿ç•™æ‰©å±•ç©ºé—´ã€‚

---

## 1. æ¨¡å—æ¦‚è¿°ä¸å­æ¨¡å—åˆ’åˆ†

AI æ¨¡å—åœ¨é¦–å‘ç‰ˆæœ¬ä¸­åŒ…å«å››ä¸ªå­èƒ½åŠ›ï¼Œå…¨éƒ¨é€šè¿‡ä¸€ä¸ª CloudBase äº‘å‡½æ•°ç»Ÿä¸€æš´éœ²ï¼š

- äº‘å‡½æ•°ï¼š`ai-engine`ï¼ˆåç§°å¯è°ƒæ•´ï¼Œä½†å¿…é¡»å•ä¸€å…¥å£ + å¤š Actionï¼‰ã€‚  
- é¦–å‘å¿…é¡»å®ç°çš„ Action åˆ—è¡¨ï¼š
  1. `analyzePronunciation` â€“ AI å‘éŸ³åé¦ˆå¼•æ“ï¼ˆé¦–å‘å®ç° MVP ç‰ˆï¼Œæä¾›åŸºç¡€æ‰“åˆ†ä¸æ–‡å­—åé¦ˆï¼‰ï¼›  
  2. `generateWeaknessVocabulary` â€“ åŸºäºå¼±é¡¹çš„è¯æ±‡å¼ºåŒ–å»ºè®®ï¼›  
  3. `generateMicroReading` â€“ å¾®é˜…è¯»ææ–™ç”Ÿæˆï¼ˆ1â€“2 å¥çŸ­æ–‡ï¼‰ï¼›  
  4. `explainVocabulary` â€“ è¯æ±‡è§£æä¸è¡¥å……ä¾‹å¥ï¼ˆä»…åšè§£é‡Šå’Œç¤ºä¾‹æ‰©å±•ï¼Œä¸ç›´æ¥ä¿®æ”¹è®°å¿†çŠ¶æ€ï¼‰ã€‚

### 1.1 ä¸å…¶ä»–æ¨¡å—çš„å…³ç³»

- Alphabet / Vocabulary æ¨¡å—ä»æ˜¯**å­¦ä¹ ä¸»è§’**ï¼›AI æ¨¡å—åªæä¾›**é¢å¤–ç»ƒä¹  & åé¦ˆ**ã€‚  
- æ‰€æœ‰è°ƒç”¨éƒ½å¿…é¡»é€šè¿‡å‰ç«¯ `callCloudFunction('ai-engine', { action, data })` å®Œæˆï¼›  
- AI æ¨¡å—ä¸ç›´æ¥ä¿®æ”¹ `memory_status` / `learningStatus`ï¼Œåªè¿”å›å»ºè®®ï¼Œç”±å‰ç«¯é€‰æ‹©æ˜¯å¦è®°å…¥é”™é¢˜æˆ–æç¤ºã€‚

---

## 2. äº‘å‡½æ•°æ¥å£è®¾è®¡ï¼š`ai-engine`

### 2.1 é€šç”¨å…¥å£

```ts
// HTTP / CloudBase å…¥å£è§„èŒƒ
type AiEngineAction =
  | 'analyzePronunciation'
  | 'generateWeaknessVocabulary'
  | 'generateMicroReading'
  | 'explainVocabulary';

interface AiEngineRequest<T = unknown> {
  action: AiEngineAction;
  data: T;
}

interface AiEngineResponse<T = unknown> {
  success: boolean;
  data: T | null;
  message: string;
  errorCode: string | null;
}
```

å‰ç«¯è°ƒç”¨ç¤ºä¾‹ï¼ˆå‘éŸ³åé¦ˆï¼‰ï¼š

```ts
await callCloudFunction<AiEngineResponse<PronunciationFeedback>>('ai-engine', {
  action: 'analyzePronunciation',
  data: { /* AnalyzePronunciationRequest */ },
});
```

å‰ç«¯è°ƒç”¨ç¤ºä¾‹ï¼ˆè¯æ±‡è§£æï¼‰ï¼š

```ts
await callCloudFunction<AiEngineResponse<ExplainVocabularyResponse>>('ai-engine', {
  action: 'explainVocabulary',
  data: { /* ExplainVocabularyRequest */ },
});
```

### 2.2 Action: analyzePronunciationï¼ˆAI å‘éŸ³åé¦ˆï¼‰

**ç”¨é€”ï¼š**  
åœ¨å­—æ¯æ¨¡å—æˆ–è¯æ±‡æ¨¡å—ä¸­ï¼Œç”¨æˆ·æœ—è¯»æŸä¸ªå­—æ¯ / å•è¯ / å¥å­åï¼Œå°†å½•éŸ³ä¸Šä¼ ï¼Œè·å¾— AI ç”Ÿæˆçš„åé¦ˆä¸å»ºè®®ç»ƒä¹ ç‚¹ã€‚

è¯·æ±‚ä½“ï¼ˆåˆç‰ˆï¼‰ï¼š

```ts
interface AnalyzePronunciationRequest {
  userId: string;
  targetType: 'letter' | 'word' | 'sentence';
  targetId: string;              // letterId æˆ– vocabularyId æˆ–è‡ªå®šä¹‰å¥å­ ID
  targetText: string;           // ç›®æ ‡æ–‡æœ¬ï¼ˆæ³°æ–‡ï¼‰
  audioUrl: string;             // å·²ä¸Šä¼ åˆ° COS çš„éŸ³é¢‘ URL / key
  alphabetContext?: {
    // å¯é€‰ï¼šå½“å‰å­—æ¯çš„è¾…éŸ³ç±»åˆ«ã€å£°è°ƒç­‰ä¿¡æ¯ï¼Œä¾¿äº LLM ä½¿ç”¨æœ¯è¯­
    consonantClass?: 'high' | 'mid' | 'low';
    toneMark?: string | null;
  };
}

interface PronunciationFeedback {
  overallScore: number;          // 0â€“100 ç»¼åˆè¯„åˆ†
  level: 'éœ€è¦åŠ å¼º' | 'åˆæ ¼' | 'ä¼˜ç§€';
  issues: Array<{
    type: 'tone' | 'vowel' | 'consonant' | 'rhythm';
    description: string;        // ä¸­æ–‡è§£é‡Šé—®é¢˜
    suggestion: string;         // ä¸­æ–‡ç»ƒä¹ å»ºè®®
  }>;
  syllableBreakdown?: Array<{
    syllable: string;
    tone: string;
    score: number;
  }>;
  recommendedDrills?: string[];  // å»ºè®®é‡å¤ç»ƒä¹ çš„çŸ­è¯æˆ–çŸ­å¥
}
```

è¿”å›ç¤ºä¾‹ï¼ˆç®€åŒ–ï¼‰ï¼š

```json
{
  "success": true,
  "data": {
    "overallScore": 78,
    "level": "åˆæ ¼",
    "issues": [
      {
        "type": "tone",
        "description": "ç¬¬ä¸€ä¸ªéŸ³èŠ‚å£°è°ƒåä½ï¼Œå¬èµ·æ¥æ¥è¿‘äºŒå£°",
        "suggestion": "ç»ƒä¹ ä»ä¸­è¾…éŸ³å¹³è°ƒå‘é«˜è°ƒè¿‡æ¸¡ï¼Œå¯ä»¥å…ˆå¤¸å¼ ä¸€ç‚¹è¯»é«˜"
      }
    ],
    "syllableBreakdown": [
      { "syllable": "à¸à¸°", "tone": "é«˜", "score": 70 },
      { "syllable": "à¸›à¸µ", "tone": "å¹³", "score": 85 }
    ],
    "recommendedDrills": [
      "à¸à¸°à¸›à¸µ",
      "à¸›à¸µà¹ƒà¸«à¸¡à¹ˆ"
    ]
  },
  "message": "åˆ†ææˆåŠŸ",
  "errorCode": null
}
```

### 2.3 Action: generateWeaknessVocabularyï¼ˆå¼±é¡¹è¯æ±‡å¼ºåŒ–ï¼‰

**ç”¨é€”ï¼š**  
åŸºäºç”¨æˆ·åœ¨ `memory_status` / `user_vocabulary_progress` ä¸­çš„é”™è¯¯ç»Ÿè®¡ï¼Œ**ç»“åˆå‰ç«¯ä¼ å…¥çš„æœ¬åœ°é”™é¢˜æœ¬ï¼ˆå¦‚æœ‰ï¼‰**ï¼Œä¸ºè¯æ±‡æ¨¡å—ç”Ÿæˆé¢å¤–ç»ƒä¹ å»ºè®®ï¼ˆä¾‹å¥ã€è®°å¿†æç¤ºç­‰ï¼‰ï¼Œä½†ä¸ç›´æ¥ä¿®æ”¹è®°å¿†é˜Ÿåˆ—ã€‚

è¯·æ±‚ä½“ï¼š

```ts
interface GenerateWeaknessVocabularyRequest {
  userId: string;
  topN?: number;                     // é»˜è®¤ 5

  // å¯é€‰ï¼šå‰ç«¯æœ¬åœ°é”™é¢˜æœ¬ï¼ˆå½“æ—¥ä¼šè¯å†…çš„é”™è¯ï¼‰
  focusVocabularyIds?: string[];     // æ¥è‡ª VocabularySessionState.wrongWordIds
  source?: string;                   // è¯¾ç¨‹æ¥æºï¼Œç”¨äºé™å®šæ•™æèŒƒå›´
}

interface WeakVocabularySuggestion {
  vocabularyId: string;
  thaiWord: string;
  meaning: string;
  currentMastery: 'é™Œç”Ÿ' | 'æ¨¡ç³Š' | 'è®°å¾—';
  aiExamples: Array<{
    scene: string;
    thai: string;
    chinese: string;
  }>;
  mnemonic?: string;                 // AI ç”Ÿæˆè”æƒ³è®°å¿†
}
```

è¿”å›ï¼š

```ts
type GenerateWeaknessVocabularyResponse = WeakVocabularySuggestion[];
```

å‰ç«¯å‘ˆç°æ–¹å¼ï¼ˆå»ºè®®ï¼‰ï¼š

- åœ¨è¯æ±‡æ¨¡å—å®Œæˆé¡µæˆ–â€œAI æ¨èâ€é¡µå±•ç¤ºâ€œä½ çš„è–„å¼±è¯æ±‡ TopNâ€ï¼›  
- ç”¨æˆ·å¯ç‚¹å‡»æŸä¸ªè¯ç›´æ¥è¿›å…¥ NewWordView / å¤ä¹ é¢˜æ¨¡å¼ï¼›  
- è‹¥ä¼ å…¥äº† `focusVocabularyIds`ï¼ŒUI å¯æ ‡è®°â€œæ¥è‡ªæœ¬æ¬¡é”™é¢˜â€çš„è¯æ±‡ã€‚

### 2.4 Action: generateMicroReadingï¼ˆå¾®é˜…è¯»ææ–™ï¼‰

**ç”¨é€”ï¼š**  
æ ¹æ®ç”¨æˆ·çš„å¼±é¡¹è¯æ±‡/å­—æ¯ï¼Œè‡ªåŠ¨ç”Ÿæˆ 1â€“2 å¥çŸ­æ–‡ï¼Œç”¨äº**æœ—è¯» + å‘éŸ³åé¦ˆ**çš„é—­ç¯ç»ƒä¹ ã€‚

è¯·æ±‚ä½“ï¼š

```ts
interface GenerateMicroReadingRequest {
  userId: string;
  focusType: 'letter' | 'word' | 'mixed';
  focusIds?: string[];          // letterId / vocabularyIdï¼ˆå¯ä¸é”™é¢˜åˆ—è¡¨ä¸€è‡´ï¼‰
  length?: 'short' | 'medium';  // 1 å¥æˆ– 2 å¥ï¼Œé»˜è®¤ short

  // å¯é€‰ï¼šæœ¬åœ°é”™é¢˜ä¿¡æ¯ï¼Œä¾¿äº LLM ç²¾å‡†é’ˆå¯¹å¼±é¡¹ç”Ÿæˆå†…å®¹
  wrongLetters?: string[];      // ä»Šæ—¥é”™è¯¯å­—æ¯ ID
  wrongVocabularyIds?: string[];// ä»Šæ—¥é”™è¯¯å•è¯ ID
}

interface MicroReading {
  id: string;
  thaiText: string;
  chineseHint: string;
  highlightWords: string[];     // éœ€è¦ç‰¹åˆ«å…³æ³¨çš„è¯
}
```

è¿”å›ï¼š

```ts
type GenerateMicroReadingResponse = MicroReading;
```

å‰ç«¯æµç¨‹å»ºè®®ï¼š

1. AI é¢æ¿å±•ç¤ºç”Ÿæˆçš„çŸ­æ–‡ï¼›  
2. ç”¨æˆ·ç‚¹å‡»â€œå¼€å§‹æœ—è¯»â€ï¼Œå½•éŸ³å®Œæˆåè‡ªåŠ¨è°ƒç”¨ `analyzePronunciation`ï¼›  
3. å°†åé¦ˆç»“æœä¸åŸæ–‡å¹¶æ’å±•ç¤ºï¼Œå½¢æˆ â€œAI â†’ ç”¨æˆ· â†’ AI â†’ ç”¨æˆ·â€ å¾ªç¯ã€‚

---

## 3. æ–°å¢ Actionï¼šexplainVocabularyï¼ˆåŸºç¡€è¯æ±‡è§£æï¼‰

**ç”¨é€”ï¼š**  
ä¸ºç”¨æˆ·æä¾›æŸä¸ªå•è¯çš„è¯¦ç»†è§£é‡Šå’Œè¡¥å……ä¾‹å¥ï¼Œç”¨äºâ€œçœ‹ä¸å¤ªæ‡‚/è®°ä¸ç‰¢â€æ—¶çš„ä¸€é”®è§£æã€‚åªä½œä¸ºå­¦ä¹ è¾…åŠ©ï¼Œä¸ç›´æ¥æ”¹å˜è®°å¿†ç­–ç•¥ã€‚

è¯·æ±‚ä½“ï¼š

```ts
interface ExplainVocabularyRequest {
  userId: string;
  vocabularyId?: string;   // æ¨èä½¿ç”¨ vocabulary é›†åˆä¸­çš„ _id
  thaiWord?: string;       // å¤‡é€‰ï¼šå½“æ²¡æœ‰ id æ—¶å¯ç›´æ¥ä¼ è¯å½¢
}

interface ExplainVocabularyItem {
  vocabularyId: string;
  thaiWord: string;
  meaning: string;
  breakdown?: string;      // æ‹†è§£/è®°å¿†æç¤º
  extraExamples?: Array<{
    scene?: string;
    thai: string;
    chinese: string;
  }>;
}

type ExplainVocabularyResponse = ExplainVocabularyItem;
```

å‰ç«¯è°ƒç”¨ç¤ºä¾‹ï¼š

```ts
await callCloudFunction<AiEngineResponse<ExplainVocabularyResponse>>('ai-engine', {
  action: 'explainVocabulary',
  data: {
    userId,
    vocabularyId,
  },
}, {
  endpoint: API_ENDPOINTS.AI.ENGINE.cloudbase,
});
```

---

## 4. å‰ç«¯æ¥å…¥çº¦æŸ

### 4.1 ç»Ÿä¸€è°ƒç”¨è·¯å¾„

- æ‰€æœ‰ AI è°ƒç”¨å¿…é¡»é€šè¿‡ç»Ÿä¸€ utilï¼š

```ts
import { callCloudFunction } from '@/src/utils/apiClient';

await callCloudFunction('ai-engine', { action, data }, {
  endpoint: API_ENDPOINTS.AI.ENGINE.cloudbase,
});
```

- ä¸å…è®¸åœ¨ç»„ä»¶ä¸­ç›´æ¥å†™æ­» URL æˆ–ä½¿ç”¨ `fetch`ã€‚

### 4.2 çŠ¶æ€ç®¡ç†

- AI æ¨¡å—ä¸å•ç‹¬å»ºç«‹å¤§å‹ Storeï¼ŒåŸåˆ™ä¸Šä½¿ç”¨ï¼š
  - å±€éƒ¨ç»„ä»¶çŠ¶æ€ï¼ˆå¦‚å½“å‰åé¦ˆç»“æœï¼‰ï¼›  
  - æˆ–åœ¨ `learningStore` ä¸­å¢åŠ è½»é‡å­—æ®µï¼š

```ts
interface AiUsageSnapshot {
  lastPronunciationScore?: number;
  lastMicroReadingId?: string;
  lastExplainVocabularyId?: string;
  totalPronunciationSessions: number;
}
```

### 4.3 ä¸è®°å¿†å¼•æ“çš„å…³ç³»

- AI æ¨¡å—ä¸ç›´æ¥ä¿®æ”¹ `memory_status` / `learningStatus`ï¼›  
- è‹¥éœ€è¦æŠŠ AI ç»ƒä¹ ç»“æœè½¬åŒ–ä¸ºè®°å¿†è´¨é‡ï¼Œå¿…é¡»èµ°ç°æœ‰çš„ `submitMemoryResult` / `updateMastery` æ¥å£ï¼Œç”±å‰ç«¯å†³å®šä»€ä¹ˆæ—¶å€™æäº¤ï¼ˆä¾‹å¦‚ç”¨æˆ·åœ¨ AI ç»ƒä¹ ä¸­è¿ç»­ 3 æ¬¡è¯»å¯¹æŸä¸ªè¯ï¼‰ã€‚

---

## 5. ä»»åŠ¡æ¸…å•ä¸ä¼˜å…ˆçº§ï¼ˆæ›´æ–°åï¼‰

> ä»¥ä¸‹ä»»åŠ¡ä¸­ï¼ŒP0 æ˜¯é¦–å‘ç‰ˆæœ¬å¿…é¡»å®Œæˆçš„èŒƒå›´ï¼›P1 åŠä»¥åå¯ä»¥åœ¨é¦–å‘åè¿­ä»£å¢å¼ºã€‚

### 5.1 P0ï¼šai-engine äº‘å‡½æ•° + å››å¤§ Actionï¼ˆé¦–å‘å¿…åšï¼Œçº¦ 2â€“3 å‘¨ï¼‰

- [ ] åˆ›å»º `cloudbase/functions/ai-engine` äº‘å‡½æ•°éª¨æ¶ï¼Œæ”¯æŒ `action` åˆ†å‘å’Œ `createResponse`ã€‚  
- [ ] åœ¨ `API_ENDPOINTS` ä¸­å¢åŠ  `AI.ENGINE` é…ç½®ã€‚  
- [ ] åœ¨ `utils/apiClient.ts` ä¸­å¢åŠ  `callAiEngine` è½»é‡å°è£…ï¼ˆå¯é€‰ï¼‰ã€‚  
- [ ] å®ç° `generateWeaknessVocabulary`ï¼Œå¹¶åœ¨è¯æ±‡æ¨¡å—å®Œæˆé¡µæä¾›â€œAI å¼ºåŒ–ç»ƒä¹ â€å…¥å£ã€‚  
- [ ] å®ç° `generateMicroReading`ï¼Œå¹¶ä¸ `analyzePronunciation` ç»„åˆæˆä¸€ä¸ªâ€œçŸ­æ–‡æœ—è¯» + AI åé¦ˆâ€çš„é—­ç¯ç»ƒä¹ é¡µé¢ã€‚  
- [ ] å®ç° `explainVocabulary`ï¼Œåœ¨ NewWordView æˆ–è¯æ±‡è¯¦æƒ…é¡µæä¾›â€œä¸€é”® AI è§£é‡Š/ä¾‹å¥è¡¥å……â€å…¥å£ã€‚  
- [ ] å®ç° `analyzePronunciation` çš„ MVPï¼šå½•éŸ³ â†’ ä¸Šä¼  COS â†’ è°ƒç”¨äº‘å‡½æ•° â†’ è¿”å›åŸºç¡€è¯„åˆ†å’Œæ–‡å­—åé¦ˆï¼Œå¹¶åœ¨å­—æ¯/è¯æ±‡æ¨¡å—ä¸­å„æ¥å…¥ä¸€ä¸ªå…¥å£åœºæ™¯ã€‚

### 5.2 P1ï¼šæ•ˆæœä¼˜åŒ–ä¸é«˜çº§èƒ½åŠ›ï¼ˆé¦–å‘åè¿­ä»£ï¼Œçº¦ 2â€“3 å‘¨ï¼‰

- [ ] åŸºäºçœŸå®ç”¨æˆ·æ•°æ®è¿­ä»£å‘éŸ³è¯„åˆ†é˜ˆå€¼å’Œåé¦ˆæ–‡æ¡ˆã€‚  
- [ ] åœ¨ AI æ¨¡å—å†…å®ç°æ›´æ™ºèƒ½çš„é¢˜ç›®æ¨èç­–ç•¥ï¼Œä¸é”™é¢˜æœ¬å’Œ memory-engine æ›´ç´§å¯†ç»“åˆã€‚  
- [ ] æ‰©å±• `generateMicroReading` æ”¯æŒæ›´ä¸°å¯Œçš„æ–‡æœ¬ä½“è£ä¸é•¿åº¦é…ç½®ã€‚  
- [ ] å®ç° `generateMicroReading`ï¼Œå¹¶ä¸ `analyzePronunciation` ç»„åˆæˆä¸€ä¸ªé—­ç¯ç»ƒä¹ é¡µé¢ã€‚  
- [ ] å°† AI ç»ƒä¹ ç»“æœåŒæ­¥åˆ° `learningStore` ä½œä¸ºç»Ÿè®¡ä¿¡æ¯ã€‚

---

æœ¬è½»é‡è§„æ ¼æ–‡æ¡£åªå†»ç»“ AI æ¨¡å—çš„**è¾¹ç•Œã€Action åç§°ä¸å…¸å‹æ•°æ®ç»“æ„**ï¼Œå®ç°ç»†èŠ‚ï¼ˆå…·ä½“æ¨¡å‹ã€æç¤ºè¯ã€è¯„åˆ†ç®—æ³•ï¼‰å¯åœ¨åç»­è¿­ä»£ä¸­é€æ­¥å®Œå–„ã€‚  
é¦–å‘ç‰ˆæœ¬å¯ä»¥å®Œå…¨ä¸æ¥å…¥ AI åŠŸèƒ½ï¼Œè€Œä¸ä¼šå½±å“ Alphabet / Vocabulary æ¨¡å—çš„æ ¸å¿ƒæµç¨‹ã€‚***
````

## File: docs/project-freeze/alphabet-module-spec.md
````markdown
# æ³°è¯­å­—æ¯æ¨¡å—æœ€ç»ˆè§„æ ¼è¯´æ˜ï¼ˆAlphabet Module Spec, Final v3.0ï¼‰

> **çŠ¶æ€**: Frozenï¼ˆå†»ç»“ï¼‰  
> **ç‰ˆæœ¬**: v3.0  
> **æœ€åæ›´æ–°**: 2026-01-05  
> **ç›®å½•**: `docs/project-freeze/alphabet-module-spec.md`  
> **é€‚ç”¨èŒƒå›´**: Alphabet æ¨¡å—å…¨éƒ¨ä»£ç ï¼ˆå‰ç«¯ + åç«¯ memory-engineï¼‰  
> **æƒå¨æ€§å£°æ˜**: æœ¬æ–‡ä»¶æ˜¯ Alphabet æ¨¡å—çš„**å”¯ä¸€æƒå¨è§„èŒƒ**ï¼Œä¼˜å…ˆäºæ‰€æœ‰å†å²ä»£ç ã€å†å²æ–‡æ¡£ã€AI å»ºè®®  
> **ä¿®è®¢æ‘˜è¦**: v3.0 åˆå¹¶äº† FINAL_FACTSã€IMPLEMENTATION_SKELETONã€P0ä¿®å¤è§„èŒƒï¼Œè½åœ° lesson-scoped roundã€completedLessons æƒå¨æ¥æºã€å››æ®µé˜Ÿåˆ—ç»“æ„ã€isNew è¯­ä¹‰è¾¹ç•Œç­‰æœ€ç»ˆè§„åˆ™  
> **ç›®æ ‡**: è®©ä»»ä½•å¼€å‘è€…åœ¨ä¸é€šè¯»å…¨éƒ¨ä»£ç çš„å‰æä¸‹ï¼Œä»…å‡­æœ¬è§„æ ¼ + ç›¸å…³ç±»å‹å®šä¹‰ï¼Œå³å¯å®ç° / é‡æ„ / æ‰©å±•å­—æ¯æ¨¡å—çš„æ‰€æœ‰åŠŸèƒ½ï¼Œè€Œä¸ä¼šç ´åå…¨å±€æ¶æ„

---

## 0. é¦–å‘ç‰ˆå†»ç»“å£°æ˜ï¼ˆå½“å‰çœŸå®å®ç°ï¼‰

> ç¦æ­¢åœ¨æ­¤é˜¶æ®µåˆå¹¶é¢˜å‹ä½“ç³» / é‡æ„ Phase / å•è¾¹åˆ é™¤é˜Ÿåˆ—æ’å…¥é€»è¾‘ã€‚

- å•ä¸€æƒå¨ï¼ˆSource of Truthï¼‰
  - è¯¾ç¨‹å­—æ¯ï¼šDB `letters.curriculumLessonIds` + `getTodayMemories` (handlers/getTodayMemories.js 167-184)ï¼›å‰åç«¯ `lessonMetadata` ä»…å±•ç¤º/å›é€€ï¼Œä¸” **lesson1 å…ƒéŸ³å­˜åœ¨ä¸ä¸€è‡´**ï¼ˆå‰ç«¯ ['à¸²','à¸µ','à¸¹']ï¼Œåç«¯ ['à¸²','à¸°','à¸´']ï¼‰ã€‚
  - é˜Ÿåˆ—ç”Ÿæˆï¼šåç«¯ `getTodayMemories` å…ˆå–å¤ä¹ ï¼ˆä¸æŒ‰ lesson è¿‡æ»¤ï¼Œå­˜åœ¨è·¨è¯¾æ··å…¥é£é™©ï¼‰+ 3æ–°1å¤æ’å…¥ï¼Œç„¶åå‰ç«¯ `buildAlphabetQueue` å†åš mini-review(æ¯3ä¸ªæ–°å­—æ¯å›æ”¾) + final-review å…¨é‡ + error-review è¿½åŠ ã€‚
  - é¢˜å‹ï¼šå®é™…æ¸²æŸ“ä½¿ç”¨ `AlphabetGameType` + `lettersQuestionGenerator`ï¼ˆSOUND_TO_LETTER / LETTER_TO_SOUND / CONSONANT_CLASS / INITIAL_SOUND / FINAL_SOUNDï¼›TONE_CALCULATION/PHONICS_MATH ä»ä¸ºå ä½ï¼‰ã€‚`QuestionType` / `alphabetQuestionTypes` / `alphabetQuestionGenerator` ä¸ºå†å²å®šä¹‰ï¼Œæœªåœ¨é¦–å‘ç‰ˆç”Ÿæ•ˆã€‚
  - Phaseï¼šUI/é€»è¾‘ä»¥ `queue.source`ï¼ˆnew/mini-review/final-review/error-reviewï¼‰æ´¾ç”Ÿï¼Œ`LearningPhase` æšä¸¾çš„ 7 é˜¶æ®µæœªè¢«å½“å‰å®ç°é©±åŠ¨ã€‚

- å·²çŸ¥åå·®ï¼ˆéœ€åç»­æ²»ç†ï¼Œå½“å‰ä¸æ”¹ä»£ç ï¼‰
  - è¯¾ç¨‹å…ƒæ•°æ®å‰åç«¯ä¸ä¸€è‡´ï¼›`SEQUENCE_LESSONS` ä¸è¯¾ç¨‹åˆ—è¡¨æ•°é‡ä¸å¯¹é½ã€‚
  - å¤ä¹ æ± ä¸æŒ‰ lesson è¿‡æ»¤ï¼Œå¯èƒ½å°†å…¶ä»–è¯¾åˆ°æœŸå­—æ¯æ··å…¥æœ¬è¯¾é˜Ÿåˆ—ã€‚
  - åŒå±‚ 3æ–°1å¤æ’å…¥å¯¼è‡´èŠ‚å¥ä¸å†»ç»“è®¾è®¡ä¸å®Œå…¨ä¸€è‡´ã€‚
  - å¤šå¥—é¢˜å‹/Phase å®šä¹‰å¹¶å­˜ï¼Œå¯èƒ½å¯¼è‡´æ–°ä»£ç è¯¯ç”¨å†å²æ¥å£ã€‚

- æ–‡æ¡£ä½¿ç”¨æç¤º
  - æœ¬èŠ‚æè¿°çš„æ˜¯â€œé¦–å‘ç‰ˆç°çŠ¶â€ï¼Œä½œä¸ºå†»ç»“è®°å½•ï¼›åç»­è¿­ä»£éœ€åœ¨æ˜ç¡®æ²»ç†è®¡åˆ’åå†è°ƒæ•´æƒå¨å®šä¹‰ã€‚

## 1. æ¨¡å—å®šä½ä¸è¾¹ç•Œ

### 1.1 æ¨¡å—èŒè´£

å­—æ¯æ¨¡å—ï¼ˆAlphabet Moduleï¼‰è´Ÿè´£ï¼š

- æä¾›ä¸€å¥— **å¾ªåºæ¸è¿›çš„æ³°è¯­å­—æ¯è¯¾ç¨‹**ï¼ˆå½“å‰ä¸º Lesson1~7ï¼‰ï¼›  
- é€šè¿‡ memory-engine çš„ç»Ÿä¸€è®°å¿†é˜Ÿåˆ—ï¼Œå®ç°ï¼š
  - æ˜¨æ—¥å¤ä¹  â†’ ä»Šæ—¥å­¦ä¹  â†’ å°å¤ä¹ ï¼ˆMini Reviewï¼‰â†’ æœ«å°¾å¤ä¹ ï¼ˆFinal Reviewï¼‰â†’ ä»Šæ—¥è¡¥æ•‘ï¼ˆToday Remedyï¼‰â†’ ä¸‰è½®è¯„ä¼°ï¼ˆRound Evaluationï¼‰ï¼›
  - å°†æ¯ä¸ªå­—æ¯çš„è®°å¿†æƒ…å†µå†™å…¥ `memory_status`ï¼Œå¹¶å°†æ¯è¯¾ä¸‰è½®ç»Ÿè®¡å†™å…¥ `user_alphabet_progress`ï¼›
- æä¾›é¢˜å‹é©±åŠ¨çš„å­¦ä¹ ä½“éªŒï¼ˆå½“å‰ç”± `lettersQuestionGenerator` æä¾›å¤šç§é¢˜å‹ï¼Œæœªæ¥ç”± 6 å¤§é¢˜å‹åè®®æ¥ç®¡ï¼‰ã€‚

### 1.2 æ¨¡å—è¾¹ç•Œï¼ˆä¸å…¶ä»–æ¨¡å—çš„å…³ç³»ï¼‰

- **å­—æ¯æ¨¡å—ä½¿ç”¨çš„å…±äº«è®¾æ–½ï¼š**
  - ç»Ÿä¸€è®°å¿†å¼•æ“ï¼š`cloudbase/functions/memory-engine`
  - å…¨å±€è¿›åº¦ / è§£é”ï¼š`moduleAccessStore` + memory-engine handlers
  - å…¨å±€è¯¾ç¨‹å…¥å£ï¼šCourses é¡µ + `learningStore`ï¼ˆå½“å‰å­¦ä¹ çš„ä¸»è¯¾ç¨‹ / å­—æ¯å¤§è¯¾ç¨‹ï¼‰
  - è¯¾ç¨‹å…ƒæ•°æ®ï¼š`alphabet_lessons` + `phonics_rules`ï¼ˆDBï¼‰ + `lessonMetadata.config.ts`ï¼ˆå‰ç«¯å›é€€ï¼‰
  - å­—æ¯å®ä½“æ•°æ®ï¼š`letters` é›†åˆï¼ˆæ¥æºäº `assets/courses/letters_final.enriched.json`ï¼‰

- **å­—æ¯æ¨¡å—ä¸åšçš„äº‹æƒ…ï¼š**
  - ä¸ç›´æ¥æ“ä½œ `memory_status` / `user_*_progress`ï¼ˆå…¨éƒ¨äº¤ç»™ memory-engine handlersï¼‰ï¼›
  - ä¸åœ¨ç»„ä»¶ä¸­ç›´æ¥æ‹¼æ¥äº‘å‡½æ•° URLï¼ˆç»Ÿä¸€é€šè¿‡ `callCloudFunction`ï¼‰ï¼›
  - ä¸å®šä¹‰ç”¨æˆ·è®¤è¯ / ä¸»è¯¾ç¨‹é€‰æ‹©ï¼ˆç”± Auth æ¨¡å— + Courses æ¨¡å—å¤„ç†ï¼‰ã€‚

---

## 2. ç›¸å…³ä»£ç æ–‡ä»¶æ€»è§ˆï¼ˆâ€œç±»å›¾è§†è§’â€ï¼‰

æœ¬èŠ‚åˆ—å‡ºå­—æ¯æ¨¡å—æ¶‰åŠçš„æ‰€æœ‰å…³é”®æ–‡ä»¶å’Œå…¶èŒè´£ï¼Œç±»ä¼¼â€œç±»å›¾ + åŒ…å›¾â€çš„æ–‡å­—ç‰ˆæœ¬ã€‚

### 2.1 å‰ç«¯è·¯ç”±å±‚ï¼ˆapp/ï¼‰

- `app/(tabs)/courses.tsx`
  - èŒè´£ï¼š
    - å±•ç¤ºå…¨éƒ¨è¯¾ç¨‹ï¼ˆåŸºç¡€æ³°è¯­ 1~4 + å­—æ¯é¡¹ç›®ç­‰ï¼‰ï¼›
    - å­—æ¯å…¥å£ä½¿ç”¨ `AlphabetCourseCard` æ¸²æŸ“ï¼›
    - ç‚¹å‡»å­—æ¯å¡ç‰‡æ—¶å¯¼èˆªåˆ° `app/alphabet/index.tsx`ã€‚
  - ä¸å­—æ¯æ¨¡å—çš„å…³ç³»ï¼š
    - åªä½œä¸ºâ€œå…¥å£è§¦å‘å™¨â€ï¼Œæœ¬èº«ä¸åŒ…å«å­—æ¯é€»è¾‘ã€‚

- `app/alphabet/index.tsx`ï¼ˆå½“å‰ï¼š**å­—æ¯è¯¾ç¨‹æ€»è§ˆé¡µï¼Œå°è¯¾ç¨‹åˆ—è¡¨**ï¼‰
  - èŒè´£ï¼š
    - å±•ç¤ºå½“å‰å­—æ¯è¯¾ç¨‹åˆ—è¡¨ï¼ˆLesson1~7ï¼‰ï¼›
    - è®¡ç®—æ•´ä½“å®Œæˆåº¦ï¼ˆä½¿ç”¨ `useAlphabetStore` çš„ `completedCount` / `totalCount`ï¼‰ï¼›
    - ä»åç«¯æ‹‰å–è¯¾ç¨‹å…ƒæ•°æ®ï¼ˆ`getAlphabetLessons`ï¼‰æˆ–å›é€€åˆ°å‰ç«¯ `lessonMetadata.config.ts`ï¼›
    - æŒ‰â€œç´¯è®¡å·²å®Œæˆå­—æ¯æ•°â€å†³å®šè¯¾ç¨‹è§£é”ä¸â€œå½“å‰è¯¾ç¨‹â€çŠ¶æ€ï¼›
    - ç‚¹å‡»â€œå¼€å§‹å­¦ä¹ â€æŒ‰é’®æ—¶è·³è½¬åˆ° `/alphabet/[lessonId]`ã€‚
  - æœªæ¥è§„åˆ’ï¼š
    - å¯ä»¥æ¼”åŒ–ä¸ºâ€œå¤§è¯¾ç¨‹å…¥å£é¡µ + å°è¯¾ç¨‹åˆ—è¡¨é¡µâ€çš„ç»„åˆï¼Œç›®å‰ä»ä½œä¸ºâ€œå°è¯¾ç¨‹åˆ—è¡¨é¡µâ€ä½¿ç”¨ã€‚

- `app/alphabet/[lessonId].tsx`
  - èŒè´£ï¼š
    - ä»è·¯ç”±å‚æ•°è·å– `lessonId`ï¼›
    - è°ƒç”¨ `useAlphabetLearningEngine(lessonId)` åˆå§‹åŒ–å­¦ä¹ å¼•æ“ï¼›
    - å°† Hook è¿”å›çš„çŠ¶æ€ä¸å›è°ƒå…¨éƒ¨ä¼ å…¥ `AlphabetLearningEngineView`ï¼›
    - å¤„ç†â€œè¿”å›â€å¯¼èˆªï¼ˆ`router.back()`ï¼‰ã€‚

### 2.2 å­—æ¯æ¨¡å—è°ƒç”¨æ ˆæ¦‚è§ˆ

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ React Native Screens / Components           â”‚
â”‚ app/(tabs)/courses.tsx                      â”‚
â”‚ app/alphabet/*                              â”‚
â”‚ src/components/learning/alphabet/*          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â”‚ é€šè¿‡ props / äº‹ä»¶è°ƒç”¨
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ä¸šåŠ¡ Hooks                                   â”‚
â”‚ src/hooks/useAlphabetLearningEngine.ts       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â”‚ è°ƒç”¨ Zustand Store
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Zustand Stores                              â”‚
â”‚ src/stores/alphabetStore.ts                 â”‚
â”‚ src/stores/moduleAccessStore.ts             â”‚
â”‚ src/stores/userStore.ts                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â”‚ ä½¿ç”¨ apiClient / callCloudFunction
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ apiClient / callCloudFunction               â”‚
â”‚ src/utils/apiClient.ts                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â”‚ HTTP è°ƒç”¨ CloudBase HTTP è§¦å‘å™¨
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CloudBase Functions                         â”‚
â”‚ cloudbase/functions/memory-engine           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â”‚ é€šè¿‡ wx-server-sdk è®¿é—® DB
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CloudBase DB                                â”‚
â”‚ letters, alphabet_lessons, phonics_rules    â”‚
â”‚ memory_status, user_alphabet_progress       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 å‰ç«¯ç»„ä»¶å±‚ï¼ˆsrc/components/learning/alphabetï¼‰

- `AlphabetLearningEngineView.tsx`
  - èŒè´£ï¼š
    - **å­—æ¯å­¦ä¹  UI å®¹å™¨**ï¼šå°è¯¾å†…æ‰€æœ‰ Phase çš„ç»Ÿä¸€æ¸²æŸ“å…¥å£ï¼›
    - æŒ‰ `phase` å†³å®šæ¸²æŸ“å“ªç§å­è§†å›¾ï¼š
      - æ˜¨æ—¥å¤ä¹  / æ˜¨æ—¥è¡¥æ•‘ / Final Review / Today Remedy â†’ `AlphabetReviewView`
      - Mini Review â†’ `MiniReviewQuestionComponent`ï¼ˆmini é¢˜å‹ç»„ä»¶ï¼‰
      - ä»Šæ—¥å­¦ä¹  â†’ `PhonicsRuleCard` æˆ– `AlphabetLearningView`
      - å®Œæˆ â†’ æˆç»©æ±‡æ€»è§†å›¾ï¼ˆå±•ç¤ºä¸‰è½®è¯„ä¼°ç»“æœï¼‰
    - ä¸ç›´æ¥è°ƒç”¨ Store æˆ– cloud functionï¼Œæ‰€æœ‰ä¸šåŠ¡è¡Œä¸ºé€šè¿‡ props å›è°ƒä¸Šæµ®ç»™ Hookã€‚

- `AlphabetLearningView.tsx`
  - èŒè´£ï¼š
    - â€œæ•™å­¦å¡â€è§†å›¾ï¼šå±•ç¤ºå•ä¸ªå­—æ¯çš„è¯¦ç»†ä¿¡æ¯ï¼ˆå­—å½¢ã€ç½—é©¬éŸ³ã€éŸ³èŠ‚ã€ä¾‹è¯ã€é”®ç›˜é”®ç­‰ï¼‰å¹¶æ”¯æŒæ’­æ”¾å‘éŸ³ï¼›
    -ä½¿ç”¨ `AlphabetLearningState` ä½œä¸ºè¾“å…¥ï¼Œå†…éƒ¨ä» `letter` å­—æ®µä¸­æ‹†å‡ºéœ€è¦å±•ç¤ºçš„å„ç§å±æ€§ï¼›
    - åˆ©ç”¨ Expo AV æ’­æ”¾æœ¬åœ°éŸ³é¢‘ï¼š
      - ä¼˜å…ˆä½¿ç”¨ `letter.fullSoundLocalPath / syllableSoundLocalPath / letterPronunciationLocalPath`ï¼›
      - å›é€€æ—¶å¯ä½¿ç”¨ `alphabet.audioUrl`ï¼ˆç”± Store é¢„ä¸‹è½½å¡«å……ï¼‰ã€‚

- `AlphabetReviewView.tsx`
  - èŒè´£ï¼š
    - â€œå¤ä¹ é¢˜ç›®è§†å›¾â€ï¼šé’ˆå¯¹å½“å‰å­—æ¯ç”Ÿæˆä¸€é“é¢˜ç›®å¹¶å±•ç¤ºï¼›
    - ä½¿ç”¨ `generateAlphabetQuestion(letter, pool, preferredType)` ç”Ÿæˆé¢˜ç›®ï¼›
    - æ¸²æŸ“å¤šç§â€œåŸºç¡€é¢˜å‹â€ï¼ˆå¬éŸ³é€‰å­—ã€çœ‹å­—é€‰éŸ³ã€syllable æ‹¼è¯»ç­‰ï¼‰ï¼›
    - åœ¨ç”¨æˆ·ç­”é¢˜åè°ƒç”¨ `onAnswer(isCorrect)`ï¼Œå†æ ¹æ®éœ€è¦è°ƒç”¨ `onNext()` / `onBack()`ã€‚

> æ³¨æ„ï¼šå½“å‰ `AlphabetReviewView`+`lettersQuestionGenerator` æä¾›çš„æ˜¯â€œæ—§ç‰ˆé¢˜å‹ç³»ç»Ÿâ€ï¼Œ  
> æœªæ¥ä¼šè¢« `docs/project-freeze/DESIGN_SPEC.md` ä¸­å®šä¹‰çš„ 6 å¤§é¢˜å‹åè®®å’Œ Question Engine æ¸è¿›æ›¿æ¢ã€‚

### 2.3 Hooks å±‚ï¼ˆsrc/hooksï¼‰

- `useAlphabetLearningEngine.ts`
  - èŒè´£ï¼š
    - **è¯¾ç¨‹çº§å­¦ä¹ å¼•æ“**ï¼Œå³ä½ è®¾è®¡çš„ 8 Phase + 3 è½®è¯„ä¼°é€»è¾‘çš„å‰ç«¯å®ç°ï¼›
    - å…³é”®èŒè´£æ‹†åˆ†ï¼š
      1) åˆå§‹åŒ–å½“å‰ Lesson çš„ä¼šè¯çŠ¶æ€ï¼šè°ƒç”¨ `alphabetStore.initializeSession(userId, { lessonId })`ï¼›
      2) ç®¡ç† Phase çŠ¶æ€æœºï¼š
         - `phase: 'yesterday-review' | 'yesterday-remedy' | 'today-learning' | 'today-mini-review' | 'today-final-review' | 'today-remedy' | 'finished'` ç­‰ï¼›
         - å†³å®šä½•æ—¶è§¦å‘ Mini Reviewã€Final Reviewã€Today Remedyã€ä¸‰è½®è¯„ä¼°ï¼›
      3) å¤„ç†ç­”é¢˜é€»è¾‘ï¼š
         - å°† UI çš„ isCorrect æ˜ å°„åˆ° `alphabetStore.submitResult(userId, isCorrect)`ï¼›
         - ç»´æŠ¤é”™é¢˜é›†åˆ `wrongAnswers`ï¼Œä¾› Round Evaluation ä½¿ç”¨ï¼›
      4) ç®¡ç†ä¸‰è½®è¯„ä¼°ï¼š
         - `currentRound: 1 | 2 | 3`ï¼›
         - `roundEvaluation` è®°å½•æ¯è½®æ­£ç¡®ç‡ä¸æ˜¯å¦é€šè¿‡ï¼›
         - å½“ä¸‰è½®å®Œæˆä¸”é€šè¿‡æ—¶ï¼Œè°ƒç”¨ `markAlphabetLessonCompleted(lessonId)`ï¼ˆæ¥è‡ª `moduleAccessStore`ï¼‰ã€‚
    - å¯¹å¤–æš´éœ²ï¼š
      - `initialized`ï¼šæ˜¯å¦å®Œæˆåˆå§‹åŒ–ï¼›
      - `phase` / `currentRound` / `roundEvaluation`ï¼›
      - `currentItem: AlphabetLearningState | null`ï¼›
      - `currentQuestionType`ï¼ˆå¤ä¹ é¢˜å‹åå¥½ï¼‰ï¼›
      - `letterPool: Letter[]`ï¼ˆä»Šæ—¥æ¶‰åŠçš„æ‰€æœ‰å­—æ¯ï¼Œä¾›é¢˜å‹å¼•æ“ä½¿ç”¨ï¼‰ï¼›
      - å›è°ƒï¼š
        - `onAnswer(isCorrect, questionType)`ï¼›
        - `onNext()`ï¼›
        - `onSkipYesterdayReview()`ï¼›
        - `onCompletePhonicsRule()`ï¼›
        - `onMiniReviewAnswer()` / `onMiniReviewNext()`ã€‚

- `useModuleAccess.ts`
  - ä¸å­—æ¯æ¨¡å—å…³ç³»ï¼š
    - æä¾› `markAlphabetLessonCompleted(lessonId)` ç»™ `useAlphabetLearningEngine` ä½¿ç”¨ï¼›
    - å®é™…å†™å…¥ `user_alphabet_progress` / `user_progress` ç›¸å…³å­—æ®µçš„èŒè´£åœ¨åç«¯ memory-engine + learn-vocabã€‚

### 2.4 Store å±‚ï¼ˆsrc/storesï¼‰

- `alphabetStore.ts`
  - å·²åœ¨ snapshot æ–‡æ¡£ä¸­æœ‰è¯¦ç»†ä»‹ç»ï¼Œè¿™é‡Œèšç„¦ä¸å­—æ¯æ¨¡å—çš„è¿æ¥ç‚¹ï¼š
  - æ ¸å¿ƒçŠ¶æ€ï¼ˆèŠ‚é€‰ï¼‰ï¼š
    - `queue: AlphabetLearningState[]`ï¼šæœ¬æ¬¡ä¼šè¯çš„å­—æ¯é˜Ÿåˆ—ï¼›
    - `currentIndex: number` / `currentItem: AlphabetLearningState | null`ï¼›
    - `completedCount: number` / `totalCount: number`ï¼šæœ¬è®¾å¤‡ä¸Šå·²å®Œæˆå­—æ¯æ•°é‡å’Œæ€»æ•°ï¼ˆç”¨äºè¯¾ç¨‹è§£é”ï¼‰ï¼›
    - `lessonMetadata: LessonMetadata | null`ï¼šå½“å‰ Lesson çš„å…ƒæ•°æ®ï¼›
    - `phonicsRule: PhonicsRule | null`ï¼šå½“å‰ Lesson çš„æ‹¼è¯»è§„åˆ™ï¼›
    - `cachedAudioKeys: string[]`ï¼šå·²é¢„ä¸‹è½½éŸ³é¢‘çš„ key åˆ—è¡¨ï¼›
    - `phase: LearningPhase`ï¼šä¼šè¯çº§åˆ«ï¼ˆIDLE/COMPLETED ç­‰ï¼‰ã€‚
  - å…³é”®æ–¹æ³•ï¼š
    - `initializeSession(userId, { limit?, lessonId? })`
      - è°ƒç”¨ `callCloudFunction('getTodayMemories', { userId, entityType: 'letter', limit, includeNew: true, lessonId }, { endpoint: API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase })`ï¼›
      - å°†è¿”å›çš„ `items` æ˜ å°„ä¸º `AlphabetLearningState` é˜Ÿåˆ—ï¼›
      - è®¾ç½® `lessonMetadata` / `phonicsRule`ï¼›
      - å¯åŠ¨é¢„ä¸‹è½½ä»»åŠ¡ï¼Œå°† COS éŸ³é¢‘ä¸‹è½½åˆ°æœ¬åœ°å¹¶æ›´æ–° `letter.*LocalPath` å’Œ `audioUrl`ã€‚
    - `submitResult(userId, isCorrect)`
      - å°† `isCorrect` æ˜ å°„ä¸º `QualityButton.KNOW | QualityButton.FORGET`ï¼›
      - è°ƒç”¨ `callCloudFunction('submitMemoryResult', { userId, entityType: 'letter', entityId: currentItem.alphabetId, quality }, { endpoint: API_ENDPOINTS.MEMORY.SUBMIT_MEMORY_RESULT.cloudbase })`ï¼›
      - æ›´æ–°æœ¬åœ° `currentAttempts` / `qualityHistory` / `isCompleted`ï¼›
      - è°ƒç”¨ `next()` è‡ªåŠ¨è¿›å…¥ä¸‹ä¸€é¢˜æˆ–æ ‡è®° `phase=COMPLETED`ã€‚
    - `submitRoundEvaluation(params)`
      - è°ƒç”¨ `callCloudFunction('submitRoundEvaluation', { userId, entityType: 'letter', lessonId, roundNumber, totalQuestions, correctCount, accuracy }, { endpoint: API_ENDPOINTS.MEMORY.SUBMIT_ROUND_EVALUATION.cloudbase })`ï¼›
      - ä¸æ”¹å˜è®°å¿†é˜Ÿåˆ—ï¼Œåªåšç»Ÿè®¡å†™å…¥ã€‚

### 2.5 é…ç½® / ç±»å‹ / å·¥å…·å±‚

- `src/config/alphabet/lessonMetadata.config.ts`
  - å‰ç«¯ç‰ˆè¯¾ç¨‹å…ƒæ•°æ®ï¼ˆLesson1~7ï¼‰ï¼š
    - `LESSON_METADATA: Record<string, LessonMetadata>`ï¼›
    - `LessonMetadata` å®šä¹‰ï¼ˆæ¥è‡ª `phonicsRule.types.ts`ï¼‰åŒ…æ‹¬ï¼š
      - lessonId, title, description, consonants[], vowels[], tones[];
      - phonicsRuleId, totalCount, minPassRate, miniReviewInterval, orderã€‚
  - æä¾›è¾…åŠ©å‡½æ•°ï¼š
    - `getLessonMetadata(lessonId)`ï¼šæŒ‰ id è·å–ï¼›
    - `getAllLessons()`ï¼šæŒ‰ order æ’åºè¿”å›æ‰€æœ‰è¯¾ç¨‹ï¼›
    - `getLessonByLetter(thaiChar)`ï¼šé€šè¿‡å­—æ¯åæŸ¥è¯¾ç¨‹ã€‚

- `src/entities/types/alphabet.types.ts`
  - å®šä¹‰ä¸å­—æ¯æ¨¡å—ç›¸å…³çš„ TypeScript ç±»å‹ï¼š
    - `AlphabetLearningState`ï¼šä¸ `alphabetStore` ä¸­åŒåç±»å‹ç›¸å¯¹åº”ï¼›
    - `AlphabetTest`, `AlphabetTestQuestion`, `AlphabetTestResult`ï¼šç”¨äºå•ç‹¬å­—æ¯æµ‹è¯•åŠŸèƒ½ï¼ˆé 3-Round ä¸»æµï¼‰ã€‚

- `src/entities/enums/LearningPhase.enum.ts`
  - å®šä¹‰å…¨å±€å­¦ä¹ é˜¶æ®µæšä¸¾ `LearningPhase`ï¼Œå­—æ¯æ¨¡å—ä½¿ç”¨å…¶ä¸­çš„ IDLE / COMPLETED ç­‰çŠ¶æ€ã€‚

- `src/utils/lettersQuestionGenerator.ts`
  - èŒè´£ï¼š
    - é’ˆå¯¹å•ä¸ª `Letter` + å­—æ¯æ±  `pool` ç”Ÿæˆå¤ä¹ é¢˜ç›®ï¼›
    - é¢˜å‹ `QuestionType` åŒ…æ‹¬ï¼šSOUND_TO_LETTERã€LETTER_TO_SOUNDã€SYLLABLEã€REVERSE_SYLLABLEã€MISSING_LETTERã€FINAL_CONSONANTã€CLASS_CHOICEã€LETTER_NAME ç­‰ï¼›
    - ç”Ÿæˆç»“æ„ï¼š
      - `AlphabetQuestion`ï¼šåŒ…å« `type`, `stem`, `options`, `correct`, `audioUrl`ï¼›
    - ä½¿ç”¨ `getLetterAudioUrl(letter, 'letter' | 'syllable')` å†³å®šæ’­æ”¾å“ªä¸ªéŸ³é¢‘ã€‚
  - å½“å‰ä½œç”¨ï¼š
    - è¢« `AlphabetReviewView` ä½¿ç”¨ï¼Œä½œä¸ºâ€œåŸºç¡€é¢˜å‹â€ç”Ÿæˆå™¨ï¼›
    - åœ¨æœªæ¥ä¼šä¸ `project-freeze/DESIGN_SPEC.md` ä¸­çš„ 6 å¤§é¢˜å‹æ•´åˆã€‚

### 2.6 åç«¯ memory-engineï¼ˆcloudbase/functions/memory-engineï¼‰

- `index.js`
  - èŒè´£ï¼š
    - CloudBase äº‘å‡½æ•°å…¥å£ï¼›
    - è§£æ HTTP è¯·æ±‚ bodyï¼ŒæŠ½å– `{ action, data }`ï¼›
    - æ ¹æ® action åˆ†å‘è‡³ï¼š
      - `getTodayMemories`, `submitMemoryResult`, `submitRoundEvaluation`, `checkModuleAccess`, `getUserProgress`, `getAlphabetLessons` ç­‰ã€‚

- `handlers/getTodayMemories.js`
  - å­—æ¯åˆ†æ”¯é€»è¾‘ï¼š
    - å½“ `entityType === 'letter'` æ—¶ï¼š
      1. ä» `alphabet_lessons` ä¸­è¯»å– `lessonId` å¯¹åº”é…ç½®ï¼ˆconsonants/vowels/tonesï¼‰ï¼›
      2. ä» `letters` é›†åˆæŸ¥è¯¢å±äºè¯¥è¯¾ç¨‹çš„å­—æ¯ï¼ˆä½¿ç”¨ curriculumLessonIds å­—æ®µï¼‰ï¼›
      3. ä» `memory_status` ä¸­è¯»å–æ¯ä¸ªå­—æ¯çš„è®°å¿†çŠ¶æ€ï¼›
      4. å¯ä» `user_alphabet_progress` / `phonics_rules` ä¸­è¡¥å…… lessonMetadata / phonicsRuleï¼›
      5. è¿”å›ï¼š
         - `items: Array<Letter & { memoryState?: MemoryStatus }>`ï¼›
         - `summary: { total, newCount, reviewCount, entityType: 'letter' }`ï¼›
         - `lessonMetadata`ï¼›
         - `phonicsRule`ã€‚

- `handlers/submitMemoryResult.js`
  - å­—æ¯åˆ†æ”¯é€»è¾‘ï¼š
    - æ ¹æ® `userId + entityType = 'letter' + entityId` æŸ¥æ‰¾ `memory_status` æ–‡æ¡£ï¼›
    - ä½¿ç”¨ç»Ÿä¸€ç®—æ³• `computeNextReview(doc, quality)` æ›´æ–° masteryLevel / reviewStage / nextReviewAt ç­‰ï¼›
    - æ›´æ–°æˆ–æ’å…¥è¯¥æ–‡æ¡£ã€‚

- `handlers/submitRoundEvaluation.js`
  - å­—æ¯ä¸“ç”¨ï¼š
    - å°† `{ userId, entityType: 'letter', lessonId, roundNumber, totalQuestions, correctCount, accuracy }` å†™å…¥ `user_alphabet_progress`ï¼›
    - æ›´æ–° `currentRound`ï¼Œåœ¨ `roundHistory` æ•°ç»„ä¸­è¿½åŠ æ–°è®°å½•ã€‚

- `handlers/getAlphabetLessons.js`
  - èŒè´£ï¼š
    - è¿”å› `alphabet_lessons` é›†åˆä¸­çš„æ‰€æœ‰è¯¾ç¨‹é…ç½®ï¼›
    - åœ¨å‰ç«¯ `app/alphabet/index.tsx` ä¸­ç”¨ä½œè¯¾ç¨‹æ€»è§ˆæ•°æ®æºã€‚

---

## 3. é¡µé¢ä¸å¯¼èˆªé€»è¾‘ï¼ˆå‰ç«¯è·¯ç”± Flowï¼‰

æœ¬èŠ‚ä»â€œç”¨æˆ·è¿›å…¥å­—æ¯æ¨¡å—â€çš„è§’åº¦ï¼Œæ¢³ç†è·¯ç”±ä¸ç»„ä»¶çš„è°ƒç”¨æ¬¡åºã€‚

### 3.1 ä» Courses é¡µè¿›å…¥å­—æ¯æ¨¡å—

ï¼ˆå½“å‰å®ç°ï¼›æœªæ¥å¤§è¯¾ç¨‹é¡µä¼šå¢åŠ ä¸€å±‚ï¼Œä½†æ€»ä½“è·¯çº¿ä¸å˜ï¼‰

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ app/(tabs)/courses.tsx                      â”‚
â”‚ è¯¾ç¨‹æ€»è§ˆé¡µ                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”‚ ç‚¹å‡»â€œæ³°è¯­å­—æ¯â€å¡ç‰‡
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ app/alphabet/index.tsx                      â”‚
â”‚ å­—æ¯è¯¾ç¨‹æ€»è§ˆï¼ˆLesson1~7 åˆ—è¡¨ï¼‰              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”‚ ç‚¹å‡»æŸä¸ª Lesson å¡ç‰‡çš„â€œå¼€å§‹å­¦ä¹ â€
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ app/alphabet/[lessonId].tsx                â”‚
â”‚ å•è¯¾å­¦ä¹ æµï¼ˆ3 è½® + Phase çŠ¶æ€æœºï¼‰           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 å­—æ¯è¯¾ç¨‹æ€»è§ˆé¡µï¼š`app/alphabet/index.tsx`

- åˆå§‹åŒ–æµç¨‹ï¼š
  1. ç»„ä»¶æŒ‚è½½åï¼Œè°ƒç”¨ `callCloudFunction('getAlphabetLessons')`ï¼š
     - endpoint ä½¿ç”¨ `API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase`ï¼ˆå¤ç”¨ memory-engine HTTP å…¥å£ï¼‰ï¼›
     - è‹¥æˆåŠŸï¼Œä½¿ç”¨è¿”å›çš„ `lessons: LessonMetadata[]`ï¼›
     - è‹¥å¤±è´¥ï¼Œä½¿ç”¨ `getAllLessons()` ä»æœ¬åœ° `lessonMetadata.config.ts` è·å–è¯¾ç¨‹è¡¨ï¼›
  2. å°† `LessonMetadata[]` æ˜ å°„ä¸ºæœ¬åœ° `LessonCardProps[]`ï¼š
     - `id` = lessonIdï¼›
     - `title` / `description` = å…ƒæ•°æ®ï¼›
     - `letterKeys` = `consonants + vowels + tones`ï¼›
     - `progress.total` = `lesson.totalCount`ã€‚

- è§£é”é€»è¾‘ï¼š
  - ä» `useAlphabetStore()` è¯»å–ï¼š
    - `completedCount`ï¼šæœ¬åœ°å·²å®Œæˆå­—æ¯æ•°ï¼›
    - `totalCount`ï¼šå½“å‰ä¼šè¯ä¸­å­—æ¯æ€»æ•°ã€‚
  - é€šè¿‡ `lessons.reduce` è®¡ç®—æ¯è¯¾çš„ç´¯è®¡å­—æ¯æ•°é‡ `cumulativeCounts`ï¼›
  - å¯¹äºç¬¬ i è¯¾ï¼š
    - `unlocked = index === 0 || completedCount >= cumulativeCounts[index - 1]`ï¼›
    - `isCurrent = completedCount < cumulativeCounts[index] && unlocked`ã€‚

- UI è¡Œä¸ºï¼š
  - æ¯ä¸ª Lesson å¡ç‰‡æ˜¾ç¤ºï¼š
    - æ ‡é¢˜ / æè¿°ï¼›
    - æœ¬è¯¾å­—æ¯æ•°ï¼›
    - å½“å‰è¿›åº¦ï¼ˆæš‚ä»¥ completedCount ä¸ cumulativeCounts è®¡ç®—ï¼‰ã€‚
  - ç‚¹å‡»â€œå¼€å§‹å­¦ä¹ â€æŒ‰é’®ï¼š
    - `router.push(`/alphabet/${lesson.id}`)`ï¼›
    - ä¸ç›´æ¥æ“ä½œ Storeï¼ŒStore åˆå§‹åŒ–åœ¨ `[lessonId]` é¡µé¢è¿›è¡Œã€‚

### 3.3 å•è¯¾å­¦ä¹ å…¥å£ï¼š`app/alphabet/[lessonId].tsx`

```ts
// å…³é”®ä¼ªä»£ç ç»“æ„
const { lessonId } = useLocalSearchParams<{ lessonId: string }>();
const router = useRouter();

const engine = useAlphabetLearningEngine(lessonId);

return (
  <AlphabetLearningEngineView
    {...engine}
    onBack={() => router.back()}
  />
);
```

- `[lessonId]` é¡µé¢ä¸ç›´æ¥å…³å¿ƒï¼š
  - é˜Ÿåˆ—å¦‚ä½•ç”Ÿæˆï¼›
  - Phase å¦‚ä½•åˆ‡æ¢ï¼›
  - é¢˜å‹å¦‚ä½•æ¸²æŸ“ã€‚
- å…¨éƒ¨äº¤ç»™ï¼š
  - `useAlphabetLearningEngine`ï¼ˆä¸šåŠ¡çŠ¶æ€æœºï¼‰ï¼›
  - `AlphabetLearningEngineView`ï¼ˆè§†å›¾è·¯ç”±å™¨ï¼‰ã€‚

---

## 4. å­¦ä¹ å¼•æ“ï¼šuseAlphabetLearningEngineï¼ˆPhase é€»è¾‘ï¼‰

### 4.1 Phase çŠ¶æ€ä¸ Round æ¦‚å¿µ

åœ¨ Hook å†…éƒ¨ï¼Œæˆ‘ä»¬æœ‰ä¸¤å±‚â€œé˜¶æ®µâ€ï¼š

- **Phaseï¼ˆé˜¶æ®µï¼‰**ï¼šä»£è¡¨å½“å‰ UI æ‰€åœ¨çš„ä¸šåŠ¡é˜¶æ®µï¼š
  - `yesterday-review`ï¼šæ˜¨æ—¥å¤ä¹ ï¼›
  - `yesterday-remedy`ï¼šæ˜¨æ—¥é”™é¢˜è¡¥æ•‘ï¼›
  - `today-learning`ï¼šä»Šæ—¥å­¦ä¹ ï¼›
  - `today-mini-review`ï¼šä»Šæ—¥å°å¤ä¹ ï¼ˆæ¯å­¦ 3 ä¸ªå­—æ¯è§¦å‘ä¸€æ¬¡ï¼‰ï¼›
  - `today-final-review`ï¼šä»Šæ—¥æœ«å°¾å¤ä¹ ï¼›
  - `today-remedy`ï¼šä»Šæ—¥é”™é¢˜è¡¥æ•‘ï¼›
  - `finished`ï¼šè¯¾ç¨‹ä¸‰è½®è¯„ä¼°ç»“æŸã€‚
- **Roundï¼ˆä¸‰è½®è¯„ä¼°è½®æ¬¡ï¼‰**ï¼š
  - `currentRound: 1 | 2 | 3`ï¼›
  - å¯¹åº”ä½ è®¾è®¡çš„ï¼š
    - Round1ï¼šè®¤çŸ¥ï¼ˆè®¤å­—/å¬éŸ³ï¼‰ï¼›
    - Round2ï¼šå±æ€§ï¼ˆè¾…éŸ³ç±»åˆ«ç­‰ï¼‰ï¼›
    - Round3ï¼šåº”ç”¨ï¼ˆå˜å½¢/å£°è°ƒç­‰ï¼Œæœªæ¥ç”± Question Engine ä½“ç°ï¼‰ã€‚

### 4.1.0 å­—æ¯è¯¾ç¨‹æ•´ä½“é˜¶æ®µæµç¨‹å›¾ï¼ˆç±»ä¼¼ç¬¬ä¸€å¼ å›¾ï¼‰

> è¿™å¼ å›¾æ˜¯ **â€œç†æƒ³çŠ¶æ€ / ç›®æ ‡è®¾è®¡â€** çš„çº¿æ€§æµç¨‹å›¾ï¼Œ  
> å±•ç¤ºä» Lesson Start åˆ°ä¸‰è½®è¯„ä¼°å®Œæˆçš„ Phase æµç¨‹ä¸å…³é”®æ–¹æ³•è°ƒç”¨ã€‚

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Lesson Start                                â”‚
â”‚ é¦–æ¬¡è¿›å…¥ /alphabet/[lessonId]               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â”‚ è°ƒç”¨ useAlphabetLearningEngine(lessonId)
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ åˆå§‹åŒ–åç«¯é˜Ÿåˆ—                               â”‚
â”‚ alphabetStore.initializeSession(userId,{    â”‚
â”‚   lessonId                                  â”‚
â”‚ })                                          â”‚
â”‚ â†’ callCloudFunction('getTodayMemories',â€¦)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â”‚ è¿”å› items[] = æ˜¨æ—¥éœ€å¤ä¹  + ä»Šæ—¥æ–°å­—æ¯
                       â”‚ ï¼ˆmemory-engine æŒ‰è¯¾ç¨‹ + SRS è¿‡æ»¤ï¼‰
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 1: yesterday-reviewï¼ˆæ˜¨æ—¥å¤ä¹ ï¼‰       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                     â”‚
        â”‚ ç­”å¯¹                â”‚ ç­”é”™
        â–¼                     â–¼
  nextInQueue()      wrongAnswers.add(alphabetId)
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 2: yesterday-remedyï¼ˆæ˜¨æ—¥è¡¥æ•‘ï¼‰       â”‚
â”‚ æŒ‰ wrongAnswers å‡ºå¤ä¹ é¢˜                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”œâ”€â”€ ä»æœ‰é”™é¢˜ â†’ å›åˆ°è¡¥æ•‘é˜¶æ®µå‡ºé¢˜
        â”‚
        â””â”€â”€ é”™é¢˜æ¸…ç©º â†’ è¿›å…¥ä»Šæ—¥å­¦ä¹ 
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 3: today-learningï¼ˆä»Šæ—¥å­¦ä¹ ï¼‰         â”‚
â”‚ ä¸‰æ–°ä¸€å¤ä¹  + Mini Review                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 4: today-mini-review / final-review   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 5: today-remedyï¼ˆä»Šæ—¥è¡¥æ•‘ï¼‰           â”‚
â”‚ é’ˆå¯¹ä»Šæ—¥é”™é¢˜ç»§ç»­å‡ºé¢˜                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”œâ”€â”€ ä»æœ‰é”™é¢˜ â†’ ç•™åœ¨è¡¥æ•‘é˜¶æ®µ
        â””â”€â”€ é”™é¢˜æ¸…ç©º â†’ è¿›å…¥ä¸‰è½®åˆ¤å®š
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 6: round-evaluationï¼ˆä¸‰è½®è¯„ä¼°ï¼‰       â”‚
â”‚ submitRoundResults() â†’ submitRoundEvaluationâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”œâ”€â”€ è‹¥ currentRound < 3 ä¸”æœ¬è½®é€šè¿‡ â†’   â”‚
        â”‚    currentRound + 1, phase='yesterday-review'
        â”‚
        â””â”€â”€ è‹¥ currentRound = 3 ä¸”é€šè¿‡ â†’       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 7: finishedï¼ˆè¯¾ç¨‹å®Œæˆï¼‰               â”‚
â”‚ markAlphabetLessonCompleted(lessonId)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.1.1 å­—æ¯å­¦ä¹  Phase + æ–¹æ³•è°ƒç”¨æ€»è§ˆï¼ˆMermaidï¼‰

```text
ã€è°ƒç”¨å…³ç³»æ¦‚è§ˆã€‘

app/alphabet/[lessonId].tsx
  â””â”€ è°ƒç”¨ useAlphabetLearningEngine(lessonId)
       â”œâ”€ åˆå§‹åŒ–é˜¶æ®µï¼š
       â”‚    â””â”€ alphabetStore.initializeSession(userId,{ lessonId })
       â”‚         â””â”€ callCloudFunction('getTodayMemories', { entityType:'letter', lessonId })
       â”‚              â””â”€ memory-engine.handlers.getTodayMemories
       â”‚                   â””â”€ è¿”å› items + memoryState + lessonMetadata + phonicsRule
       â”‚
       â”œâ”€ Phase = 'yesterday-review' / 'today-final-review' / 'today-remedy'
       â”‚    â””â”€ AlphabetLearningEngineView â†’ AlphabetReviewView
       â”‚         â””â”€ ç”¨æˆ·ç­”é¢˜ onAnswer(isCorrect, qType)
       â”‚              â””â”€ useAlphabetLearningEngine.handleAnswer
       â”‚                   â””â”€ alphabetStore.submitResult(userId, isCorrect)
       â”‚                        â”œâ”€ callCloudFunction('submitMemoryResult', {...})
       â”‚                        â””â”€ æ›´æ–°æœ¬åœ° currentAttempts / isCompleted
       â”‚                             â””â”€ alphabetStore.nextInQueue()
       â”‚                                  â””â”€ åˆ‡æ¢ currentItem
       â”‚
       â”œâ”€ Phase = 'today-learning'
       â”‚    â”œâ”€ è‹¥ showPhonicsRuleCard â†’ PhonicsRuleCard
       â”‚    â””â”€ å¦åˆ™ â†’ AlphabetLearningViewï¼ˆæ•™å­¦å¡ï¼‰
       â”‚
       â”œâ”€ Phase = 'today-mini-review'
       â”‚    â””â”€ MiniReviewQuestionComponent
       â”‚         â””â”€ onMiniReviewAnswer / onMiniReviewNext
       â”‚            ï¼ˆå½“å‰åªå½±å“æœ¬åœ° miniReview é˜Ÿåˆ—ï¼Œä¸è°ƒç”¨åç«¯ï¼‰
       â”‚
       â””â”€ ä¸‰è½®ç»“æŸï¼š
            â””â”€ submitRoundResults()
                 â”œâ”€ alphabetStore.submitRoundEvaluation({ userId, lessonId, ... })
                 â”‚    â””â”€ callCloudFunction('submitRoundEvaluation', {...})
                 â”‚         â””â”€ memory-engine.handlers.submitRoundEvaluation
                 â””â”€ è‹¥ currentRound < 3 â†’ currentRound++ï¼Œphase='yesterday-review'
                    è‹¥ = 3 â†’ moduleAccessStore.markAlphabetLessonCompleted(lessonId)ï¼Œphase='finished'
```

### 4.2 åˆå§‹åŒ–ï¼šè°ƒç”¨ alphabetStore.initializeSession

æ ¸å¿ƒé€»è¾‘ï¼ˆä¼ªä»£ç ï¼‰ï¼š

```ts
const { queue, currentItem, lessonMetadata, phonicsRule, initializeSession, submitResult, submitRoundEvaluation: submitRoundToStore, next: nextInQueue } = useAlphabetStore();
const { markAlphabetLessonCompleted } = useModuleAccessStore();
const { currentUser } = useUserStore();
const userId = currentUser?.userId ?? 'test-user';

useEffect(() => {
  let cancelled = false;

  (async () => {
    try {
      await initializeSession(userId, { lessonId });  // è°ƒç”¨ memory-engine.getTodayMemories
    } catch (e) {
      if (!cancelled) {
        setInitialized(true);
        setPhase('finished'); // å‡ºé”™æ—¶è§†ä¸ºæ— æ³•å­¦ä¹ ï¼Œç›´æ¥å®Œæˆ
      }
      return;
    }
    if (!cancelled) setInitialized(true);
  })();

  return () => { cancelled = true; };
}, [lessonId, userId, initializeSession]);
```

- ä¾èµ–ï¼š
  - `alphabetStore.initializeSession(...)` å®Œæˆä¸ memory-engine çš„äº¤äº’ï¼Œå‡†å¤‡å¥½ `queue` å’Œ `currentItem`ï¼›
  - `lessonMetadata` / `phonicsRule` è¢«ä¿å­˜åœ¨ `alphabetStore` ä¸­ï¼Œä¾› UI ä½¿ç”¨ã€‚

### 4.3 æ˜¨æ—¥å¤ä¹ ä¸è·³è¿‡é€»è¾‘

- åˆå§‹åŒ–å Phase é»˜è®¤è¿›å…¥ `'yesterday-review'`ã€‚
- ä½¿ç”¨ä¸€ä¸ª effect åˆ¤æ–­æ˜¯å¦å­˜åœ¨â€œéæ–°å­—æ¯â€ï¼š

```ts
useEffect(() => {
  if (!initialized) return;
  if (phase !== 'yesterday-review') return;

  const hasNonNew = queue.some(
    (item) => item.memoryState && item.memoryState.isNew === false,
  );

  if (!hasNonNew) {
    setPhase('today-learning'); // æ²¡æœ‰æ—§å­—æ¯æ—¶è·³è¿‡æ˜¨æ—¥å¤ä¹ 
  }
}, [initialized, phase, queue]);
```

- `onSkipYesterdayReview`ï¼š
  - æš´éœ²ç»™ UIï¼Œåœ¨ `AlphabetLearningEngineView` æ˜¾ç¤ºâ€œè·³è¿‡æ˜¨æ—¥å¤ä¹ â€æŒ‰é’®ï¼›
  - ç‚¹å‡»æ—¶ç›´æ¥ `setPhase('today-learning')`ã€‚

#### 4.3.1 yesterday-review çš„æ•°æ®æ¥æºä¸åˆ¤å®šè§„åˆ™

- **æ•°æ®æ¥æºï¼š**
  - æ‰€æœ‰é¢˜ç›®æ•°æ®éƒ½æ¥è‡ª `alphabetStore.queue`ï¼Œè€Œ `queue` åˆå®Œå…¨ç”± `memory-engine.getTodayMemories` è¿”å›çš„ `items` æ˜ å°„è€Œæ¥ï¼š
    - `items: Array<Letter & { memoryState?: MemoryStatus }>`ï¼›
    - æ¯ä¸ª `item.memoryState` ç”±åç«¯æ ¹æ® `memory_status` è®¡ç®—å¾—åˆ°ã€‚
  - å‰ç«¯æœ¬èº«**ä¸ä¼šå•ç‹¬å†æŸ¥ DB**ï¼Œæ‰€æœ‰â€œæ˜¨æ—¥å¤ä¹ /ä»Šæ—¥æ–°å­—æ¯â€çš„åˆ¤æ–­éƒ½åŸºäº `memoryState`ã€‚

- **ä»€ä¹ˆå†…å®¹ä¼šè¢«è®¤ä¸ºæ˜¯â€œæ˜¨æ—¥å¤ä¹ â€ï¼Ÿ**
  - memory-engine åœ¨å­—æ¯åˆ†æ”¯ä¸­è¿”å› `summary.newCount` / `summary.reviewCount`ï¼Œå¹¶ä¸ºæ¯ä¸ªå­—æ¯é™„åŠ ï¼š
    - `memoryState.isNew: boolean`ï¼š
      - `true`ï¼šåç«¯è®¤ä¸ºè¯¥å­—æ¯æ˜¯â€œæ–°å­—æ¯â€ï¼ˆæ²¡æœ‰å†å²è®°å¿†è®°å½•ï¼‰ï¼›
      - `false`ï¼šå·²æœ‰è®°å¿†è®°å½•ï¼Œéœ€è¦å¤ä¹ ã€‚
  - åœ¨å‰ç«¯ï¼š
    - **æ˜¯å¦å­˜åœ¨æ˜¨æ—¥å¤ä¹ é˜¶æ®µ**ï¼šä»…æ£€æŸ¥
      ```ts
      queue.some(
        (item) => item.memoryState && item.memoryState.isNew === false,
      );
      ```
      - è‹¥å­˜åœ¨ä»»æ„ `isNew === false` çš„å­—æ¯ï¼Œåˆ™ä¿ç•™ `'yesterday-review'` Phaseï¼›
      - è‹¥æ‰€æœ‰å­—æ¯ `isNew === true`ï¼Œåˆ™è®¤ä¸ºæ²¡æœ‰â€œæ—§å­—æ¯â€ï¼Œç›´æ¥è¿›å…¥ `'today-learning'`ã€‚
    - **åœ¨ `'yesterday-review'` é˜¶æ®µå±•ç¤ºçš„å†…å®¹**ï¼š
      - å½“å‰å®ç°ä¸­ï¼Œ`AlphabetLearningEngineView` å¹¶ä¸å¯¹ `queue` å†åšåˆ†æ®µï¼Œè€Œæ˜¯ä¾èµ– memory-engine å¯¹é˜Ÿåˆ—é¡ºåºçš„çº¦å®šï¼š
        - åç«¯è´Ÿè´£å°†â€œéœ€å¤ä¹ çš„å­—æ¯â€ä¸â€œæ–°å­—æ¯â€æ··æ’/æ’åºï¼›
        - å‰ç«¯åœ¨ `'yesterday-review'` Phase ä¸‹ï¼Œå¯¹ `currentItem` è¿›è¡Œå¤ä¹ ï¼›
        - ä¸€æ—¦åç«¯è¿”å›çš„é˜Ÿåˆ—ä¸­å·²æ— éæ–°å­—æ¯ï¼ˆæ‰€æœ‰å‰©ä½™é¡¹ `isNew === true`ï¼‰ï¼Œå³å¯åˆ‡æ¢åˆ° `'today-learning'`ã€‚
      - ç®€åŒ–ç†è§£ï¼š**å‡¡æ˜¯ `memoryState.isNew === false` çš„å­—æ¯ï¼Œéƒ½ä¼šåœ¨ Yesterday Review é˜¶æ®µè¢«å½“ä½œâ€œå¤ä¹ é¡¹ç›®â€å¤„ç†**ï¼Œå…·ä½“â€œæ˜¯å¦çœŸçš„æ¥è‡ªæ˜¨å¤©â€ç”± memory-engineï¼ˆSRS ç®—æ³•ï¼‰è´Ÿè´£ï¼Œå‰ç«¯ä¸åŒºåˆ†â€œæ˜¨å¤© vs æ›´æ—©â€ã€‚

- **ä¸ Today Learning çš„å…³ç³»ï¼š**
  - `'today-learning'` é˜¶æ®µä¸»è¦é¢å‘ `isNew === true` çš„å­—æ¯ï¼›
  - è¿™äº›å­—æ¯åœ¨æœ¬è½®å®Œæˆåä¼šé€šè¿‡ `submitMemoryResult` å†™å…¥ `memory_status`ï¼Œä»ä¸‹ä¸€æ¬¡è¿›å…¥æœ¬è¯¾èµ·ï¼Œå°†è¢«è§†ä¸ºâ€œæœ‰è®°å¿†è®°å½•â€çš„å¤ä¹ å¯¹è±¡ã€‚

### 4.4 ä»Šæ—¥å­¦ä¹  + Mini Review

- `handleNext()` é€»è¾‘ï¼š

```ts
const handleNext = useCallback(() => {
  if (phase === 'today-learning') {
    setTodayList((prev) => [...prev, currentItem!]);
    setLearnedCount((prev) => prev + 1);

    const newCount = learnedCount + 1;
    if (newCount % MINI_REVIEW_INTERVAL === 0) {
      triggerMiniReview();   // è¿›å…¥ today-mini-review
      return;
    }
  }

  nextInQueue(); // è°ƒç”¨ alphabetStore.nextï¼Œåˆ‡åˆ°ä¸‹ä¸€ä¸ªå­—æ¯
}, [...]);
```

- Mini Reviewï¼š
  - `triggerMiniReview()` ä¼šä½¿ç”¨æœ€è¿‘å­¦ä¹ è¿‡çš„è‹¥å¹²å­—æ¯æ„é€  `miniReviewQuestions` åˆ—è¡¨ï¼›
  - Phase åˆ‡æ¢ä¸º `'today-mini-review'`ï¼›
  - UI ä½¿ç”¨ `MiniReviewQuestionComponent` æ¸²æŸ“ï¼›
  - æ‰€æœ‰ mini é¢˜ç­”å®Œä¸”é”™é¢˜æ¸…ç©ºåï¼Œå›åˆ° `'today-learning'`ã€‚

### 4.5 ç­”é¢˜æäº¤ä¸é”™é¢˜è®°å½•

- `handleAnswer(isCorrect, questionType)`ï¼š

```ts
const handleAnswer = useCallback(
  async (isCorrect: boolean, questionType: QuestionType) => {
    if (!currentItem) return;

    await submitResult(userId, isCorrect); // alphabetStore â†’ memory-engine.submitMemoryResult

    if (!isCorrect) {
      setWrongAnswers((prev) => new Set(prev).add(currentItem.alphabetId));
    }
  },
  [currentItem, userId, submitResult]
);
```

- æ³¨æ„ï¼š
  - æ‰€æœ‰â€œé¢˜ç›®å¯¹/é”™â€ä¿¡æ¯éƒ½ä¼šä¼ ç»™ `alphabetStore.submitResult`ï¼Œåè€…å†è°ƒç”¨ memory-engineï¼›
  - æœ¬åœ°é¢å¤–ç»´æŠ¤ä¸€ä¸ª `wrongAnswers: Set<string>`ï¼ˆæŒ‰ alphabetIdï¼‰ï¼Œä¾›ä¸‰è½®è¯„ä¼°ä½¿ç”¨ã€‚

### 4.6 ä¸‰è½®è¯„ä¼°ä¸ç»“æŸæ¡ä»¶

- `submitRoundResults()`ï¼š

```ts
const submitRoundResults = useCallback(async () => {
  const roundData = {
    roundNumber: currentRound,
    totalQuestions: todayList.length,
    correctCount: todayList.length - wrongAnswers.size,
    accuracy: (todayList.length - wrongAnswers.size) / todayList.length,
    passed: wrongAnswers.size / todayList.length <= 0.1, // é”™é¢˜ â‰¤ 10%
  };

  setRoundEvaluation((prev) => ({
    ...prev,
    currentRound: currentRound,
    rounds: [...prev.rounds, roundData],
  }));

  await submitRoundToStore({
    userId,
    lessonId,
    ...roundData,
  });

  if (currentRound < 3) {
    setCurrentRound((currentRound + 1) as 1 | 2 | 3);
    setWrongAnswers(new Set());
    setPhase('yesterday-review');  // æ–°ä¸€è½®ä»æ˜¨æ—¥å¤ä¹ å¼€å§‹
  } else {
    markAlphabetLessonCompleted(lessonId); // é€šçŸ¥æ¨¡å—è®¿é—® Store
    setPhase('finished');
  }
}, [...]);
```

- ç»“æŸæ¡ä»¶ï¼š
  - ä¸‰è½®éƒ½é€šè¿‡ï¼ˆæ¯è½®é”™é¢˜æ¯”ä¾‹ â‰¤ 10%ï¼‰ï¼›
  - Phase è¿›å…¥ `'finished'`ï¼›
  - `AlphabetLearningEngineView` åœ¨è¯¥ phase å±•ç¤ºä¸‰è½®ç»“æœï¼Œå¹¶å¯æä¾›â€œè¿”å›è¯¾ç¨‹åˆ—è¡¨â€ç­‰æ“ä½œã€‚

---

## 5. è§†å›¾å±‚ï¼šAlphabetLearningEngineView çš„ Phase æ¸²æŸ“

### 5.1 Props æ¥å£

```ts
interface AlphabetLearningEngineViewProps {
  initialized: boolean;
  phase: Phase;                        // useAlphabetLearningEngine ä¸­å®šä¹‰çš„ç±»å‹
  currentRound: 1 | 2 | 3;
  roundEvaluation?: RoundEvaluationState;

  currentItem: AlphabetLearningState | null;
  currentQuestionType: QuestionType | null;
  letterPool: Letter[];

  // æ ¸å¿ƒäº¤äº’
  onAnswer: (isCorrect: boolean, type: QuestionType) => void;
  onNext: () => void;
  onBack?: () => void;

  // æ˜¨æ—¥å¤ä¹ æ§åˆ¶
  onSkipYesterdayReview?: () => void;

  // æ‹¼è¯»è§„åˆ™å¡
  phonicsRule: PhonicsRule | null;
  showPhonicsRuleCard: boolean;
  onCompletePhonicsRule?: () => void;

  // Mini Review
  miniReviewQuestion: MiniReviewQuestionType | null;
  onMiniReviewAnswer?: (isCorrect: boolean) => void;
  onMiniReviewNext?: () => void;
}
```

### 5.2 Phase â†’ è§†å›¾æ˜ å°„

- `!initialized || !currentItem`ï¼š
  - å±•ç¤ºåŠ è½½ä¸­çš„ `ActivityIndicator`ã€‚

- `phase === 'yesterday-review' | 'yesterday-remedy' | 'today-final-review' | 'today-remedy'`ï¼š
  - æ¸²æŸ“ï¼š

```tsx
<SafeAreaView style={{ flex: 1 }}>
  <RoundHeader currentRound={currentRound} />
  {phase === 'yesterday-review' && onSkipYesterdayReview && (
    // å³ä¸Šè§’â€œè·³è¿‡æ˜¨æ—¥å¤ä¹ â€æŒ‰é’®
  )}
  <AlphabetReviewView
    alphabet={currentItem}
    letterPool={letterPool}
    preferredType={currentQuestionType ?? undefined}
    onAnswer={onAnswer}
    onNext={onNext}
    onBack={onBack}
  />
</SafeAreaView>
```

- `phase === 'today-mini-review'`ï¼š
  - å¦‚æœæœ‰ `miniReviewQuestion`ï¼š
    - ä½¿ç”¨ `MiniReviewQuestionComponent` æ¸²æŸ“ï¼›
  - å¦åˆ™å›é€€ä¸º `AlphabetReviewView`ã€‚

- `phase === 'today-learning'`ï¼š
  - å¦‚æœ `showPhonicsRuleCard && phonicsRule`ï¼š
    - æ¸²æŸ“ `PhonicsRuleCard`ï¼ˆå±•ç¤ºæ‹¼è¯»è§„åˆ™ï¼Œç”¨æˆ·è¯»å®Œåç‚¹å‡»â€œå®Œæˆâ€ï¼Œè°ƒç”¨ `onCompletePhonicsRule`ï¼‰ï¼›
  - å¦åˆ™æ¸²æŸ“ `AlphabetLearningView`ï¼ˆå•å­—æ¯æ•™å­¦å¡ï¼‰ã€‚

- `phase === 'finished'`ï¼š
  - å±•ç¤ºä¸‰è½®è¯„ä¼°ç»“æœï¼ˆ`roundEvaluation.rounds`ï¼‰ï¼›
  - æ˜¾ç¤ºæ¯ä¸€è½®çš„æ­£ç¡®ç‡å’Œæ˜¯å¦é€šè¿‡ï¼›
  - å¯ä»¥åœ¨æ­¤å¤„æ·»åŠ â€œè¿”å›è¯¾ç¨‹åˆ—è¡¨â€ç­‰æŒ‰é’®ã€‚

---

## 6. é¢˜å‹ä¸ Question Engineï¼ˆç°çŠ¶ä¸è§„åˆ’ï¼‰

### 6.1 ç°çŠ¶ï¼šlettersQuestionGenerator æä¾›çš„é¢˜å‹

å½“å‰å¤ä¹ é¢˜ä¸»è¦ç”± `src/utils/lettersQuestionGenerator.ts` æä¾›ï¼š

- è¾“å…¥ï¼š
  - `letter: Letter`ï¼šå½“å‰å¤ä¹ çš„å­—æ¯ï¼›
  - `pool: Letter[]`ï¼šä»Šæ—¥æ‰€æœ‰å­—æ¯ï¼Œç”¨äºç”Ÿæˆå¹²æ‰°é¡¹ï¼›
  - `preferredType?: QuestionType`ï¼šå¯ä»¥æŒ‡å®šé¢˜å‹ã€‚
- è¾“å‡ºï¼š
  - `AlphabetQuestion`ï¼š
    - `type: QuestionType`ï¼›
    - `stem: string`ï¼šé¢˜å¹²ï¼›
    - `options: string[]`ï¼šé€‰é¡¹ï¼›
    - `correct: string`ï¼šæ­£ç¡®ç­”æ¡ˆï¼›
    - `audioUrl?: string`ï¼šå…³è”éŸ³é¢‘ã€‚

é¢˜å‹ç¤ºä¾‹ï¼š

- SOUND_TO_LETTERï¼šå¬éŸ³é€‰å­—æ¯ï¼›
- LETTER_TO_SOUNDï¼šçœ‹å­—é€‰å‘éŸ³ï¼›
- SYLLABLEï¼šå­—æ¯ + å…ƒéŸ³çš„æ‹¼è¯»ï¼›
- REVERSE_SYLLABLEï¼šç»™è¯»éŸ³åæ¨å­—æ¯ï¼›
- MISSING_LETTERï¼šç¼ºå­—å¡«ç©ºï¼›
- FINAL_CONSONANTï¼šè€ƒå¯Ÿå°¾è¾…éŸ³å‘éŸ³ï¼›
- CLASS_CHOICEï¼šè¾…éŸ³ç±»åˆ«é€‰æ‹©ï¼ˆä¸­/é«˜/ä½ï¼‰ï¼›
- LETTER_NAMEï¼šå­—æ¯åç§°åˆ¤æ–­ã€‚

### 6.2 è§„åˆ’ï¼šç»Ÿä¸€ Question Engineï¼ˆæœ¬æ¨¡å—å†…éƒ¨å®šä¹‰ï¼‰

æœ¬æ¨¡å—æœªæ¥ç‰ˆæœ¬ä¸­ï¼Œå­—æ¯é¢˜å‹å°†ç”±ç»Ÿä¸€çš„ Question Engine åè®®é©±åŠ¨ï¼š

- æšä¸¾ `GameType`ï¼šæ˜ å°„ 6 å¤§é¢˜å‹ï¼ˆåŸºç¡€å¬è§‰/è§†è§‰é¢˜ + æ‹¼è¯»æ•°å­¦ + å£°è°ƒè®¡ç®—å™¨ç­‰ï¼‰ï¼›  
- ç»“æ„åŒ–çš„ `QueueItem` / `InstructItem` / `QuizItem`ï¼›  
- å„é¢˜å‹çš„ä¸“ç”¨ payloadï¼ˆä¾‹å¦‚ ConsonantClassSortã€SpellingMathã€ToneCalculator ç­‰ï¼‰ã€‚

ä¸å­—æ¯æ¨¡å—çš„å…³ç³»ï¼š

- æœªæ¥æ”¹é€ åŸåˆ™ï¼š
  - `useAlphabetLearningEngine` ä¸ç›´æ¥ä¾èµ– `lettersQuestionGenerator`ï¼›  
  - è€Œæ˜¯åœ¨ Phase å†…è°ƒç”¨ `generateQueueItems(FlowContext)`ï¼›  
  - `AlphabetLearningEngineView` ä¸ç›´æ¥æ¸²æŸ“ `AlphabetReviewView`ï¼Œè€Œæ˜¯æ¸²æŸ“ `GameContainer + StepRenderer`ã€‚

åœ¨å½“å‰ç‰ˆæœ¬ï¼Œæœ¬ spec åªè¦æ±‚ç†è§£ç°æœ‰å®ç°ï¼›  
åç»­çœŸæ­£è¿ç§»åˆ° 6 å¤§é¢˜å‹æ—¶ï¼Œåº”åœ¨æœ¬èŠ‚å†…ç»™å‡º `GameType` / payload çš„æ­£å¼å®šä¹‰ï¼Œå¹¶æ®æ­¤å®ç°ã€‚

### 6.3 Question Engine é›†æˆæµç¨‹å›¾

> æœ¬å°èŠ‚è¯´æ˜ Question Engine å°†å¦‚ä½•åµŒå…¥å­—æ¯æ¨¡å—ï¼Œæ˜¯æœªæ¥å®ç°æ—¶çš„ç»“æ„å‚è€ƒã€‚

```text
AlphabetLessonFlow / app/alphabet/[lessonId].tsx
  â””â”€ useAlphabetLearningEngine
       â””â”€ åœ¨æ¯ä¸ª Phase / Round å†…æ„é€  FlowContextï¼š
            { lessonId, round, phase, letters, userStats? }
             â–¼
       è°ƒç”¨ generateQueueItems(FlowContext)
             â–¼
       è¿”å› QueueItem[] = [
         { kind:'INSTRUCT', ... },
         { kind:'QUIZ', gameType:GameType.X, payload:{...} },
         ...
       ]
             â–¼
       äº¤ç»™ GameContainer æ¸²æŸ“æœ¬è½®é˜Ÿåˆ—ï¼š
         - ç»´æŠ¤ currentIndex / å½“å‰ QueueItem
         - ç»´æŠ¤ wrongPoolï¼ˆé”™é¢˜æ± ï¼‰
         - å°†å½“å‰ QueueItem äº¤ç»™ StepRenderer
             â–¼
       StepRenderer:
         - æ ¹æ® gameType å†³å®šå…·ä½“ç»„ä»¶ï¼š
             LISTEN_SELECT          â†’ <ListenSelectView />
             CONSONANT_CLASS_SORT   â†’ <ConsonantClassSorter />
             SPELLING_MATH          â†’ <SpellingMathView />
             TONE_CALCULATOR        â†’ <ToneCalculatorView />
             ...
         - ç”¨æˆ·ä½œç­” â†’ onAnswer(isCorrect)
             â–¼
       GameContainer:
         - è‹¥éœ€è¦ï¼Œè°ƒç”¨ alphabetStore.submitResult(userId, isCorrect)
         - è‹¥é”™è¯¯ï¼Œå°†é¢˜ç›®/å­—æ¯åŠ å…¥ wrongPool
         - é˜Ÿåˆ—ç»“æŸæ—¶ï¼Œå›è°ƒ onQueueComplete({ stats, wrongPool })
             â–¼
       useAlphabetLearningEngine:
         - æ ¹æ® stats / wrongPool å†³å®šï¼š
             * æ˜¯å¦è¿›å…¥è¡¥æ•‘é˜¶æ®µ
             * æ˜¯å¦è¿›å…¥ä¸‹ä¸€è½® Round
             * æ˜¯å¦è¿›å…¥ finished
```

- åœ¨è¿™ä¸€è®¾è®¡ä¸‹ï¼š
  - **Hook å±‚**ï¼ˆ`useAlphabetLearningEngine`ï¼‰åªè´Ÿè´£ Phase çŠ¶æ€æœºï¼Œä¸é¢˜å‹æ— å…³ï¼›
  - **Question Engine å±‚**è´Ÿè´£ï¼š
    - æ ¹æ® Round/Phase å†³å®šä½¿ç”¨å“ªäº› `GameType`ï¼›
    - ä¸ºæ¯ç§ `GameType` ç”Ÿæˆç»“æ„åŒ– payloadï¼›
  - **GameContainer + StepRenderer** å°† `QueueItem` æ˜ å°„ä¸ºå…·ä½“ UI ç»„ä»¶ï¼Œå¹¶åœ¨ç­”é¢˜åç»Ÿä¸€è°ƒç”¨ `submitResult`ã€‚

---

## 7. æ•°æ®ç»“æ„ä¸å­—æ®µä½¿ç”¨ï¼ˆLetters / Lessons / Memoryï¼‰

### 7.1 å­—æ¯å®ä½“ï¼šLETTERS é›†åˆ

- æ¥æºï¼š`assets/courses/letters_final.enriched.json`ï¼›
- å…³é”®å­—æ®µï¼ˆèŠ‚é€‰ï¼‰ï¼š
  - `_id: string`ï¼ˆå¦‚ `TH_C_01`ï¼‰
  - `type: 'consonant' | 'vowel' | 'tone'`
  - `thaiChar: string`
  - `nameThai: string`
  - `nameEnglish: string`
  - `initialSound: string`
  - `finalSound: string`
  - `class: 'high' | 'mid' | 'low' | null`
  - `category: string`ï¼ˆå¦‚ `mid_consonant`, `vowel`ï¼‰
  - `subCategory: string`
  - éŸ³é¢‘ç›¸å…³ï¼š
    - `fullSoundUrl`, `syllableSoundUrl`, `endSyllableSoundUrl`, `letterPronunciationUrl`
    - ä»¥åŠ Store é¢„ä¸‹è½½åé™„åŠ çš„ `fullSoundLocalPath`, `syllableSoundLocalPath`, `endSyllableSoundLocalPath`, `letterPronunciationLocalPath`
  - è¯¾ç¨‹æ˜ å°„ï¼š
    - `curriculumLessonIds: string[]`
    - `curriculumLessonOrders: number[]`
    - `primaryCurriculumLessonId: string`
    - `primaryCurriculumLessonOrder: number`

å­—æ¯æ¨¡å—ä¸­ï¼š

- `alphabetStore.initializeSession` ä¼šæ ¹æ® `lessonId` ä»åç«¯å–å›åŒ…å«è¿™äº›å­—æ®µçš„ `Letter` æ–‡æ¡£ï¼›
- `AlphabetLearningState.letter` ä¸­å®Œæ•´ä¿å­˜äº† `Letter`ï¼Œä¾› `AlphabetLearningView` / é¢˜å‹å¼•æ“ä½¿ç”¨ã€‚

### 7.2 è¯¾ç¨‹å…ƒæ•°æ®ï¼šALPHABET_LESSONS é›†åˆ + lessonMetadata.config.ts

- åç«¯é›†åˆ `ALPHABET_LESSONS`ï¼š
  - å­—æ®µä¸ `LessonMetadata` å¯¹é½ï¼›
  - ç”¨äº memory-engine å’Œå‰ç«¯ `getAlphabetLessons` handlerã€‚

- å‰ç«¯ `lessonMetadata.config.ts`ï¼š
  - æœ¬åœ°å¤‡ä»½ï¼ˆå›é€€é€»è¾‘ä½¿ç”¨ï¼‰ï¼›
  - å­—æ®µï¼š
    - `lessonId`, `title`, `description`ï¼›
    - `consonants[]`, `vowels[]`, `tones[]`ï¼›
    - `phonicsRuleId`, `totalCount`, `minPassRate`, `miniReviewInterval`, `order`ã€‚

### 7.3 è®°å¿†çŠ¶æ€ï¼šMEMORY_STATUS + USER_ALPHABET_PROGRESS

- `MEMORY_STATUS`ï¼š
  - `userId`, `entityType = 'letter'`, `entityId`ï¼›
  - `masteryLevel`, `reviewStage`, `correctCount`, `wrongCount`, `streakCorrect`, `nextReviewAt`, `isNew`ã€‚
  - æ‰€æœ‰å¯¹/é”™ç»“æœé€šè¿‡ `submitMemoryResult` å†™å…¥ã€‚

- `USER_ALPHABET_PROGRESS`ï¼š
  - `userId`, `lessonId`, `currentRound`, `roundHistory[]`ï¼›
  - ä¸‰è½®è¯„ä¼°ç»“æœé€šè¿‡ `submitRoundEvaluation` å†™å…¥ã€‚

### 7.4 å­—æ¯æ¨¡å—â€œåˆ†æ•° / ç»Ÿè®¡â€å¦‚ä½•è®¡ç®—

å­—æ¯æ¨¡å—ç›®å‰æœ‰ä¸¤å±‚â€œåˆ†æ•°/ç»Ÿè®¡â€ï¼Œåˆ†åˆ«å¯¹åº”çŸ­æœŸå’Œé•¿æœŸï¼š

1. **çŸ­æœŸï¼šå•è¯¾ä¸‰è½®è¯„ä¼°ï¼ˆRoundEvaluationï¼‰**
   - åœ¨ `useAlphabetLearningEngine.submitRoundResults` ä¸­æŒ‰å¦‚ä¸‹æ–¹å¼è®¡ç®—ï¼š
     - `totalQuestions = todayList.length`ï¼ˆæœ¬è¯¾å½“å‰è½®æ¬¡å®é™…å‡ºç°è¿‡çš„å­—æ¯æ•°é‡ï¼‰ï¼›
     - `wrongAnswers: Set<string>` è®°å½•å½“å‰è½®ä¸­â€œæ›¾ç»ç­”é”™è¿‡çš„å­—æ¯ IDâ€ï¼ˆæŒ‰ alphabetId å»é‡ï¼‰ï¼›
     - `correctCount = totalQuestions - wrongAnswers.size`ï¼›
     - `accuracy = correctCount / totalQuestions`ï¼ˆ0~1 ä¹‹é—´ï¼‰ï¼›
     - `passed = wrongAnswers.size / totalQuestions <= 0.1`ï¼ˆé”™é¢˜æ¯”ä¾‹ â‰¤ 10% è§†ä¸ºé€šè¿‡ï¼‰ã€‚
   - è¯¥ç»Ÿè®¡ç»“æœï¼š
     - ä¸€æ–¹é¢ä¿å­˜åœ¨ Hook çš„æœ¬åœ°çŠ¶æ€ `roundEvaluation.rounds` ä¸­ï¼Œç”¨äºå®Œæˆé¡µå±•ç¤ºï¼›
     - å¦ä¸€æ–¹é¢é€šè¿‡ `alphabetStore.submitRoundEvaluation` å†™å…¥ `user_alphabet_progress.roundHistory`ï¼Œä¾›åç«¯ç»Ÿè®¡ä¸è§£é”é€»è¾‘ä½¿ç”¨ã€‚

2. **é•¿æœŸï¼šè®°å¿†æ›²çº¿ä¸ masteryï¼ˆmemory-engineï¼‰**
   - æ¯é“é¢˜çš„å¯¹/é”™éƒ½ä¼šè°ƒç”¨ `submitMemoryResult(userId, quality)`ï¼š
     - å‰ç«¯åªåŒºåˆ† `isCorrect: boolean`ï¼›
     - Store å°†å…¶æ˜ å°„ä¸º `QualityButton.KNOW | QualityButton.FORGET`ï¼Œå‘é€ç»™ memory-engineï¼›
   - memory-engine å†…éƒ¨é€šè¿‡ `computeNextReview(doc, quality)`ï¼š
     - æ›´æ–° `masteryLevel`, `reviewStage`, `nextReviewAt`, `correctCount`, `wrongCount`, `streakCorrect` ç­‰ï¼›
     - è¿™äº›å­—æ®µå†³å®šæœªæ¥è¯¥å­—æ¯å‡ºç°åœ¨â€œæ˜¨æ—¥å¤ä¹  / ä»Šæ—¥å¤ä¹ â€çš„é¢‘ç‡å’Œæ—¶æœºã€‚
   - å‰ç«¯çš„ `alphabetStore.completedCount`ï¼š
     - ä»…ä½œä¸ºâ€œæœ¬è®¾å¤‡æœ¬æ¬¡å­¦ä¹ ä¼šè¯çš„å®Œæˆæ•°é‡ç»Ÿè®¡â€ï¼Œç”¨äºè¯¾ç¨‹è§£é”ï¼›
     - ä¸ç›´æ¥ç­‰åŒäº `masteryLevel`ï¼Œè€Œæ˜¯ä¸€ä¸ªæ›´â€œç²—ç²’åº¦â€çš„è§†è§’ã€‚

---

## 8. å…¸å‹ç”¨ä¾‹ä¸ç«¯åˆ°ç«¯æ—¶åºï¼ˆä»ç‚¹å‡»â€œå¼€å§‹å­¦ä¹ â€åˆ°è¯¾ç¨‹å®Œæˆï¼‰

### 8.1 ä» Lesson å¡ç‰‡åˆ°å¼€å§‹åˆ·é¢˜ï¼ˆæ›´ç»†è‡´è°ƒç”¨ç¤ºæ„ï¼‰

```text
æ­¥éª¤è§†å›¾ï¼ˆä¸Šâ†’ä¸‹ï¼‰ï¼š

  [User]
    ç‚¹å‡» app/alphabet/index.tsx ä¸­ LessonX å¡ç‰‡ä¸Šçš„ã€Œå¼€å§‹å­¦ä¹ ã€æŒ‰é’®
        â”‚
        â–¼
  [app/alphabet/index.tsx]
    è°ƒç”¨ router.push('/alphabet/lessonX')
        â”‚
        â–¼
  [expo-router]
    åŒ¹é…åˆ° app/alphabet/[lessonId].tsx
        â”‚
        â–¼
  [app/alphabet/[lessonId].tsx]
    1. é€šè¿‡ useLocalSearchParams() è·å– lessonId='lessonX'
    2. è°ƒç”¨ const engine = useAlphabetLearningEngine(lessonId)
    3. å°† engine è¿”å›çš„å…¨éƒ¨å­—æ®µé€ä¼ ç»™ <AlphabetLearningEngineView {...engine} />
        â”‚
        â–¼
  [useAlphabetLearningEngine(lessonId)]
    é¦–æ¬¡æ¸²æŸ“æ—¶ useEffect è§¦å‘ï¼š
      a. è°ƒç”¨ alphabetStore.initializeSession(userId, { lessonId })
           â”‚
           â–¼
      b. alphabetStore.initializeSession å†…éƒ¨ï¼š
           - ç»„è£…è¯·æ±‚ä½“ï¼š
               action = 'getTodayMemories'
               data   = { userId, entityType:'letter', limit, includeNew:true, lessonId }
           - è°ƒç”¨ callCloudFunction<TodayLettersResponse>(
               'getTodayMemories',
               data,
               { endpoint: API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase }
             )
               â”‚
               â–¼
      c. callCloudFunctionï¼š
           - é€šè¿‡ apiClient.post() è°ƒç”¨åç«¯ HTTP è§¦å‘å™¨ /memory-engine
           - å‘é€ body: { action:'getTodayMemories', data:{...} }
               â”‚
               â–¼
  [memory-engine/index.js]
    - è§£æ event.bodyï¼Œå¾—åˆ° { action:'getTodayMemories', data }
    - åˆ†å‘åˆ° handlers/getTodayMemories(db, data)
        â”‚
        â–¼
  [handlers/getTodayMemories.js]
    1. ä» alphabet_lessons ä¸­æŸ¥è¯¢ lessonId å¯¹åº”çš„è¯¾ç¨‹å®šä¹‰ï¼›
    2. ä» letters é›†åˆä¸­æŸ¥è¯¢å±äºè¯¥ lessonId çš„æ‰€æœ‰å­—æ¯ï¼›
    3. ä» memory_status ä¸­æŸ¥è¯¢ userId + entityType:'letter' + entityId çš„è®°å¿†çŠ¶æ€ï¼›
    4. ç»„è£…ï¼š
       items: Array<Letter & { memoryState?: MemoryStatus }>
       summary: { total, newCount, reviewCount, entityType:'letter' }
       lessonMetadata: å½“å‰è¯¾çš„å…ƒæ•°æ®
       phonicsRule: å½“å‰è¯¾çš„æ‹¼è¯»è§„åˆ™
    5. ä½¿ç”¨ createResponse(true, { items, summary, lessonMetadata, phonicsRule }, ...) è¿”å›
        â”‚
        â–¼
  [callCloudFunction / alphabetStore.initializeSession]
    - å°† response.data.items æ˜ å°„ä¸º queue: AlphabetLearningState[]
    - è®¾ç½® currentItem = queue[0]
    - å†™å…¥ lessonMetadata / phonicsRule åˆ° alphabetStore
    - å¯åŠ¨é¢„ä¸‹è½½éŸ³é¢‘ä»»åŠ¡ï¼Œå¡«å…… letter.*LocalPath / alphabet.audioUrl
        â”‚
        â–¼
  [useAlphabetLearningEngine]
    - çœ‹åˆ° initializeSession æˆåŠŸï¼Œè®¾ç½®ï¼š
        initialized = true
        phase = 'yesterday-review'ï¼ˆè‹¥é˜Ÿåˆ—å­˜åœ¨éæ–°å­—æ¯ï¼‰ï¼›å¦åˆ™ç›´æ¥ 'today-learning'
    - è®¡ç®— letterPool = queue.map(item => item.letter)
        â”‚
        â–¼
  [AlphabetLearningEngineView]
    - æ ¹æ® phase æ¸²æŸ“ï¼š
        'yesterday-review' â†’ AlphabetReviewViewï¼ˆå¤ä¹ ï¼‰
        'today-learning'   â†’ AlphabetLearningView / PhonicsRuleCard
        ...
```

### 8.2 ç”¨æˆ·ç­”é¢˜å¹¶å®Œæˆä¸€è½®ï¼ˆå•é¢˜ç²’åº¦ï¼‰

```text
å‚ä¸è€…ï¼š
  User           ç”¨æˆ·
  AlphabetLearningEngineViewï¼ˆç®€ç§° EngineViewï¼‰
  AlphabetReviewView / MiniReviewQuestionComponent / å…¶ä»–é¢˜ç›®ç»„ä»¶
  useAlphabetLearningEngineï¼ˆç®€ç§° Engineï¼‰
  alphabetStoreï¼ˆç®€ç§° Storeï¼‰
  callCloudFunctionï¼ˆç®€ç§° APIï¼‰
  memory-engine.submitMemoryResultï¼ˆç®€ç§° CFï¼‰

è¯¦ç»†æ­¥éª¤ï¼ˆä»¥æ™®é€šå¤ä¹ é¢˜ä¸ºä¾‹ï¼‰ï¼š

1. EngineView æ ¹æ®å½“å‰ phase æ¸²æŸ“ AlphabetReviewViewï¼š
     - props ä¸­å¸¦å…¥ï¼š
         alphabet        = currentItem
         letterPool      = letterPool
         preferredType   = currentQuestionType
         onAnswer        = Engine.onAnswer
         onNext          = Engine.onNext

2. AlphabetReviewView å†…ï¼š
     a. è°ƒç”¨ generateAlphabetQuestion(letter, pool, preferredType)
        å¾—åˆ° question: { stem, options, correct, audioUrl, type }
     b. æ¸²æŸ“é¢˜å¹²å’Œé€‰é¡¹ï¼Œç”¨æˆ·ç‚¹å‡»æŸä¸ªé€‰é¡¹ã€‚

3. ç”¨æˆ·ç‚¹å‡»é€‰é¡¹åï¼ŒAlphabetReviewView åšæœ¬åœ°åˆ¤å®šï¼š
     - isCorrect = (é€‰ä¸­çš„ value === question.correct)
     - è°ƒç”¨ onAnswer(isCorrect, question.type)

4. Engine.onAnswer(isCorrect, questionType) å†…éƒ¨ï¼š
     a. è‹¥ currentItem ä¸ºç©ºåˆ™ç›´æ¥ returnï¼›
     b. è°ƒç”¨ Store.submitResult(userId, isCorrect)ï¼š
          - è´¨é‡æ˜ å°„ï¼š
              isCorrect === true  â†’ QualityButton.KNOW
              isCorrect === false â†’ QualityButton.FORGET
          - è°ƒç”¨ API.post('/memory-engine', {
                action: 'submitMemoryResult',
                data: { userId, entityType:'letter', entityId: currentItem.alphabetId, quality }
            })
     c. å¦‚æœ isCorrect === falseï¼š
          wrongAnswers = wrongAnswers âˆª { currentItem.alphabetId }

5. memory-engine.submitMemoryResultï¼š
     a. åœ¨ memory_status é›†åˆä¸­æ ¹æ® { userId, entityType:'letter', entityId } æŸ¥è¯¢å½“å‰è®°å½•ï¼›
     b. ä½¿ç”¨ computeNextReview(doc, quality) è®¡ç®—ä¸‹ä¸€æ¬¡å¤ä¹ å‚æ•°ï¼š
          - æ›´æ–° masteryLevelã€reviewStageã€nextReviewAtã€correctCountã€wrongCount ç­‰ï¼›
     c. æ›´æ–°æˆ–æ’å…¥è¯¥è®°å½•ï¼›
     d. è¿”å› createResponse(true, null, 'æäº¤è®°å¿†ç»“æœæˆåŠŸ')ã€‚

6. Store.submitResult æ”¶åˆ°æˆåŠŸå“åº”åï¼š
     a. åœ¨æœ¬åœ° queue[currentIndex] ä¸Šæ›´æ–°ï¼š
          currentAttempts += ATTEMPTS_INCREMENT_MAP[quality]
          qualityHistory.push(QUALITY_SCORE_MAP[quality])
          è‹¥ currentAttempts >= requiredAttempts â†’ isCompleted = true
     b. é‡æ–°è®¡ç®— completedCount = é˜Ÿåˆ—ä¸­ isCompleted === true çš„é¡¹æ•°ï¼›
     c. è°ƒç”¨ Store.next()ï¼ˆå³ Engine çœ‹åˆ°çš„ nextInQueueï¼‰ï¼š
          - è‹¥è¿˜æœ‰ä¸‹ä¸€é¡¹ï¼š
              currentIndex++
              currentItem = queue[currentIndex]
          - è‹¥é˜Ÿåˆ—ç»“æŸï¼š
              phase = LearningPhase.COMPLETEDï¼ˆä¼šè¯çº§ï¼‰

7. EngineView åœ¨ç”¨æˆ·ç‚¹å‡»â€œä¸‹ä¸€é¢˜â€æŒ‰é’®æ—¶è°ƒç”¨ Engine.onNext()ï¼š
     a. Engine.onNext å†…éƒ¨ï¼š
          - è‹¥ phase === 'today-learning'ï¼š
              å°† currentItem è¿½åŠ åˆ° todayListï¼Œå¹¶é€’å¢ learnedCountï¼›
              æ¯å­¦æ»¡ MINI_REVIEW_INTERVALï¼ˆ3ï¼‰ä¸ªï¼Œè°ƒç”¨ triggerMiniReview() è¿›å…¥ today-mini-reviewï¼›
          - ä¸æ»¡è¶³ä¸Šè¿°æ¡ä»¶æ—¶ï¼Œç›´æ¥è°ƒç”¨ nextInQueue()ï¼ˆå³ Store.nextï¼‰ï¼›
     b. ä¸‹ä¸€æ¬¡ render æ—¶ï¼ŒEngineView ä¼šä½¿ç”¨æ–°çš„ currentItem æ¸²æŸ“ä¸‹ä¸€é“é¢˜ã€‚
```

### 8.3 ä¸‰è½®è¯„ä¼°ç»“æŸå¹¶æ ‡è®°è¯¾ç¨‹å®Œæˆï¼ˆè¯¾ç¨‹ç²’åº¦ï¼‰

```text
å‚ä¸è€…ï¼š
  useAlphabetLearningEngineï¼ˆEngineï¼‰
  alphabetStoreï¼ˆStoreï¼‰
  callCloudFunctionï¼ˆAPIï¼‰
  memory-engine.submitRoundEvaluationï¼ˆCFï¼‰
  moduleAccessStoreï¼ˆModuleStoreï¼‰

èƒŒæ™¯ï¼š
  - æ¯ä¸€è½®å­¦ä¹ ç»“æŸæ—¶ï¼ŒEngine ä¸­ä¼šç»´æŠ¤ï¼š
      todayList: AlphabetLearningState[]   // æœ¬è½®çœŸæ­£å‡ºè¿‡é¢˜çš„æ‰€æœ‰å­—æ¯
      wrongAnswers: Set<string>           // æœ¬è½®æ›¾ç»ç­”é”™è¿‡çš„å­—æ¯ ID é›†åˆ

æ­¥éª¤ï¼š

1. ä¸€è½®ï¼ˆcurrentRoundï¼‰çš„æ‰€æœ‰ Phase ç»“æŸåï¼ŒEngine è°ƒç”¨ submitRoundResults()ï¼š
     - totalQuestions = todayList.length
     - wrongCount     = wrongAnswers.size
     - correctCount   = totalQuestions - wrongCount
     - accuracy       = correctCount / totalQuestions
     - passed         = (wrongCount / totalQuestions) <= 0.1
     - roundData = {
         roundNumber: currentRound,
         totalQuestions,
         correctCount,
         accuracy,
         passed
       }

2. Engine å°† roundData åˆå¹¶åˆ°æœ¬åœ° roundEvaluation çŠ¶æ€ï¼š
     roundEvaluation.rounds.push(roundData)
     roundEvaluation.currentRound = currentRound

3. Engine è°ƒç”¨ Store.submitRoundEvaluation({
       userId,
       entityType: 'letter',
       lessonId,
       roundNumber,
       totalQuestions,
       correctCount,
       accuracy,
     })ã€‚

4. Store.submitRoundEvaluation é€šè¿‡ API è°ƒç”¨ï¼š
     callCloudFunction('submitRoundEvaluation', { ... }, { endpoint: /memory-engine })
     â†’ memory-engine.handlers.submitRoundEvaluationï¼š
         - åœ¨ user_alphabet_progress é›†åˆä¸­ï¼š
             * å¦‚æœä¸å­˜åœ¨ { userId, lessonId } è®°å½•ï¼Œåˆ™åˆ›å»ºï¼›
             * æ›´æ–° currentRound = roundNumberï¼›
             * ä½¿ç”¨ db.command.push(roundData) å°†è¯¥è½®ç»“æœè¿½åŠ åˆ° roundHistoryã€‚

5. æˆåŠŸè¿”å›åï¼ŒEngine æ ¹æ® currentRound ä¸ passed è¿›è¡Œåˆ†æ”¯ï¼š
     a. è‹¥ currentRound < 3 ä¸” passed === trueï¼š
          - setCurrentRound(currentRound + 1 as 1|2|3)
          - setWrongAnswers(new Set())    // æ¸…ç©ºé”™é¢˜æ± 
          - setPhase('yesterday-review')  // ä¸‹ä¸€è½®ä»æ˜¨æ—¥å¤ä¹  Phase å†èµ°ä¸€éæµç¨‹

     b. è‹¥ currentRound == 3 ä¸” passed === trueï¼š
          - è°ƒç”¨ moduleAccessStore.markAlphabetLessonCompleted(lessonId)ï¼š
               * ç”¨äºæ›´æ–°æ¨¡å—è§£é”çŠ¶æ€ï¼ˆä¾‹å¦‚è§£é”åç»­è¯¾ç¨‹/æ¨¡å—ï¼‰
          - setPhase('finished')ï¼š
               * AlphabetLearningEngineView åœ¨è¯¥ Phase ä¸‹å±•ç¤ºä¸‰è½®è¯„ä¼°ç»“æœå’Œè¯¾ç¨‹å®Œæˆæç¤ºã€‚

     c. è‹¥æŸè½® passed === falseï¼ˆé”™è¯¯ç‡ > 10%ï¼‰ï¼š
          - Engine å¯ä»¥æ ¹æ®ä¸šåŠ¡éœ€è¦ï¼š
               * å›åˆ° today-remedy / today-final-review ç­‰ Phase åŠ å¼ºç»ƒä¹ ï¼›
               * æˆ–ä¿æŒ currentRound ä¸å˜ï¼Œè¦æ±‚ç”¨æˆ·é‡æ–°åˆ·ä¸€è½®ï¼ˆå®ç°ç»†èŠ‚å¯æŒ‰åç»­è®¾è®¡è¡¥å……ï¼‰ã€‚
```
```

---

## 9. æ‰©å±•ä¸å®ç°æ³¨æ„äº‹é¡¹

1. **ä¸è¦åœ¨ç»„ä»¶ä¸­ç›´æ¥è°ƒç”¨äº‘å‡½æ•°**  
   - æ‰€æœ‰ç½‘ç»œè¯·æ±‚å¿…é¡»é€šè¿‡ Store / Hookï¼ˆ`alphabetStore` + `useAlphabetLearningEngine`ï¼‰å®Œæˆï¼›
   - `AlphabetLearningView` / `AlphabetReviewView` åº”ä¿æŒçº¯ UI + å±€éƒ¨äº¤äº’ã€‚

2. **ä¸è¦åœ¨å‰ç«¯å†™æ­»è¯¾ç¨‹ç»“æ„**  
   - è¯¾ç¨‹è¡¨ä»¥ `alphabet_lessons` + `phonics_rules` ä¸ºå‡†ï¼›
   - `lessonMetadata.config.ts` ä»…ä½œä¸ºå›é€€æ•°æ®ï¼›
   - è‹¥è¯¾ç¨‹å¢å‡ï¼Œè¯·åŒæ—¶æ›´æ–°è¿™ä¸¤å¤„å¹¶åœ¨æ­¤ spec æ–‡æ¡£ä¸­æ³¨æ˜ã€‚

3. **æ–°å¢é¢˜å‹æ—¶éµå®ˆ Question Engine åè®®**  
   - æ–°é¢˜å‹å¿…é¡»å…ˆåœ¨æœ¬ spec çš„ Question Engine å°èŠ‚ä¸­å®šä¹‰ `GameType` + payload ç»“æ„ï¼›  
   - ç„¶ååœ¨ QuestionRenderer ä¸­å¢åŠ  caseï¼›  
   - å†ç”± FlowGenerator å†³å®šåœ¨å“ªä¸ª Round / Phase ä½¿ç”¨ã€‚

4. **ç¡®ä¿éŸ³é¢‘åªä»æœ¬åœ°æ’­æ”¾**  
   - æ–°å¢ä»»ä½•å­—æ¯éŸ³é¢‘å­—æ®µæ—¶ï¼Œåº”éµå®ˆï¼š
     - åç«¯ï¼šåªå­˜å‚¨ COS key / ç›¸å¯¹è·¯å¾„ï¼›
     - å‰ç«¯ï¼šåœ¨ `alphabetStore.initializeSession` é¢„ä¸‹è½½åˆ° `file://`ï¼Œå¹¶å†™å…¥ `*LocalPath` å­—æ®µï¼›
     - ç»„ä»¶åªä½¿ç”¨æœ¬åœ°è·¯å¾„ã€‚

5. **æ‰€æœ‰å¯¹/é”™éƒ½è¦è¿›å…¥ memory-engine**  
   - ç¦æ­¢åœ¨å‰ç«¯â€œä¸´æ—¶æä¸€ä¸ªé”™é¢˜æœ¬é›†åˆâ€ï¼›  
   - é”™é¢˜æ± åªåœ¨ Hook å†…å­˜ä¸­å­˜åœ¨ï¼Œç”¨äºä¸‰è½®è¯„ä¼°ï¼Œä¸è¿›å…¥ DBï¼›  
   - é•¿æœŸè®°å¿†/å¤ä¹ ç»Ÿä¸€é€šè¿‡ `memory_status` å’Œåç«¯ç®—æ³•ç®¡ç†ã€‚

---

### 9.1 Session çŠ¶æ€ vs è®°å¿†å¼•æ“çŠ¶æ€ï¼ˆå‰ç«¯ / åç«¯åˆ†å·¥ï¼‰

> ä¸ºé¿å…â€œå‰ç«¯å†é€ ä¸€å¥—è®°å¿†å¼•æ“â€ï¼Œå¿…é¡»æ¸…æ™°åŒºåˆ†ï¼š  
> å“ªäº›çŠ¶æ€åªåœ¨æœ¬åœ° Session ä½¿ç”¨ï¼Œå“ªäº›å¿…é¡»å†™å…¥ memory-engineã€‚

**æœ¬åœ° Session çº§çŠ¶æ€ï¼ˆåªå½±å“å½“å¤©è¯¥è¯¾çš„è„šæœ¬ä¸ UIï¼Œä¿å­˜åœ¨ alphabetStore / Hook ä¸­ï¼Œå¯æŒä¹…åŒ–ï¼‰ï¼š**

- `queue`ï¼šæœ¬æ¬¡è¿›å…¥è¯¥è¯¾æ—¶çš„å­—æ¯é˜Ÿåˆ—ï¼ˆæ¥è‡ª getTodayMemories æ•´è¯¾è¿”å›ï¼‰ã€‚  
- `todayList`ï¼šä»Šæ—¥åœ¨ Round1 å†…å·²ç»å­¦ä¹ è¿‡çš„æ–°å­—æ¯åˆ—è¡¨ã€‚  
- `todayNewLetters: Set<alphabetId>`ï¼šä»Šæ—¥å‡ºç°è¿‡çš„æ‰€æœ‰æ–°å­—æ¯ IDã€‚  
- `todayReviewedLetters: Set<alphabetId>`ï¼šåœ¨å½“æ—¥è½»é‡é¢˜ / Mini Review ä¸­å·²ç»åšè¿‡é¢˜çš„æ–°å­—æ¯ IDã€‚  
- `wrongAnswers: Set<alphabetId>`ï¼šå½“å‰ Round å†…æ›¾ç»ç­”é”™è¿‡çš„å­—æ¯ IDï¼ˆç”¨äºç»Ÿè®¡ & è¡¥æ•‘ï¼‰ã€‚  
- `currentRound: 1 | 2 | 3`ï¼šå½“å‰è½®æ¬¡ã€‚  
- `roundEvaluation`ï¼šä»…ç”¨äº UI å±•ç¤ºæ¯è½® accuracy/passedï¼Œä¸ç›´æ¥å‚ä¸ SM-2ã€‚  
- `phase`ï¼šä»Šæ—¥è¯¾ç¨‹è„šæœ¬çš„é˜¶æ®µï¼ˆæ˜¨æ—¥å¤ä¹  / ä»Šæ—¥å­¦ä¹  / Mini Review / Final Review / Remedy / finishedï¼‰ã€‚  

è¿™äº›çŠ¶æ€å¯ä»¥ç”¨ AsyncStorage åšè½»é‡æŒä¹…åŒ–ï¼Œç”¨äºâ€œä¸­é€”é€€å‡º â†’ ä¸‹æ¬¡æ¢å¤åˆ°ç›¸è¿‘é˜¶æ®µâ€ï¼Œä½†**ä¸è¢«åç«¯ä¾èµ–**ã€‚

**è®°å¿†å¼•æ“çº§çŠ¶æ€ï¼ˆå”¯ä¸€çœŸç›¸ï¼Œå­˜æ”¾åœ¨ CloudBase DB ä¸­ï¼‰ï¼š**

- `memory_status`ï¼šper-letter è®°å¿†çŠ¶æ€ï¼Œç®—æ³•åªå…³å¿ƒï¼š
  - `userId, entityType:'letter', entityId`ï¼›  
  - `masteryLevel, reviewStage, nextReviewAt, correctCount, wrongCount, streakCorrect, isNew` ç­‰ã€‚  
- `user_alphabet_progress`ï¼šper-lesson è½®æ¬¡ç»Ÿè®¡ï¼Œç”¨äºæ¨¡å—è§£é” / æŠ¥å‘Šå±•ç¤ºï¼š  
  - `currentRound, roundHistory[]`ã€‚

**çº¦æŸï¼š**

- Session çº§çŠ¶æ€å¯ä»¥éšå‰ç«¯ç‰ˆæœ¬æ¼”è¿›è€Œå˜åŒ–ï¼Œåªè¦ä¸ç¯¡æ”¹ DBï¼›  
- è®°å¿†å¼•æ“çº§çŠ¶æ€åªèƒ½é€šè¿‡ `submitMemoryResult` / `submitRoundEvaluation` ä¿®æ”¹ï¼›  
- `getTodayMemories(entityType:'letter', lessonId)` çš„å®ç°åº”æŒ‰ lessonId è¯­ä¹‰è¿”å›â€œæ•´è¯¾å­—æ¯é›† + memoryStateâ€ï¼Œä¸è¯»å–å‰ç«¯ Session çŠ¶æ€ã€‚

### 9.2 è½®æ¬¡ä¸è¯„åˆ†è§„åˆ™ï¼ˆæŒ‰å­—æ¯èšåˆè´¨é‡ï¼‰

> 3 è½®æœºåˆ¶ = è¯¾ç¨‹çº§è®­ç»ƒè„šæœ¬ï¼›SM-2 = è·¨å¤©è®°å¿†è°ƒåº¦ï¼Œä¸¤è€…é€šè¿‡â€œè´¨é‡å€¼ Qualityâ€è¡”æ¥ã€‚

**å½“å‰ç­–ç•¥ï¼ˆé¢˜çº§æäº¤ï¼Œå·²å®ç°ï¼‰ï¼š**

- æ¯é“é¢˜ç»“æŸæ—¶è°ƒç”¨ `submitResult(userId, isCorrect)`ï¼š  
  - å‰ç«¯å°† `isCorrect` æ˜ å°„ä¸º `QualityButton.KNOW / FORGET`ï¼›  
  - Store å†…éƒ¨è°ƒç”¨ `submitMemoryResult` å†™å…¥ `memory_status`ï¼›  
  - Session çº§é”™é¢˜é›†åˆ `wrongAnswers` åªç”¨äº RoundEvaluation å’Œè¡¥æ•‘é€»è¾‘ã€‚
- ä¼˜ç‚¹ï¼šå®ç°ç®€å•ï¼Œå·²æœ‰ä»£ç å¯ç”¨ï¼›  
- ç¼ºç‚¹ï¼šåŒä¸€ä¸ªå­—æ¯åœ¨ä¸€è½®å†…å¯èƒ½å¤šæ¬¡å†™å…¥ qualityï¼ŒSM-2 ç®—æ³•éœ€è¦è€ƒè™‘â€œé«˜é¢‘è§‚æµ‹â€çš„å½±å“ã€‚

**å¯é€‰å‡çº§ç­–ç•¥ï¼ˆæ¯å­—æ¯æ¯è½®ä¸€æ¬¡æäº¤ï¼Œæœªæ¥è¿­ä»£ï¼‰ï¼š**

- åœ¨ Hook ä¸­è®°å½• per-letter / per-round è¡Œä¸ºï¼Œä¾‹å¦‚ï¼š

  ```ts
  type LetterRoundStats = {
    attempts: number;
    wrongCount: number;
    everCorrect: boolean;
    usedHint: boolean;
  };
  // Map<alphabetId, LetterRoundStats>
  ```

- å½“æŸä¸ªå­—æ¯åœ¨å½“å‰ Round çš„â€œæ‰€æœ‰é¢˜ + é”™é¢˜è¡¥æ•‘â€ç»“æŸæ—¶ï¼š
  - ä½¿ç”¨ `wrongCount / attempts / everCorrect / usedHint` è®¡ç®—å‡º 3 æ¡£è´¨é‡ï¼š
    - è®°å¾—ï¼ˆKNOWï¼‰ï¼šå…¨ç¨‹æ— é”™ï¼Œä¸”æ›¾ç­”å¯¹ï¼›  
    - æ¨¡ç³Šï¼ˆFUZZYï¼‰ï¼šæœ‰ 1~2 æ¬¡é”™è¯¯ï¼Œä½†æœ€ç»ˆç­”å¯¹ä¸”æœªä¾èµ–å®Œæ•´ç­”æ¡ˆï¼›  
    - å¿˜è®°ï¼ˆFORGETï¼‰ï¼šé”™è¯¯ â‰¥3 æ¬¡ï¼Œæˆ–éœ€è¦çœ‹ç­”æ¡ˆã€‚  
  - ä»…æäº¤ä¸€æ¬¡ï¼š

    ```ts
    submitMemoryResult({
      userId,
      entityType: 'letter',
      entityId: alphabetId,
      quality: QualityButton.KNOW | FUZZY | FORGET,
    });
    ```

- Round1/2/3 å¯ä»¥å„æäº¤ä¸€æ¬¡è´¨é‡ï¼›RoundEvaluation ä»åªåšè¯¾ç¨‹çº§ç»Ÿè®¡ä¸è§£é”åˆ¤å®šã€‚

### 9.3 Round ä¸è¯¾ç¨‹çº§å¤ä¹  / é•¿æœŸå¤ä¹ çš„å…³ç³»ï¼ˆè®¾è®¡çº¦å®šï¼‰

- **è¯¾ç¨‹çº§è®­ç»ƒæ¨¡å¼ï¼ˆlessonId æ¨¡å¼ï¼‰**ï¼š
  - å½“å‰å­—æ¯æ¨¡å—ä¸»è¦ä½¿ç”¨ `getTodayMemories(entityType:'letter', lessonId)`ï¼›  
  - çº¦å®šï¼šåªè¦è¯¥è¯¾ `currentRound < 3`ï¼Œè¯¥æ¥å£åº”è¿”å›æ•´è¯¾æ‰€æœ‰å­—æ¯ï¼ˆä¸æŒ‰ SM-2 è¿‡æ»¤ï¼‰ï¼Œä»¥ä¾¿å®Œæˆè¯¾ç¨‹å†… 3 è½®è®­ç»ƒè„šæœ¬ã€‚  
  - å³ä¾¿ Round è¢«æ‹†æˆå¤šå¤©å®Œæˆï¼Œä»è§†ä¸ºâ€œè¯¾ç¨‹è®­ç»ƒè¿‡ç¨‹çš„ä¸€éƒ¨åˆ†â€ï¼Œä¸å¼ºåˆ¶æŒ‰æ—¥åˆ‡ç‰‡ã€‚

- **é•¿æœŸ SRS æ¨¡å¼ï¼ˆæœªæ¥å¯é€‰ï¼Œæ—  lessonIdï¼‰**ï¼š
  - è‹¥å°†æ¥æ–°å¢â€œå­—æ¯ç»¼åˆå¤ä¹ ä¸­å¿ƒâ€ï¼Œå¯è°ƒç”¨ä¸å¸¦ lessonId çš„ï¼š
    `getTodayMemories({ entityType:'letter', includeNew:false })`ï¼Œè®© SM-2 æŒ‰ `nextReviewAt` è‡ªç”±è°ƒåº¦æ‰€æœ‰è¯¾ä¸­çš„åˆ°æœŸå­—æ¯ã€‚  
  - è¯¥æ¨¡å¼ä¸è¯¾ç¨‹çº§è®­ç»ƒæ¨¡å¼ç‹¬ç«‹ï¼Œä¸å½±å“å½“å‰ Lesson æµç¨‹ä¸è§£é”é€»è¾‘ã€‚

- **è¯¾ç¨‹ç»“æŸä¸â€œé€€å½¹â€å­—æ¯ï¼š**
  - å½“ `moduleAccessStore.userProgress.letterCompleted === true`ï¼ˆæ ¸å¿ƒ 6 è¯¾å®Œæˆï¼‰æ—¶ï¼Œ  
    é»˜è®¤ä¸å†è°ƒç”¨ `getTodayMemories(letter, lessonId)` ä½œä¸ºæ¯æ—¥ä»»åŠ¡ï¼›  
  - å­—æ¯ä¸ä¼šåœ¨æ—¥å¸¸å­¦ä¹ ï¼ˆä¾‹å¦‚è¯æ±‡æ¨¡å—ï¼‰ä¸­åå¤å‡ºç°ï¼Œé™¤éç”¨æˆ·æ˜¾å¼è¿›å…¥æŸä¸ªâ€œå­—æ¯å¤ä¹ æ¨¡å¼â€ã€‚

---

## 10. å®æ–½å·¥å•ä¸é‡Œç¨‹ç¢‘ï¼ˆAlphabet Moduleï¼‰

> æœ¬å°èŠ‚ä¸ºå¼€å‘è½åœ°å‡†å¤‡ä¸€ä¸ª checklistï¼ŒæŒ‰ä¼˜å…ˆçº§è§„åˆ’è¿­ä»£ã€‚

### 10.1 P0ï¼šä¿æŒç°æœ‰è¡Œä¸ºï¼Œè¡¥é½è§£é”é€»è¾‘ä¸æ–‡æ¡£

ç›®æ ‡ï¼šåœ¨ä¸å¤§æ”¹ä»£ç çš„å‰æä¸‹ï¼Œä½¿å½“å‰å®ç°ä¸ Spec çš„â€œè§£é”æ¡ä»¶ / è¯¾ç¨‹æµç¨‹â€åŸºæœ¬ä¸€è‡´ã€‚

- [ ] æ˜ç¡® `submitRoundResults` è°ƒç”¨æ—¶æœºï¼Œå¹¶åœ¨å®ç°ä¸­ç¡®ä¿åªåœ¨å®Œæ•´è½®æ¬¡ç»“æŸæ—¶è°ƒç”¨ã€‚  
- [ ] åœ¨ `useAlphabetLearningEngine` ä¸­ï¼Œåªæœ‰å½“ `passed === true` ä¸” `currentRound === 3` æ—¶æ‰è°ƒç”¨ `markAlphabetLessonCompleted(lessonId)`ï¼ˆæˆ–æ ¹æ®éœ€è¦è®¾ç½®é€šè¿‡é˜ˆå€¼ï¼‰ï¼Œé¿å…â€œæœªé€šè¿‡ä¹Ÿè§£é”ä¸‹ä¸€è¯¾â€ã€‚  
- [ ] æ ¹æ®å®é™…å®ç°ï¼Œå¯¹æ–‡æ¡£ä¸­çš„ Round æµç¨‹ä¸è§£é”æ¡ä»¶è¿›è¡Œä¸€æ¬¡æœ€ç»ˆæ ¸å¯¹ï¼ˆæœ¬ Spec å·²ç»™å‡ºç›®æ ‡è®¾è®¡ï¼Œå¯æ®æ­¤æ¯”å¯¹ä»£ç ï¼‰ã€‚

### 10.2 P1ï¼šå®Œå–„ Phase æµç¨‹ä¸é”™é¢˜è¡¥æ•‘ï¼ˆRound1 å†…ï¼‰

ç›®æ ‡ï¼šè®© Round1 å†…çš„â€œæ˜¨æ—¥å¤ä¹  â†’ ä»Šæ—¥å­¦ä¹  + ä¸‰æ–°ä¸€å¤ â†’ Final Reviewï¼ˆè¡¥é½ä»Šæ—¥æœªå¤ä¹ å­—æ¯ï¼‰â†’ ä»Šæ—¥é”™é¢˜è¡¥æ•‘â€é€»è¾‘å®Œæ•´å¯ç”¨ã€‚

- [ ] åœ¨ `useAlphabetLearningEngine` ä¸­å®ç°ï¼š  
  - `yesterday-remedy` Phaseï¼šåŸºäºæ˜¨æ—¥é”™é¢˜é›†åˆï¼ˆä¾‹å¦‚ `yesterdayWrongIds`ï¼‰å‡ºé¢˜ï¼Œå…¨éƒ¨åšå¯¹åæ‰è¿›å…¥ `today-learning`ï¼›  
  - `today-final-review` Phaseï¼š  
    - ç»´æŠ¤ `todayNewLetters` / `todayReviewedLetters` é›†åˆï¼›  
    - å¯¹ `pendingFinal = todayNewLetters - todayReviewedLetters` ä¸­çš„å­—æ¯ï¼Œæ¯ä¸ªå‡º 2 é“é€»è¾‘/æ•´åˆé¢˜ï¼›  
  - `today-remedy` Phaseï¼š  
    - é’ˆå¯¹ä»Šæ—¥æ‰€æœ‰é”™é¢˜å‡ºé¢˜ï¼Œç›´åˆ°å…¨éƒ¨ç­”å¯¹ã€‚  
- [ ] åœ¨ Spec ä¸­å·²æœ‰çš„ ASCII æµç¨‹å›¾åŸºç¡€ä¸Šï¼Œä¸ºæ–°å¢ Phase è¡¥å……æ›´è¯¦ç»†çš„æ³¨é‡Šï¼Œä¾¿äºå¯¹ç…§å®ç°ã€‚

### 10.3 P2ï¼šä¸ memory-engine çš„è´¨é‡æäº¤ç­–ç•¥ç»Ÿä¸€

ç›®æ ‡ï¼šå†³å®šå¹¶å®ç°â€œé¢˜çº§æäº¤ vs å­—æ¯/è½®æ¬¡çº§æäº¤â€çš„æœ€ç»ˆæ–¹æ¡ˆã€‚

- [ ] è‹¥ç»§ç»­ä½¿ç”¨â€œæ¯é¢˜æäº¤â€æ–¹æ¡ˆï¼š  
  - å°†å…¶åœ¨ Spec ä¸­æ ‡è®°ä¸ºâ€œæ­£å¼ç­–ç•¥â€ï¼›  
  - ç¡®è®¤ `alphabetStore.submitResult` å§‹ç»ˆåŒ…å« `entityType:'letter'` ä¸æ­£ç¡®çš„ `entityId`ï¼Œå¹¶åœ¨ CloudBase æ—¥å¿—ä¸­éªŒè¯ã€‚  
- [ ] è‹¥æ¼”è¿›ä¸ºâ€œæ¯å­—æ¯æ¯è½®ä¸€æ¬¡è´¨é‡â€ï¼š  
  - åœ¨ Hook å†…å¢åŠ  per-letter per-round ç»Ÿè®¡ç»“æ„ï¼›  
  - å®ç° `computeLetterQualityForRound(letterId, stats)`ï¼›  
  - åœ¨è¯¥å­—æ¯æœ¬è½®æ‰€æœ‰é¢˜ + è¡¥æ•‘é¢˜ç»“æŸæ—¶è°ƒç”¨ä¸€æ¬¡ `submitMemoryResult`ï¼›  
  - ä¿ç•™ `submitRoundEvaluation` ä»…ç”¨äºè¯¾ç¨‹çº§å±•ç¤º/è§£é”ã€‚

### 10.4 P3ï¼šQuestion Engine é›†æˆä¸é¢˜å‹å‡çº§

ç›®æ ‡ï¼šå°†æœ¬ spec ä¸­è§„åˆ’çš„ 6 å¤§é¢˜å‹é€æ­¥æ›¿æ¢ç°æœ‰ `lettersQuestionGenerator` é¢˜å‹ã€‚

- [ ] åœ¨å‰ç«¯å®ç° `generateQueueItems(FlowContext)`ï¼Œå¹¶åœ¨ `useAlphabetLearningEngine` ä¸­å¯¹æ¥ã€‚  
- [ ] æ–°å¢ `GameContainer + StepRenderer`ï¼Œæ›¿æ¢ `AlphabetReviewView` ä¸ MiniReview å•ç‚¹é€»è¾‘ã€‚  
- [ ] åˆ†é˜¶æ®µå¼•å…¥ï¼š  
  - ç¬¬ä¸€é˜¶æ®µï¼šä¿æŒå½“å‰é¢˜å‹ï¼Œä»…é€šè¿‡ Question Engine ç»Ÿä¸€è°ƒåº¦ï¼›  
  - ç¬¬äºŒé˜¶æ®µï¼šå¼•å…¥æ‹¼è¯»æ•°å­¦ã€å£°è°ƒè®¡ç®—ç­‰é€»è¾‘é¢˜å‹ã€‚

### 10.5 é‡Œç¨‹ç¢‘è§„åˆ’

- **M1ï¼šè§£é”é€»è¾‘ä¿®æ­£ + æ–‡æ¡£å¯¹é½ï¼ˆçº¦ 1 å‘¨ï¼‰**  
  - å®Œæˆ P0ï¼›  
  - ç¡®ä¿ä¸‰è½®é€šè¿‡åæ‰è§£é”ä¸‹ä¸€è¯¾ï¼›  
  - æ›´æ–°æ–‡æ¡£ä¸ UI æ–‡æ¡ˆè¯´æ˜ã€‚  

- **M2ï¼šPhase + é”™é¢˜è¡¥æ•‘å®Œæ•´è½åœ°ï¼ˆçº¦ 2â€“3 å‘¨ï¼‰**  
  - å®Œæˆ P1ï¼›  
  - Round1 å†… Phase æµç¨‹ä¸é”™é¢˜è¡¥æ•‘å¯ç”¨ï¼›  
  - å›å½’æµ‹è¯•æ‰€æœ‰ Phase è½¬ç§»åœºæ™¯ã€‚  

- **M3ï¼šè´¨é‡æäº¤ç­–ç•¥å®šç‰ˆ + memory-engine å¯¹é½ï¼ˆçº¦ 1â€“2 å‘¨ï¼‰**  
  - å®Œæˆ P2ï¼ˆé€‰æ‹©é¢˜çº§æˆ–å­—æ¯/è½®æ¬¡çº§æ–¹æ¡ˆä¹‹ä¸€å¹¶å®ç°ï¼‰ï¼›  
  - ç¡®è®¤ CloudBase æ—¥å¿—ä¸­è´¨é‡å‚æ•°æ­£å¸¸ï¼Œ`memory_status` æ›´æ–°ç¬¦åˆé¢„æœŸã€‚  

- **M4ï¼šé¢˜å‹å‡çº§ä¸ Question Engine åˆæ­¥é›†æˆï¼ˆåç»­è¿­ä»£ï¼‰**  
  - å®Œæˆ P3 çš„ç¬¬ä¸€é˜¶æ®µï¼›  
  - è§†æ—¶é—´ä¸äº§å“è§„åˆ’å†³å®šæ˜¯å¦å¼•å…¥æ–°é¢˜å‹ã€‚  

---

æœ¬è§„æ ¼æ–‡æ¡£è¦†ç›–äº†å­—æ¯æ¨¡å—ä»è·¯ç”±ã€ç»„ä»¶ã€Hookã€Storeã€äº‘å‡½æ•°åˆ°æ•°æ®åº“å­—æ®µçš„å®Œæ•´é“¾è·¯ï¼Œå¹¶å¯¹ Session çº§çŠ¶æ€ä¸è®°å¿†å¼•æ“çŠ¶æ€çš„åˆ†å·¥ã€è½®æ¬¡è¯„åˆ†ç­–ç•¥åŠå®æ–½é‡Œç¨‹ç¢‘åšå‡ºäº†çº¦æŸã€‚  
åç»­æ–°å¢åŠŸèƒ½ï¼ˆå¦‚ 6 å¤§é¢˜å‹ Question Engineã€AI å‘éŸ³è®­ç»ƒï¼‰å¿…é¡»åœ¨æœ¬è§„èŒƒåŸºç¡€ä¸Šæ‰©å±•ï¼Œä¸å¾—ç»•å¼€æ—¢æœ‰è¾¹ç•Œã€‚

---

## 11. V2 èšåˆè¯„åˆ†ä¸ä¼šè¯æ¢å¤æ–¹æ¡ˆï¼ˆæœ€ç»ˆå®šç¨¿ï¼‰

> æœ¬èŠ‚æ˜¯åœ¨ä¸äº§å“è®¨è®ºåçš„**æœ€ç»ˆç‰ˆå­—æ¯è®°å¿†æ–¹æ¡ˆ**ï¼Œç”¨äºè¦†ç›–å’Œç»†åŒ–ä¸Šæ–‡ 9.2 / 10.3 ä¸­çš„è®¾è®¡å»ºè®®ã€‚  
> å¦‚æœæœ¬èŠ‚ä¸å‰æ–‡å­˜åœ¨å†²çªï¼Œä»¥æœ¬èŠ‚ä¸ºå‡†ã€‚

### 11.1 è®¾è®¡ç›®æ ‡å›é¡¾

- é™ä½ç½‘ç»œè°ƒç”¨é¢‘ç‡ï¼šä¸å†æŒ‰â€œæ¯é¢˜ä¸€æ¬¡â€è°ƒç”¨ `submitMemoryResult`ï¼Œæ”¹ä¸º**æ¯å­—æ¯æ¯è½®ä¸€æ¬¡**ã€‚  
- å…è®¸ç”¨æˆ·åœ¨ Round ä¸­é€”é€€å‡ºï¼Œå¹¶åœ¨ä¸‹ä¸€æ¬¡è¿›å…¥æ—¶æ— ç¼æ¢å¤ã€‚  
- è®©â€œå­—æ¯è¯¾ç¨‹â€ä¿æŒè¯¾ç¨‹çº§çš„ä¸‰è½®è®­ç»ƒé€»è¾‘ï¼Œè€Œä¸æ˜¯ä¸¥æ ¼çš„æ—¥çº§ SRSã€‚  
- ä¸ºåç»­è¯æ±‡æ¨¡å—å¤ç”¨åŒä¸€å¥—â€œå‰ç«¯èšåˆ + ç»Ÿä¸€æäº¤â€æ€è·¯æ‰“åŸºç¡€ã€‚

### 11.2 AlphabetSessionStateï¼ˆå»ºè®®ç»“æ„ï¼‰

```ts
export interface AlphabetSessionState {
  userId: string;
  lessonId: string;
  currentRound: 1 | 2 | 3;
  phase: Phase; // yesterday-review / today-learning / ...

  queue: AlphabetLearningState[];
  cursorIndex: number;

  todayNewLetters: string[];      // alphabetId[]
  todayReviewedLetters: string[]; // å·²ç»åœ¨è½»é‡é¢˜ / é€»è¾‘é¢˜ä¸­è¢«è€ƒè¿‡
  wrongLetterIds: string[];       // æœ¬è½®æ›¾ç»å‡ºé”™è¿‡

  perLetterStats: Record<
    string,
    {
      attempts: number;
      wrongCount: number;
      lastPhase: Phase;
    }
  >;

  roundFinished: boolean;         // æœ¬è½®æ˜¯å¦å·²ç»å®Œæˆå¹¶æˆåŠŸæäº¤
  updatedAt: string;              // ISO æ—¶é—´æˆ³ï¼Œæ–¹ä¾¿è°ƒè¯•
}
```

- å®é™…å®ç°æ—¶å¯ä»¥æ”¾åœ¨ `alphabetStore` ä¸­ï¼Œé€šè¿‡ `getState()` / `setState()` ç®¡ç†ï¼Œå¹¶å®šæœŸå†™å…¥ AsyncStorageã€‚  
- å½“ App é‡æ–°æ‰“å¼€æˆ–ç”¨æˆ·å†æ¬¡è¿›å…¥è¯¥è¯¾æ—¶ï¼Œè‹¥å‘ç° `roundFinished === false` çš„ Sessionï¼Œåˆ™ç›´æ¥æ¢å¤ï¼Œä¸é‡æ–°ç”Ÿæˆé˜Ÿåˆ—ã€‚

### 11.3 è´¨é‡è®¡ç®—è§„åˆ™ï¼ˆFORGET / FUZZY / KNOWï¼‰

åœ¨ä¸€ä¸ª Round å†…ï¼Œå¯¹åŒä¸€ä¸ªå­—æ¯å¯èƒ½å‡ºç°å¤šé“é¢˜ + å¤šæ¬¡é”™é¢˜è¡¥æ•‘ï¼Œæœ€ç»ˆèšåˆä¸º 3 æ¡£è´¨é‡ï¼š

```ts
type LetterRoundQuality = 'FORGET' | 'FUZZY' | 'KNOW';

function computeLetterQuality(
  stats: { attempts: number; wrongCount: number },
): LetterRoundQuality {
  if (stats.attempts === 0) return 'FORGET';   // ç†è®ºå…œåº•
  if (stats.wrongCount === 0) return 'KNOW';   // å…¨ç¨‹æ— é”™
  if (stats.wrongCount === 1) return 'FUZZY';  // è½»åº¦é”™è¯¯
  return 'FORGET';                             // é”™è¯¯ â‰¥2 è§†ä¸ºæ²¡æŒæ¡
}
```

æ˜ å°„åˆ° memory-engine / SMâ€‘2ï¼š

```ts
function mapQualityToSm2Score(q: LetterRoundQuality): number {
  if (q === 'KNOW') return 5;   // è®°å¾—
  if (q === 'FUZZY') return 3;  // æ¨¡ç³Š
  return 0;                     // å¿˜è®°
}
```

### 11.4 æ‰¹é‡æäº¤æ—¶æœºä¸ä¼ªä»£ç 

åœ¨ Round å®Œæˆæˆ–ç”¨æˆ·ç‚¹å‡»â€œç»“æŸä»Šå¤©å­¦ä¹ â€æ—¶ï¼š

```ts
async function syncAlphabetRoundResults(state: AlphabetSessionState) {
  const { userId, lessonId, currentRound, perLetterStats } = state;

  const payloads = Object.entries(perLetterStats).map(([entityId, stats]) => ({
    userId,
    entityType: 'letter' as const,
    entityId,
    quality: mapQualityToSm2Score(computeLetterQuality(stats)),
  }));

  // 1. æ‰¹é‡ memory ç»“æœ
  for (const p of payloads) {
    await callCloudFunction('submitMemoryResult', p, {
      endpoint: API_ENDPOINTS.MEMORY.SUBMIT_MEMORY_RESULT.cloudbase,
    });
  }

  // 2. è¯¾ç¨‹çº§è½®æ¬¡ç»Ÿè®¡
  const totalQuestions = Object.values(perLetterStats).reduce(
    (sum, s) => sum + s.attempts,
    0,
  );
  const wrongCount = Object.values(perLetterStats).reduce(
    (sum, s) => sum + s.wrongCount,
    0,
  );

  await callCloudFunction(
    'submitRoundEvaluation',
    {
      userId,
      entityType: 'letter',
      lessonId,
      roundNumber: currentRound,
      totalQuestions,
      correctCount: totalQuestions - wrongCount,
      accuracy: totalQuestions === 0 ? 0 : (totalQuestions - wrongCount) / totalQuestions,
    },
    { endpoint: API_ENDPOINTS.MEMORY.SUBMIT_ROUND_EVALUATION.cloudbase },
  );
}
```

å®ç°çº¦æŸï¼š

- åŒä¸€ä¸ª `(userId, lessonId, currentRound)` åœ¨ä¸€ä¸ªè‡ªç„¶æ—¥å†…åªè°ƒç”¨ä¸€æ¬¡ `syncAlphabetRoundResults`ã€‚  
- è‹¥ç½‘ç»œé”™è¯¯ï¼Œå¯åœ¨ä¸‹æ¬¡è¿›å…¥è¯¾ç¨‹æ—¶é‡è¯•ï¼Œç›´åˆ°æˆåŠŸä¸ºæ­¢ã€‚  
- å½“ Round3 çš„åŒæ­¥å®Œæˆå¹¶é€šè¿‡é˜ˆå€¼åï¼Œæ‰å…è®¸è§£é”ä¸‹ä¸€è¯¾ã€‚

### 11.5 ä¸ä»»åŠ¡åˆ—è¡¨çš„å…³ç³»

- ç¬¬ 9 ç« ä¸­å…³äºâ€œSession çŠ¶æ€ vs è®°å¿†å¼•æ“çŠ¶æ€â€çš„åˆ†å·¥ä¿æŒæœ‰æ•ˆã€‚  
- ç¬¬ 10 ç« ä¸­çš„ P2ï¼ˆè´¨é‡æäº¤ç­–ç•¥ï¼‰åº”æŒ‰æœ¬èŠ‚æ–¹æ¡ˆå®ç°ï¼Œå³**æŒ‰å­—æ¯èšåˆ + æ‰¹é‡æäº¤**ï¼Œä¸å†æ¨èâ€œæ¯é¢˜æäº¤â€ã€‚  
- è‹¥å°†æ¥éœ€è¦è¿›ä¸€æ­¥ä¼˜åŒ–ï¼Œå¯åœ¨ memory-engine å¢åŠ  `submitBatchMemoryResults`ï¼Œä½†å‰ç«¯åè®®ï¼ˆæŒ‰å­—æ¯èšåˆåæäº¤ï¼‰ä¿æŒä¸å˜ã€‚

è‡³æ­¤ï¼Œå­—æ¯æ¨¡å—çš„è®°å¿†ç­–ç•¥å·²å†»ç»“ï¼š  
**å‰ç«¯è´Ÿè´£é¢˜ç›®è„šæœ¬ã€é”™é¢˜ç»Ÿè®¡ä¸è´¨é‡èšåˆï¼›åç«¯åªè´Ÿè´£æŒä¹…åŒ– SMâ€‘2 çŠ¶æ€ä¸è·¨å¤©è°ƒåº¦ã€‚**

---

## ğŸ“Œ v3.0 æ–°å¢ç« èŠ‚ï¼ˆ2026-01-05 P0ä¿®å¤åè¡¥å……ï¼‰

> **è¯´æ˜**: ä»¥ä¸‹ç« èŠ‚åŸºäº P0 çº§ Bug ä¿®å¤åˆå¹¶è€Œæ¥ï¼ŒåŒ…å« lesson-scoped roundã€completedLessons æƒå¨æ¥æºã€isNew è¯­ä¹‰è¾¹ç•Œã€free-play è§„åˆ™ã€AsyncStorageè§„åˆ™ç­‰æœ€ç»ˆè§„åˆ™ã€‚è¿™äº›è§„åˆ™**ä¼˜å…ˆäº**æ–‡æ¡£å‰é¢éƒ¨åˆ†çš„ä»»ä½•å†²çªæè¿°ã€‚

---

## 12. lesson-scoped Round æ¨å¯¼è§„åˆ™ï¼ˆP0-A ä¿®å¤ï¼‰

### 12.1 é—®é¢˜èƒŒæ™¯

**å†å²é”™è¯¯**ï¼ˆå·²åºŸå¼ƒï¼‰ï¼š
- å‰ç«¯ç›´æ¥è¯»å– `progress.currentRound` å¹¶ä¼ ç»™ `getTodayMemories`
- å¯¼è‡´ Lesson2 ä» Round2 å¼€å§‹ï¼ˆå› ä¸ºLesson1 Round1 passed å currentRound è¢«å†™ä¸º2ï¼‰

**æœ€ç»ˆè§„åˆ™**ï¼š
- Round å¿…é¡»æŒ‰ **lesson-scoped** æ¨å¯¼ï¼Œä¸å—å…¶ä»–è¯¾ç¨‹å½±å“
- å…¬å¼ï¼š`computedRound = Math.min(Math.max(lastPassedRound + 1, 1), 3)`
- å…¶ä¸­ `lastPassedRound` = å½“å‰ lessonId åœ¨ roundHistory ä¸­ passed=true çš„æœ€å¤§ roundNumber

### 12.2 å®ç°è¦ç‚¹ï¼ˆå‰ç«¯ï¼‰

**æ–‡ä»¶**: `src/stores/alphabetStore.ts`  
**ä½ç½®**: `initializeSession` æ–¹æ³•ä¸­

```typescript
// ğŸ”¥ P0-A: lesson-scoped round æ¨å¯¼ï¼ˆä¸å†ä½¿ç”¨å…¨å±€ currentRoundï¼‰
if (!options?.round && lessonId) {
  const roundHistory = progress.roundHistory || [];
  
  // è¿‡æ»¤å‡ºå½“å‰è¯¾ç¨‹ä¸” passed çš„ round è®°å½•
  const lessonHistoryRounds = roundHistory
    .filter((r: any) => r.lessonId === lessonId && r.passed === true)
    .map((r: any) => r.roundNumber);
  
  const lastPassedRound = lessonHistoryRounds.length > 0 
    ? Math.max(...lessonHistoryRounds) 
    : 0;
  
  const computedRound = Math.min(Math.max(lastPassedRound + 1, 1), 3);
  round = computedRound;
  
  console.log(`ğŸ” [P0-A] lessonId: ${lessonId}, backendCurrentRound: ${progress.currentRound || 'N/A'}, computedRound: ${computedRound}, lessonHistoryRounds: [${lessonHistoryRounds.join(',')}]`);
}
```

### 12.3 éªŒè¯è§„åˆ™

- Lesson1 Round1 passed â†’ è¿›å…¥ Lesson2 â†’ `computedRound` **å¿…é¡»**ä¸º 1ï¼ˆä¸å— Lesson1 å½±å“ï¼‰
- Lesson2 Round1 passed â†’ ç»§ç»­ Lesson2 â†’ `computedRound` **å¿…é¡»**ä¸º 2
- ä»»ä½• lesson çš„ Round3 passed â†’ `computedRound` **å¿…é¡»**é‡ç½®ä¸º 1ï¼ˆä¸‹æ¬¡è¿›å…¥è¯¥ lesson æ—¶ï¼‰

---

## 13. completedLessons æƒå¨æ¥æºä¸è¯¾ç¨‹è§£é”ï¼ˆP0-B ä¿®å¤ï¼‰

### 13.1 å”¯ä¸€å†™å…¥æ—¶æœºï¼ˆå¼ºåˆ¶ï¼‰

```typescript
mode === 'learning'
  AND roundNumber === 3
  AND passed === true
```

**ç¦æ­¢**åœ¨ä»¥ä¸‹æƒ…å†µå†™å…¥ï¼š
- free-play æ¨¡å¼
- Round1/Round2ï¼ˆå³ä½¿ passedï¼‰
- Round3 ä½† passed=false

### 13.2 åç«¯å®ç°ï¼ˆsubmitRoundEvaluation.jsï¼‰

```javascript
// ğŸ”¥ P0-B: Round3 passed æ—¶å†™å…¥ completedLessons
let updatedCompletedLessons = Array.isArray(doc.completedLessons) 
  ? [...doc.completedLessons] 
  : [];

if (passed && roundNumber === 3 && lessonId) {
  if (!updatedCompletedLessons.includes(lessonId)) {
    updatedCompletedLessons.push(lessonId);
  }
}

await col.doc(docId).update({
  data: {
    completedLessons: updatedCompletedLessons,
    // ...å…¶ä»–å­—æ®µ
  },
});
```

### 13.3 è¯¾ç¨‹è§£é”åˆ¤å®šå…¬å¼

**æ–‡ä»¶**: `app/alphabet/index.tsx`

```typescript
const isLessonUnlocked = (lessonIndex: number) => {
  if (lessonIndex === 0) return true; // Lesson1 æ°¸è¿œè§£é”
  
  const prevLessonId = lessons[lessonIndex - 1].id;
  return completedAlphabetLessons.includes(prevLessonId);
};
```

**æƒå¨æ¥æº**ï¼š
- âœ… åç«¯è¿”å›çš„ `progress.completedLessons`
- âŒ ç¦æ­¢ä½¿ç”¨ `alphabetStore.completedCount`ï¼ˆä¼šè¯æ€ï¼Œä¸å‡†ç¡®ï¼‰

### 13.4 nextRound é‡ç½®è§„åˆ™ï¼ˆé˜²æ­¢è·¨è¯¾æ±¡æŸ“ï¼‰

```javascript
// submitRoundEvaluation.js
const nextRound = passed
  ? (roundNumber < 3 ? roundNumber + 1 : 1)  // Round3 passed é‡ç½®ä¸º 1
  : 1;                                       // failed ä¹Ÿé‡ç½®ä¸º 1
```

**ç†ç”±**: é¿å… `currentRound` å…¨å±€æ±¡æŸ“å¯¼è‡´ Lesson2 ä» Round2 å¼€å§‹

---

## 14. å››æ®µé˜Ÿåˆ—ç»“æ„ä¸ previous-review æ¥æºï¼ˆP0-C/D ä¿®å¤ï¼‰

### 14.1 å››æ®µç»“æ„ï¼ˆæ‰€æœ‰ round å¿…é¡»åŒ…å«ï¼‰

| æ®µè½ | åç§° | æ˜¯å¦å…è®¸ä¸ºç©º | ç”¨é€” |
|------|------|--------------|------|
| 1 | `previous-review` | âœ… å…è®¸ï¼ˆä»… Lesson1 Round1ï¼‰ | ä¸Šä¸€è½®/ä¸Šä¸€è¯¾å¤ä¹  |
| 2 | `new-learning` | âŒ å¿…é¡»æœ‰å†…å®¹ | æ–°å­—æ¯å­¦ä¹  |
| 3 | `mini-review` | âŒ å¿…é¡»æœ‰å†…å®¹ | æ¯3ä¸ªæ–°å­—æ¯å›æ”¾ |
| 4 | `final-review` | âŒ å¿…é¡»æœ‰å†…å®¹ | å…¨é‡å¤ä¹  |

### 14.2 previous-review æ•°æ®æ¥æºè§„åˆ™

| Round | Lesson | previous-review æ¥æº | å®ç°æ–¹å¼ |
|-------|--------|---------------------|----------|
| Round1 | Lesson1 | **ç©ºæ•°ç»„** | å‰ç«¯: `reviewLetters = []` |
| Round1 | Lesson2+ | **Lesson(N-1) å­—æ¯** | åç«¯æ˜¾å¼æ³¨å…¥ + å‰ç«¯æŒ‰ lessonId åˆ‡åˆ† |
| Round2/3 | ä»»æ„ | **å½“å‰ Lesson å­—æ¯** | å‰ç«¯æŒ‰ lessonId åˆ‡åˆ†ï¼ˆåŒä¸€æ‰¹å­—æ¯å¤ç”¨ï¼‰ |

### 14.3 åç«¯æ˜¾å¼æ³¨å…¥ï¼ˆP0-Cï¼Œä»… Round1 ä¸” lesson>1ï¼‰

**æ–‡ä»¶**: `cloudbase/functions/memory-engine/handlers/getTodayMemories.js`

```javascript
// ğŸ”¥ P0-C: æ˜¾å¼è·å– Round1 è·¨è¯¾ç¨‹ previous-review
if (entityType === 'letter' && roundNumber === 1 && params.lessonId && params.lessonId !== 'lesson1') {
  const currentLessonMeta = await getLessonMetadataFromDb(db, params.lessonId);
  if (currentLessonMeta && currentLessonMeta.order && currentLessonMeta.order > 1) {
    const prevLessonId = `lesson${currentLessonMeta.order - 1}`;
    
    // æŸ¥è¯¢ä¸Šä¸€è¯¾çš„å­—æ¯
    const prevLettersResult = await db.collection('letters')
      .where({ curriculumLessonIds: db.command.in([prevLessonId]) })
      .limit(20)
      .get();
    
    const explicitPrevMemories = [];
    
    for (const letter of prevLettersResult.data) {
      const mem = await getOrCreateMemory(db, userId, entityType, letter._id, false);
      if (mem) {
        // ğŸ”¥ æµ…æ‹·è´é¿å…å‰¯ä½œç”¨ï¼Œå¼ºåˆ¶ reviewStage >= 1
        const patched = { 
          ...mem, 
          reviewStage: Math.max(mem.reviewStage || 0, 1) 
        };
        explicitPrevMemories.push(patched);
      }
    }
    
    // åˆå¹¶åˆ° reviewMemoriesï¼ˆå»é‡ï¼‰
    const existingIds = new Set(reviewMemories.map(m => m.entityId));
    const uniquePrev = explicitPrevMemories.filter(m => !existingIds.has(m.entityId));
    reviewMemories = [...uniquePrev, ...reviewMemories];
    
    console.log(`ğŸ” [P0-C] lessonId: ${params.lessonId}, prevLessonId: ${prevLessonId}, explicitPrevCount: ${explicitPrevMemories.length}`);
  }
}
```

**å…³é”®ç‚¹**ï¼š
- `reviewStage >= 1` ç¡®ä¿ `isNew = false`
- ä»…å½±å“æœ¬æ¬¡è¿”å›ï¼Œä¸æŒä¹…åŒ–åˆ° DB
- å»é‡é˜²æ­¢é‡å¤å­—æ¯

### 14.4 å‰ç«¯æŒ‰ lessonId åˆ‡åˆ†ï¼ˆP0-Dï¼‰

**æ–‡ä»¶**: `src/stores/alphabetStore.ts`

```typescript
// ğŸ”¥ P0-D: æŒ‰ lessonId åˆ‡åˆ†ï¼ˆä¸ä¾èµ– isNewï¼‰
const currentLessonLetters = learningItems.filter(
  (item) => lessonId && item.letter.curriculumLessonIds?.includes(lessonId)
);

const nonCurrentLessonLetters = learningItems.filter(
  (item) => lessonId && !item.letter.curriculumLessonIds?.includes(lessonId)
);

let reviewLetters: AlphabetLearningState[];
let newLetters: AlphabetLearningState[];

if (round === 1) {
  // Round1: previous = éæœ¬è¯¾å­—æ¯ï¼ˆè·¨è¯¾ï¼‰ï¼Œnew = æœ¬è¯¾å­—æ¯
  reviewLetters = nonCurrentLessonLetters;
  newLetters = currentLessonLetters;
} else {
  // Round2/3: previous = æœ¬è¯¾å­—æ¯ï¼ˆåŒè¯¾å¤ä¹ ï¼‰ï¼Œnew = æœ¬è¯¾å­—æ¯ï¼ˆä¿è¯å››æ®µï¼‰
  reviewLetters = currentLessonLetters;
  newLetters = currentLessonLetters;
}

const queue = buildAlphabetQueue({
  lessonLetters: newLetters,
  round,
  mode,
  previousRoundLetters: reviewLetters,
});
```

**Round2/3 é˜Ÿåˆ—é‡å¤è¯´æ˜**ï¼š
- `reviewLetters` å’Œ `newLetters` éƒ½æŒ‡å‘ `currentLessonLetters`
- åŒä¸€å­—æ¯ä¼šåœ¨ `previous-review` å’Œ `new-learning` ä¸­é‡å¤å‡ºç°
- âœ… **å…è®¸**è¿™ç§é‡å¤ï¼ˆä¸ºä¿è¯å››æ®µç»“æ„å­˜åœ¨ï¼‰
- âš ï¸ é˜Ÿåˆ—æ€»é•¿åº¦ä¼šå¢åŠ ï¼Œéœ€è§‚å¯Ÿç”¨æˆ·å®Œæˆæ—¶é•¿

---

## 15. isNew æ•°æ®è¯­ä¹‰è¾¹ç•Œï¼ˆP0-D è¡¥å……ï¼‰

### 15.1 ç²¾ç¡®å®šä¹‰

- `memoryState.isNew`ï¼šè¡¨ç¤º**è®°å¿†çŠ¶æ€çš„æ–°æ—§**
  - `true`ï¼šè¯¥å­—æ¯åœ¨ `memory_status` ä¸­æ— è®°å½•æˆ– `reviewStage === 0`
  - `false`ï¼šè¯¥å­—æ¯å·²æœ‰å­¦ä¹ è®°å½•ä¸” `reviewStage > 0`

### 15.2 è¯­ä¹‰è¾¹ç•Œï¼ˆç¦æ­¢æ··æ·†ï¼‰

âŒ **`isNew` ä¸ç­‰ä»·äº** "æ˜¯å¦ä¸ºæœ¬è¯¾æ–°å­—æ¯"  
âŒ **`isNew` ä¸ç­‰ä»·äº** "æ˜¯å¦åº”è¿›å…¥ previous-review"  
âœ… **`isNew` ä»…è¡¨ç¤º** "è¯¥å­—æ¯æ˜¯å¦æœ‰å­¦ä¹ å†å²"

### 15.3 æ­£ç¡®ç”¨æ³• vs é”™è¯¯ç”¨æ³•

**âœ… æ­£ç¡®ç”¨æ³•**ï¼šåˆ¤æ–­æ˜¯å¦è·¨è¯¾å¤ä¹ 
```typescript
const hasNonNew = queue.some(item => item.memoryState?.isNew === false);
if (!hasNonNew) setPhase('today-learning'); // è·³è¿‡ yesterday-review
```

**âŒ é”™è¯¯ç”¨æ³•**ï¼ˆå·²ç¦ç”¨ï¼‰ï¼šç”¨äºåˆ†ç»„ previous/new
```typescript
// è¿™ä¼šå¯¼è‡´ Round1 çš„ previous-review ä¸ºç©ºï¼ˆå› ä¸ºä¸Šä¸€è¯¾å­—æ¯çš„ isNew å¯èƒ½ä¸º trueï¼‰
const reviewLetters = learningItems.filter(item => item.memoryState?.isNew === false);
const newLetters = learningItems.filter(item => item.memoryState?.isNew === true);
```

**âœ… æ­£ç¡®æ›¿ä»£æ–¹æ¡ˆ**ï¼šæŒ‰ `curriculumLessonIds` åˆ‡åˆ†ï¼ˆè§ 14.4 èŠ‚ï¼‰

---

## 16. free-play æ¨¡å¼è§„åˆ™ï¼ˆåˆå¹¶è‡ª IMPLEMENTATION_SKELETONï¼‰

### 16.1 å”¯ä¸€åˆ¤å®šæ¡ä»¶

```typescript
mode = user_alphabet_progress.letterCompleted === true
  ? 'free-play'
  : 'learning'
```

âŒ **ç¦æ­¢**ä½¿ç”¨ round/phase/è¿›åº¦ç™¾åˆ†æ¯”æ¨æ–­ mode  
âœ… `letterCompleted` æ˜¯å”¯ä¸€åˆæ³•æ¥æº

### 16.2 free-play è¯­ä¹‰

- free-play â‰  "é‡å¤è¿›å…¥å·²å®Œæˆè¯¾ç¨‹"
- free-play = "Alphabet æ•™å­¦æ•´ä½“ç»“æŸï¼Œè¿›å…¥åªè¯»å¤ä¹ çŠ¶æ€"
- free-play æ˜¯**å…¨å±€çŠ¶æ€**ï¼Œä¸æ˜¯**è¯¾ç¨‹çŠ¶æ€**

### 16.3 ç¦æ­¢å†™å…¥è§„åˆ™ï¼ˆå¼ºåˆ¶ï¼‰

free-play æ¨¡å¼ä¸‹**ç¦æ­¢**å†™å…¥ä»¥ä¸‹ä»»ä½•å­—æ®µï¼š

âŒ `currentRound`  
âŒ `roundHistory`  
âŒ `completedLessons`  
âŒ `letterProgress`  
âŒ `letterCompleted`  
âŒ ä»»ä½•è§£é”å­—æ®µ

**å®ç°è¦ç‚¹**ï¼ˆå‰ç«¯ï¼‰ï¼š
```typescript
// useAlphabetLearningEngine.ts: submitRoundResults
if (mode === 'learning') {
  // æ­£å¸¸å†™å…¥
  await submitRoundToStore({ ... });
  if (currentRound === 3 && passed) {
    markAlphabetLessonCompleted(lessonId);
  }
} else {
  // free-play: åªæ¸…é™¤ sessionï¼Œä¸å†™ä»»ä½•è¿›åº¦
  setPhase('round-completed');
}
```

### 16.4 æœªå®Œæˆ Alphabet æ—¶çš„è¡Œä¸ºè§„åˆ™

**åœºæ™¯**: ç”¨æˆ·åªå®Œæˆäº† Lesson1~5ï¼Œç¬¬6è¯¾å·²è§£é”ï¼Œ`letterCompleted === false`

**å†»ç»“è¡Œä¸º**ï¼ˆå¿…é¡»éµå®ˆï¼‰ï¼š

1. ç”¨æˆ·è¿›å…¥ä»»ä½•å·²è§£é”è¯¾ç¨‹ â†’ `mode = 'learning'`ï¼ˆä¸è¿›å…¥ `free-play`ï¼‰
2. ç”¨æˆ·è¿›å…¥å·² Round3 å®Œæˆçš„æ—§è¯¾ç¨‹ â†’ ä»æŒ‰ `learning` æ¨¡å¼è¿è¡Œ
   - `previous-review` ä»…æ¥è‡ªè¯¥è¯¾ç¨‹è‡ªèº«
   - âŒ **ç¦æ­¢**è·¨è¯¾ç¨‹å–å­—æ¯
3. ä¸å¾—äº§ç”Ÿä»»ä½•æ±¡æŸ“ï¼š
   - âŒ ä¸å½±å“ä¸‹ä¸€è¯¾çš„ `previous-review`
   - âŒ ä¸å½±å“è¯¾ç¨‹è§£é”é¡ºåº

---

## 17. AsyncStorage è§„åˆ™ï¼ˆv3.0 æ–°å¢ï¼‰

### 17.1 userId-scope è§„åˆ™ï¼ˆå¼ºåˆ¶ï¼‰

âœ… **å¿…é¡»**æ‰€æœ‰ç¼“å­˜ key åŒ…å« `userId`
```typescript
const key = `alphabet_progress_${userId}`;
```

âŒ **ç¦æ­¢**ä½¿ç”¨å…¨å±€ keyï¼ˆå¦‚ `alphabet_completedLessons`ï¼‰

### 17.2 æ—§å…¨å±€ key è¿ç§»/åˆ é™¤

```typescript
const oldData = await AsyncStorage.getItem('alphabet_completedLessons');
if (oldData) {
  await AsyncStorage.setItem(`alphabet_completedLessons_${userId}`, oldData);
  await AsyncStorage.removeItem('alphabet_completedLessons');
}
```

### 17.3 logout æ—¶çš„ç¼“å­˜æ¸…ç†ç­–ç•¥

**æ¨èç­–ç•¥**ï¼š
- âœ… ä¿ç•™ userId-scope ç¼“å­˜ï¼ˆä¸‹æ¬¡ç™»å½•åŒè´¦å·æ—¶å¤ç”¨ï¼‰
- âœ… æ¸…é™¤ session çº§åˆ«ç¼“å­˜ï¼ˆå¦‚ `alphabet_session_${userId}`ï¼‰
- âŒ ä¸æ¸…é™¤æŒä¹…åŒ–è¿›åº¦ç¼“å­˜ï¼ˆå‡å°‘ç½‘ç»œè¯·æ±‚ï¼‰

**å¯é€‰ä¸¥æ ¼ç­–ç•¥**ï¼š
- å¦‚éœ€ä¸¥æ ¼éšç§ä¿æŠ¤ï¼Œlogout æ—¶æ¸…é™¤æ‰€æœ‰ userId-scope ç¼“å­˜
- ä¸‹æ¬¡ç™»å½•æ—¶é‡æ–°ä»åç«¯åŒæ­¥

---

## 18. å…³é”®æ—¥å¿—/æ’æ¡©å»ºè®®ï¼ˆDEV/çŸ­æœŸï¼‰

### 18.1 æ—¥å¿—ç›®çš„

- âœ… éªŒè¯ P0 ä¿®å¤æ˜¯å¦ç”Ÿæ•ˆ
- âœ… å®šä½ previous-review æ¥æºé—®é¢˜
- âœ… ç¡®è®¤ round æ¨å¯¼æ­£ç¡®æ€§
- âš ï¸ æ‰€æœ‰æ—¥å¿—ä»…ç”¨äºå¼€å‘/æµ‹è¯•é˜¶æ®µ

### 18.2 å¿…è¦æ—¥å¿—ç‚¹ï¼ˆâ‰¤8 æ¡ï¼‰

#### Log 1: lesson-scoped round æ¨å¯¼
**æ–‡ä»¶**: `alphabetStore.ts`  
```typescript
console.log(`ğŸ” [P0-A] lessonId: ${lessonId}, computedRound: ${computedRound}, lessonHistoryRounds: [${lessonHistoryRounds.join(',')}]`);
```

#### Log 2: è·¨è¯¾ç¨‹ previous-review æ³¨å…¥
**æ–‡ä»¶**: `getTodayMemories.js`  
```javascript
console.log(`ğŸ” [P0-C] lessonId: ${params.lessonId}, prevLessonId: ${prevLessonId}, explicitPrevCount: ${explicitPreviousCount}`);
```

#### Log 3: å‰ç«¯ lessonId åˆ‡åˆ†ç»“æœ
**æ–‡ä»¶**: `alphabetStore.ts`  
```typescript
console.log('ğŸ“Š [buildQueue] sourceCounts:', sourceCounts); // {'previous-review': 5, 'new-learning': 12, ...}
```

#### Log 4: completedLessons å†™å…¥
**æ–‡ä»¶**: `submitRoundEvaluation.js`  
```javascript
console.log(`ğŸ” [P0-B] completedAfter: [${updatedCompletedLessons.join(',')}]`);
```

#### Log 5-8: getUserProgress roundHistoryã€nextRound é‡ç½®ã€free-play åˆ¤å®šã€Phase åˆ‡æ¢
è¯¦è§ v2.1 è§„èŒƒç¬¬ 8.2 èŠ‚ã€‚

### 18.3 ç§»é™¤è®¡åˆ’

- âœ… éªŒè¯é€šè¿‡åï¼ˆçº¦ 2 å‘¨å†…ï¼‰
- âœ… ç§»é™¤æ‰€æœ‰å¸¦ `ğŸ” [P0-*]` æ ‡è®°çš„æ—¥å¿—
- âœ… ä¿ç•™å…³é”®é”™è¯¯æ—¥å¿—ï¼ˆ`console.error`ï¼‰

---

## 19. å¼ºåˆ¶æ‰§è¡Œæ¸…å•ï¼ˆAI / å¼€å‘è€…å¿…è¯»ï¼‰

åœ¨ä¿®æ”¹ Alphabet æ¨¡å—ä»»ä½•ä»£ç å‰ï¼Œ**å¿…é¡»**ç¡®è®¤ï¼š

- [ ] æˆ‘å·²å®Œæ•´é˜…è¯»æœ¬å†»ç»“è§„èŒƒ
- [ ] æˆ‘çš„ä¿®æ”¹ç¬¦åˆå››æ®µé˜Ÿåˆ—ç»“æ„
- [ ] æˆ‘çš„ä¿®æ”¹ä¸ä¾èµ– `isNew` åˆ†ç»„ previous/new
- [ ] æˆ‘çš„ä¿®æ”¹ä½¿ç”¨ lesson-scoped round æ¨å¯¼
- [ ] æˆ‘çš„ä¿®æ”¹åœ¨ Round3 passed æ—¶å†™å…¥ completedLessons
- [ ] æˆ‘çš„ä¿®æ”¹åœ¨ free-play æ¨¡å¼ä¸‹ä¸å†™å…¥ä»»ä½•è¿›åº¦
- [ ] æˆ‘çš„ä¿®æ”¹ä½¿ç”¨ AsyncStorage userId-scope key

è‹¥ä»»æ„ä¸€é¡¹ä¸º "å¦"ï¼Œ**ç«‹å³åœæ­¢**å¹¶é‡æ–°å®¡æŸ¥è®¾è®¡ã€‚

---

## 20. æ–‡æ¡£ä¼˜å…ˆçº§ä¸å†²çªè§£å†³ï¼ˆv3.0 æœ€ç»ˆï¼‰

### 20.1 æ–‡æ¡£ä¼˜å…ˆçº§

1. **æœ¬æ–‡ä»¶ v3.0** (`alphabet-module-spec.md`)
2. ~~ALPHABET_MODULE_IMPLEMENTATION_SKELETON.md~~ï¼ˆå·²å½’æ¡£ï¼‰
3. ~~ALPHABET_MODULE_FINAL_FACTS.md~~ï¼ˆå·²å½’æ¡£ï¼‰
4. å†å²ä»£ç 
5. AI å»ºè®®

### 20.2 å†²çªè§£å†³åŸåˆ™

- æ–‡æ¡£å†…éƒ¨å†²çªï¼š**ç¬¬ 12-20 èŠ‚ï¼ˆv3.0 æ–°å¢ï¼‰ä¼˜å…ˆäºå‰é¢ç« èŠ‚**
- è‹¥ä»£ç ä¸æœ¬æ–‡ä»¶å†²çªï¼š**ä¿®æ”¹ä»£ç **
- è‹¥éœ€ä¿®æ”¹æœ¬æ–‡ä»¶ï¼š**å¿…é¡»é€šè¿‡æ­£å¼è¯„å®¡å¹¶æ›´æ–°ç‰ˆæœ¬å·è‡³ v3.1+**

### 20.3 æ—§æ–‡æ¡£å½’æ¡£è¯´æ˜

ä»¥ä¸‹æ–‡æ¡£å·²åˆå¹¶åˆ°æœ¬æ–‡ä»¶ï¼Œ**ä¸å†å…·å¤‡è§„èŒƒæ•ˆåŠ›**ï¼š

- `docs/ALPHABET_MODULE_FINAL_FACTS.md` â†’ å·²å½’æ¡£è‡³ `docs/OLD/`
- `docs/ALPHABET_MODULE_IMPLEMENTATION_SKELETON.md` â†’ å·²å½’æ¡£è‡³ `docs/OLD/`
- `.gemini/.../alphabet_module_freeze_spec_v2.1.md` â†’ ä¸´æ—¶æ–‡ä»¶ï¼Œå·²åˆ é™¤

**ç¦æ­¢å¼•ç”¨**ä»¥ä¸Šæ–‡æ¡£ã€‚å¦‚æœ‰å†²çªï¼Œä»¥æœ¬æ–‡ä»¶ä¸ºå‡†ã€‚

---

## 21. ç‰ˆæœ¬å†å²

| ç‰ˆæœ¬ | æ—¥æœŸ | ä¿®è®¢å†…å®¹ |
|------|------|----------|
| v3.0 | 2026-01-05 | **é‡å¤§æ›´æ–°**: åˆå¹¶ FINAL_FACTSã€IMPLEMENTATION_SKELETONã€P0ä¿®å¤è§„èŒƒã€‚æ–°å¢ç¬¬12-20èŠ‚ï¼šlesson-scoped roundã€completedLessonsæƒå¨ã€å››æ®µé˜Ÿåˆ—ã€isNewè¯­ä¹‰ã€free-playè§„åˆ™ã€AsyncStorageè§„åˆ™ã€æ—¥å¿—å»ºè®®ã€‚å†²çªè§£å†³ï¼šåºŸå¼ƒå…¨å±€currentRoundã€isNewåˆ†ç»„ã€Round2/3ä¸¤æ®µç»“æ„ç­‰å†å²é”™è¯¯ |
| v2.0.1 | 2025-12-XX | åˆç‰ˆè¯¦ç»†è§„æ ¼ï¼ŒåŒ…å«ä»£ç æ–‡ä»¶èŒè´£ã€è°ƒç”¨é“¾ã€Phaseæµç¨‹å›¾ã€æ•°æ®åº“schema |

---

## 22. å½“å‰æ¨¡å—çŠ¶æ€ä¸æœªæ¥å·¥ä½œï¼ˆ2026-01-17 æ›´æ–°ï¼‰

> **çŠ¶æ€**: æ¨¡å—åŸºæœ¬è·‘é€šï¼Œè¿›å…¥ä¼˜åŒ–é˜¶æ®µ  
> **æœ€åæ›´æ–°**: 2026-01-17

### 22.1 å·²å®Œæˆå·¥ä½œ

#### æµ‹è¯•é¡µé¢é‡æ„ï¼ˆapp/alphabet/test.tsxï¼‰
- å®¢æˆ·ç«¯é¢˜ç›®ç”Ÿæˆ + æœ¬åœ°åˆ¤åˆ†
- åå°éŸ³é¢‘é¢„åŠ è½½ï¼ˆä½¿ç”¨ expo-file-systemï¼‰
- ç­”æ¡ˆæ ¼å¼ä¿®å¤ï¼ˆé¿å…å¤šé€‰ bugï¼‰

#### åç«¯ç®€åŒ–
- submitLetterTest: ç§»é™¤åˆ¤åˆ†é€»è¾‘
- passLetterTest: å®ç° upsert é€»è¾‘

### 22.2 å·²çŸ¥é—®é¢˜

#### éŸ³é¢‘æ’­æ”¾ Bugï¼ˆP1ï¼‰
éƒ¨åˆ†å­—æ¯æ— å£°éŸ³ï¼Œæ€€ç–‘éŸ³é¢‘æ–‡ä»¶è·¯å¾„ä¸å­—æ¯å­—æ®µä¸åŒ¹é…ã€‚

### 22.3 å¾…ä¼˜åŒ–é¡¹

- æµ‹è¯•é¡µé¢ UI ä¼˜åŒ–ï¼ˆP2ï¼‰
- å¤ä¹ é¢˜ä¼˜åŒ–ï¼ˆP2ï¼‰

### 22.4 æœªæ¥å¢å¼º

- çœŸå®æ³°è¯­å‘éŸ³æ›¿æ¢ï¼ˆP3ï¼‰
- æ³°è¯­æ‹¼è¯»æ˜¾ç¤ºï¼ˆP3ï¼Œå‚è€ƒ PRONUNCIATION_RESTORATION_MODULE_SPEC_FROZEN_v1.0.mdï¼‰

---

**æœ¬æ–‡ä»¶ï¼ˆv3.0ï¼‰å³ä¸º Alphabet æ¨¡å—çš„å”¯ä¸€æƒå¨è§„èŒƒã€‚**
````

## File: docs/project-freeze/PROJECT_OVERVIEW_SPEC.md
````markdown
# æ³°è¯­å­¦ä¹ åº”ç”¨é¡¹ç›®æ€»çº² & æ¶æ„è§„æ ¼ï¼ˆProject Overview Spec, Freeze V2.0.1ï¼‰

> ç›®å½•ï¼š`docs/project-freeze/PROJECT_OVERVIEW_SPEC.md`  
> ä½œç”¨ï¼šä½œä¸º **é¡¹ç›®å”¯ä¸€çš„é¡¶å±‚ç®¡ç†æ–‡æ¡£**ï¼Œç»Ÿæ‘„ Alphabet / Vocabulary / Courses & LearningStore / Backend Memory Engine / AI æ¨¡å—çš„è§„æ ¼ä¸è¿›åº¦ã€‚  
> ç¡¬æ€§çº¦æŸï¼šåç»­æ‰€æœ‰å¼€å‘ä¸è¯„å®¡åªèƒ½ä¿¡ä»»æœ¬æ–‡ä»¶ + å¯¹åº”æ¨¡å— Spec + åç«¯è®°å¿†å¼•æ“ Spec + æ•°æ®åº“ç»“æ„æ–‡æ¡£ (`docs/database_schema.md`)ï¼Œå…¶ä»–ä»»ä½•æ–‡æ¡£ä¸€å¾‹è§†ä¸ºã€Œå†å²èµ„æ–™ã€ï¼Œä¸å¾—ä½œä¸ºå®ç°ä¾æ®ã€‚  
> è¦æ±‚ï¼šä»»ä½•æ¶æ„æˆ–æ¥å£è°ƒæ•´ï¼Œå¿…é¡»å…ˆæ›´æ–°æœ¬æ–‡ä»¶ï¼Œå†åŒæ­¥æ›´æ–°å¯¹åº”æ¨¡å—çš„ Specã€åç«¯ Spec ä¸æ•°æ®åº“ç»“æ„æ–‡æ¡£ã€‚

---

## 1. é¡¹ç›®ç›®æ ‡ä¸ä¸Šçº¿èŒƒå›´

### 1.1 äº§å“ç›®æ ‡ï¼ˆé¦–å‘ç‰ˆæœ¬ï¼‰

- é¢å‘ä¸­æ–‡ç”¨æˆ·çš„æ³°è¯­å…¥é—¨å­¦ä¹  Appï¼Œé¦–å‘ç‰ˆæœ¬åŒ…å«ï¼š
  - **å­—æ¯æ¨¡å—ï¼ˆAlphabet Moduleï¼‰**ï¼šLesson1â€“7ï¼Œå¸¦ä¸‰è½®è¯¾ç¨‹çº§è®­ç»ƒä¸é€»è¾‘é¢˜å‹åŸºç¡€ï¼›
  - **è¯æ±‡æ¨¡å—ï¼ˆVocabulary Moduleï¼‰**ï¼šè‡³å°‘ 1 é—¨åŸºç¡€æ³°è¯­è¯¾ç¨‹ï¼ˆThai_1ï¼‰ï¼Œæ”¯æŒä¾‹å¥/å¯¹è¯/ç”¨æ³•ç²¾è®²ä¸è½»é‡åŒ–å¤ä¹ ï¼›
  - **è¯¾ç¨‹å…¥å£ + å­¦ä¹ ä»ªè¡¨ç›˜**ï¼šç»Ÿä¸€çš„ Courses é¡µ + LearningStore ç»Ÿè®¡ï¼›
  - **ç»Ÿä¸€è®°å¿†å¼•æ“ï¼ˆSMâ€‘2ï¼‰**ï¼šé€šè¿‡ `memory-engine` / `vocabulary` äº‘å‡½æ•°ç®¡ç†é•¿æœŸå¤ä¹ ï¼›
  - **è½»é‡ AI æ¨¡å—ï¼ˆAI Module, Liteï¼‰**ï¼šåœ¨é¦–å‘ä¸­çœŸæ­£æ¥å…¥ä»¥ä¸‹å››ç±» AI èƒ½åŠ›ï¼š
    - åŸºäºé”™é¢˜å’Œå­¦ä¹ è¿›åº¦çš„**å¼±é¡¹è¯æ±‡å¼ºåŒ–ç»ƒä¹ **ï¼ˆ`generateWeaknessVocabulary`ï¼‰ï¼›
    - åŸºäºç”¨æˆ·é€‰æ‹©è¯/é”™é¢˜ç”Ÿæˆçš„**å¾®é˜…è¯»çŸ­æ–‡**ï¼ˆ`generateMicroReading`ï¼‰ï¼›
    - é’ˆå¯¹å•è¯çš„**åŸºç¡€è¯æ±‡è§£æ/è¡¥å……ä¾‹å¥**ï¼ˆ`explainVocabulary`ï¼Œä»…åšè§£é‡Šä¸ä¾‹å¥æ‰©å±•ï¼Œä¸ç›´æ¥ä¿®æ”¹è®°å¿†çŠ¶æ€ï¼‰ï¼›
    - é’ˆå¯¹å­—æ¯ / å•è¯ / å¥å­çš„**å‘éŸ³åˆ†æä¸åé¦ˆ**ï¼ˆ`analyzePronunciation` çš„é¦–å‘ MVP ç‰ˆï¼Œç”¨äºåŸºç¡€æ‰“åˆ†ä¸æ–‡å­—åé¦ˆï¼‰ã€‚
- AI æ¨¡å—ä»ä¿æŒ **Lite / é¦–å‘ MVP** çš„å®šä½ï¼šåªè¦†ç›–ä»¥ä¸Š 4 ç±»ä¸å­¦ä¹ é—­ç¯å¼ºç›¸å…³çš„èƒ½åŠ›ï¼Œå…¶ä½™é«˜é˜¶åŠŸèƒ½ï¼ˆå¤æ‚æ¨èç³»ç»Ÿã€æ›´ä¸°å¯Œçš„é˜…è¯»ç†è§£åœºæ™¯ç­‰ï¼‰ä½œä¸ºåç»­ç‰ˆæœ¬æ‰©å±•ã€‚

### 1.2 æ¶æ„åŸºçº¿

- å‰ç«¯ï¼šReact Native + Expo Router + TypeScript + Zustandï¼›
- åç«¯ï¼šCloudBase äº‘å‡½æ•°ï¼ˆwx-server-sdkï¼‰+ NoSQL é›†åˆï¼›
- è®°å¿†å¼•æ“ï¼šç»Ÿä¸€çš„ `memory_status` + ä¼˜åŒ–ç‰ˆ SMâ€‘2 ç®—æ³•ï¼›
- æ–‡æ¡£ï¼š**ä»¥ `docs/project-freeze` ç›®å½•ä¸‹çš„ Spec + `docs/database_schema.md` ä¸ºæƒå¨ä¿¡æ¯æº**ï¼Œä»“åº“ä¸­å…¶ä»–æ–‡æ¡£ï¼ˆå«æ—§è®¾è®¡ç¨¿ã€å‘¨æŠ¥ã€å¤‡ä»½è¯´æ˜ç­‰ï¼‰åªå¯ä½œä¸ºå†å²å‚è€ƒï¼Œä¸å¯ä¾èµ–ã€‚

---

## 2. æ¨¡å—åˆ’åˆ†ä¸ä¸»è¦æ–‡æ¡£

| æ¨¡å— | è¯´æ˜ | å¯¹åº” Spec |
|------|------|-----------|
| Frontend Shell & Navigation | é¦–é¡µã€Tab å¯¼èˆªã€ç”¨æˆ·ä¸­å¿ƒã€åŸºç¡€è®¾ç½® | `frontend-shell-module-spec.md` |
| Alphabet Module | å­—æ¯è¯¾ç¨‹å­¦ä¹ ä¸ä¸‰è½®è®­ç»ƒ | `alphabet-module-spec.md` |
| Vocabulary Module | å•è¯ç²¾è®²ä¸ SRS å¤ä¹  | `vocabulary-module-spec.md` |
| Courses + LearningStore | è¯¾ç¨‹å…¥å£ã€å…¨å±€å­¦ä¹ ä»ªè¡¨ç›˜ | `courses-and-learningstore-spec.md` |
| Backend Memory Engine | ç»Ÿä¸€è®°å¿†å¼•æ“ + æ¨¡å—è§£é” | `backend-memory-engine-spec.md` |
| AI Module (Lite) | å‘éŸ³åé¦ˆã€å¼±é¡¹å¼ºåŒ–ã€å¾®é˜…è¯»ï¼ˆè®¾è®¡çº§ï¼‰ | `ai-module-spec.md` |

> é¡¶å±‚ç»„ä»¶å’Œè°ƒç”¨å…³ç³»ä»¥ç¬¬ 2.1 èŠ‚ä¸‹æ–¹çš„ Mermaid ç±»å›¾ä¸ºå”¯ä¸€æ¶æ„è“å›¾ï¼Œåç»­è¿­ä»£ä¸å¾—éšæ„å¢åˆ å›¾ä¸­çš„ç»„ä»¶ï¼Œåªèƒ½åœ¨å…¶å†…éƒ¨æ¼”åŒ–å®ç°ã€‚

### 2.1 é¡¶å±‚ç»„ä»¶/ç±»å›¾ï¼ˆå†»ç»“ç‰ˆï¼Œå…¨é¡¹ç›®å”¯ä¸€æ¶æ„ï¼‰

```mermaid
classDiagram

%% ===================================================================
%% 1. Frontend Shell & Navigation
%% ===================================================================
class TabsLayout {
  +tabs
}

class HomeScreen {
  +render()
  +handleBubbleClick()
  +getCurrentCourse()
}
class CoursesScreen {
  +render()
  +handleStartAlphabet()
  +handleStartWordCourse()
}
class ProfileScreen {
  +render()
  +updateDailyLimit()
  +handleLogout()
}
class LanguageSwitcher {
  +render()
  +setLanguage()
}
class FloatingBubbles {
  +render()
  +onOpenReview()
}
class ThaiPatternBackground {
  +render()
}

TabsLayout <|-- HomeScreen
TabsLayout <|-- CoursesScreen
TabsLayout <|-- ProfileScreen

HomeScreen --> UserStore
HomeScreen --> ModuleAccessStore
HomeScreen --> LearningStore
HomeScreen --> FloatingBubbles
HomeScreen --> ThaiPatternBackground

CoursesScreen --> VocabularyStore
CoursesScreen --> ModuleAccessStore

ProfileScreen --> UserStore
ProfileScreen --> LearningStore
ProfileScreen --> ModuleAccessStore
ProfileScreen --> LanguageSwitcher
ProfileScreen --> LearningPreferenceStore

%% ===================================================================
%% 2. Stores & Global State
%% ===================================================================
class UserStore {
  +currentUser
  +login()
  +logout()
}
class ModuleAccessStore {
  +userProgress
  +fetchUserProgress()
}
class LearningStore {
  +currentCourseId
  +currentAlphabetProgramId
  +streakDays
  +totalStudyMinutes
  +lastStudyAt
  +setCurrentCourse()
  +setCurrentAlphabetProgram()
  +registerStudySession()
}
class LearningPreferenceStore {
  +dailyLimitsWord
  +dailyLimitsLetter
  +setDailyLimit()
}

UserStore --> Users
ModuleAccessStore --> ApiClient
LearningStore --> ApiClient

%% ===================================================================
%% 3. Alphabet Module
%% ===================================================================
class AlphabetLessonListScreen {
  +render()
  +fetchLessons()
  +handleStartLesson()
}
class AlphabetLessonScreen {
  +render()
  +lessonId
}
class AlphabetLearningEngineView {
  +render()
}
class AlphabetLearningView {
  +renderLetter()
}
class AlphabetReviewView {
  +renderQuestion()
}
class GameContainer {
  +queue
  +currentIndex
  +wrongPool
  +next()
}
class StepRenderer {
  +render()
}

class AlphabetQuestionEngine {
  +generateQueueItems()
}
class LettersQuestionGenerator {
  +generate()
}

class AlphabetSessionState {
  +userId
  +lessonId
  +currentRound
  +phase
  +queue
  +cursorIndex
  +todayNewLetters
  +todayReviewedLetters
  +wrongLetterIds
  +perLetterStats
  +roundFinished
  +updatedAt
}

class AlphabetStore {
  +state
  +initializeSession()
  +loadSession()
  +saveSession()
  +clearSession()
  +submitRoundResults()
}

class UseAlphabetLearningEngine {
  +phase
  +currentRound
  +handleAnswer()
  +handleNext()
  +submitRoundResults()
}

AlphabetLessonListScreen --> AlphabetStore
AlphabetLessonListScreen --> AlphabetLessonScreen
AlphabetLessonScreen --> UseAlphabetLearningEngine
UseAlphabetLearningEngine --> AlphabetStore
UseAlphabetLearningEngine --> AlphabetLearningEngineView
AlphabetLearningEngineView --> GameContainer
GameContainer --> StepRenderer
StepRenderer --> AlphabetLearningView
StepRenderer --> AlphabetReviewView

UseAlphabetLearningEngine --> AlphabetQuestionEngine
AlphabetQuestionEngine --> LettersQuestionGenerator

AlphabetStore --> AlphabetSessionState
AlphabetStore --> ApiClient
AlphabetStore --> AsyncStorage

%% ===================================================================
%% 4. Vocabulary Module
%% ===================================================================
class WordLearningScreen {
  +render()
}
class NewWordView {
  +renderRichCard()
}
class ReviewWordView {
  +renderQuestion()
}
class VocabularyQuestionView {
  +renderMCQ()
  +renderSpelling()
}

class VocabularyQuestionEngine {
  +pickQuestionTypes()
  +buildQuestion()
}

class VocabularyQuestionRecord {
  +vocabularyId
  +questionType
  +isCorrect
  +usedHint
}

class VocabularyPerWordStats {
  +attempts
  +wrongCount
  +usedHint
  +questionTypes
}

class VocabularySessionState {
  +userId
  +courseSource
  +dateKey
  +reviewQueue
  +newQueue
  +currentIndex
  +mode
  +perWordStats
  +wrongWordIds
  +wrongRecords
  +submitted
}

class VocabularyStore {
  +state
  +initializeSession()
  +answerQuestion()
  +skipReviewAndLearnNew()
  +finishSession()
  +resetCourseProgress()
}

WordLearningScreen --> VocabularyStore
WordLearningScreen --> NewWordView
WordLearningScreen --> VocabularyQuestionView
VocabularyQuestionView --> ReviewWordView
VocabularyQuestionView --> VocabularyQuestionEngine
VocabularyStore --> VocabularyQuestionEngine

VocabularyStore --> VocabularySessionState
VocabularySessionState --> VocabularyPerWordStats
VocabularySessionState --> VocabularyQuestionRecord

VocabularyStore --> ApiClient
VocabularyStore --> AsyncStorage

%% ===================================================================
%% 5. AI Module
%% ===================================================================
class AiPronunciationScreen {
  +render()
  +startRecording()
  +submitRecording()
}
class AiWeaknessPracticeScreen {
  +render()
  +loadWeakVocab()
}
class AiMicroReadingScreen {
  +render()
  +generateReading()
  +submitReadingRecording()
}

class AiEngineCF {
  +analyzePronunciation()
  +generateWeaknessVocabulary()
  +generateMicroReading()
  +explainVocabulary()
}

AiPronunciationScreen --> ApiClient
AiWeaknessPracticeScreen --> ApiClient
AiMicroReadingScreen --> ApiClient

AiWeaknessPracticeScreen --> VocabularyStore
AiMicroReadingScreen --> VocabularyStore
AiPronunciationScreen --> AlphabetStore
AiPronunciationScreen --> VocabularyStore

%% ===================================================================
%% 6. Courses & Access
%% ===================================================================
CoursesScreen --> LearningPreferenceStore
CoursesScreen --> LearningStore
HomeScreen --> LearningStore
HomeScreen --> ModuleAccessStore
ProfileScreen --> LearningPreferenceStore
ProfileScreen --> LearningStore
ProfileScreen --> ModuleAccessStore

ModuleAccessStore --> MemoryEngineCF
LearningStore --> MemoryEngineCF

%% ===================================================================
%% 7. Backend Cloud Functions
%% ===================================================================
class ApiClient {
  +callCloudFunction()
}

class MemoryEngineCF {
  +getTodayMemories()
  +submitMemoryResult()
  +submitRoundEvaluation()
  +checkModuleAccess()
  +getUserProgress()
  +getAlphabetLessons()
  +registerStudySession()
}

class LearnVocabCF {
  +getTodayWords()
  +updateMastery()
  +getVocabularyDetail()
  +getReviewStatistics()
  +getVocabularyList()
  +getSkippedWords()
}

ApiClient --> MemoryEngineCF
ApiClient --> LearnVocabCF
ApiClient --> AiEngineCF

AlphabetStore --> MemoryEngineCF
UseAlphabetLearningEngine --> MemoryEngineCF
VocabularyStore --> LearnVocabCF
VocabularyStore --> MemoryEngineCF
ModuleAccessStore --> MemoryEngineCF
LearningStore --> MemoryEngineCF

%% ===================================================================
%% 8. Database Collectionsï¼ˆç®€ç•¥ï¼‰
%% ===================================================================
class Users {
  +userId
  +nickname
  +avatarUrl
  +createdAt
}
class Letters {
  +_id
  +thaiChar
  +type
  +class
  +curriculumLessonIds
}
class Vocabulary {
  +_id
  +source
  +lessonNumber
  +thaiWord
  +meaning
}
class MemoryStatus {
  +userId
  +entityType
  +entityId
  +masteryLevel
  +nextReviewAt
}
class UserProgress {
  +userId
  +letterCompleted
  +letterProgress
  +wordUnlocked
  +wordProgress
  +totalStudyDays
  +streakDays
  +lastStudyDate
  +totalStudyMinutes
}
class UserAlphabetProgress {
  +userId
  +letterProgress
  +letterCompleted
}
class UserVocabularyProgress {
  +userId
  +vocabularyId
  +mastery
  +nextReviewDate
}

MemoryEngineCF --> Letters
MemoryEngineCF --> Vocabulary
MemoryEngineCF --> MemoryStatus
MemoryEngineCF --> UserProgress
MemoryEngineCF --> UserAlphabetProgress
LearnVocabCF --> Vocabulary
LearnVocabCF --> UserVocabularyProgress
AiEngineCF --> MemoryStatus
AiEngineCF --> Vocabulary
AiEngineCF --> Letters
```

### 2.2 é¡¶å±‚ç”¨ä¾‹å›¾ï¼ˆå†»ç»“ç‰ˆï¼Œå…¨é¡¹ç›®å”¯ä¸€ç”¨ä¾‹é›†åˆï¼‰

```mermaid
flowchart TD
  %% Actor
  U[User]

  %% Core use cases (â‰¤10)
  UC_Auth((Sign Up / Sign In / Sign Out))
  UC_Home((View Home & Current Course))
  UC_SelectCourse((Browse & Select Course))
  UC_AlphabetLearn((Learn Alphabet Lessons))
  UC_VocabLearn((Learn Vocabulary Lessons))
  UC_Review((Review Learned Items))
  UC_ViewProgress((View Progress & Achievements))
  UC_Settings((Change Study Settings))
  UC_AIPractice((AI-assisted Practice))

  %% Actor â†’ Use case
  U --> UC_Auth
  U --> UC_Home
  U --> UC_SelectCourse
  U --> UC_AlphabetLearn
  U --> UC_VocabLearn
  U --> UC_Review
  U --> UC_ViewProgress
  U --> UC_Settings
  U --> UC_AIPractice

  %% Relationships between use cases
  UC_SelectCourse -. includes .-> UC_AlphabetLearn
  UC_SelectCourse -. includes .-> UC_VocabLearn
  UC_AlphabetLearn -. includes .-> UC_Review
  UC_VocabLearn -. includes .-> UC_Review
  UC_AIPractice -. extends .-> UC_Review
```

> ä»¥ä¸Šç”¨ä¾‹å›¾ä¸ºæœ¬é¡¹ç›®å”¯ä¸€çš„â€œä¸šåŠ¡åœºæ™¯é›†åˆâ€ã€‚åç»­å¦‚éœ€æ–°å¢/åˆ é™¤ç”¨ä¾‹ï¼Œå¿…é¡»é¦–å…ˆæ›´æ–°æœ¬å›¾ï¼Œå†åŒæ­¥è°ƒæ•´å¯¹åº”æ¨¡å— Specã€‚

### 2.3 å…³é”®ç”¨ä¾‹æ—¶åºå›¾ï¼ˆæŒ‰ç”¨ä¾‹åˆ†ç»„ï¼‰

#### 2.3.1 UC_Auth â€“ Sign Up / Sign In / Sign Out

```mermaid
sequenceDiagram
  actor U as User
  participant AuthScreen as Auth Screen
  participant UserStore
  participant ApiClient
  participant UserCF as user-* CF
  participant Users as users collection

  U ->> AuthScreen: enter credentials / tap login
  AuthScreen ->> UserStore: login(email,password)
  UserStore ->> ApiClient: callCloudFunction('user-login',data)
  ApiClient ->> UserCF: main({action:'login',data})
  UserCF ->> Users: query user by email
  Users -->> UserCF: user document
  UserCF -->> ApiClient: success + user profile
  ApiClient -->> UserStore: response
  UserStore -->> AuthScreen: update currentUser\nnavigate to Home

  U ->> ProfileScreen: tap logout
  ProfileScreen ->> UserStore: logout()
  UserStore -->> ProfileScreen: clear currentUser\nnavigate to Login
```

#### 2.3.2 UC_Home â€“ View Home & Current Course

```mermaid
sequenceDiagram
  actor U as User
  participant HomeScreen
  participant UserStore
  participant ModuleAccessStore
  participant LearningStore

  U ->> HomeScreen: open app / switch to Home tab
  HomeScreen ->> UserStore: get currentUser
  UserStore -->> HomeScreen: currentUser
  HomeScreen ->> ModuleAccessStore: userProgress (if not loaded)
  ModuleAccessStore -->> HomeScreen: letterProgress,wordProgress,...
  HomeScreen ->> LearningStore: get currentCourseId / stats
  LearningStore -->> HomeScreen: streakDays,totalStudyMinutes
  HomeScreen ->> HomeScreen: compute currentCourse via getCurrentCourse()
  HomeScreen -->> U: render greeting, hero card,\nfloating bubbles, stats
```

#### 2.3.3 UC_SelectCourse â€“ Browse & Select Course

```mermaid
sequenceDiagram
  actor U as User
  participant CoursesScreen
  participant LearningPreferenceStore
  participant LearningStore
  participant ModuleAccessStore
  participant Router as expo-router

  U ->> CoursesScreen: open Courses tab
  CoursesScreen ->> LearningPreferenceStore: read dailyLimits
  CoursesScreen ->> ModuleAccessStore: read userProgress (locks)
  CoursesScreen -->> U: render alphabet & vocab course cards

  U ->> CoursesScreen: tap Alphabet course
  CoursesScreen ->> LearningStore: setCurrentAlphabetProgram('alphabet')
  CoursesScreen ->> Router: push('/alphabet')

  U ->> CoursesScreen: tap Vocabulary course
  CoursesScreen ->> LearningStore: setCurrentCourse(courseId)
  CoursesScreen ->> Router: push('/learning?module=word&source=courseSource')
```

#### 2.3.4 UC_AlphabetLearn â€“ Learn Alphabet Lessons

```mermaid
sequenceDiagram
  actor U as User
  participant AlphabetLessonListScreen as LessonList
  participant AlphabetLessonScreen as LessonScreen
  participant UseAlphabetLearningEngine as Hook
  participant AlphabetStore
  participant ApiClient
  participant MemoryEngineCF as memory-engine

  U ->> LessonList: open alphabet course
  LessonList ->> ApiClient: callCloudFunction('memory-engine',{action:'getAlphabetLessons'})
  ApiClient ->> MemoryEngineCF: getAlphabetLessons
  MemoryEngineCF -->> ApiClient: lessons[]
  ApiClient -->> LessonList: lessons[]
  LessonList -->> U: render Lesson1..7 cards

  U ->> LessonList: tap "Start" on LessonN
  LessonList ->> LessonScreen: navigate with lessonId

  LessonScreen ->> Hook: useAlphabetLearningEngine(lessonId)
  Hook ->> AlphabetStore: initializeSession(userId,lessonId)
  AlphabetStore ->> ApiClient: callCloudFunction('memory-engine',{action:'getTodayMemories',data:{entityType:'letter',lessonId}})
  ApiClient ->> MemoryEngineCF: getTodayMemories(letter,lessonId)
  MemoryEngineCF ->> MemoryStatus: read existing memory records
  MemoryEngineCF ->> Letters: query letters in lesson
  MemoryEngineCF -->> ApiClient: items + lessonMetadata + phonicsRule
  ApiClient -->> AlphabetStore: items
  AlphabetStore -->> Hook: queue,sessionState
  Hook -->> U: render LessonScreen via AlphabetLearningEngineView
```

#### 2.3.5 UC_VocabLearn â€“ Learn Vocabulary Lessons

```mermaid
sequenceDiagram
  actor U as User
  participant WordLearningScreen as WordScreen
  participant VocabularyStore
  participant ApiClient
  participant LearnVocabCF as vocabulary

  U ->> WordScreen: navigate from Courses or Home\n(module=word, source)
  WordScreen ->> VocabularyStore: initializeSession(userId,source)
  VocabularyStore ->> ApiClient: callCloudFunction('vocabulary',{action:'getTodayWords',data:{userId,limit,level}})
  ApiClient ->> LearnVocabCF: getTodayWords
  LearnVocabCF ->> UserVocabularyProgress: read review items
  LearnVocabCF ->> Vocabulary: read vocab documents
  LearnVocabCF -->> ApiClient: words + summary
  ApiClient -->> VocabularyStore: todayWords
  VocabularyStore -->> WordScreen: sessionState (reviewQueue,newQueue)
  WordScreen -->> U: render NewWordView + VocabularyQuestionView
```

#### 2.3.6 UC_Review â€“ Review Learned Items

```mermaid
sequenceDiagram
  actor U as User
  participant WordScreen
  participant AlphabetLessonScreen as AlphaScreen
  participant VocabularyStore
  participant AlphabetStore
  participant ApiClient
  participant MemoryEngineCF as memory-engine
  participant LearnVocabCF as vocabulary

  U ->> AlphaScreen: answer alphabet quiz
  AlphaScreen ->> AlphabetStore: submitResult(userId,isCorrect)
  AlphabetStore ->> ApiClient: callCloudFunction('memory-engine',{action:'submitMemoryResult',data:{userId,entityType:'letter',entityId,quality}})
  ApiClient ->> MemoryEngineCF: submitMemoryResult
  MemoryEngineCF ->> MemoryStatus: update letter memory

  U ->> WordScreen: answer vocabulary question
  WordScreen ->> VocabularyStore: answerQuestion(vocabId,isCorrect,type)
  VocabularyStore ->> VocabularyStore: update perWordStats & wrongWordIds
  Note right of VocabularyStore: At end of session\ncompute mastery per word
  VocabularyStore ->> ApiClient: callCloudFunction('vocabulary',{action:'updateMastery',data:{userId,vocabularyId,mastery}})
  ApiClient ->> LearnVocabCF: updateMastery
  LearnVocabCF ->> UserVocabularyProgress: update record
```

#### 2.3.7 UC_ViewProgress â€“ View Progress & Achievements

```mermaid
sequenceDiagram
  actor U as User
  participant ProfileScreen
  participant ModuleAccessStore
  participant LearningStore

  U ->> ProfileScreen: open Profile tab
  ProfileScreen ->> ModuleAccessStore: get userProgress
  ModuleAccessStore -->> ProfileScreen: letterProgress,wordProgress,...
  ProfileScreen ->> LearningStore: get progress (streakDays,totalStudyMinutes)
  LearningStore -->> ProfileScreen: stats
  ProfileScreen -->> U: render achievements, stats cards
```

#### 2.3.8 UC_Settings â€“ Change Study Settings

```mermaid
sequenceDiagram
  actor U as User
  participant ProfileScreen
  participant LearningPreferenceStore
  participant ModuleAccessStore

  U ->> ProfileScreen: open settings section
  U ->> ProfileScreen: tap "Daily Study Goal"
  ProfileScreen ->> LearningPreferenceStore: setDailyLimit(module,limit)
  ProfileScreen ->> ModuleAccessStore: update local userProgress.dailyLimit
  Note right of ProfileScreen: ä¸‹æ¬¡å­¦ä¹ æ—¶ï¼Œå­¦ä¹ æ¨¡å—\nä¼šæŠŠæ–°çš„ dailyLimit ä¼ ç»™ memory-engine\nå¹¶ç”±åç«¯æŒä¹…åŒ–

  U ->> ProfileScreen: select language
  ProfileScreen ->> LanguageSwitcher: setLanguage(lang)
  LanguageSwitcher -->> ProfileScreen: reload i18n resources
```

#### 2.3.9 UC_AIPractice â€“ AI-assisted Practice

```mermaid
sequenceDiagram
  actor U as User
  participant AiWeaknessPracticeScreen as WeakScreen
  participant AiPronunciationScreen as PronScreen
  participant AiMicroReadingScreen as ReadScreen
   participant AiExplainVocabScreen as ExplainScreen
  participant VocabularyStore
  participant AlphabetStore
  participant ApiClient
  participant AiEngineCF as ai-engine

  U ->> WeakScreen: open AI Weak Vocabulary
  WeakScreen ->> VocabularyStore: get wrongWordIds,courseSource
  WeakScreen ->> ApiClient: callCloudFunction('ai-engine',{action:'generateWeaknessVocabulary',data:{userId,focusVocabularyIds}})
  ApiClient ->> AiEngineCF: generateWeaknessVocabulary
  AiEngineCF -->> ApiClient: suggestions[]
  ApiClient -->> WeakScreen: suggestions[]
  WeakScreen -->> U: render AI extra examples & mnemonics

  U ->> ReadScreen: open AI Micro Reading
  ReadScreen ->> VocabularyStore: get wrongWordIds
  ReadScreen ->> ApiClient: callCloudFunction('ai-engine',{action:'generateMicroReading',data:{userId,focusType:'word',focusIds:wrongWordIds}})
  ApiClient ->> AiEngineCF: generateMicroReading
  AiEngineCF -->> ApiClient: microReading
  ApiClient -->> ReadScreen: microReading
  ReadScreen -->> U: display Thai text + hint

  U ->> ExplainScreen: request AI explanation for a word
  ExplainScreen ->> VocabularyStore: get current vocabularyId / thaiWord
  ExplainScreen ->> ApiClient: callCloudFunction('ai-engine',{action:'explainVocabulary',data:{userId,vocabularyId}})
  ApiClient ->> AiEngineCF: explainVocabulary
  AiEngineCF -->> ApiClient: explanation
  ApiClient -->> ExplainScreen: explanation
  ExplainScreen -->> U: show meaning, breakdown, extra examples

  U ->> PronScreen: record pronunciation
  PronScreen ->> ApiClient: callCloudFunction('ai-engine',{action:'analyzePronunciation',data:{userId,targetType,targetId,audioUrl}})
  ApiClient ->> AiEngineCF: analyzePronunciation
  AiEngineCF -->> ApiClient: feedback
  ApiClient -->> PronScreen: feedback
  PronScreen -->> U: show scores & suggestions
```

> æ—§ç‰ˆé¡¹ç›®å¿«ç…§æ–‡æ¡£ï¼ˆ`docs/Document/project-snapshot-*` ç­‰ï¼‰å·²åˆ é™¤ï¼Œä»»ä½•æ–°éœ€æ±‚å¿…é¡»åŸºäºä»¥ä¸Š Spec æ›´æ–°ã€‚

---

## 3. å½“å‰å®ç°çŠ¶æ€æ¦‚è§ˆï¼ˆæŒ‰æ¨¡å—ï¼‰

çŠ¶æ€ä½¿ç”¨ï¼š`âœ… å®Œæˆ` / `ğŸŸ¡ éƒ¨åˆ†å®ç°` / `â³ è§„åˆ’ä¸­`

### 3.1 Alphabet Module

- è·¯ç”± & ç»„ä»¶ç»“æ„ï¼š`app/alphabet/*` + `AlphabetLearningEngineView`ï¼šğŸŸ¡ éƒ¨åˆ†å®ç°  
  - ç°æœ‰å®ç°åŒ…å«åŸºæœ¬â€œæ˜¨æ—¥å¤ä¹  + ä»Šæ—¥å­¦ä¹  + Mini Review + ä¸‰è½®è¯„ä¼°â€é€»è¾‘ï¼Œä½†ä¸‰æ–°ä¸€å¤/Final Review/é”™é¢˜è¡¥æ•‘å°šæœªå®Œå…¨æŒ‰ Spec å®è£…ã€‚  
- Store & Hookï¼š`alphabetStore` + `useAlphabetLearningEngine`ï¼šğŸŸ¡ éƒ¨åˆ†å®ç°  
  - å·²å¯¹æ¥ `memory-engine.getTodayMemories` / `submitMemoryResult` / `submitRoundEvaluation`ï¼›  
  - å°šæœªå¼•å…¥ç¬¬ 11 ç« å®šä¹‰çš„æœ¬åœ° `AlphabetSessionState` èšåˆè¯„åˆ†ä¸ä¼šè¯æ¢å¤ã€‚  
- Question Engineï¼ˆ6 å¤§é¢˜å‹ï¼‰ï¼šâ³ è§„åˆ’ä¸­  
  - ç›®å‰ä»ä½¿ç”¨ `lettersQuestionGenerator` çš„å¤šé¢˜å‹å‡½æ•°ï¼Œæœªåˆ‡æ¢åˆ°ç»Ÿä¸€ GameType åè®®ã€‚

### 3.2 Vocabulary Module

- è·¯ç”± & é¡µé¢ï¼š`app/learning/index.tsx` ä¸­çš„ `WordSession`ï¼šğŸŸ¡ éƒ¨åˆ†å®ç°ï¼ˆä½¿ç”¨ mock é˜Ÿåˆ—ï¼‰  
  - å½“å‰ç‰ˆæœ¬ä½¿ç”¨å›ºå®šçš„ `MOCK_OLD_WORDS` / `MOCK_NEW_WORDS` é˜Ÿåˆ—æ¨¡æ‹Ÿå¤ä¹ ä¸æ–°è¯ï¼›  
  - å°šæœªæ¥å…¥ `vocabulary` äº‘å‡½æ•°çš„ `getTodayWords`ï¼Œä¹Ÿæœªä½¿ç”¨ç»Ÿä¸€è®°å¿†å¼•æ“æäº¤åˆ†æ•°ã€‚  
- Storeï¼š`src/stores/vocabularyStore.ts`ï¼šğŸŸ¡ éƒ¨åˆ†å®ç°  
  - å·²å…·å¤‡ `initSession` / `submitAnswer` ç­‰æ¥å£ï¼Œä½†å­—æ®µå’Œåç«¯æ–°é›†åˆç»“æ„å­˜åœ¨åå·®ï¼›  
  - éœ€è¦æŒ‰ `vocabulary-module-spec.md` é‡æ„ä¸º `VocabularySessionState` é©±åŠ¨ã€‚  
- é¢˜å‹ä½“ç³»ï¼ˆ4 ä¸ªé€‰æ‹©é¢˜ + 2 ä¸ªæ‹¼å†™é¢˜ï¼‰ï¼šâ³ è§„åˆ’ä¸­  
  - ç›®å‰æ²¡æœ‰ç»Ÿä¸€çš„é¢˜å‹æšä¸¾å’Œå®¹å™¨ç»„ä»¶ï¼ŒNewWordView / ReviewWordView ä¸»è¦ç”¨äº Web ç«¯åŸå‹ã€‚

### 3.3 Courses + LearningStore

- Courses é¡µé¢ï¼š`app/(tabs)/courses.tsx`ï¼šâœ… å®Œæˆï¼ˆé¦–å‘éœ€æ±‚ï¼‰  
  - å·²èƒ½æ ¹æ® `alphabetCourses.json` å’Œ `courses.json` å±•ç¤ºè¯¾ç¨‹å¡ç‰‡ï¼Œå¹¶è·³è½¬åˆ° `/alphabet` æˆ– `/learning`ï¼›  
  - æ”¯æŒæŒ‰ category / æœç´¢è¿‡æ»¤è¯¾ç¨‹ã€‚  
- LearningPreferenceStoreï¼ˆæ¯æ—¥ä¸Šé™ï¼‰ï¼šâœ… å®Œæˆ  
  - å·²å¯é…ç½® `dailyLimits.word` / `dailyLimits.letter`ï¼Œå¹¶åœ¨ `WordSession` / `AlphabetSession` ä¸­ä½¿ç”¨ã€‚  
- LearningStoreï¼ˆå…¨å±€ä»ªè¡¨ç›˜ï¼‰ï¼šğŸŸ¡ éƒ¨åˆ†å®ç°  
  - å½“å‰ `learningStore` ä»æ˜¯ demo å‹å®ç°ï¼Œæœªå®Œå…¨æŒ‰ spec çš„ `currentCourseId` / `streakDays` ç­‰å­—æ®µé‡æ„ã€‚  

### 3.4 Backend Memory Engine

- `memory-engine` äº‘å‡½æ•°ï¼šâœ… å®Œæˆ  
  - `getTodayMemories` / `submitMemoryResult` / `submitRoundEvaluation` / `checkModuleAccess` / `getUserProgress` å·²ä¸Šçº¿å¹¶è¢« Alphabet / éƒ¨åˆ†å‰ç«¯é€»è¾‘ä½¿ç”¨ã€‚  
- `learn-vocab` äº‘å‡½æ•°ï¼šâœ… å®Œæˆï¼ˆè€ç‰ˆè¯æ±‡ APIï¼‰  
  - `getTodayWords` / `updateMastery` / `getVocabularyDetail` / `getReviewStatistics` ç­‰å·²å®ç°ï¼›  
  - å°†é€æ­¥ä¸æ–°çš„ Vocabulary Module Spec å¯¹é½ã€‚

### 3.5 AI Module

- äº‘å‡½æ•° `ai-engine`ï¼šâ³ è§„åˆ’ä¸­ï¼ˆæœªåˆ›å»ºï¼‰  
- å‰ç«¯å…¥å£ï¼ˆé¡µé¢/æŒ‰é’®ï¼‰ï¼šâ³ è§„åˆ’ä¸­  
- ä»…åœ¨ Spec ä¸­å®šä¹‰äº† Action å’Œæ•°æ®ç»“æ„ï¼Œä¸å½±å“é¦–å‘ã€‚

---

## 4. å…¨å±€ä»»åŠ¡åˆ—è¡¨ï¼ˆæŒ‰æ¨¡å—é¡ºåºï¼Œä¸æ··åˆå¼€å‘ï¼‰

> ä»»åŠ¡çŠ¶æ€ï¼š`[x] å·²å®Œæˆ` / `[~] è¿›è¡Œä¸­` / `[ ] å¾…åš`  
> å¼€å‘é¡ºåºï¼š**å…ˆå®Œæˆä¸€ä¸ªæ¨¡å—çš„æ ¸å¿ƒä»»åŠ¡å†è¿›å…¥ä¸‹ä¸€ä¸ªæ¨¡å—**ï¼Œé¿å…è·¨æ¨¡å—æ¥å›åˆ‡æ¢ã€‚

### 4.1 Phase 0ï¼šæ¶æ„ä¸æ–‡æ¡£åŸºçº¿ï¼ˆå·²å®Œæˆï¼‰

- [x] åˆ é™¤æ‰€æœ‰æ—§ç‰ˆé¡¹ç›®å¿«ç…§æ–‡æ¡£ï¼ˆ`docs/Document/project-snapshot-*`ï¼‰ã€‚  
- [x] ä¸º Alphabet / Vocabulary / Courses & LearningStore / Backend / AI å„æ¨¡å—ç”Ÿæˆå†»ç»“ Specã€‚  
- [x] æŠ½å–ç»Ÿä¸€è®°å¿†å¼•æ“ + SMâ€‘2 è¡Œä¸ºåˆ° `backend-memory-engine-spec.md`ã€‚  
- [x] æ–°å¢é¡¹ç›®æ€»çº²æ–‡æ¡£ `PROJECT_OVERVIEW_SPEC.md` ä½œä¸ºé¡¶å±‚å…¥å£ã€‚  

> ä»æœ¬é˜¶æ®µç»“æŸèµ·ï¼Œæ‰€æœ‰è®¾è®¡ä¸å®ç°ä»¥ `project-freeze` ä¸‹çš„ Spec + å®é™…ä»£ç ä¸ºå”¯ä¸€ä¾æ®ã€‚

### 4.2 Phase 1ï¼šå¯¹é½å­—æ¯æ¨¡å—ä¸ç»Ÿä¸€è®°å¿†å¼•æ“ï¼ˆå½“å‰ä¼˜å…ˆä»»åŠ¡ï¼‰

> ç›®æ ‡ï¼šå…ˆå½»åº•æŠŠ Alphabet Module ä¸ `memory-engine` å¯¹é½ï¼Œä¿è¯è¯¾ç¨‹çº§ä¸‰è½®é€»è¾‘ + SMâ€‘2 è´¨é‡æäº¤æµç¨‹å®Œå…¨é—­ç¯ï¼Œç„¶åå†å¯åŠ¨ä¸‹ä¸€ä¸ªæ¨¡å—ã€‚

- [~] A1ï¼šæ ¡å‡†å­—æ¯è¯¾ç¨‹è§£é”é€»è¾‘ï¼ˆ`alphabet-module-spec.md` ç¬¬ 10 ç« ï¼‰ã€‚  
  - åªåœ¨ Round3 å®Œæˆä¸”é€šè¿‡æ—¶ï¼Œè°ƒç”¨ `markAlphabetLessonCompleted(lessonId)` è§£é”ä¸‹ä¸€è¯¾ã€‚  
  - ä¸ `user_alphabet_progress.currentRound` / `roundHistory` å­—æ®µä¿æŒä¸€è‡´ã€‚  
- [ ] A2ï¼šå®ç° `AlphabetSessionState` ä¸ä¼šè¯æ¢å¤ï¼ˆç¬¬ 11 ç« ï¼‰ã€‚  
  - åœ¨ `alphabetStore` ä¸­å¢åŠ  Session çŠ¶æ€ç»“æ„ï¼›  
  - ä½¿ç”¨ AsyncStorage ä»¥ `alphabet-session:${userId}:${lessonId}` ä¸º key æŒä¹…åŒ–ï¼›  
  - æ”¯æŒåœ¨ Yesterday Review / ä¸‰æ–°ä¸€å¤ / Final Review / é”™é¢˜é›†ä»»æ„é˜¶æ®µä¸­é€”é€€å‡ºå¹¶æ¢å¤ã€‚  
- [ ] A3ï¼šæŒ‰â€œå­—æ¯ Ã— è½®æ¬¡ Ã— å½“å¤©â€èšåˆè´¨é‡ï¼Œå¹¶åˆ‡æ¢åˆ°æ‰¹é‡ `submitMemoryResult`ã€‚  
  - åœ¨ Hook å†…ç»´æŠ¤ `perLetterStats`ï¼›  
  - Round ç»“æŸæˆ–ç”¨æˆ·ç‚¹å‡»â€œç»“æŸä»Šå¤©å­¦ä¹ â€æ—¶ï¼Œæ„é€  `{ results: [{ entityType:'letter', entityId, quality }, ...] }` è°ƒç”¨ memory-engineï¼›  
  - ç¡®è®¤ CloudBase æ—¥å¿—ä¸­æ¯ä¸ªå­—æ¯æ¯è½®æœ€å¤šåªäº§ç”Ÿä¸€æ¬¡è´¨é‡è®°å½•ã€‚  
- [ ] A4ï¼šä¸ `backend-memory-engine-spec.md` çš„ `getTodayMemories(letter, lessonId)` çº¦å®šå¯¹é½ã€‚  
  - è¯¾ç¨‹é˜Ÿåˆ—ä¸»è¦ç”±å‰ç«¯æ„å»ºï¼›  
  - è‹¥ä»ä½¿ç”¨ `getTodayMemories` åˆå§‹åŒ–é˜Ÿåˆ—ï¼Œéœ€è¦ç¡®ä¿åªä½œä¸ºâ€œæ•´è¯¾å­—æ¯ + memoryStateâ€çš„æ•°æ®æºï¼Œè€Œä¸ä¸å‰ç«¯ Session é˜Ÿåˆ—é€»è¾‘å†²çªã€‚  

> åªæœ‰å½“ A1â€“A4 å®Œæ•´é€šè¿‡è‡ªæµ‹å¹¶ç¨³å®šåï¼Œæ‰å¼€å§‹ Phase 2ã€‚

### 4.3 Phase 2ï¼šAlphabet é¢˜å‹ä¸ä½“éªŒå®Œå–„

- [ ] B1ï¼šå®ç°ç»Ÿä¸€çš„ Alphabet Question Engineï¼ˆæ¥å£å®šä¹‰è§æœ¬æ–‡ä»¶ä¸ `alphabet-module-spec.md` ç¬¬ 6 ç« ï¼‰ã€‚  
  - å®šä¹‰ `GameType / QueueItem` åè®®ï¼›  
  - å°†ç°æœ‰ `lettersQuestionGenerator` è¿ç§»åˆ°æ–°åè®®ä¸‹ã€‚  
- [ ] B2ï¼šå®ç°ä¸‰æ–°ä¸€å¤ + Final Review çš„é¢˜å‹ç¼–æ’ã€‚  
  - ä¸‰æ–°ä¸€å¤ï¼šä½¿ç”¨è½»é‡é¢˜å‹ï¼ˆå¬éŸ³é€‰å­— / çœ‹å­—é€‰éŸ³ï¼‰ï¼›  
  - Final Reviewï¼šä½¿ç”¨é€»è¾‘/æ•´åˆé¢˜ï¼ˆæ‹¼è¯»æ•°å­¦ / å£°è°ƒè®¡ç®—ç­‰ï¼‰ã€‚  
- [ ] B3ï¼šå®Œå–„é”™é¢˜é›†ä¸ä¸‰è½®è¯„ä¼°å±•ç¤ºã€‚  
  - Round ç»“æœé¡µå±•ç¤ºæ¯è½®æ­£ç¡®ç‡ä¸â€œé”™è¯¯æœ€å¤šçš„è‹¥å¹²å­—æ¯â€ï¼›  
  - ä¸ºåç»­ AI æ¨¡å—æä¾›è¾“å…¥æ•°æ®ã€‚

### 4.4 Phase 3ï¼šVocabulary Module é‡æ„ï¼ˆåœ¨ Phase 2 å®Œæˆåå¯åŠ¨ï¼‰

- [ ] C1ï¼šæ¥å…¥ `vocabulary.getTodayWords`ï¼Œç§»é™¤ `WordSession` ä¸­çš„ mock é˜Ÿåˆ—ã€‚  
  - `WordSession` ä½¿ç”¨ `vocabularyStore.initializeSession` è·å–ä»Šæ—¥å¤ä¹  + æ–°è¯åˆ—è¡¨ã€‚  
- [ ] C2ï¼šé‡æ„ `vocabularyStore`ï¼Œå®ç° `VocabularySessionState` + `perWordStats` + ä¼šè¯æ¢å¤ã€‚  
  - ç»“æ„ä¸å­—æ¯æ¨¡å—çš„ Session æ€è·¯å¯¹é½ï¼Œä½†ä»ä½¿ç”¨ `learn-vocab.updateMastery` æäº¤ç»“æœã€‚  
- [ ] C3ï¼šå®ç° 4 ç§é€‰æ‹©é¢˜é¢˜å‹å®¹å™¨ï¼Œå¹¶æ¥å…¥ `ReviewWordView`ã€‚  
  - çœ‹æ³°è¯­é€‰ä¸­æ–‡ã€çœ‹ä¸­æ–‡é€‰æ³°è¯­ã€å¬éŸ³é€‰æ³°è¯­ã€å¬éŸ³é€‰ä¸­æ–‡ã€‚  
- [ ] C4ï¼ˆå¯é€‰ï¼‰ï¼šå®ç° 2 ç§æ‹¼å†™é¢˜ï¼Œå¹¶æ¥å…¥ç»Ÿè®¡ã€‚  
- [ ] C5ï¼šç¡®å®šè¯æ±‡æœ€ç»ˆä½¿ç”¨çš„è®°å¿†åç«¯ï¼ˆ`user_vocabulary_progress` vs `memory_status`ï¼‰ï¼Œå¹¶å®Œæˆåˆ°ç»Ÿä¸€æ¥æºçš„è¿ç§»ã€‚

### 4.5 Phase 4ï¼šCourses + LearningStore æ”¶å°¾

- [x] D0ï¼šCourses é¡µé¢æ¥å…¥å­—æ¯/å•è¯è¯¾ç¨‹ JSON å¹¶å±•ç¤ºã€‚  
- [ ] D1ï¼šLearningStore é‡æ„ä¸ºè½»é‡ä»ªè¡¨ç›˜ï¼ˆ`currentCourseId` / `currentAlphabetProgramId` / `streakDays` / `totalStudyMinutes` ç­‰ï¼‰ã€‚  
- [ ] D2ï¼šåœ¨ Courses ç‚¹å‡»è¯¾ç¨‹æ—¶æ›´æ–° LearningStoreã€‚  
  - å­—æ¯è¯¾ç¨‹ï¼š`setCurrentAlphabetProgram('alphabet')`ï¼›  
  - è¯æ±‡è¯¾ç¨‹ï¼š`setCurrentCourse(courseId)`ã€‚  
- [ ] D3ï¼šé¦–é¡µ/ä¸ªäººä¸­å¿ƒæ ¹æ® `learningStore` å’Œ `moduleAccessStore` å±•ç¤ºå­¦ä¹ æ¦‚è§ˆï¼ˆå½“å‰åœ¨å­¦è¯¾ç¨‹ã€æœ€è¿‘å­¦ä¹ æ—¶é—´ã€å­¦ä¹ æ—¶é•¿ç­‰ï¼‰ã€‚

### 4.6 Phase 5ï¼šAI æ¨¡å—å ä½ä¸ MVP

- [ ] E1ï¼šåˆ›å»º `ai-engine` äº‘å‡½æ•°éª¨æ¶ + API_ENDPOINTS å ä½ã€‚  
- [ ] E2ï¼šåœ¨å­—æ¯/è¯æ±‡æ¨¡å—ä¸­å¢åŠ â€œAI å‘éŸ³ç»ƒä¹ â€å…¥å£ï¼ˆä»…è°ƒç”¨å ä½æ¥å£ï¼Œè¿”å›å›ºå®šæ–‡æ¡ˆï¼‰ã€‚  
- [ ] E3ï¼ˆå¯é€‰ï¼‰ï¼šå®ç°å‘éŸ³åé¦ˆ MVPï¼ˆå½•éŸ³ â†’ ä¸Šä¼  â†’ `analyzePronunciation`ï¼‰ã€‚  


---

## 5. é‡Œç¨‹ç¢‘è§„åˆ’ï¼ˆä»ç°åœ¨èµ·çº¦ 2 ä¸ªæœˆï¼‰

> æ—¶é—´ä¼°ç®—ä»¥â€œå…¨èŒå¼€å‘è€…â€ä¸ºå‚è€ƒï¼Œå¯æ ¹æ®å®é™…äººåŠ›è°ƒæ•´ã€‚

### M1ï¼ˆç¬¬ 1â€“2 å‘¨ï¼‰ï¼šæ¶æ„ç¨³å®š & Alphabet P0

- å®Œæˆäº‹é¡¹ï¼š
  - [x] åˆ é™¤æ—§å¿«ç…§æ–‡æ¡£ï¼Œå†»ç»“ project-freeze ç»“æ„ï¼›  
  - [x] åç«¯ memory-engine / learn-vocab è¡Œä¸ºæ¢³ç†å®Œæ¯•ï¼›  
  - [~] ä¿®æ­£ Alphabet è§£é”é€»è¾‘ï¼Œä½¿ Round3 é€šè¿‡åæ‰è§£é”ä¸‹ä¸€è¯¾ã€‚  
- è¾“å‡ºï¼š
  - å¯ç¨³å®šä½¿ç”¨çš„å­—æ¯è¯¾ç¨‹æµç¨‹ï¼ˆå³ä½¿ Question Engine å°šæœªå®Œå…¨ä¸Šçº¿ï¼‰ã€‚

### M2ï¼ˆç¬¬ 3â€“4 å‘¨ï¼‰ï¼šAlphabet ä¼šè¯æ¢å¤ + Vocabulary æ¥å…¥åç«¯

- ç›®æ ‡ï¼š
  - [ ] å®ç° Alphabet `AlphabetSessionState` + ä¼šè¯æ¢å¤ +æ‰¹é‡æäº¤ï¼›  
  - [ ] è¯æ±‡æ¨¡å—æ¥å…¥ `getTodayWords`ï¼Œç§»é™¤ mock é˜Ÿåˆ—ï¼›  
  - [ ] åˆæ­¥å®ç° VocabularySessionStateï¼ˆä¸å«æ‹¼å†™é¢˜ï¼‰ã€‚

### M3ï¼ˆç¬¬ 5â€“6 å‘¨ï¼‰ï¼šé¢˜å‹å®Œå–„ + LearningStore é‡æ„

- ç›®æ ‡ï¼š
  - [ ] Alphabet / Vocabulary çš„é€‰æ‹©é¢˜é¢˜å‹å®¹å™¨ç¨³å®šï¼›  
  - [ ] LearningStore é‡æ„å®Œæˆï¼Œé¦–é¡µ/è¯¾ç¨‹é¡µæ­£ç¡®æ˜¾ç¤ºå½“å‰è¯¾ç¨‹å’Œå­¦ä¹ ç»Ÿè®¡ï¼›  
  - [ ] å›å½’æµ‹è¯•å¤šæ¨¡å—åˆ‡æ¢ä¸è§£é”é€»è¾‘ã€‚

### M4ï¼ˆè§†æ—¶é—´è€Œå®šï¼‰ï¼šæ‹¼å†™é¢˜ + AI å ä½

- ç›®æ ‡ï¼š
  - [ ] è‡³å°‘å®ç°ä¸€ç±»æ‹¼å†™é¢˜ï¼ˆçœ‹ä¸­æ–‡æ‹¼å†™æ³°è¯­ï¼‰å¹¶æ¥å…¥ç»Ÿè®¡ï¼›  
  - [ ] å®Œæˆ `ai-engine` äº‘å‡½æ•°éª¨æ¶å’Œå‰ç«¯å…¥å£ï¼ˆæŒ‰é’®/é¡µé¢ï¼‰ï¼Œä½¿åç»­ AI èƒ½åŠ›å¯ä»¥å¹³æ»‘æ¥å…¥ã€‚

---

## 6. å¼€å‘çº¦å®šä¸å˜æ›´æµç¨‹

1. **ä»¥ä»£ç ä¸ºå‡†ï¼Œä½†å¿…é¡»åŒæ­¥æ›´æ–° Specï¼š**
   - æ‰€æœ‰ä¸šåŠ¡/æ¥å£å˜æ›´å¿…é¡»å…ˆåœ¨å¯¹åº”æ¨¡å— Spec ä¸­ä¿®æ”¹ï¼Œå†æ›´æ–°å®ç°ï¼›  
   - è‹¥å‘ç° Spec ä¸ä»£ç ä¸ä¸€è‡´ï¼Œä»¥**å½“å‰ä»£ç  + æœ¬æ€»çº²**ä¸ºåŸºå‡†ä¿®æ­£æ–‡æ¡£ã€‚
2. **ç¦æ­¢æ–°å¢â€œç¬¬äºŒå¥—é€»è¾‘â€ï¼š**
   - è®°å¿†é˜Ÿåˆ— / è¯„åˆ† / æ¨¡å—è§£é”åªèƒ½é€šè¿‡ç»Ÿä¸€è®°å¿†å¼•æ“ + å„æ¨¡å— Spec çº¦å®šçš„ Storeï¼›  
   - ä¸å¾—åœ¨ç»„ä»¶å†…éƒ¨å·å·æ·»åŠ æ–°çš„çŠ¶æ€æˆ–åç«¯é›†åˆã€‚
3. **æ–‡æ¡£ä½ç½®çº¦å®šï¼š**
   - æ–°æ¨¡å—ã€æ–°äº‘å‡½æ•°çš„è§„æ ¼å¿…é¡»æ”¾åœ¨ `docs/project-freeze` ä¸‹ï¼Œå¹¶ä» `PROJECT_OVERVIEW_SPEC.md` é“¾æ¥å‡ºå»ã€‚  

æœ¬æ–‡ä»¶ä¸åŒç›®å½•ä¸‹å…¶ä»– Spec ä¸€èµ·ï¼Œæ„æˆæœ¬é¡¹ç›®çš„â€œæœ€ç»ˆå†»ç»“è“å›¾â€ã€‚  
åç»­å¼€å‘äººå‘˜åªéœ€éµå®ˆæœ¬æ€»çº²å’Œå„æ¨¡å— Specï¼Œå³å¯åœ¨ä¸ç ´åæ•´ä½“æ¶æ„çš„å‰æä¸‹è¿­ä»£å®ç°åŠŸèƒ½ã€‚

---

## 7. é¡¹ç›®ä»£ç å¿«ç…§ï¼ˆæŒ‰å½“å‰ä»“åº“çŠ¶æ€ï¼‰

> æœ¬èŠ‚ä»…ç”¨äº**å¿«é€Ÿäº†è§£å½“å‰ä»£ç ç»“æ„ä¸å®ç°èŒƒå›´**ï¼Œä¸é¢å¤–å¼•å…¥æ–°è®¾è®¡ã€‚  
> ä»»ä½•è¡Œä¸ºå®šä¹‰ä»ä»¥å„æ¨¡å— Spec + å®é™…ä»£ç ä¸ºå‡†ã€‚

### 7.1 å‰ç«¯ç›®å½•å¿«ç…§ï¼ˆsrc/ï¼‰

- `src/components/`
  - `learning/`
    - `NewWordView.tsx`ï¼šWeb é£æ ¼è¯æ±‡ç²¾è®²å¡ç‰‡ç»„ä»¶ï¼Œç›®å‰ä¸»è¦ç”¨äºè®¾è®¡å‚è€ƒï¼Œç§»åŠ¨ç«¯å­¦ä¹ æš‚æœªå®Œå…¨æ¥å…¥ã€‚  
    - `ReviewWordView.tsx`ï¼šæ—§ç‰ˆè¯æ±‡å¤ä¹ ç»„ä»¶ï¼Œå†…éƒ¨ä»ä½¿ç”¨â€œå¿˜è®°/æ¨¡ç³Š/è®°å¾—â€ä¸‰æŒ‰é’®ã€‚  
    - `alphabet/AlphabetLearningView.tsx`ï¼šå•å­—æ¯æ•™å­¦å¡ï¼ˆå±•ç¤ºå­—å½¢ã€åç§°ã€å‘éŸ³æŒ‰é’®ç­‰ï¼‰ã€‚  
    - `alphabet/AlphabetReviewView.tsx`ï¼šå­—æ¯å¤ä¹ ç»„ä»¶ï¼Œè°ƒç”¨ `lettersQuestionGenerator` ç”Ÿæˆé¢˜ç›®ã€‚  
  - `courses/AlphabetCourseCard.tsx`ï¼šå­—æ¯å¤§è¯¾ç¨‹å¡ç‰‡ï¼›`CourseCard.tsx`ï¼šè¯æ±‡è¯¾ç¨‹å¡ç‰‡ã€‚
  - `common/ThaiPatternBackground.tsx`ï¼šé€šç”¨èƒŒæ™¯è£…é¥°ã€‚

- `src/stores/`
  - `alphabetStore.ts`ï¼šå­—æ¯å­¦ä¹  Storeï¼Œç»´æŠ¤ `queue / currentAlphabet / completedCount / totalCount`ï¼Œå¯¹æ¥ `memory-engine`ã€‚  
  - `vocabularyStore.ts`ï¼šè¯æ±‡ Storeï¼Œå½“å‰å®ç°ä»åŸºäºæ—§ç‰ˆ `TodayVocabularyResponse` å’Œæœ¬åœ°è¿›åº¦ï¼Œéœ€è¦æŒ‰ Spec é‡æ„ã€‚  
  - `moduleAccessStore.ts`ï¼šåŒ…è£…åç«¯ `getUserProgress / checkModuleAccess`ï¼Œæä¾›æ¨¡å—è§£é”çŠ¶æ€ç»™å‰ç«¯ã€‚  
  - `learningPreferenceStore.ts`ï¼šæ¯æ—¥å­¦ä¹ ä¸Šé™è®¾ç½®ï¼ˆå­—æ¯/å•è¯ï¼‰ã€‚  
  - `learningStore.ts`ï¼šæ—§ç‰ˆå…¨å±€å­¦ä¹ ä»ªè¡¨ç›˜ï¼Œå«å†™æ­» demo æ•°æ®ã€‚  
  - `userStore.ts`ï¼šç™»å½•ç”¨æˆ·ä¿¡æ¯ã€‚

- `src/hooks/`
  - `useAlphabetLearningEngine.ts`ï¼šå­—æ¯ä¸‰è½®å­¦ä¹ ä¸šåŠ¡ Hookï¼Œé©±åŠ¨ `AlphabetLearningEngineView`ï¼›éƒ¨åˆ† Phase ä¸é”™é¢˜è¡¥æ•‘é€»è¾‘å°šæœªå®Œå…¨å®ç°ã€‚  
  - å…¶ä»–ä¸šåŠ¡ Hookï¼ˆå¦‚å…¬ç”¨ API è°ƒç”¨ç­‰ï¼‰ã€‚

- `src/entities/types/`
  - `alphabet.types.ts`ï¼šå­—æ¯å®ä½“ç±»å‹ã€å­¦ä¹ çŠ¶æ€ç±»å‹ç­‰ã€‚  
  - `vocabulary.types.ts`ï¼šæ–°ç‰ˆè¯æ±‡ç±»å‹ï¼Œä¸æ•°æ®åº“ schema å¯¹é½ï¼ˆåŒ…å«ä¾‹å¥ã€å¯¹è¯ã€ç”¨æ³•ç­‰å¯Œå­—æ®µï¼‰ã€‚  
  - å…¶ä»–åŸºç¡€ç±»å‹å®šä¹‰ã€‚

- `src/utils/`
  - `apiClient.ts`ï¼š`callCloudFunction` å°è£…ï¼Œè´Ÿè´£ HTTP è§¦å‘å™¨è°ƒç”¨ã€‚  
  - `lettersQuestionGenerator.ts`ï¼šå½“å‰å­—æ¯é¢˜ç›®ç”Ÿæˆå™¨ï¼ˆSOUND_TO_LETTER ç­‰å¤šé¢˜å‹ï¼‰ã€‚  

### 7.2 è·¯ç”±ç»“æ„å¿«ç…§ï¼ˆapp/ï¼‰

- `app/(tabs)/_layout.tsx`ï¼šåº•éƒ¨ Tab å¯¼èˆªå¸ƒå±€ã€‚  
- `app/(tabs)/courses.tsx`ï¼šè¯¾ç¨‹æ€»è§ˆé¡µï¼Œè¯»å– `alphabetCourses.json` + `courses.json`ï¼Œå±•ç¤ºè¯¾ç¨‹å¡ç‰‡ã€‚  
- `app/alphabet/index.tsx`ï¼šå­—æ¯è¯¾ç¨‹åˆ—è¡¨é¡µï¼ˆå½“å‰ç›´æ¥åˆ—å‡º Lesson1~7ï¼‰ï¼Œç‚¹å‡»è·³è½¬åˆ° `/alphabet/[lessonId]`ã€‚  
- `app/alphabet/[lessonId].tsx`ï¼šå•è¯¾å­—æ¯å­¦ä¹ å…¥å£ï¼Œè°ƒç”¨ `useAlphabetLearningEngine(lessonId)`ã€‚  
- `app/learning/index.tsx`ï¼š
  - æ ¹æ® `module` åŒºåˆ† `WordSession`ï¼ˆè¯æ±‡ï¼‰ä¸ `AlphabetSession`ï¼ˆå­—æ¯ï¼‰ï¼›  
  - å½“å‰ `WordSession` ä»ä½¿ç”¨ç¡¬ç¼–ç çš„ `MOCK_OLD_WORDS` / `MOCK_NEW_WORDS` é˜Ÿåˆ—ï¼›  
  - `AlphabetSession` ä½œä¸ºæ—§ç‰ˆå­—æ¯å­¦ä¹ å…¥å£å­˜åœ¨ï¼Œåç»­å°†ä»¥ `/alphabet/*` ç»“æ„ä¸ºä¸»ã€‚  
- `app/learning/setup.tsx`ï¼šè®¾ç½®æ¯æ—¥å­¦ä¹ è®¡åˆ’é¡µé¢ï¼ˆå­—æ¯/å•è¯æ¯æ—¥ä¸Šé™ï¼‰ã€‚
- `app/auth/*`ï¼šç™»å½•ã€æ³¨å†Œç­‰è®¤è¯é¡µã€‚

### 7.3 äº‘å‡½æ•°ä¸åç«¯å¿«ç…§ï¼ˆcloudbase/functions/ï¼‰

- `memory-engine/`
  - `index.js`ï¼šç»Ÿä¸€è®°å¿†å¼•æ“å…¥å£ï¼Œè§£æ HTTP bodyï¼ŒæŒ‰ `action` åˆ†å‘ã€‚  
  - `handlers/getTodayMemories.js`ï¼šåŸºäº `memory_status` + å®ä½“é›†åˆç”Ÿæˆä»Šæ—¥å­—æ¯/å•è¯/å¥å­é˜Ÿåˆ—ï¼›æ”¯æŒå­—æ¯è¯¾ç¨‹çš„ `lessonId` æ¨¡å¼ã€‚  
  - `handlers/submitMemoryResult.js`ï¼šæ”¯æŒå•æ¡æˆ–æ‰¹é‡å­¦ä¹ ç»“æœæäº¤ï¼Œå†…éƒ¨è°ƒç”¨ `updateMemoryAfterReview`ã€‚  
  - `handlers/submitRoundEvaluation.js`ï¼šå­—æ¯ä¸‰è½®è¯„ä¼°ç»“æœå†™å…¥ `user_alphabet_progress`ã€‚  
  - `utils/memoryEngine.js`ï¼š`getOrCreateMemory` / `updateMemoryAfterReview` / `checkModuleAccess` / `initUserProgress`ã€‚  
  - `utils/sm2.js`ï¼šä¼˜åŒ–ç‰ˆ SMâ€‘2 ç®—æ³•å®ç°ã€‚  

- `learn-vocab/`
  - `index.js`ï¼šè¯æ±‡ä¸“ç”¨äº‘å‡½æ•°å…¥å£ï¼ŒåŠ¨ä½œåŒ…æ‹¬ `getTodayWords` / `updateMastery` / `getVocabularyDetail` / `getReviewStatistics` ç­‰ã€‚  
  - `handlers/getTodayWords.js`ï¼šä» `user_vocabulary_progress` + `vocabulary` æ„å»ºä»Šæ—¥è¯æ±‡åˆ—è¡¨ã€‚  
  - `handlers/updateMastery.js`ï¼šæ ¹æ® `mastery` å­—æ®µæ›´æ–°è¯æ±‡ SRS ä¿¡æ¯ã€‚  

- å…¶ä»–ï¼š
  - `alphabet/`ï¼šä¸å­—æ¯æ•°æ®ç®¡ç†ç›¸å…³çš„è¾…åŠ©äº‘å‡½æ•°ï¼ˆå¦‚æ‰¹é‡å¯¼å…¥ç­‰ï¼Œé¦–å‘ä¸å¿…ä¾èµ–ï¼‰ã€‚  
  - `user-*`ï¼šç”¨æˆ·æ³¨å†Œã€ç™»å½•ã€é‡ç½®å¯†ç ã€æ›´æ–°ä¿¡æ¯ã€‚  
  - `storage-download` / `shared`ï¼šå…¬å…±å·¥å…·ä¸æ–‡ä»¶ä¸‹è½½ã€‚

### 7.4 æ•°æ®åº“ç»“æ„å¿«ç…§ï¼ˆå…³é”®é›†åˆï¼‰

> è¯¦ç»†å­—æ®µè§„èŒƒä»¥ `docs/database_schema.md` ä¸ºå‡†ï¼›  
> æœ¬èŠ‚åªåšç®€è¦ç´¢å¼•ï¼Œæ–¹ä¾¿ä»ä»£ç å¿«ç…§è·³è½¬åˆ°æ•°æ®åº“æ–‡æ¡£ã€‚

- `letters`ï¼ˆå­—æ¯/å…ƒéŸ³/å£°è°ƒè¡¨ï¼‰
  - ç»“æ„ï¼šè§ `database_schema.md` 1.4ï¼›  
  - ç”¨é€”ï¼šå­—æ¯æ¨¡å—è¯¾ç¨‹æ•°æ®ã€é¢˜ç›®ç”Ÿæˆã€‚

- `vocabulary`ï¼ˆè¯æ±‡è¡¨ï¼‰
  - ç»“æ„ï¼šè§ `database_schema.md` 1.2ï¼›  
  - ç”¨é€”ï¼šè¯æ±‡æ¨¡å—å­¦ä¹ /å¤ä¹ ã€å¯Œåª’ä½“å†…å®¹ï¼ˆä¾‹å¥ã€å¯¹è¯ã€åŒæºè¯ï¼‰ã€‚

- `memory_status`ï¼ˆç»Ÿä¸€è®°å¿†çŠ¶æ€è¡¨ï¼‰
  - ç»“æ„ï¼šè§ `database_schema.md` 1.7ï¼›  
  - ç”¨é€”ï¼šç»Ÿä¸€ SRS å¼•æ“æ ¸å¿ƒè®°å½•ï¼ŒAlphabet / Vocabulary å‡å¯ä½¿ç”¨ã€‚

- `user_progress`ã€`user_alphabet_progress`ã€`user_vocabulary_progress`
  - ç»“æ„ï¼šè§ `database_schema.md` 1.8â€“1.9 / 1.3ï¼›  
  - ç”¨é€”ï¼šæ¨¡å—è§£é”ã€å­—æ¯ä¸‰è½®è¯„ä¼°ç»Ÿè®¡ã€æ—§ç‰ˆè¯æ±‡è¿›åº¦ã€‚
  - å…³é”®å­—æ®µï¼š  
    - `userId`: stringï¼›  
    - `letterProgress`: numberï¼›`letterCompleted`: booleanï¼›  
    - `completedLessons`: string[]ï¼›`masteredLetterCount`: numberï¼›`totalLetterCount`: numberï¼›  
    - `currentRound`: numberï¼›`roundHistory`: Array\<{ lessonId, roundNumber, totalQuestions, correctCount, accuracy, passed, updatedAt }\>ï¼›  
    - `createdAt` / `updatedAt`: stringã€‚

- `user_vocabulary_progress`ï¼ˆæ—§ç‰ˆè¯æ±‡ SRS çŠ¶æ€ï¼‰
  - æºï¼š`learn-vocab/handlers/getTodayWords.js` / `updateMastery.js`ã€‚  
  - å…³é”®å­—æ®µï¼š  
    - `userId`: stringï¼›`vocabularyId`: string | nullï¼›  
    - `mastery`: `'UNFAMILIAR' | 'FUZZY' | 'REMEMBERED' | null`ï¼›  
    - `skipped`: booleanï¼›  
    - `reviewCount`: numberï¼›`lastReviewed`: string | nullï¼›`nextReviewDate`: string | nullï¼›  
    - `intervalDays`: numberï¼›`easinessFactor`: numberï¼›  
    - `createdAt` / `updatedAt`: stringã€‚

---

æœ¬èŠ‚è®°å½•çš„æ˜¯å½“å‰ä»“åº“çš„**ä»£ç ç»“æ„ä¸å®ç°å¿«ç…§**ï¼Œç”¨äºå¸®åŠ©åç»­å¼€å‘è€…å¿«é€Ÿå»ºç«‹æ•´ä½“è®¤çŸ¥ã€‚  
å¦‚ä»£ç ç»“æ„å‘ç”Ÿé‡å¤§è°ƒæ•´ï¼Œè¯·åœ¨å®Œæˆé‡æ„åæ›´æ–°æœ¬å¿«ç…§ä»¥åŠç›¸å…³æ¨¡å— Specã€‚***
````

## File: docs/project-freeze/README.md
````markdown
# project-freeze è¯´æ˜

æœ¬ç›®å½•ä¸‹çš„æ–‡æ¡£ç”¨äºå†»ç»“ ThaiLearningApp çš„æ ¸å¿ƒæ¶æ„ä¸æ¨¡å—è§„æ ¼ï¼Œ  
æ‰€æœ‰åç»­å¼€å‘åº”ä¼˜å…ˆå‚è€ƒè¿™é‡Œçš„ Specï¼Œè€Œä¸æ˜¯ç›´æ¥å‡­æ„Ÿè§‰æ”¹ä»£ç ã€‚

å½“å‰åŒ…å«ï¼ˆæŒ‰æ¨¡å—åˆ’åˆ†ï¼Œä¸€æ¨¡å—ä¸€æ–‡æ¡£ï¼‰ï¼š

- `PROJECT_OVERVIEW_SPEC.md`  
  - é¡¹ç›®æ€»çº²ï¼šæ¨¡å—åˆ’åˆ†ã€é˜¶æ®µä»»åŠ¡ã€é‡Œç¨‹ç¢‘ã€ä»£ç å¿«ç…§ä¸æ•°æ®åº“æ–‡æ¡£çº¦å®šã€‚

- `frontend-shell-module-spec.md`  
  - å‰ç«¯å£³å±‚ä¸å¯¼èˆªæ¨¡å—ï¼šTab å¯¼èˆªã€é¦–é¡µå±•ç¤ºã€ç”¨æˆ·ä¸­å¿ƒä¸åŸºç¡€è®¾ç½®ã€‚

- `alphabet-module-spec.md`  
  - å­—æ¯æ¨¡å—ï¼ˆAlphabet Moduleï¼‰å®Œæ•´è§„æ ¼ï¼šè·¯ç”±ã€Hookã€Storeã€memory-engineã€æ•°æ®ç»“æ„ä¸æµç¨‹ã€‚

- `courses-and-learningstore-spec.md`  
  - Courses å…¥å£é¡µ + LearningStore å…¨å±€å­¦ä¹ ç®¡ç†å±‚è§„æ ¼ã€‚

- `backend-memory-engine-spec.md`  
  - ç»Ÿä¸€è®°å¿†å¼•æ“ï¼ˆmemory-engine + learn-vocabï¼‰ä¸æ¨¡å—è§£é”é€»è¾‘ã€‚

- `vocabulary-module-spec.md`  
  - è¯æ±‡æ¨¡å—ï¼ˆVocabulary Moduleï¼‰è§„æ ¼ï¼šé¢˜å‹ã€ä¼šè¯çŠ¶æ€ã€ä¸ learn-vocab/memory-engine çš„å¯¹æ¥ã€‚

- `ai-module-spec.md`  
  - è½»é‡ AI æ¨¡å—è®¾è®¡ï¼šå‘éŸ³åé¦ˆã€å¼±é¡¹è¯æ±‡å¼ºåŒ–ã€å¾®é˜…è¯»ç”Ÿæˆã€è¯æ±‡è§£æã€‚

- `database_schema.md`  
  - æ•°æ®åº“ç»“æ„è§„èŒƒï¼ˆV2.1.0ï¼‰ï¼šä»¥ local_cleaner è¾“å‡ºä¸å½“å‰äº‘å‡½æ•°ä¸ºå‡†ã€‚

æ‰€æœ‰æ–°æ¨¡å—ã€æ–°äº‘å‡½æ•°ã€æ–° Store åœ¨è½åœ°ä¹‹å‰éƒ½åº”å…ˆåœ¨æœ¬ç›®å½•ä¸‹è¡¥å……å¯¹åº” Specï¼Œå¹¶åœ¨ `PROJECT_OVERVIEW_SPEC.md` ä¸­ç™»è®°ã€‚***
````

## File: src/components/common/FloatingBubbles.tsx
````typescript
// src/components/common/FloatingBubbles.tsx
import React from 'react';
import { View, Text, Pressable, StyleSheet, Dimensions } from 'react-native';
import { Sparkles, PlayCircle } from 'lucide-react-native';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { ReviewItem } from '../../entities/types/entities';

interface FloatingBubblesProps {
  reviews: ReviewItem[];
  onOpenReview: () => void;
}

const { width } = Dimensions.get('window');

export const FloatingBubbles: React.FC<FloatingBubblesProps> = ({
  reviews,
  onOpenReview,
}) => {
  if (reviews.length === 0) return null;

  return (
    <View style={styles.container}>
      {/* Floating Title */}
      <View style={styles.titleContainer}>
        <View style={styles.titleBadge}>
          <Sparkles size={12} color={Colors.thaiGold} />
          <Text style={styles.titleText}>å¾…å¤ä¹ å†…å®¹</Text>
        </View>
      </View>

      {/* Card Stack */}
      <View>
        <Pressable
          onPress={onOpenReview}
          style={styles.cardStackContainer}
        >
          {reviews.slice(0, 3).reverse().map((review, index) => (
            <Card key={review.id} review={review} index={index} />
          ))}

          {/* Notification Badge */}
          <View style={styles.badge}>
            <Text style={styles.badgeText}>{reviews.length}</Text>
          </View>
        </Pressable>
      </View>
    </View>
  );
};

interface CardProps {
  review: ReviewItem;
  index: number;
}

const Card: React.FC<CardProps> = ({ review, index }) => {
  const offsetY = index * 10;
  const scale = 1 - index * 0.04;
  const cardOpacity = 1 - index * 0.1;
  const rotate = index % 2 === 0 ? '-1.5deg' : '1.5deg';

  return (
    <View
      style={[
        styles.card,
        {
          transform: [
            { translateY: offsetY },
            { scale },
            { rotate },
          ],
          zIndex: 30 - index,
          opacity: cardOpacity,
        },
      ]}
    >
      {/* Content */}
      <View style={styles.cardContent}>
        {/* Top Row */}
        <View style={styles.cardTopRow}>
          <View style={styles.typeTag}>
            <Text style={styles.typeTagText}>
              {review.type === 'New' ? 'æ–°è¯' : 'å¤ä¹ '}
            </Text>
          </View>
          <View style={styles.statusDot} />
        </View>

        {/* Middle */}
        <View style={styles.cardMiddleRow}>
          <View>
            <Text style={styles.charText}>{review.char}</Text>
            <Text style={styles.phoneticText}>{review.phonetic}</Text>
          </View>
          <View style={styles.playButton}>
            <PlayCircle size={20} color={Colors.white} />
          </View>
        </View>

        {/* Bottom Progress */}
        <View style={styles.progressBarContainer}>
          <View style={styles.progressBar} />
        </View>
      </View>

      {/* Background Gradient */}
      <View style={styles.backgroundGradient} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: '100%',
    height: 340,
    marginBottom: 32,
    alignItems: 'center',
    justifyContent: 'flex-end',
  },
  titleContainer: {
    position: 'absolute',
    top: 30,
    left: 0,
    right: 0,
    alignItems: 'center',
  },
  titleBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    backgroundColor: 'rgba(26, 26, 26, 0.9)',
    paddingHorizontal: 16,
    paddingVertical: 6,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: 'rgba(212, 175, 55, 0.3)',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  titleText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 11,
    fontWeight: '700',
    letterSpacing: 1.5,
    color: Colors.white,
  },
  cardStackContainer: {
    width: Math.min(320, width - 48),
    height: 280,
    alignItems: 'center',
    justifyContent: 'center',
  },
  card: {
    position: 'absolute',
    width: 256,
    height: 176,
    backgroundColor: Colors.ink,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: 'rgba(212, 175, 55, 0.2)',
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 15 },
    shadowOpacity: 0.2,
    shadowRadius: 40,
    elevation: 10,
  },
  cardContent: {
    flex: 1,
    padding: 20,
    justifyContent: 'space-between',
    zIndex: 10,
  },
  cardTopRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
  },
  typeTag: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 4,
    borderWidth: 1,
    borderColor: 'rgba(212, 175, 55, 0.3)',
  },
  typeTagText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 10,
    fontWeight: '700',
    letterSpacing: 1.5,
    color: Colors.thaiGold,
    textTransform: 'uppercase',
  },
  statusDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    backgroundColor: Colors.thaiGold,
  },
  cardMiddleRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  charText: {
    fontFamily: Typography.sarabunRegular,
    fontSize: 36,
    lineHeight: 40,
    color: Colors.white,
    marginBottom: 4,
  },
  phoneticText: {
    fontFamily: Typography.playfairRegular,
    fontSize: 14,
    fontStyle: 'italic',
    color: 'rgba(229, 226, 219, 0.8)',
  },
  playButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    alignItems: 'center',
    justifyContent: 'center',
  },
  progressBarContainer: {
    width: '100%',
    height: 4,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 2,
    overflow: 'hidden',
    marginTop: 8,
  },
  progressBar: {
    width: '66%',
    height: '100%',
    backgroundColor: Colors.thaiGold,
  },
  backgroundGradient: {
    position: 'absolute',
    top: -40,
    right: -40,
    width: 128,
    height: 128,
    borderRadius: 64,
    backgroundColor: 'rgba(212, 175, 55, 0.1)',
  },
  badge: {
    position: 'absolute',
    top: -2,
    right: 1,
    width: 24,
    height: 24,
    borderRadius: 12,
    backgroundColor: '#DC2626',
    borderWidth: 2,
    borderColor: Colors.paper,
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 40,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 4,
    elevation: 5,
  },
  badgeText: {
    fontSize: 12,
    fontWeight: '700',
    color: Colors.white,
  },
});
````

## File: src/config/constants.ts
````typescript
// src/config/constants.ts

/**
 * åº”ç”¨å¸¸é‡é…ç½®
 *
 * ç›®æ ‡ï¼š
 * 1. ç»Ÿä¸€ç®¡ç†å…¨å±€å¸¸é‡ï¼ˆé›†åˆå / è¶…æ—¶ / æ–‡æœ¬ç­‰ï¼‰ï¼Œé¿å…åœ¨ä»£ç ä¸­æ•£è½ç¡¬ç¼–ç å­—ç¬¦ä¸²ï¼›
 * 2. COLLECTIONS ä¸­åªæ”¾â€œçœŸå®å­˜åœ¨æˆ–è§„åˆ’ä¸­çš„é›†åˆåâ€ï¼Œå¹¶é€šè¿‡æ³¨é‡ŠåŒºåˆ†ã€Œå·²ä½¿ç”¨ã€ä¸ã€Œé¢„ç•™/åºŸå¼ƒã€ã€‚
 */

// ==================== æ•°æ®åº“é›†åˆåç§° ====================
export const COLLECTIONS = {
  // ===== æ ¸å¿ƒç”¨æˆ·ä¸è¿›åº¦é›†åˆï¼ˆCloudBase å·²å®é™…ä½¿ç”¨ï¼‰ =====
  USERS: 'users',
  USER_PROGRESS: 'user_progress',
  USER_ALPHABET_PROGRESS: 'user_alphabet_progress',
  USER_VOCABULARY_PROGRESS: 'user_vocabulary_progress',

  // ===== å­¦ä¹ å®ä½“é›†åˆï¼ˆCloudBase å·²å®é™…ä½¿ç”¨ï¼‰ =====
  LETTERS: 'letters',
  VOCABULARY: 'vocabulary',
  VOCABULARIES: 'vocabularies', // ç‰¹å®š handlerï¼ˆgetSkippedWordsï¼‰ä½¿ç”¨çš„è¯æ±‡é›†åˆ
  SENTENCES: 'sentences',
  MEMORY_STATUS: 'memory_status',

  // ===== å­—æ¯è¯¾ç¨‹ä¸æ‹¼è¯»è§„åˆ™ï¼ˆå·²è¿ç§»çš„è¯¾ç¨‹é…ç½®ï¼‰ =====
  ALPHABET_LESSONS: 'alphabet_lessons',
  PHONICS_RULES: 'phonics_rules',

  // ===== å­—æ¯æµ‹è¯•ç›¸å…³ =====
  LETTER_TEST_BANK: 'letter_test_bank',

  // ===== é¢„ç•™ / è§„åˆ’ä¸­çš„é›†åˆï¼ˆå½“å‰ä»£ç ä¸­æœªå®é™…ä½¿ç”¨ï¼‰ =====
  COURSES: 'courses',
  LESSONS: 'lessons',
  EXERCISES: 'exercises',
  ARTICLES: 'articles',
  PRONUNCIATION_RECORDS: 'pronunciationRecords',
  PROGRESS: 'progress',
  REVIEW_SCHEDULES: 'reviewSchedules',
  LEARNING_RECORDS: 'learningRecords',

  // ===== å·²åºŸå¼ƒå‘½åï¼ˆä»…å…¼å®¹æ—§ç‰ˆæœ¬ï¼Œä¸æ¨èå†ä½¿ç”¨ï¼‰ =====
  // æ—§ç‰ˆå­—æ¯é›†åˆï¼Œç°å·²ç»Ÿä¸€ä½¿ç”¨ LETTERS: 'letters'
  ALPHABETS: 'alphabets',
} as const;

// ==================== API è¶…æ—¶é…ç½® ====================
export const API_TIMEOUT = {
  DEFAULT: 10000,   // 10 ç§’ - ä¸€èˆ¬è¯·æ±‚
  UPLOAD: 30000,    // 30 ç§’ - æ–‡ä»¶ä¸Šä¼ 
  LONG: 60000,      // 60 ç§’ - é•¿æ—¶é—´æ“ä½œï¼ˆå¦‚å‘éŸ³è¯„ä¼°ï¼‰
};

// ==================== é”™è¯¯æ¶ˆæ¯ ====================
export const ERROR_MESSAGES = {
  NETWORK_ERROR: 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œã€‚',
  TIMEOUT_ERROR: 'è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•ã€‚',
  AUTH_ERROR: 'èº«ä»½éªŒè¯å¤±è´¥ï¼Œè¯·é‡æ–°ç™»å½•ã€‚',
  TOKEN_EXPIRED: 'ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•ã€‚',
  SERVER_ERROR: 'æœåŠ¡å™¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚',
  INVALID_INPUT: 'è¾“å…¥ä¿¡æ¯ä¸å®Œæ•´æˆ–æ ¼å¼é”™è¯¯ã€‚',
  UNKNOWN_ERROR: 'æœªçŸ¥é”™è¯¯ï¼Œè¯·è”ç³»å®¢æœã€‚',
};

// ==================== ç”¨æˆ·è§’è‰² ====================
export const USER_ROLES = {
  LEARNER: 'LEARNER',
  ADMIN: 'ADMIN',
} as const;

// ==================== å­¦ä¹ ç­‰çº§ ====================
export const LEVELS = {
  BEGINNER_A: 'BEGINNER_A',
  BEGINNER_B: 'BEGINNER_B',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED',
} as const;

// ==================== æŒæ¡ç¨‹åº¦ ====================
export const MASTER_LEVELS = {
  NOT_LEARNED: 'NOT_LEARNED',
  LEARNING: 'LEARNING',
  REVIEWING: 'REVIEWING',
  MASTERED: 'MASTERED',
} as const;

// ==================== å†…å®¹ç±»å‹ ====================
export const CONTENT_TYPES = {
  ALPHABET: 'alphabet',
  VOCABULARY: 'vocabulary',
  SENTENCE: 'sentence',
  ARTICLE: 'article',
} as const;
````

## File: src/entities/enums/LearningPhase.enum.ts
````typescript
// src/entities/enums/LearningPhase.enum.ts

/**
 * å­¦ä¹ é˜¶æ®µæšä¸¾
 * 
 * ç”¨äºå­—æ¯å­¦ä¹ çš„7é˜¶æ®µæµç¨‹ + æµ‹è¯•ç›¸å…³é˜¶æ®µ
 * å¯¹åº”V3.0è¯¾ç¨‹æ–¹æ¡ˆçš„å®Œæ•´æµç¨‹
 * 
 * @version 2.0.0
 * @see project-snapshot-v2.0.0-V10.md ç¬¬7èŠ‚ å­¦ä¹ æµç¨‹
 */
export enum LearningPhase {
  // ===== åˆå§‹çŠ¶æ€ =====
  IDLE = 'IDLE',
  LOADING = 'LOADING',
  
  // ===== 7é˜¶æ®µå­¦ä¹ æµç¨‹ =====
  YESTERDAY_REVIEW = 'yesterday-review',
  YESTERDAY_REMEDY = 'yesterday-remedy',
  TODAY_LEARNING = 'today-learning',
  TODAY_MINI_REVIEW = 'today-mini-review',
  TODAY_FINAL_REVIEW = 'today-final-review',
  TODAY_REMEDY = 'today-remedy',
  ROUND_EVALUATION = 'round-evaluation',
  
  // ===== æµ‹è¯•ç›¸å…³(ç”¨äºè¯¾ç¨‹æµ‹è¯•) =====
  TEST_PROMPT = 'test-prompt',
  TESTING = 'testing',
  TEST_RESULT = 'test-result',
  
  // ===== å®ŒæˆçŠ¶æ€ =====
  FINISHED = 'finished',
  COMPLETED = 'COMPLETED',
}

/**
 * Phase ç±»å‹(ç”¨äºç±»å‹å®ˆå«)
 * å¯¹åº”AlphabetLearningEngineViewä¸­ä½¿ç”¨çš„å­—ç¬¦ä¸²å­—é¢é‡
 */
export type Phase = 
  | 'yesterday-review'
  | 'yesterday-remedy'
  | 'today-learning'
  | 'today-mini-review'
  | 'today-final-review'
  | 'today-remedy'
  | 'round-evaluation'
  | 'finished';

/**
 * Phase æ˜¾ç¤ºæ–‡æ¡ˆæ˜ å°„
 */
export const PHASE_LABELS: Record<Phase, string> = {
  'yesterday-review': 'æ˜¨æ—¥å¤ä¹ ',
  'yesterday-remedy': 'æ˜¨æ—¥è¡¥æ•‘',
  'today-learning': 'ä»Šæ—¥å­¦ä¹ ',
  'today-mini-review': 'å°å¤ä¹ ',
  'today-final-review': 'æœ«å°¾å¤ä¹ ',
  'today-remedy': 'ä»Šæ—¥è¡¥æ•‘',
  'round-evaluation': 'è½®æ¬¡è¯„ä¼°',
  'finished': 'å®Œæˆ',
};

/**
 * Phase å›¾æ ‡æ˜ å°„(ç”¨äºUIæ˜¾ç¤º)
 */
export const PHASE_ICONS: Record<Phase, string> = {
  'yesterday-review': 'ğŸ”„',
  'yesterday-remedy': 'ğŸ”§',
  'today-learning': 'ğŸ“š',
  'today-mini-review': 'âœ¨',
  'today-final-review': 'ğŸ¯',
  'today-remedy': 'ğŸ’ª',
  'round-evaluation': 'ğŸ“Š',
  'finished': 'ğŸ‰',
};

/**
 * Phase è¿›åº¦æƒé‡(ç”¨äºè¿›åº¦æ¡è®¡ç®—)
 */
export const PHASE_PROGRESS_WEIGHTS: Record<Phase, number> = {
  'yesterday-review': 0.1,
  'yesterday-remedy': 0.15,
  'today-learning': 0.4,
  'today-mini-review': 0.5,
  'today-final-review': 0.7,
  'today-remedy': 0.85,
  'round-evaluation': 0.95,
  'finished': 1.0,
};

/**
 * åˆ¤æ–­æ˜¯å¦ä¸ºå¤ä¹ é˜¶æ®µ
 */
export function isReviewPhase(phase: Phase): boolean {
  return [
    'yesterday-review',
    'yesterday-remedy',
    'today-mini-review',
    'today-final-review',
    'today-remedy',
  ].includes(phase);
}

/**
 * åˆ¤æ–­æ˜¯å¦ä¸ºå­¦ä¹ é˜¶æ®µ
 */
export function isLearningPhase(phase: Phase): boolean {
  return phase === 'today-learning';
}

/**
 * åˆ¤æ–­æ˜¯å¦ä¸ºè¡¥æ•‘é˜¶æ®µ
 */
export function isRemedyPhase(phase: Phase): boolean {
  return ['yesterday-remedy', 'today-remedy'].includes(phase);
}

/**
 * è·å–ä¸‹ä¸€ä¸ªé˜¶æ®µ
 */
export function getNextPhase(currentPhase: Phase): Phase | null {
  const phaseSequence: Phase[] = [
    'yesterday-review',
    'yesterday-remedy',
    'today-learning',
    'today-mini-review',
    'today-final-review',
    'today-remedy',
    'round-evaluation',
    'finished',
  ];
  
  const currentIndex = phaseSequence.indexOf(currentPhase);
  if (currentIndex === -1 || currentIndex === phaseSequence.length - 1) {
    return null;
  }
  
  return phaseSequence[currentIndex + 1];
}
````

## File: src/i18n/index.ts
````typescript
import i18n from 'i18next';  // æ ¸å¿ƒåº“
import { initReactI18next } from 'react-i18next';  // React ç»‘å®š
import * as Localization from 'expo-localization';  // è·å–è®¾å¤‡è¯­è¨€
import AsyncStorage from '@react-native-async-storage/async-storage';  // æœ¬åœ°å­˜å‚¨

import zh from './locales/zh';  // ä¸­æ–‡ç¿»è¯‘
import en from './locales/en';  // è‹±æ–‡ç¿»è¯‘

const LANGUAGE_KEY = 'user-language';  // å­˜å‚¨è¯­è¨€çš„ key

// ã€æ ¸å¿ƒå‡½æ•°1ã€‘ä»æœ¬åœ°å­˜å‚¨è¯»å–ç”¨æˆ·ä¸Šæ¬¡é€‰æ‹©çš„è¯­è¨€
const getStoredLanguage = async (): Promise<string | null> => {
  try {
    return await AsyncStorage.getItem(LANGUAGE_KEY);  // è¯»å–æœ¬åœ°å­˜å‚¨
  } catch (error) {
    console.error('Error reading language:', error);
    return null;
  }
};

// ã€æ ¸å¿ƒå‡½æ•°2ã€‘è·å–è®¾å¤‡è¯­è¨€(å¦‚æœç”¨æˆ·æ²¡é€‰è¿‡)
const getDeviceLanguage = (): string => {
  const locales = Localization.getLocales();  // è·å–åŒºåŸŸè®¾ç½®æ•°ç»„
  if (!locales || locales.length === 0) {
    return 'zh'; // é»˜è®¤ä¸­æ–‡
  }
  const languageCode = locales[0].languageCode;  // ä¾‹å¦‚: "zh" æˆ– "en"
  return languageCode === 'zh' ? 'zh' : 'en';  // é»˜è®¤ä¸­æ–‡
};

// ã€æ ¸å¿ƒå‡½æ•°3ã€‘åˆå§‹åŒ– i18n
const initI18n = async () => {
  const storedLanguage = await getStoredLanguage();  // å…ˆè¯»æœ¬åœ°å­˜å‚¨
  const initialLanguage = storedLanguage || getDeviceLanguage();  // æœ¬åœ°æ²¡æœ‰å°±ç”¨è®¾å¤‡è¯­è¨€

  i18n
    .use(initReactI18next)  // ç»‘å®š React
    .init({  // é…ç½®
      resources: {  // ç¿»è¯‘èµ„æº
        zh: { translation: zh },  // ä¸­æ–‡
        en: { translation: en },  // è‹±æ–‡
      },
      lng: initialLanguage,  // åˆå§‹è¯­è¨€
      fallbackLng: 'zh',  // å¦‚æœç¿»è¯‘ç¼ºå¤±,å›é€€åˆ°ä¸­æ–‡
      interpolation: {
        escapeValue: false,  // React å·²ç»é˜² XSS äº†
      },
    });
};

initI18n();  // ç«‹å³æ‰§è¡Œåˆå§‹åŒ–

export default i18n;
````

## File: src/utils/alphabet/audioHelper.ts
````typescript
// src/utils/alphabet/audioHelper.ts

import type { Letter } from '@/src/entities/types/letter.types';
import type { AudioRequirementType } from '@/src/entities/enums/QuestionType.enum';

/**
 * éŸ³é¢‘Base URL
 */
const LETTER_AUDIO_BASE =
  'https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/';

/**
 * å°†å¯èƒ½æ˜¯ã€Œå®Œæ•´ URLã€æˆ–ã€Œç›¸å¯¹è·¯å¾„ / keyã€çš„éŸ³é¢‘å­—æ®µè§„èŒƒåŒ–ä¸ºå®Œæ•´ URLã€‚
 */
function normalizeAudioSource(path?: string | null): string {
  if (!path) return '';
  if (path.startsWith('http://') || path.startsWith('https://') || path.startsWith('file://')) {
    return path;
  }
  return resolveAudioPath(path);
}

/**
 * éŸ³é¢‘ä¼˜å…ˆçº§ç­–ç•¥
 * 
 * @param letter - å­—æ¯å¯¹è±¡
 * @param type - éŸ³é¢‘éœ€æ±‚ç±»å‹
 * @returns éŸ³é¢‘URLï¼ˆå§‹ç»ˆä¸ºå®Œæ•´ HTTP URL æˆ–ç©ºå­—ç¬¦ä¸²ï¼‰
 */
export function getLetterAudioUrl(
  letter: Letter,
  type: AudioRequirementType = 'letter'
): string {
  // P0-Optimization: ä¼˜å…ˆä½¿ç”¨æœ¬åœ°ç¼“å­˜è·¯å¾„
  const getLocalOrRemote = (local?: string, remote?: string) => {
    return normalizeAudioSource(local) || normalizeAudioSource(remote);
  };

  switch (type) {
    case 'letter':
      // é»˜è®¤ä½¿ç”¨å®Œæ•´è¯»éŸ³:
      // fullSoundLocal > fullSoundUrl > ...
      return (
        getLocalOrRemote(letter.fullSoundLocalPath, letter.fullSoundUrl) ||
        getLocalOrRemote(letter.letterPronunciationLocalPath, letter.letterPronunciationUrl) ||
        resolveAudioPath(letter.audioPath)
      );

    case 'syllable':
      // éŸ³èŠ‚å‘éŸ³
      return (
        getLocalOrRemote(letter.syllableSoundLocalPath, letter.syllableSoundUrl) ||
        getLocalOrRemote(letter.fullSoundLocalPath, letter.fullSoundUrl) ||
        resolveAudioPath(letter.audioPath)
      );

    case 'minimal-pair':
      // æœ€å°å¯¹ç«‹ç»„(ä½¿ç”¨letterç±»å‹,ç”±è°ƒç”¨æ–¹å¤„ç†å¯¹æ¯”)
      return (
        getLocalOrRemote(letter.fullSoundLocalPath, letter.fullSoundUrl) ||
        getLocalOrRemote(letter.letterPronunciationLocalPath, letter.letterPronunciationUrl) ||
        resolveAudioPath(letter.audioPath)
      );

    case 'tone-set':
      // å£°è°ƒå˜ä½“(éœ€TTSç”Ÿæˆ,è¿”å›åŸºç¡€éŸ³é¢‘)
      return (
        getLocalOrRemote(letter.syllableSoundLocalPath, letter.syllableSoundUrl) ||
        getLocalOrRemote(letter.fullSoundLocalPath, letter.fullSoundUrl) ||
        resolveAudioPath(letter.audioPath)
      );

    default:
      return (
        getLocalOrRemote(letter.fullSoundLocalPath, letter.fullSoundUrl) ||
        resolveAudioPath(letter.audioPath)
      );
  }
}

/**
 * è§£æéŸ³é¢‘è·¯å¾„
 * 
 * @param path - éŸ³é¢‘è·¯å¾„
 * @returns å®Œæ•´URL
 */
function resolveAudioPath(path?: string | null): string {
  if (!path) return '';

  // å¦‚æœå·²ç»æ˜¯å®Œæ•´URL,ç›´æ¥è¿”å›
  if (path.startsWith('http://') || path.startsWith('https://')) {
    return path;
  }

  // å¯¹ç±»ä¼¼ "word-kai" / "sound-k" è¿™ç±» key è‡ªåŠ¨è¡¥å…¨ .mp3 åç¼€
  let finalPath = path;
  if (!/\.mp3($|\?)/.test(finalPath)) {
    finalPath = `${finalPath}.mp3`;
  }

  // æ‹¼æ¥Base URL
  return `${LETTER_AUDIO_BASE}${finalPath}`;
}

/**
 * è·å–æœ€å°å¯¹ç«‹ç»„çš„éŸ³é¢‘URLåˆ—è¡¨
 * 
 * @param letters - å­—æ¯åˆ—è¡¨(åŒ…å«ç›®æ ‡å­—æ¯+å¯¹æ¯”å­—æ¯)
 * @returns éŸ³é¢‘URLæ•°ç»„
 */
export function getMinimalPairAudioUrls(letters: Letter[]): string[] {
  return letters.map(letter => getLetterAudioUrl(letter, 'minimal-pair'));
}

/**
 * ç”Ÿæˆå£°è°ƒå˜ä½“éŸ³é¢‘URLs
 * 
 * âš ï¸ å½“å‰å®ç°:è¿”å›åŸºç¡€éŸ³é¢‘
 * ğŸ”® æœªæ¥å®ç°:è°ƒç”¨TTS APIç”Ÿæˆ5ä¸ªå£°è°ƒå˜ä½“
 * 
 * @param letter - å­—æ¯å¯¹è±¡
 * @param vowel - å…ƒéŸ³(å¯é€‰)
 * @returns 5ä¸ªå£°è°ƒéŸ³é¢‘URLæ•°ç»„
 */
export function getToneVariantAudioUrls(
  letter: Letter,
  vowel?: string
): string[] {
  const baseAudioUrl = getLetterAudioUrl(letter, 'tone-set');

  // å½“å‰ç­–ç•¥:è¿”å›ç›¸åŒçš„åŸºç¡€éŸ³é¢‘(ä¸´æ—¶æ–¹æ¡ˆ)
  // å‰ç«¯å¯ä»¥åœ¨UIä¸Šæ ‡æ³¨"éœ€TTSç”Ÿæˆ"
  return [
    baseAudioUrl, // ä¸­å¹³è°ƒ
    baseAudioUrl, // ä½é™è°ƒ
    baseAudioUrl, // é™è°ƒ
    baseAudioUrl, // é«˜è°ƒ
    baseAudioUrl, // å‡è°ƒ
  ];

  // ğŸ”® æœªæ¥å®ç°(éœ€åç«¯TTSæœåŠ¡):
  // return await ttsService.generateToneVariants(letter, vowel);
}

/**
 * è·å–æŸä¸ªå­—æ¯ç›¸å…³çš„æ‰€æœ‰éŸ³é¢‘ URLï¼ˆå»é‡åï¼‰ã€‚
 *
 * è®¾è®¡ç›®çš„ï¼š
 * - ç”¨äºè¯¾ç¨‹åˆå§‹åŒ–æ—¶ï¼Œä¸€æ¬¡æ€§é¢„ç¼“å­˜è¯¥å­—æ¯æ‰€æœ‰å¯èƒ½ä¼šç”¨åˆ°çš„éŸ³é¢‘ï¼›
 * - åŒ…å«ï¼š
 *   - letterPronunciationUrlï¼ˆå­—æ¯æ ‡å‡†è¯»éŸ³ï¼‰
 *   - fullSoundUrlï¼ˆå®Œæ•´è¯»éŸ³ï¼‰
 *   - syllableSoundUrlï¼ˆéŸ³èŠ‚å‘éŸ³ï¼‰
 *   - endSyllableSoundUrlï¼ˆå°¾éŸ³èŠ‚å‘éŸ³ï¼‰
 *   - audioPathï¼ˆæ—§ç‰ˆè·¯å¾„ï¼‰
 */
export function getAllLetterAudioUrls(letter: Letter): string[] {
  const rawSources: Array<string | null | undefined> = [
    // ä»¥å®é™…å­˜åœ¨çš„éŸ³é¢‘ä¸ºä¸»ï¼šfullSoundUrl ä¸å„ç±» *SoundUrl
    letter.fullSoundUrl,
    letter.syllableSoundUrl,
    letter.endSyllableSoundUrl,
    letter.audioPath,
  ];

  const urls = rawSources
    .map((src) => normalizeAudioSource(src ?? undefined))
    .filter((u): u is string => !!u);

  // å»é‡
  return Array.from(new Set(urls));
}

/**
 * æ£€æŸ¥éŸ³é¢‘æ˜¯å¦å¯ç”¨
 * 
 * @param url - éŸ³é¢‘URL
 * @returns æ˜¯å¦å¯ç”¨
 */
export async function checkAudioAvailable(url: string): Promise<boolean> {
  if (!url) return false;

  try {
    const response = await fetch(url, { method: 'HEAD' });
    return response.ok;
  } catch (error) {
    console.warn('[AudioHelper] éŸ³é¢‘ä¸å¯ç”¨:', url, error);
    return false;
  }
}
````

## File: babel.config.js
````javascript
module.exports = function (api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      [
        'module-resolver',
        {
          root: ['./'],
          alias: {
            '@': './',
          },
        },
      ],
      'react-native-reanimated/plugin', // å¿…é¡»åœ¨æœ€å
    ],
  };
};
````

## File: index.ts
````typescript
import 'react-native-gesture-handler';
import 'react-native-reanimated';
import 'expo-router/entry';
````

## File: app/review-modal.tsx
````typescript
import { View, Text, StyleSheet } from 'react-native';
import { Stack } from 'expo-router';

export default function ReviewModal() {
  return (
    <View style={styles.container}>
      <Stack.Screen
        options={{
          title: 'Review',
        }}
      />
      <Text style={styles.text}>Review Modal Screen</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff',
  },
  text: {
    fontSize: 18,
    fontWeight: 'bold',
  },
});
````

## File: cloudbase/functions/alphabet/handlers/submitLetterTest.js
````javascript
// âœ… æäº¤å­—æ¯æµ‹è¯•ç»“æœï¼ˆRoute Aï¼šå‰ç«¯åˆ¤åˆ†ï¼‰
const { createResponse } = require('../utils/response');
const passLetterTest = require('./passLetterTest');

/**
 * æäº¤å­—æ¯æµ‹è¯•ç»“æœ
 * @param {Object} db - æ•°æ®åº“å®ä¾‹
 * @param {Object} data - è¯·æ±‚æ•°æ® { userId, passed }
 */
async function submitLetterTest(db, data) {
    // 1. æ ¡éªŒå‚æ•°
    const { userId, passed } = data || {};

    if (!userId) {
        return createResponse(false, null, 'userId å‚æ•°ç¼ºå¤±', 'INVALID_PARAMS');
    }

    if (typeof passed !== 'boolean') {
        return createResponse(false, null, 'passed å‚æ•°å¿…é¡»ä¸ºå¸ƒå°”å€¼', 'INVALID_PARAMS');
    }

    // 2. å¦‚æœæœªé€šè¿‡ï¼Œç›´æ¥è¿”å›ï¼ˆä¸å†™æ•°æ®åº“ï¼‰
    if (!passed) {
        return createResponse(true, {
            passed: false,
            message: 'æœªé€šè¿‡æµ‹è¯•ï¼Œä¸è®°å½•è¿›åº¦'
        }, 'æµ‹è¯•æœªé€šè¿‡');
    }

    // 3. å¦‚æœé€šè¿‡ï¼Œè°ƒç”¨ passLetterTest å†™å…¥è§£é”è®°å½•
    try {
        await passLetterTest(db, { userId });

        return createResponse(true, {
            passed: true,
            message: 'æ­å–œé€šè¿‡å­—æ¯æµ‹è¯•ï¼æ‰€æœ‰æ¨¡å—å·²è§£é”ã€‚'
        }, 'æµ‹è¯•é€šè¿‡');
    } catch (error) {
        console.error('[submitLetterTest] passLetterTest å¤±è´¥ï¼š', error);
        return createResponse(false, null, 'å†™å…¥è¿›åº¦å¤±è´¥', 'DB_ERROR');
    }
}

module.exports = submitLetterTest;
````

## File: cloudbase/functions/alphabet/index.js
````javascript
const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.SYMBOL_CURRENT_ENV });
const db = cloud.database();


// âœ… å¤„ç†å‡½æ•°
const { createResponse } = require('./utils/response');
const getLetterTest = require('./handlers/getLetterTest');
const submitLetterTest = require('./handlers/submitLetterTest');
const passLetterTest = require('./handlers/passLetterTest');
const getAllLetters = require('./handlers/getAllLetters');

exports.main = async (event, context) => {

    // ===== è§£æ HTTP è¯·æ±‚ =====
    let requestData = event;

    // HTTP è§¦å‘å™¨ï¼šbody å¯èƒ½æ˜¯å­—ç¬¦ä¸²æˆ–å¯¹è±¡
    if (event.body) {
        if (typeof event.body === 'string') {
            try {
                requestData = JSON.parse(event.body);
            } catch (e) {
                console.error('[alphabet] JSON è§£æå¤±è´¥:', e.message);
                return createResponse(false, null, 'Invalid JSON in request body', 'INVALID_JSON');
            }
        } else if (typeof event.body === 'object') {
            requestData = event.body;
        }
    }

    const { action, data } = requestData;

    try {
        switch (action) {

            // âœ… 0ï¸âƒ£ è·å–æ‰€æœ‰å­—æ¯ï¼ˆç”¨äºå‰ç«¯ç”Ÿæˆæµ‹è¯•é¢˜ï¼‰
            case 'getAllLetters':
                return await getAllLetters(db);

            // âœ… 1ï¸âƒ£ è·å–å­—æ¯æµ‹è¯•é¢˜ï¼ˆå›ºå®šé¢˜ï¼‰
            case 'getLetterTest':
                return await getLetterTest(db);

            // âœ… 2ï¸âƒ£ æäº¤å­—æ¯æµ‹è¯•å¹¶åˆ¤å®š
            case 'submitLetterTest':
                return await submitLetterTest(db, data);

            // âœ… 3ï¸âƒ£ ç›´æ¥é€šè¿‡å­—æ¯æµ‹è¯•ï¼ˆè°ƒè¯•/ç‰¹æ®Šé€»è¾‘ç”¨ï¼‰
            case 'passLetterTest':
                return await passLetterTest(db, data);

            default:
                return createResponse(false, null, 'æœªçŸ¥ action', 'INVALID_ACTION');
        }
    } catch (err) {
        console.error('learn-alphabet error:', err);
        return createResponse(false, null, err.message || 'æœåŠ¡å™¨é”™è¯¯', 'SERVER_ERROR');
    }
};
````

## File: cloudbase/functions/learn-vocab/handlers/getVocabularyDetail.js
````javascript
/**
 * è·å–è¯æ±‡è¯¦æƒ…å¤„ç†å™¨
 * @action getVocabularyDetail
 */
'use strict';

const { createResponse } = require('../utils/response');

/**
 * è·å–è¯æ±‡è¯¦ç»†ä¿¡æ¯
 * @param {Object} db - æ•°æ®åº“å®ä¾‹
 * @param {Object} params
 * @param {string} params.vocabularyId - è¯æ±‡ID (å¿…å¡«)
 * @param {string} params.userId - ç”¨æˆ·ID (å¯é€‰ï¼Œç”¨äºè·å–å­¦ä¹ çŠ¶æ€)
 */
async function getVocabularyDetail(db, params) {
  const { vocabularyId, userId } = params;

  if (!vocabularyId) {
    return createResponse(false, null, 'ç¼ºå°‘è¯æ±‡ID', 'INVALID_PARAMS');
  }

  try {
    // 1. æ£€æŸ¥æƒé™ (å¦‚æœæœ‰ userId)
    if (userId) {
      const { checkModuleAccess } = require('../utils/memoryEngine');
      const accessResult = await checkModuleAccess(db, userId, 'word');

      if (!accessResult.allowed) {
        return createResponse(false, null, accessResult.message, accessResult.errorCode);
      }
    }

    // 2. è·å–è¯æ±‡è¯¦æƒ…
    // æ³¨æ„ï¼šæ ¹æ®ä½ çš„æ•°æ®åº“ç»“æ„ï¼Œå¦‚æœä¸»é”®æ˜¯ _idï¼Œè¯·ä½¿ç”¨ doc(id)ï¼›å¦‚æœæ˜¯ vocabularyId å­—æ®µï¼Œä½¿ç”¨ where
    // å‡è®¾ vocabularyId å­—æ®µå­˜å‚¨çš„æ˜¯ä¸šåŠ¡ID
    const vocabResult = await db.collection('vocabulary')
      .where({ vocabularyId: vocabularyId }) // æˆ–è€… .doc(vocabularyId) å¦‚æœå®ƒæ˜¯ _id
      .get();

    if (!vocabResult.data || vocabResult.data.length === 0) {
      // å°è¯•ç”¨ _id å†æŸ¥ä¸€æ¬¡ï¼Œå…¼å®¹ä¸åŒä¼ å‚
      const vocabByIdResult = await db.collection('vocabulary').doc(vocabularyId).get().catch(() => ({ data: [] }));
      if (!vocabByIdResult.data) {
        return createResponse(false, null, 'æœªæ‰¾åˆ°è¯¥è¯æ±‡', 'VOCABULARY_NOT_FOUND');
      }
      vocabResult.data = [vocabByIdResult.data];
    }

    const vocabulary = vocabResult.data[0];

    // 3. æ„å»ºè¯¦ç»†å“åº”
    const detail = {
      // åŸºæœ¬ä¿¡æ¯
      vocabularyId: vocabulary.vocabularyId || vocabulary._id,
      thaiWord: vocabulary.thaiWord,
      meaning: vocabulary.meaning,
      pronunciation: vocabulary.pronunciation,
      audioPath: vocabulary.audioPath,
      partOfSpeech: vocabulary.partOfSpeech,
      level: vocabulary.level,
      lessonNumber: vocabulary.lessonNumber,
      startingLetter: vocabulary.startingLetter,

      // æ‰©å±•å­¦ä¹ å†…å®¹
      cognates: vocabulary.cognates || [],
      dialogue: vocabulary.dialogue || null,
      exampleSentences: vocabulary.exampleSentences || {},
      usage: vocabulary.usage || {},
      mistakes: vocabulary.mistakes || {},

      // å…ƒæ•°æ®
      source: vocabulary.source,
      createdAt: vocabulary.createdAt,
    };

    // 4. å¦‚æœæä¾›äº† userIdï¼Œé™„åŠ å­¦ä¹ çŠ¶æ€
    if (userId) {
      const progressResult = await db.collection('user_vocabulary_progress')
        .where({ userId, vocabularyId: detail.vocabularyId }) // ç¡®ä¿IDåŒ¹é…
        .limit(1)
        .get();

      if (progressResult.data.length > 0) {
        const p = progressResult.data[0];
        detail.learningStatus = {
          mastery: p.mastery,
          skipped: p.skipped,
          reviewCount: p.reviewCount,
          lastReviewed: p.lastReviewed,
          nextReviewDate: p.nextReviewDate,
          intervalDays: p.intervalDays,
          easinessFactor: p.easinessFactor,
          isNew: false,
        };
      } else {
        detail.learningStatus = {
          mastery: null,
          skipped: false,
          reviewCount: 0,
          lastReviewed: null,
          nextReviewDate: null,
          intervalDays: 0,
          isNew: true,
        };
      }
    }

    return createResponse(true, detail, 'è·å–è¯æ±‡è¯¦æƒ…æˆåŠŸ');

  } catch (error) {
    console.error('getVocabularyDetail error:', error);
    return createResponse(false, null, error.message, 'SERVER_ERROR');
  }
}

module.exports = getVocabularyDetail;
````

## File: cloudbase/functions/learn-vocab/handlers/getVocabularyList.js
````javascript
/**
 * è·å–è¯æ±‡åˆ—è¡¨å¤„ç†å™¨
 * @action getVocabularyList
 */
'use strict';

const { createResponse } = require('../utils/response');

/**
 * æ ¼å¼åŒ–è¯æ±‡ä¸ºåˆ—è¡¨é¡¹
 */
function formatVocabularyForList(vocab) {
  return {
    vocabularyId: vocab.vocabularyId || vocab._id,
    thaiWord: vocab.thaiWord,
    meaning: vocab.meaning,
    pronunciation: vocab.pronunciation,
    audioPath: vocab.audioPath,
    partOfSpeech: vocab.partOfSpeech,
    level: vocab.level,
    lessonNumber: vocab.lessonNumber,
  };
}

/**
 * è·å–è¯æ±‡åˆ—è¡¨
 * @param {Object} db - æ•°æ®åº“å®ä¾‹
 * @param {Object} params - å‚æ•°
 */
async function getVocabularyList(db, params) {
  const { filters = {}, limit = 20, offset = 0, userId } = params;

  try {
    // 1. æ£€æŸ¥ç”¨æˆ·æƒé™ (å¦‚æœä¼ äº† userId)
    if (userId) {
      const { checkModuleAccess } = require('../utils/memoryEngine');
      const accessResult = await checkModuleAccess(db, userId, 'word');

      if (!accessResult.allowed) {
        return createResponse(false, null, accessResult.message, accessResult.errorCode);
      }
    }

    // 2. éªŒè¯åˆ†é¡µå‚æ•°
    const validLimit = Math.max(1, Math.min(limit, 100));
    const validOffset = Math.max(0, offset);

    // 3. æ„å»ºæŸ¥è¯¢æ¡ä»¶
    const query = db.collection('vocabulary');
    const whereConditions = {};

    if (filters.level) whereConditions.level = filters.level;
    if (filters.lessonNumber) whereConditions.lessonNumber = filters.lessonNumber;
    if (filters.startingLetter) whereConditions.startingLetter = filters.startingLetter;
    if (filters.partOfSpeech) whereConditions.partOfSpeech = filters.partOfSpeech;

    let dbQuery = query;
    if (Object.keys(whereConditions).length > 0) {
      dbQuery = dbQuery.where(whereConditions);
    }

    // 4. è·å–æ€»æ•°
    const countResult = await dbQuery.count();
    const total = countResult.total;

    // 5. è·å–åˆ†é¡µæ•°æ®
    // æ³¨æ„ï¼šorderBy å­—æ®µéœ€è¦ç¡®ä¿æœ‰ç´¢å¼•ï¼Œå¦åˆ™å¯èƒ½æŠ¥é”™æˆ–æ…¢
    const dataResult = await dbQuery
      .orderBy('lessonNumber', 'asc')
      .skip(validOffset)
      .limit(validLimit)
      .get();

    const vocabularies = dataResult.data.map(formatVocabularyForList);

    return createResponse(true, {
      vocabularies,
      pagination: {
        total,
        limit: validLimit,
        offset: validOffset,
        hasMore: validOffset + validLimit < total,
      },
    }, 'è·å–è¯æ±‡åˆ—è¡¨æˆåŠŸ');

  } catch (error) {
    console.error('getVocabularyList error:', error);
    return createResponse(false, null, error.message, 'SERVER_ERROR');
  }
}

module.exports = getVocabularyList;
````

## File: cloudbase/functions/learn-vocab/handlers/toggleSkipWord.js
````javascript
/**
 * åˆ’æ‰/æ¢å¤å•è¯å¤„ç†å™¨
 * 
 * å°†å•è¯ä»å¤ä¹ é˜Ÿåˆ—ä¸­ç§»é™¤æˆ–é‡æ–°åŠ å…¥
 * 
 * @action toggleSkipWord
 */

'use strict';

const { createResponse } = require('../utils/response');

/**
 * åˆ’æ‰æˆ–æ¢å¤å•è¯
 */
async function toggleSkipWord(db, params) {
  const { userId, vocabularyId, skipped } = params;

  // å‚æ•°éªŒè¯
  if (!userId || !vocabularyId || typeof skipped !== 'boolean') {
    return createResponse(false, null, 'ç¼ºå°‘å¿…å¡«å‚æ•°æˆ–å‚æ•°ç±»å‹é”™è¯¯', 'INVALID_PARAMS');
  }

  try {
    // éªŒè¯ç”¨æˆ·
    const userResult = await db.collection('users')
      .where({ userId })
      .get();

    if (!userResult.data || userResult.data.length === 0) {
      return createResponse(false, null, 'ç”¨æˆ·ä¸å­˜åœ¨', 'USER_NOT_FOUND');
    }

    // éªŒè¯è¯æ±‡
    const vocabResult = await db.collection('vocabulary')
      .where({ _id: vocabularyId })
      .get();

    if (!vocabResult.data || vocabResult.data.length === 0) {
      return createResponse(false, null, 'è¯æ±‡ä¸å­˜åœ¨', 'VOCABULARY_NOT_FOUND');
    }

    const now = new Date();

    // æŸ¥æ‰¾ç°æœ‰è¿›åº¦è®°å½•
    const existingProgress = await db.collection('user_vocabulary_progress')
      .where({ userId, vocabularyId })
      .limit(1)
      .get();

    if (existingProgress.data && existingProgress.data.length > 0) {
      // æ›´æ–°ç°æœ‰è®°å½•
      await db.collection('user_vocabulary_progress')
        .doc(existingProgress.data[0]._id)
        .update({
          skipped,
          updatedAt: now
        });
    } else {
      // åˆ›å»ºæ–°è®°å½•
      await db.collection('user_vocabulary_progress').add({
        userId,
        vocabularyId,
        mastery: null,
        skipped,
        lastReviewed: null,
        reviewCount: 0,
        intervalDays: 1,
        easinessFactor: 2.5,
        nextReviewDate: null,
        createdAt: now,
        updatedAt: now,
      });
    }

    const message = skipped ? 'å·²ä»å¤ä¹ é˜Ÿåˆ—ç§»é™¤' : 'å·²åŠ å…¥å¤ä¹ é˜Ÿåˆ—';

    return createResponse(true, {
      vocabularyId,
      skipped,
      message,
    }, skipped ? 'å•è¯å·²åˆ’æ‰' : 'å•è¯å·²æ¢å¤');

  } catch (error) {
    console.error('toggleSkipWord error:', error);
    return createResponse(false, null, error.message, 'SERVER_ERROR');
  }
}

module.exports = toggleSkipWord;
````

## File: cloudbase/functions/learn-vocab/handlers/updateMastery.js
````javascript
/**
 * æ›´æ–°æŒæ¡çŠ¶æ€å¤„ç†å™¨
 * 
 * è®°å½•ç”¨æˆ·å¯¹å•è¯çš„æŒæ¡ç¨‹åº¦ï¼Œä½¿ç”¨ SM-2 ç®—æ³•è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´
 * 
 * @action updateMastery
 */

'use strict';


const { progressCollection } = require('../utils/database');
const {
  createResponse,
  successResponse,
  errorResponse,
  userNotFoundResponse,
  vocabularyNotFoundResponse
} = require('../utils/response');
const {
  COLLECTIONS,
  MasteryLevel,
  SM2_PARAMS
} = require('../utils/constants');

const { validateUser, validateVocabulary, isValidMastery } = require('../utils/validators');
const { calculateSM2Optimized, generateReviewTimeline } = require('../utils/sm2');

/**
 * æ›´æ–°å•è¯æŒæ¡çŠ¶æ€
 * 
 * ä¸šåŠ¡é€»è¾‘:
 * 1. éªŒè¯ç”¨æˆ·å’Œè¯æ±‡å­˜åœ¨
 * 2. éªŒè¯æŒæ¡ç¨‹åº¦æœ‰æ•ˆæ€§
 * 3. ä½¿ç”¨ SM-2 ç®—æ³•è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸ
 * 4. åˆ›å»ºæˆ–æ›´æ–°è¿›åº¦è®°å½•
 * 
 * @param {Object} params
 * @param {string} params.userId - ç”¨æˆ·ID
 * @param {string} params.vocabularyId - è¯æ±‡ID
 * @param {string} params.mastery - æŒæ¡ç¨‹åº¦: é™Œç”Ÿ/æ¨¡ç³Š/è®°å¾—
 */
async function updateMastery({ userId, vocabularyId, mastery }) {
  // éªŒè¯æŒæ¡ç¨‹åº¦
  if (!isValidMastery(mastery)) {
    return errorResponse(ErrorCodes.INVALID_MASTERY);
  }

  // éªŒè¯ç”¨æˆ·
  const user = await validateUser(userId);
  if (!user) {
    return userNotFoundResponse();
  }

  // éªŒè¯è¯æ±‡
  const vocabulary = await validateVocabulary(vocabularyId);
  if (!vocabulary) {
    return vocabularyNotFoundResponse();
  }

  // æŸ¥æ‰¾ç°æœ‰è¿›åº¦è®°å½•
  const { data: existingProgress } = await progressCollection
    .where({ userId, vocabularyId })
    .limit(1)
    .get();

  const now = new Date().toISOString();
  let progressData;
  let isNewRecord = false;
  let newReviewCount;

  if (existingProgress.length > 0) {
    // ========== æ›´æ–°ç°æœ‰è®°å½• ==========
    const current = existingProgress[0];

    const sm2Result = calculateSM2Optimized(
      mastery,
      current.intervalDays || 1,
      current.easinessFactor || SM2_PARAMS.INITIAL_EASINESS_FACTOR,
      current.reviewCount || 0
    );

    // è®¡ç®—æ–°çš„å¤ä¹ æ¬¡æ•°
    newReviewCount = sm2Result.shouldResetCount ? 1 : (current.reviewCount || 0) + 1;

    progressData = {
      mastery,
      lastReviewed: now,
      reviewCount: newReviewCount,
      intervalDays: sm2Result.nextInterval,
      easinessFactor: sm2Result.nextEasinessFactor,
      nextReviewDate: sm2Result.nextReviewDate,
      updatedAt: now,
    };

    await progressCollection.doc(current._id).update({
      data: progressData
    });

  } else {
    // ========== åˆ›å»ºæ–°è®°å½• ==========
    isNewRecord = true;
    newReviewCount = 1;

    const sm2Result = calculateSM2Optimized(
      mastery,
      1,
      SM2_PARAMS.INITIAL_EASINESS_FACTOR,
      0
    );

    progressData = {
      userId,
      vocabularyId,
      mastery,
      skipped: false,
      lastReviewed: now,
      reviewCount: 1,
      intervalDays: sm2Result.nextInterval,
      easinessFactor: sm2Result.nextEasinessFactor,
      nextReviewDate: sm2Result.nextReviewDate,
      createdAt: now,
      updatedAt: now,
    };

    await progressCollection.add(progressData);
  }

  return successResponse({
    vocabularyId,
    mastery,
    reviewCount: newReviewCount,
    nextReviewDate: progressData.nextReviewDate,
    intervalDays: progressData.intervalDays,
    easinessFactor: progressData.easinessFactor,
    isNewRecord,
    reviewTimeline: generateReviewTimeline(newReviewCount),
  }, 'æ›´æ–°æŒæ¡çŠ¶æ€æˆåŠŸ');
}

module.exports = updateMastery;
````

## File: cloudbase/functions/learn-vocab/utils/memoryEngine.js
````javascript
/**
 * ç»Ÿä¸€è®°å¿†å¼•æ“æ ¸å¿ƒæ¨¡å—
 * æ”¯æŒå­—æ¯/å•è¯/å¥å­çš„ç»Ÿä¸€è®°å¿†ç®¡ç†
 * 
 * ä¿®å¤ï¼šwx-server-sdk ä¸æ”¯æŒ getOne()ï¼Œæ”¹ç”¨ get() + data[0]
 */

const { calculateSM2Optimized } = require('./sm2');

/**
 * åˆ›å»ºæ–°çš„è®°å¿†è®°å½•
 */
async function createMemoryRecord(db, userId, entityType, entityId, isLocked = false) {

    // éªŒè¯å‚æ•°
    if (!userId || !entityType || !entityId) {
        console.error('[createMemoryRecord] å‚æ•°ç¼ºå¤±:', { userId, entityType, entityId });
        throw new Error('userId, entityType, entityId éƒ½æ˜¯å¿…éœ€å‚æ•°');
    }

    const now = new Date();
    const nextReviewAt = isLocked ? null : new Date(now.getTime() + 24 * 60 * 60 * 1000).toISOString();

    const memoryRecord = {
        userId,
        entityType,
        entityId,
        masteryLevel: 0.0,
        reviewStage: 0,
        easinessFactor: 2.5,
        intervalDays: 1,
        lastReviewAt: null,
        nextReviewAt,
        correctCount: 0,
        wrongCount: 0,
        streakCorrect: 0,
        isLocked,
        createdAt: now.toISOString(),
        updatedAt: now.toISOString()
    };

    try {
        // å°è¯•æ’å…¥
        const result = await db.collection('memory_status').add(memoryRecord);

        console.log('[createMemoryRecord] åˆ›å»ºæˆåŠŸ:', { userId, entityType, entityId });

        return {
            _id: result._id,
            ...memoryRecord
        };
    } catch (error) {
        // å¦‚æœæ˜¯é‡å¤é”®é”™è¯¯ï¼ŒæŸ¥è¯¢å¹¶è¿”å›ç°æœ‰è®°å½•
        if (error.errCode === -502001 || error.message.includes('duplicate key')) {
            console.log('[createMemoryRecord] è®°å½•å·²å­˜åœ¨ï¼ŒæŸ¥è¯¢è¿”å›:', { userId, entityType, entityId });

            const existingResult = await db.collection('memory_status')
                .where({ userId, entityType, entityId })
                .get();

            if (existingResult.data && existingResult.data.length > 0) {
                return existingResult.data[0];
            }
        }

        // å…¶ä»–é”™è¯¯ç»§ç»­æŠ›å‡º
        console.error('[createMemoryRecord] åˆ›å»ºå¤±è´¥:', error);
        throw error;
    }
}

/**
 * è·å–æˆ–åˆ›å»ºè®°å¿†è®°å½•
 * ä¿®å¤ï¼šä½¿ç”¨ get() ä»£æ›¿ getOne()
 */
async function getOrCreateMemory(db, userId, entityType, entityId, isLocked = false) {
    // 1. å°è¯•æŸ¥è¯¢ç°æœ‰è®°å½•
    const existingMemory = await db.collection('memory_status')
        .where({
            userId,
            entityType,
            entityId
        })
        .get();

    // 2. å¦‚æœå­˜åœ¨,ç›´æ¥è¿”å›ç¬¬ä¸€æ¡
    if (existingMemory.data && existingMemory.data.length > 0) {
        return existingMemory.data[0];
    }

    // 3. ä¸å­˜åœ¨åˆ™åˆ›å»ºæ–°è®°å½•
    return await createMemoryRecord(db, userId, entityType, entityId, isLocked);
}

/**
 * æ›´æ–°è®°å¿†çŠ¶æ€(ç­”é¢˜åè°ƒç”¨)
 */
async function updateMemoryAfterReview(db, userId, entityType, entityId, quality) {
    console.log('ã€æµ‹è¯•ã€‘updateMemoryAfterReview è¢«è°ƒç”¨äº†ï¼', { userId, quality });
    console.log('=== [updateMemoryAfterReview] å¼€å§‹ ===');
    console.log('å‚æ•°:', JSON.stringify({ userId, entityType, entityId, quality }));

    try {
        // 1. è·å–å½“å‰è®°å¿†è®°å½•
        console.log('æ­¥éª¤1: è·å–è®°å¿†è®°å½•');
        const memory = await getOrCreateMemory(db, userId, entityType, entityId);
        console.log('è®°å¿†è®°å½•:', JSON.stringify(memory));

        // 2. æ˜ å°„è´¨é‡åˆ°SM-2è¯„åˆ†
        console.log('æ­¥éª¤2: æ˜ å°„è´¨é‡');
        const qualityMap = {
            'é™Œç”Ÿ': 1,
            'æ¨¡ç³Š': 3,
            'è®°å¾—': 5
        };
        const sm2Quality = qualityMap[quality] || 3;
        console.log('SM-2è´¨é‡:', sm2Quality);

        // 3. è®¡ç®—æ–°çš„SM-2å‚æ•°
        console.log('æ­¥éª¤3: è°ƒç”¨ calculateSM2Optimized');
        console.log('è°ƒç”¨å‚æ•°:', {
            quality,
            intervalDays: memory.intervalDays,
            easinessFactor: memory.easinessFactor,
            reviewStage: memory.reviewStage
        });

        const sm2Result = calculateSM2Optimized(
            quality,
            memory.intervalDays,
            memory.easinessFactor,
            memory.reviewStage
        );

        console.log('SM-2ç»“æœ:', JSON.stringify(sm2Result));

        // 4. æ›´æ–°æŒæ¡åº¦
        console.log('æ­¥éª¤4: è®¡ç®—æ–°æŒæ¡åº¦');
        let newMasteryLevel = memory.masteryLevel;
        if (quality === 'è®°å¾—') {
            newMasteryLevel = Math.min(1.0, memory.masteryLevel + 0.15);
        } else if (quality === 'æ¨¡ç³Š') {
            newMasteryLevel = Math.max(0.0, memory.masteryLevel + 0.05);
        } else {
            newMasteryLevel = Math.max(0.0, memory.masteryLevel - 0.2);
        }
        console.log('æ–°æŒæ¡åº¦:', newMasteryLevel);

        // 5. æ›´æ–°è¿èƒœå’Œè®¡æ•°
        console.log('æ­¥éª¤5: è®¡ç®—è¿èƒœ');
        const newStreakCorrect = quality === 'è®°å¾—' ? memory.streakCorrect + 1 : 0;
        const newCorrectCount = quality === 'è®°å¾—' ? memory.correctCount + 1 : memory.correctCount;
        const newWrongCount = quality === 'é™Œç”Ÿ' ? memory.wrongCount + 1 : memory.wrongCount;

        // 6. è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´
        console.log('æ­¥éª¤6: è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´');
        const now = new Date();
        const nextReviewAt = new Date(now.getTime() + sm2Result.interval * 24 * 60 * 60 * 1000);
        console.log('ä¸‹æ¬¡å¤ä¹ æ—¶é—´:', nextReviewAt);

        // 7. å‡†å¤‡æ›´æ–°æ•°æ®
        console.log('æ­¥éª¤7: å‡†å¤‡æ›´æ–°æ•°æ®åº“');
        const updateData = {
            masteryLevel: newMasteryLevel,
            reviewStage: sm2Result.repetitions,
            easinessFactor: sm2Result.easinessFactor,
            intervalDays: sm2Result.interval,
            lastReviewAt: now.toISOString(),
            nextReviewAt: nextReviewAt.toISOString(),
            correctCount: newCorrectCount,
            wrongCount: newWrongCount,
            streakCorrect: newStreakCorrect,
            updatedAt: now.toISOString()
        };

        console.log('æ›´æ–°æ•°æ®å¯¹è±¡:', JSON.stringify(updateData));

        // æ£€æŸ¥æ˜¯å¦æœ‰ undefined
        for (const [key, value] of Object.entries(updateData)) {
            if (value === undefined) {
                console.error(`âŒ å‘ç° undefined å€¼: ${key}`);
            }
        }

        // 8. æ‰§è¡Œæ›´æ–°
        console.log('æ­¥éª¤8: æ‰§è¡Œæ•°æ®åº“æ›´æ–°');
        await db.collection('memory_status')
            .where({
                userId,
                entityType,
                entityId
            })
            .update({
                data: updateData   // âœ… CloudBase å¿…é¡»è¿™æ ·å†™
            });

        console.log('âœ… æ›´æ–°æˆåŠŸ');

        return {
            entityId,
            entityType,
            masteryLevel: newMasteryLevel,
            reviewStage: sm2Result.repetitions,
            easinessFactor: sm2Result.easinessFactor,
            intervalDays: sm2Result.interval,
            nextReviewAt: nextReviewAt.toISOString(),
            correctCount: newCorrectCount,
            wrongCount: newWrongCount,
            streakCorrect: newStreakCorrect
        };

    } catch (error) {
        console.error('âŒ [updateMemoryAfterReview] é”™è¯¯:', error);
        console.error('é”™è¯¯å †æ ˆ:', error.stack);
        throw error;
    }
}

/**
 * è·å–ä»Šæ—¥å¾…å¤ä¹ çš„å®ä½“
 */
async function getTodayReviewEntities(db, userId, entityType, limit = 20) {
    const now = new Date();

    const result = await db.collection('memory_status')
        .where({
            userId,
            entityType,
            isLocked: false,
            nextReviewAt: db.command.lte(now)
        })
        .orderBy('nextReviewAt', 'asc')
        .limit(limit)
        .get();

    return result.data || [];
}

/**
 * æ£€æŸ¥å¹¶è§£é”ä¸‹ä¸€é˜¶æ®µå­¦ä¹ 
 */
// async function checkAndUnlockNextStage(db, userId) {

//   if (process.env.FORCE_UNLOCK === 'true') {
//     return {
//       allowed: true,
//       progress: 100,
//       stage: "all",
//       message: 'ã€è°ƒè¯•æ¨¡å¼ã€‘å¼ºåˆ¶è§£é”'
//     };
//   }

//   // ä¿®å¤ï¼šä½¿ç”¨ get() + data[0]
//   const progressResult = await db.collection('user_progress')
//     .where({ userId })
//     .get();

//   if (!progressResult.data || progressResult.data.length === 0) {
//     await initUserProgress(db, userId);
//     return {
//       unlocked: false,
//       stage: 'letter',
//       message: 'åˆå§‹åŒ–å­¦ä¹ è¿›åº¦æˆåŠŸ'
//     };
//   }

//   const progress = progressResult.data[0];

//   if (!progress.letterCompleted) {
//     const letterMemories = await db.collection('memory_status')
//       .where({
//         userId,
//         entityType: 'letter'
//       })
//       .get();

//     const totalLetters = 44;
//     const masteredLetters = letterMemories.data.filter(m => m.masteryLevel >= 0.7).length;
//     const letterProgress = masteredLetters / totalLetters;

//     if (letterProgress >= 0.95) {
//       await db.collection('user_progress').where({ userId }).update({
//         data: {
//           letterCompleted: true,
//           letterProgress: 1.0,
//           wordUnlocked: true,
//           currentStage: 'word',
//           updatedAt: new Date().toISOString()
//         }
//       });

//       await db.collection('memory_status')
//         .where({
//           userId,
//           entityType: 'word',
//           isLocked: true
//         })
//         .update({
//           data: {
//             isLocked: false,
//             nextReviewAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
//           }
//         });

//       return {
//         unlocked: true,
//         stage: 'word',
//         message: 'æ­å–œ!å­—æ¯å­¦ä¹ å®Œæˆ,å•è¯å­¦ä¹ å·²è§£é”!'
//       };
//     }

//     return {
//       unlocked: false,
//       stage: 'letter',
//       progress: letterProgress,
//       remaining: Math.ceil((0.95 - letterProgress) * totalLetters),
//       message: `è¿˜éœ€æŒæ¡ ${Math.ceil((0.95 - letterProgress) * totalLetters)} ä¸ªå­—æ¯`
//     };
//   }

//   return {
//     unlocked: false,
//     stage: progress.currentStage,
//     message: 'ç»§ç»­åŠ æ²¹!'
//   };
// }

/**
 * åˆå§‹åŒ–ç”¨æˆ·çš„å­¦ä¹ è¿›åº¦è®°å½•
 */
async function initUserProgress(db, userId) {
    const now = new Date();

    const progressRecord = {
        userId,
        letterCompleted: false,
        letterProgress: 0.0,
        wordUnlocked: false,
        wordProgress: 0.0,
        sentenceUnlocked: false,
        sentenceProgress: 0.0,
        articleUnlocked: false,
        currentStage: 'letter',
        totalStudyDays: 0,
        streakDays: 0,
        lastStudyDate: null,
        createdAt: now,
        updatedAt: now
    };

    await db.collection('user_progress').add(progressRecord);
    return progressRecord;
}

/**
 * æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™
 * ä¿®å¤ï¼šä½¿ç”¨ get() + data[0]
 */
async function checkModuleAccess(db, userId, moduleType) {

    // âœ…âœ…âœ…ã€è°ƒè¯•æ€»å¼€å…³ï¼šè·³è¿‡æ‰€æœ‰å­¦ä¹ é”ã€‘
    if (process.env.FORCE_UNLOCK === 'true') {
        console.warn('âš ï¸ FORCE_UNLOCK å·²å¼€å¯, å¼ºåˆ¶æ”¾è¡Œæ¨¡å—:', moduleType);
        return {
            allowed: true,
            progress: {
                letterCompleted: true,
                letterProgress: 1,
                wordUnlocked: true,
                sentenceUnlocked: true,
                articleUnlocked: true,
                currentStage: moduleType
            }
        };
    }

    const progressResult = await db.collection('user_progress')
        .where({ userId })
        .get();

    if (!progressResult.data || progressResult.data.length === 0) {
        return {
            allowed: false,
            errorCode: 'USER_PROGRESS_NOT_FOUND',
            message: 'ç”¨æˆ·å­¦ä¹ è¿›åº¦ä¸å­˜åœ¨,è¯·è”ç³»ç®¡ç†å‘˜'
        };
    }

    const progress = progressResult.data[0];

    // âœ… å­—æ¯æ¨¡å—æ°¸è¿œå…è®¸è®¿é—®
    if (moduleType === 'letter') {
        return {
            allowed: true,
            progress
        };
    }

    // âœ… å…¶ä»–æ‰€æœ‰æ¨¡å—åªä¾èµ– letterCompleted
    if (!progress.letterCompleted) {
        return {
            allowed: false,
            errorCode: 'MODULE_LOCKED',
            message: `è¯·å…ˆå®Œæˆå­—æ¯å­¦ä¹ ï¼ˆå½“å‰è¿›åº¦ï¼š${Math.round(progress.letterProgress * 100)}%ï¼‰`,
            progress
        };
    }

    // âœ… å­—æ¯å®Œæˆ â†’ å…¨éƒ¨æ¨¡å—æ”¾è¡Œ
    return {
        allowed: true,
        progress
    };
}

module.exports = {
    createMemoryRecord,
    getOrCreateMemory,
    updateMemoryAfterReview,
    getTodayReviewEntities,
    // checkAndUnlockNextStage,
    initUserProgress,
    checkModuleAccess
};
````

## File: cloudbase/functions/learn-vocab/utils/sm2.js
````javascript
/**
 * SM-2 é—´éš”é‡å¤ç®—æ³•æ¨¡å—ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
 * 
 * åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–:
 * - æ—©æœŸå¤ä¹ é—´éš”æ›´å¯†é›†: 1â†’2â†’4â†’7â†’14 å¤©
 * - "æ¨¡ç³Š"çŠ¶æ€ç¼©çŸ­é—´éš”è€Œéç»´æŒä¸å˜
 * - "é™Œç”Ÿ"çŠ¶æ€é‡ç½®å¤ä¹ è¿›åº¦
 * 
 * ç®—æ³•è®ºæ–‡: https://www.supermemo.com/en/archives1990-2015/english/ol/sm2
 */

'use strict';

const { MasteryLevel, SM2_PARAMS, EARLY_INTERVALS } = require('./constants');

/**
 * å°†æŒæ¡ç¨‹åº¦æ˜ å°„åˆ° SM-2 Quality å€¼
 * 
 * SM-2 Quality å®šä¹‰:
 * 0 - å®Œå…¨ä¸è®°å¾—
 * 1 - é”™è¯¯å›ç­”ï¼Œä½†çœ‹åˆ°æ­£ç¡®ç­”æ¡ˆåæƒ³èµ·
 * 2 - é”™è¯¯å›ç­”ï¼Œæ­£ç¡®ç­”æ¡ˆçœ‹èµ·æ¥å¾ˆç†Ÿæ‚‰
 * 3 - æ­£ç¡®å›ç­”ï¼Œä½†å›°éš¾è¾ƒå¤§
 * 4 - æ­£ç¡®å›ç­”ï¼Œæœ‰äº›çŠ¹è±«
 * 5 - æ­£ç¡®å›ç­”ï¼Œæ¯«æ— å›°éš¾
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦
 * @returns {number} Qualityå€¼ (1-5)
 */
function masteryToQuality(mastery) {
    switch (mastery) {
        case MasteryLevel.UNFAMILIAR:
            return 1;  // å®Œå…¨ä¸è®°å¾—
        case MasteryLevel.FUZZY:
            return 3;  // æœ‰å°è±¡ä½†ä¸ç¡®å®š
        case MasteryLevel.REMEMBERED:
            return 5;  // å®Œå…¨è®°å¾—
        default:
            return 1;
    }
}

/**
 * è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸï¼ˆä¼˜åŒ–ç‰ˆ SM-2 ç®—æ³•ï¼‰
 * 
 * æ”¹è¿›ç‚¹:
 * 1. æ—©æœŸé˜¶æ®µï¼ˆå‰5æ¬¡ï¼‰ä½¿ç”¨å›ºå®šçš„æ¸è¿›é—´éš” [1,2,4,7,14]
 * 2. "æ¨¡ç³Š"æ—¶ç¼©çŸ­é—´éš”è€Œéç»´æŒä¸å˜
 * 3. "é™Œç”Ÿ"æ—¶å®Œå…¨é‡ç½®å¤ä¹ è¿›åº¦
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦: å¿˜è®°/æ¨¡ç³Š/è®¤è¯†
 * @param {number} currentInterval - å½“å‰å¤ä¹ é—´éš”ï¼ˆå¤©ï¼‰
 * @param {number} easinessFactor - ç®€æ˜“åº¦å› å­ï¼ˆ1.3-2.5+ï¼‰
 * @param {number} reviewCount - å·²å¤ä¹ æ¬¡æ•°
 * @returns {Object} ç®—æ³•è®¡ç®—ç»“æœ
 * 
 * @example
 * const result = calculateSM2Optimized('è®¤è¯†', 2, 2.5, 1);
 * // {
 * //   nextInterval: 4,
 * //   nextEasinessFactor: 2.6,
 * //   nextReviewDate: "2025-12-01T10:00:00Z",
 * //   shouldResetCount: false
 * // }
 * */
function calculateSM2Optimized(
    mastery,
    currentInterval = 1,
    easinessFactor = SM2_PARAMS.INITIAL_EASINESS_FACTOR,
    reviewCount = 0
) {
    let nextInterval = currentInterval;
    let nextEF = easinessFactor;
    let shouldResetCount = false;

    const quality = masteryToQuality(mastery);

    // ==================== æ ¸å¿ƒç®—æ³•é€»è¾‘ ====================

    if (quality < 3) {
        // ========== å¿˜è®°: å®Œå…¨é‡ç½® ==========
        // ç”¨æˆ·å®Œå…¨ä¸è®°å¾—ï¼Œéœ€è¦ä»å¤´å¼€å§‹å­¦ä¹ 
        nextInterval = 1;
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF - 0.2);
        shouldResetCount = true;

    } else if (quality === 3) {
        // ========== æ¨¡ç³Š: ç¼©çŸ­é—´éš”ï¼ŒåŠ å¼ºå¤ä¹  ==========
        // æ”¹è¿›: ä¸æ˜¯ç»´æŒä¸å˜ï¼Œè€Œæ˜¯ç¼©çŸ­20%
        nextInterval = Math.max(1, Math.round(currentInterval * SM2_PARAMS.FUZZY_MULTIPLIER));
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF - 0.1);

    } else {
        // ========== è®°å¾—: ä½¿ç”¨ä¼˜åŒ–çš„é—´éš”åºåˆ— ==========
        if (reviewCount < EARLY_INTERVALS.length) {
            // æ—©æœŸé˜¶æ®µ: ä½¿ç”¨é¢„å®šä¹‰çš„æ¸è¿›é—´éš”
            // è¿™æ˜¯å…³é”®æ”¹è¿›: 1â†’2â†’4â†’7â†’14 è€ŒéåŸç‰ˆçš„ 1â†’6
            nextInterval = EARLY_INTERVALS[reviewCount];
        } else {
            // åæœŸé˜¶æ®µ: ä½¿ç”¨ EF è®¡ç®—æŒ‡æ•°å¢é•¿
            nextInterval = Math.round(currentInterval * nextEF);
        }

        // æé«˜ç®€æ˜“åº¦ (æ ‡å‡† SM-2 å…¬å¼)
        nextEF = nextEF + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
        nextEF = Math.max(SM2_PARAMS.MIN_EASINESS_FACTOR, nextEF);
    }

    // é™åˆ¶æœ€å¤§é—´éš”
    nextInterval = Math.min(nextInterval, SM2_PARAMS.MAX_INTERVAL_DAYS);

    // è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¥æœŸ
    const nextReviewDate = new Date();
    nextReviewDate.setDate(nextReviewDate.getDate() + nextInterval);

    // è®¡ç®—æ–°çš„å¤ä¹ æ¬¡æ•°
    const newRepetitions = shouldResetCount ? 0 : reviewCount + 1;

    return {
        // === å…¼å®¹ memoryEngine.js çš„æ—§æ¥å£ ===
        interval: nextInterval,
        easinessFactor: parseFloat(nextEF.toFixed(2)),
        repetitions: newRepetitions,

        // === æ–°æ¥å£ï¼ˆä¿ç•™ä¾›æœªæ¥ä½¿ç”¨ï¼‰===
        nextInterval,
        nextEasinessFactor: parseFloat(nextEF.toFixed(2)),
        nextReviewDate: nextReviewDate.toISOString(),
        shouldResetCount,
    };
}

/**
 * ç”Ÿæˆé¢„è®¡å¤ä¹ æ—¶é—´çº¿
 * 
 * ç”¨äºå‰ç«¯å±•ç¤ºæœªæ¥çš„å¤ä¹ è®¡åˆ’
 * 
 * @param {number} currentReviewCount - å½“å‰å¤ä¹ æ¬¡æ•°
 * @param {number} maxItems - è¿”å›çš„æ—¶é—´çº¿é¡¹æ•° (é»˜è®¤5)
 * @returns {Array} æœªæ¥å¤ä¹ è®¡åˆ’
 * 
 * @example
 * generateReviewTimeline(2);
 * // [
 * //   { reviewNumber: 3, intervalDays: 4 },
 * //   { reviewNumber: 4, intervalDays: 7 },
 * //   { reviewNumber: 5, intervalDays: 14 },
 * //   ...
 * // ]
 */
function generateReviewTimeline(currentReviewCount, maxItems = 5) {
    const timeline = [];
    let interval = 1;
    let ef = SM2_PARAMS.INITIAL_EASINESS_FACTOR;

    for (let i = currentReviewCount; i < currentReviewCount + maxItems; i++) {
        if (i < EARLY_INTERVALS.length) {
            interval = EARLY_INTERVALS[i];
        } else {
            interval = Math.round(interval * ef);
        }
        interval = Math.min(interval, SM2_PARAMS.MAX_INTERVAL_DAYS);

        timeline.push({
            reviewNumber: i + 1,
            intervalDays: interval,
        });
    }

    return timeline;
}

/**
 * è·å–ä»Šå¤©çš„æ—¶é—´èŒƒå›´ (UTC)
 * 
 * @returns {Object} { startOfDay, endOfDay, timestamp }
 */
function getTodayRange() {
    const now = new Date();
    const startOfDay = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate(),
        0, 0, 0, 0
    ));
    const endOfDay = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate() + 1,
        0, 0, 0, 0
    ));

    return {
        startOfDay: startOfDay.toISOString(),
        endOfDay: endOfDay.toISOString(),
        timestamp: now.toISOString(),
    };
}

/**
 * è·å–ç®—æ³•ä¿¡æ¯ (ç”¨äºå‰ç«¯å±•ç¤º)
 * 
 * @returns {Object} ç®—æ³•å…ƒä¿¡æ¯
 */
function getAlgorithmInfo() {
    return {
        name: 'Optimized SM-2',
        version: '1.1.0',
        earlyIntervals: EARLY_INTERVALS,
        maxInterval: SM2_PARAMS.MAX_INTERVAL_DAYS,
        description: 'åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ä¼˜åŒ–çš„é—´éš”é‡å¤ç®—æ³•',
    };
}

module.exports = {
    calculateSM2Optimized,
    generateReviewTimeline,
    getTodayRange,
    getAlgorithmInfo,
    masteryToQuality,
};
````

## File: cloudbase/functions/learn-vocab/utils/validators.js
````javascript
/**
 * å‚æ•°éªŒè¯æ¨¡å—
 * 
 * ç”¨æˆ·ã€è¯æ±‡éªŒè¯åŠé€šç”¨éªŒè¯å·¥å…·
 */

'use strict';

const { userCollection, vocabularyCollection } = require('./database');
const { MasteryLevel } = require('./constants');

/**
 * éªŒè¯ç”¨æˆ·æ˜¯å¦å­˜åœ¨
 * 
 * @param {string} userId - ç”¨æˆ·ID
 * @returns {Promise<Object|null>} ç”¨æˆ·å¯¹è±¡æˆ– null
 */
async function validateUser(userId) {
    if (!userId || typeof userId !== 'string') {
        return null;
    }

    try {
        const { data } = await userCollection
            .where({ userId })
            .limit(1)
            .get();

        return data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('[validateUser] Error:', error);
        return null;
    }
}

/**
 * éªŒè¯è¯æ±‡æ˜¯å¦å­˜åœ¨
 * 
 * @param {string} vocabularyId - è¯æ±‡ID
 * @returns {Promise<Object|null>} è¯æ±‡å¯¹è±¡æˆ– null
 */
async function validateVocabulary(vocabularyId) {
    if (!vocabularyId || typeof vocabularyId !== 'string') {
        return null;
    }

    try {
        const { data } = await vocabularyCollection
            .where({ vocabularyId })
            .limit(1)
            .get();

        return data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('[validateVocabulary] Error:', error);
        return null;
    }
}

/**
 * éªŒè¯æŒæ¡ç¨‹åº¦æ˜¯å¦æœ‰æ•ˆ
 * 
 * @param {string} mastery - æŒæ¡ç¨‹åº¦
 * @returns {boolean} æ˜¯å¦æœ‰æ•ˆ
 */
function isValidMastery(mastery) {
    const validValues = Object.values(MasteryLevel);
    return validValues.includes(mastery);
}

/**
 * éªŒè¯å¹¶è§„èŒƒåŒ–åˆ†é¡µå‚æ•°
 * 
 * @param {number} limit - é™åˆ¶æ•°é‡
 * @param {number} offset - åç§»é‡
 * @param {number} maxLimit - æœ€å¤§é™åˆ¶ (é»˜è®¤100)
 * @returns {Object} éªŒè¯åçš„åˆ†é¡µå‚æ•°
 */
function validatePagination(limit, offset, maxLimit = 100) {
    return {
        limit: Math.min(Math.max(1, parseInt(limit) || 20), maxLimit),
        offset: Math.max(0, parseInt(offset) || 0),
    };
}

/**
 * éªŒè¯å¿…å¡«å­—ç¬¦ä¸²å‚æ•°
 * 
 * @param {string} value - å‚æ•°å€¼
 * @param {string} name - å‚æ•°å (ç”¨äºé”™è¯¯æ¶ˆæ¯)
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateRequiredString(value, name) {
    if (!value || typeof value !== 'string' || value.trim() === '') {
        return {
            valid: false,
            error: `${name} æ˜¯å¿…å¡«å‚æ•°ä¸”ä¸èƒ½ä¸ºç©º`,
        };
    }
    return { valid: true };
}

/**
 * éªŒè¯å¸ƒå°”å‚æ•°
 * 
 * @param {any} value - å‚æ•°å€¼
 * @param {string} name - å‚æ•°å
 * @returns {Object} { valid: boolean, error?: string }
 */
function validateBoolean(value, name) {
    if (typeof value !== 'boolean') {
        return {
            valid: false,
            error: `${name} å¿…é¡»æ˜¯å¸ƒå°”å€¼`,
        };
    }
    return { valid: true };
}
/**
 * é€šç”¨å‚æ•°éªŒè¯å‡½æ•°
 * 
 * @param {Object} params - éœ€è¦éªŒè¯çš„å‚æ•°å¯¹è±¡
 * @param {Array<string>} requiredFields - å¿…éœ€å­—æ®µåˆ—è¡¨
 * @returns {Object} { isValid: boolean, message?: string }
 */
function validateParams(params, requiredFields) {
    const missing = [];

    for (const field of requiredFields) {
        if (params[field] === undefined || params[field] === null || params[field] === '') {
            missing.push(field);
        }
    }

    if (missing.length > 0) {
        return {
            isValid: false,
            message: `ç¼ºå°‘å¿…å¡«å‚æ•°: ${missing.join(', ')}`
        };
    }

    return { isValid: true };
}

module.exports = {
    validateUser,
    validateVocabulary,
    isValidMastery,
    validatePagination,
    validateRequiredString,
    validateBoolean,
    validateParams,
};
````

## File: cloudbase/functions/memory-engine/index.js
````javascript
/**
 * memory-engine äº‘å‡½æ•°
 * ç»Ÿä¸€è®°å¿†å¼•æ“æœåŠ¡
 * ç‰ˆæœ¬: 1.0.0
 * 
 * è§¦å‘æ–¹å¼: HTTP è§¦å‘å™¨
 */

const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.SYMBOL_CURRENT_ENV });
const db = cloud.database();

// ===== Handlers =====
const getTodayMemories = require('./handlers/getTodayMemories');
const submitMemoryResult = require('./handlers/submitMemoryResult');
const submitRoundEvaluation = require('./handlers/submitRoundEvaluation');
const checkModuleAccessHandler = require('./handlers/checkModuleAccess');
const getUserProgress = require('./handlers/getUserProgress');
const getAlphabetLessons = require('./handlers/getAlphabetLessons');

// ===== Utils =====
const { createResponse } = require('./utils/response');

/**
 * äº‘å‡½æ•°ä¸»å…¥å£
 */
exports.main = async (event, context) => {
    // ===== è§£æ HTTP è¯·æ±‚ =====
    let requestData = event;

    // HTTP è§¦å‘å™¨ï¼šbody å¯èƒ½æ˜¯å­—ç¬¦ä¸²æˆ–å¯¹è±¡
    if (event.body) {
        if (typeof event.body === 'string') {
            try {
                requestData = JSON.parse(event.body);
            } catch (e) {
                console.error('[memory-engine] JSON è§£æå¤±è´¥:', e.message);
                return createResponse(false, null, 'Invalid JSON in request body', 'INVALID_JSON');
            }
        } else if (typeof event.body === 'object') {
            requestData = event.body;
        }
    }

    const { action, data = {} } = requestData;

    console.log(`[memory-engine] Action: ${action}`, JSON.stringify(data));

    // éªŒè¯ action å‚æ•°
    if (!action) {
        return createResponse(
            false,
            null,
            'ç¼ºå°‘å¿…å¡«å‚æ•°: action',
            'MISSING_ACTION'
        );
    }

    try {
        /**
         * è·å–ä»Šæ—¥å­¦ä¹ å†…å®¹ (ç»Ÿä¸€æ¥å£)
         */
        if (action === 'getTodayMemories') {
            return await getTodayMemories(db, data);
        }

        /**
         * æäº¤å­¦ä¹ ç»“æœ (ç»Ÿä¸€æ¥å£)
         */
        if (action === 'submitMemoryResult') {
            return await submitMemoryResult(db, data);
        }

        /**
         * æäº¤ä¸‰è½®è¯„ä¼°ç»“æœï¼ˆå­—æ¯æ¨¡å—ï¼‰
         */
        if (action === 'submitRoundEvaluation') {
            return await submitRoundEvaluation(db, data);
        }

        /**
         * æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™
         */
        if (action === 'checkModuleAccess') {
            return await checkModuleAccessHandler(db, data);
        }

        /**
         * è·å–ç”¨æˆ·å­¦ä¹ è¿›åº¦
         */
        if (action === 'getUserProgress') {
            return await getUserProgress(db, data);
        }

        /**
         * è·å–å­—æ¯è¯¾ç¨‹åˆ—è¡¨ï¼ˆç”¨äºå‰ç«¯è¯¾ç¨‹æ€»è§ˆï¼‰
         */
        if (action === 'getAlphabetLessons') {
            return await getAlphabetLessons(db, data);
        }

        // ===== æœªçŸ¥Action =====
        const supportedActions = [
            'getTodayMemories',
            'submitMemoryResult',
            'submitRoundEvaluation',
            'checkModuleAccess',
            'getUserProgress',
            'getAlphabetLessons',
        ];

        return createResponse(
            false,
            { supportedActions },
            `æœªçŸ¥çš„æ“ä½œç±»å‹: ${action}`,
            'UNKNOWN_ACTION'
        );

    } catch (error) {
        console.error(`[memory-engine] äº‘å‡½æ•°é”™è¯¯:`, error);
        console.error('é”™è¯¯å †æ ˆ:', error.stack);

        return createResponse(
            false,
            null,
            error.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
            'SERVER_ERROR'
        );
    }
};
````

## File: cloudbase/cloudbaserc.json
````json
{
  "envId": "cloud1-1gjcyrdd7ab927c6",
  "region": "ap-shanghai",
  "functionRoot": "./functions",
  "functions": [
    {
      "name": "user-register",
      "timeout": 15,
      "runtime": "Nodejs18.15",
      "handler": "index.main"
    },
    {
      "name": "user-login",
      "timeout": 15,
      "runtime": "Nodejs18.15",
      "handler": "index.main"
    },
    {
      "name": "user-reset-password",
      "timeout": 15,
      "runtime": "Nodejs18.15",
      "handler": "index.main"
    },
    {
      "name": "user-update-profile",
      "timeout": 15,
      "runtime": "Nodejs18.15",
      "handler": "index.main"
    },
    {
      "name": "learn-vocab",
      "timeout": 15,
      "runtime": "Nodejs18.15",
      "handler": "index.main",
      "installDependency": true
    },
    {
      "name": "memory-engine",
      "timeout": 20,
      "runtime": "Nodejs18.15",
      "handler": "index.main",
      "installDependency": true
    },
    {
      "name": "alphabet",
      "timeout": 20,
      "runtime": "Nodejs18.15",
      "handler": "index.main",
      "installDependency": true
    },
    {
      "name": "storage-download",
      "timeout": 20,
      "runtime": "Nodejs18.15",
      "handler": "index.main",
      "installDependency": true
    }
  ]
}
````

## File: src/config/alphabet/lessonMetadata.config.ts
````typescript
// src/config/alphabet/lessonMetadata.config.ts

import type { LessonMetadata } from '@/src/entities/types/phonicsRule.types';

/**
 * 6è¯¾å…ƒæ•°æ®å®Œæ•´é…ç½®
 * 
 * å®šä¹‰æ¯è¯¾çš„å­—æ¯ç»„æˆã€æ‹¼è¯»è§„åˆ™å…³è”ã€é€šè¿‡ç‡è¦æ±‚ç­‰
 * 
 * @version 1.0.0
 * @see SEQUENCE_LESSONS
 */
export const LESSON_METADATA: Record<string, LessonMetadata> = {
  /**
   * Lesson 1: åŸºç¡€æ‹¼è¯»èƒ½åŠ›(5è¾…éŸ³+3å…ƒéŸ³)
   */
  lesson1: {
    lessonId: 'lesson1',
    title: 'ç¬¬ä¸€è¯¾:åŸºç¡€æ‹¼è¯»èƒ½åŠ›',
    description: 'æŒæ¡æœ€åŸºç¡€çš„ä¸­è¾…éŸ³å’Œå¸¸è§é•¿å…ƒéŸ³,å»ºç«‹CVæ‹¼è¯»æ¦‚å¿µ',
    consonants: ['à¸', 'à¸”', 'à¸•', 'à¸™', 'à¸¡'],
    vowels: ['à¸²', 'à¸µ', 'à¸¹','à¸µ'],
    tones: [],
    phonicsRuleId: 'rule_1_cv_structure',
    totalCount: 9,
    minPassRate: 0.95,
    miniReviewInterval: 3,
    order: 1,
  },

  /**
   * Lesson 2: å‰ç½®å…ƒéŸ³ç³»ç»Ÿ(6è¾…éŸ³+4å…ƒéŸ³)
   */
  lesson2: {
    lessonId: 'lesson2',
    title: 'ç¬¬äºŒè¯¾:å‰ç½®å…ƒéŸ³ç³»ç»Ÿ',
    description: 'å­¦ä¹ å‰ç½®å…ƒéŸ³(à¹€ à¹ à¹‚)å’Œæ›´å¤šé«˜é¢‘è¾…éŸ³',
    consonants: ['à¸š', 'à¸›', 'à¸£', 'à¸¥', 'à¸§', 'à¸¢'],
    vowels: ['à¹€', 'à¹', 'à¹‚', 'à¸­'],
    tones: [],
    phonicsRuleId: 'rule_2_leading_vowel',
    totalCount: 10,
    minPassRate: 0.90,
    miniReviewInterval: 3,
    order: 2,
  },

  /**
   * Lesson 3: å£°è°ƒå…¥é—¨+é€æ°”å¯¹æ¯”(5è¾…éŸ³+3å…ƒéŸ³+2å£°è°ƒ)
   */
  lesson3: {
    lessonId: 'lesson3',
    title: 'ç¬¬ä¸‰è¯¾:å£°è°ƒå…¥é—¨',
    description: 'æŒæ¡é€æ°”/ä¸é€æ°”å¯¹æ¯”,å¼•å…¥åŸºç¡€å£°è°ƒç³»ç»Ÿ',
    consonants: ['à¸‚', 'à¸–', 'à¸œ', 'à¸ª', 'à¸«'],
    vowels: ['à¸°', 'à¸¸', 'à¸¶'],
    tones: ['à¹ˆ', 'à¹‰'],
    phonicsRuleId: 'rule_3_tone_basics',
    totalCount: 10,
    minPassRate: 0.90,
    miniReviewInterval: 3,
    order: 3,
  },

  /**
   * Lesson 4: è¾…éŸ³ç±»ä¸å£°è°ƒè§„åˆ™(6è¾…éŸ³+4å…ƒéŸ³+2å£°è°ƒ)
   */
  lesson4: {
    lessonId: 'lesson4',
    title: 'ç¬¬å››è¯¾:è¾…éŸ³ç±»ä¸å£°è°ƒ',
    description: 'ç†è§£é«˜/ä¸­/ä½è¾…éŸ³å¯¹å£°è°ƒçš„å½±å“,æŒæ¡å®Œæ•´å£°è°ƒç³»ç»Ÿ',
    consonants: ['à¸„', 'à¸—', 'à¸', 'à¸Š', 'à¸ˆ', 'à¸‡'],
    vowels: ['à¹„', 'à¹ƒ', 'à¹€à¸­à¸²', 'à¸­à¸³'],
    tones: ['à¹Š', 'à¹‹'],
    phonicsRuleId: 'rule_4_consonant_class_tones',
    totalCount: 12,
    minPassRate: 0.85,
    miniReviewInterval: 3,
    order: 4,
  },

  /**
   * Lesson 5: å¤åˆå…ƒéŸ³ç³»ç»Ÿ(8è¾…éŸ³+6å…ƒéŸ³)
   */
  lesson5: {
    lessonId: 'lesson5',
    title: 'ç¬¬äº”è¯¾:å¤åˆå…ƒéŸ³ç³»ç»Ÿ',
    description: 'æŒæ¡ä¸‰åˆå…ƒéŸ³(à¹€à¸­à¸µà¸¢ à¹€à¸­à¸·à¸­ à¸­à¸±à¸§)ç­‰å¤æ‚å…ƒéŸ³ç»„åˆ',
    consonants: ['à¸‹', 'à¸‰', 'à¸', 'à¸Ÿ', 'à¸¨', 'à¸©', 'à¸®', 'à¸­'],
    vowels: ['à¹€à¸­à¸µà¸¢', 'à¹€à¸­à¸·à¸­', 'à¸­à¸±à¸§', 'à¹€à¸­à¸­', 'à¸·', 'à¸­'],
    tones: [],
    phonicsRuleId: 'rule_5_compound_vowels',
    totalCount: 14,
    minPassRate: 0.85,
    miniReviewInterval: 3,
    order: 5,
  },

  /**
   * Lesson 6: å®Œæ•´è¦†ç›–+ç‰¹æ®Šè§„åˆ™(14è¾…éŸ³+12å…ƒéŸ³)
   * è¯´æ˜:
   * - æ­¤è¯¾å…ƒéŸ³ç»„ç”¨äºè®­ç»ƒã€ŒçŸ­å…ƒéŸ³å˜å½¢ã€ä¸ Dead Syllable è§„åˆ™ï¼›
   * - å…¶ä¸­ 'à¸­à¸±à¸§' åœ¨è¿™é‡Œä»£è¡¨å®é™…æ‹¼å†™æ¨¡å¼ã€Œà¸±à¸§à¸°ã€(çŸ­ ua)ï¼Œ
   *   ç”±äº letters æ•°æ®é›†ä¸­ä¸å­˜åœ¨ç‹¬ç«‹å­—å½¢ã€Œà¸±à¸§à¸°ã€ï¼Œæ•…ç”¨ 'à¸­à¸±à¸§' ä½œä¸ºä»£è¡¨ç¬¦å·ã€‚
   */
  lesson6: {
    lessonId: 'lesson6',
    title: 'ç¬¬å…­è¯¾:å®Œæ•´è¦†ç›–(å¸¸ç”¨è¿›é˜¶)',
    description: 'è¡¥å……å¸¸ç”¨è¿›é˜¶è¾…éŸ³ä¸å¤åˆå…ƒéŸ³,æŒæ¡ç‰¹æ®Šè§„åˆ™(å¦‚ à¸« à¸™à¸³ ç­‰)',
    consonants: [
      // ä½è¾…éŸ³æ¸…éŸ³(æ¢µæ–‡å€Ÿè¯) + å¸¸ç”¨è¿›é˜¶è¾…éŸ³
      'à¸‘', 'à¸’', 'à¸“', 'à¸ ', 'à¸˜', 'à¸Œ', 'à¸', 'à¸¬', 'à¸', 'à¸', 'à¸',
    ],
    vowels: [
      // æ ¸å¿ƒå˜å½¢çŸ­å…ƒéŸ³ç»„
      'à¹‚à¸­à¸°', 'à¹€à¸­à¸°', 'à¹à¸­à¸°', 'à¹€à¸­à¸²à¸°', 'à¸­à¸±à¸§',
    ],
    tones: [],
    phonicsRuleId: 'rule_6_special_cases',
    totalCount: 16,
    minPassRate: 0.90,
    miniReviewInterval: 4,
    order: 6,
  },

  /**
   * Lesson 7: ç½•ç”¨/å¤ä½“å­—æ¯ä¸å¤æ‚å…ƒéŸ³
   * ä»…ä½œä¸ºè¡¥å……è¯¾ç¨‹,ä¸å‚ä¸å…¶ä»–æ¨¡å—è§£é”
   */
  lesson7: {
    lessonId: 'lesson7',
    title: 'ç¬¬ä¸ƒè¯¾:ç½•ç”¨å­—æ¯ä¸ç‰¹æ®Šå…ƒéŸ³',
    description: 'é›†ä¸­å­¦ä¹ ç°ä»£æ³°è¯­ä¸­è¾ƒå°‘ä½¿ç”¨çš„è¾…éŸ³ä¸å¤æ‚å…ƒéŸ³,ç”¨äºé˜…è¯»å¤æ–‡ä¸ç‰¹æ®Šä¸“æœ‰åè¯',
    consonants: [
      // å·²å¼ƒç”¨æˆ–æå°‘ä½¿ç”¨çš„è¾…éŸ³
      'à¸ƒ', 'à¸…',
    ],
    vowels: [
      // æ¢µæ–‡/å·´åˆ©å€Ÿè¯ä¸­çš„ç‰¹æ®Šå…ƒéŸ³
      'à¸¤', 'à¸¤à¹…', 'à¸¦', 'à¸¦à¹…',
    ],
    tones: [],
    phonicsRuleId: 'rule_6_special_cases',
    totalCount: 6,
    minPassRate: 0.80,
    miniReviewInterval: 4,
    order: 7,
  },
};

/**
 * æ ¹æ®è¯¾ç¨‹IDè·å–å…ƒæ•°æ®
 */
export function getLessonMetadata(lessonId: string): LessonMetadata | null {
  return LESSON_METADATA[lessonId] || null;
}

/**
 * è·å–æ‰€æœ‰è¯¾ç¨‹å…ƒæ•°æ®(æŒ‰é¡ºåº)
 */
export function getAllLessons(): LessonMetadata[] {
  return Object.values(LESSON_METADATA).sort((a, b) => a.order - b.order);
}

/**
 * æ ¹æ®å­—æ¯è·å–æ‰€å±è¯¾ç¨‹
 */
export function getLessonByLetter(thaiChar: string): LessonMetadata | null {
  for (const lesson of Object.values(LESSON_METADATA)) {
    const allLetters = [
      ...lesson.consonants,
      ...lesson.vowels,
      ...lesson.tones,
    ];
    
    if (allLetters.includes(thaiChar)) {
      return lesson;
    }
  }
  
  return null;
}

/**
 * è·å–è¯¾ç¨‹ç»Ÿè®¡
 */
export function getLessonStatistics() {
  const lessons = Object.values(LESSON_METADATA);
  
  return {
    totalLessons: lessons.length,
    totalConsonants: lessons.reduce((sum, l) => sum + l.consonants.length, 0),
    totalVowels: lessons.reduce((sum, l) => sum + l.vowels.length, 0),
    totalTones: lessons.reduce((sum, l) => sum + l.tones.length, 0),
    totalLetters: lessons.reduce((sum, l) => sum + l.totalCount, 0),
  };
}
````

## File: src/entities/types/letter.types.ts
````typescript
// src/entities/types/letter.types.ts

/**
 * å­—æ¯ç±»å‹å®šä¹‰
 *
 * æ•°æ®æº: letters_final.enriched.json (80 ä¸ªæ³°è¯­å­—æ¯/å…ƒéŸ³/å£°è°ƒ)
 * æ›´æ–°æ—¥æœŸ: 2025-12-06
 *
 * è¯´æ˜: æ­¤æ¥å£å°½é‡è´´è¿‘æ•°æ®åº“ letters é›†åˆçš„å®é™…ç»“æ„ã€‚
 * - éƒ¨åˆ†å†å²å­—æ®µ (audioPath/learningLevel/strokeCount/createdAt/lessonNumber)
 *   åœ¨æœ€æ–°ç‰ˆæœ¬ä¸­å·²ä»æ•°æ®æºä¸­ç§»é™¤,å› æ­¤åœ¨ç±»å‹ä¸­ä¿ç•™ä¸ºå¯é€‰,ä»…ç”¨äºå…¼å®¹æ—§æ•°æ®ã€‚
 */

// ==================== åŸºç¡€ç±»å‹ ====================

/**
 * å­—æ¯ç±»å‹
 */
export type LetterType = 'consonant' | 'vowel' | 'tone';

/**
 * è¾…éŸ³ç±»åˆ« (ä»…è¾…éŸ³æœ‰æ•ˆ)
 */
export type ConsonantClass = 'mid' | 'high' | 'low';

/**
 * å­¦ä¹ çº§åˆ«
 */
export type LearningLevel = 'BEGINNER' | 'INTERMEDIATE' | 'ADVANCED';

/**
 * å­—æ¯ä¸»ç±»åˆ«
 */
export type LetterCategory = 'mid_consonant' | 'high_consonant' | 'low_consonant' | 'vowel' | 'tone';

// ==================== ä¸»è¦æ¥å£ ====================

/**
 * Letter - å®Œæ•´çš„å­—æ¯æ•°æ®ç»“æ„
 * 
 * â­ æ­¤æ¥å£åŒ…å«letters_final.jsonçš„æ‰€æœ‰å­—æ®µ
 * â­ å¯¹åº”æ•°æ®åº“lettersé›†åˆçš„æ–‡æ¡£ç»“æ„
 */
export interface Letter {
    // ===== åŸºç¡€å­—æ®µ (åŸæœ‰æ•°æ®åº“å­—æ®µ) =====
    _id: string;                    // å”¯ä¸€æ ‡è¯† (å¦‚: "TH_C_01")
    type: LetterType;               // ç±»å‹: consonant | vowel | tone
    thaiChar: string;               // æ³°æ–‡å­—ç¬¦ (å¦‚: "à¸")
    nameThai: string;               // æ³°æ–‡åç§° (å¦‚: "à¹„à¸à¹ˆ")
    nameEnglish: string;            // è‹±æ–‡åç§° (å¦‚: "ko kai")
    initialSound: string;           // é¦–éŸ³ (å¦‚: "k")
    finalSound: string;             // å°¾éŸ³ (å¦‚: "k")
    class: ConsonantClass | null;   // è¾…éŸ³ç±»åˆ« (ä»…è¾…éŸ³æœ‰æ•ˆ,å…ƒéŸ³/å£°è°ƒä¸ºnull)
    exampleWord: string;            // ä¾‹è¯ (å¦‚: "à¹„à¸à¹ˆ")
    exampleMeaning: string;         // ä¾‹è¯å«ä¹‰ (å¦‚: "é¸¡")

    // ä»¥ä¸‹ä¸ºå†å²å­—æ®µ,ç›®å‰æ•°æ®æºä¸­å·²ç§»é™¤,ä¿ç•™ä¸ºå¯é€‰ä»¥å…¼å®¹æ—§æ•°æ®
    audioPath?: string;             // æ—§ç‰ˆéŸ³é¢‘è·¯å¾„ (å¯èƒ½ä¸ºç©º,å»ºè®®ä½¿ç”¨fullSoundUrl)
    strokeCount?: number;           // ç¬”ç”»æ•° (é¢„ç•™å­—æ®µ,æš‚æœªä½¿ç”¨)
    learningLevel?: LearningLevel;  // å­¦ä¹ çº§åˆ«
    createdAt?: string;             // åˆ›å»ºæ—¥æœŸ (ISOæ ¼å¼)
    
    // ===== æ–°å¢å­—æ®µ (æ¥è‡ªletters.jsonåˆå¹¶) =====
    
    // è¯¾ç¨‹ä¸åˆ†ç±»
    lessonId?: string;              // ä¸»è¯¾ç¨‹ ID (å¦‚: "lesson1")
    lessonNumber?: number;          // æ—§è¯¾ç¨‹ç¼–å· (1-7), å·²åºŸå¼ƒ
    category: LetterCategory;       // ä¸»ç±»åˆ« (å¦‚: "mid_consonant", "high_consonant")
    subCategory: string;            // å­ç±»åˆ« (å¦‚: "lesson1_mid", "lesson4_high")
    
    // é”®ç›˜è¾“å…¥
    keyboardKey?: string;           // é”®ç›˜æŒ‰é”® (å¦‚: "d", "j") - å¯é€‰
    
    // å‘éŸ³ç³»ç»Ÿ (å¤šå±‚çº§éŸ³é¢‘)
    fullSound?: string;             // å®Œæ•´å‘éŸ³æ ‡è¯† (å¦‚: "consonant-ko-kai")
    fullSoundUrl?: string;          // â­ å®Œæ•´å‘éŸ³URL (ä¼˜å…ˆä½¿ç”¨)
    fullSoundFileId?: string;       // CloudBase å®Œæ•´å‘éŸ³ fileId (cloud://...)
    fullSoundLocalPath?: string;    // æœ¬åœ°ç¼“å­˜è·¯å¾„ï¼ˆfile://ï¼‰

    syllableSoundName?: string;     // éŸ³èŠ‚å‘éŸ³åç§° (å¦‚: "k")
    syllableSound?: string;         // éŸ³èŠ‚å‘éŸ³æ ‡è¯†
    syllableSoundUrl?: string;      // éŸ³èŠ‚å‘éŸ³URL (ç”¨äºéŸ³èŠ‚ç»ƒä¹ )
    syllableSoundFileId?: string;   // CloudBase éŸ³èŠ‚å‘éŸ³ fileId
    syllableSoundLocalPath?: string;// æœ¬åœ°ç¼“å­˜è·¯å¾„

    endSyllableSoundName?: string;  // å°¾éŸ³èŠ‚åç§°
    endSyllableSound?: string;      // å°¾éŸ³èŠ‚å‘éŸ³æ ‡è¯†
    endSyllableSoundUrl?: string;   // å°¾éŸ³èŠ‚å‘éŸ³URL (ç”¨äºè¾…éŸ³å°¾éŸ³ç»ƒä¹ )
    endSyllableSoundFileId?: string;// CloudBase å°¾éŸ³èŠ‚å‘éŸ³ fileId
    endSyllableSoundLocalPath?: string;// æœ¬åœ°ç¼“å­˜è·¯å¾„

    letterNamePronunciation?: string; // â­ å­—æ¯åç§°å‘éŸ³ (å¦‚: "kay`")
    letterPronunciationUrl?: string;  // å­—æ¯å‘éŸ³URL
    letterPronunciationFileId?: string; // CloudBase å­—æ¯å‘éŸ³ fileId
    letterPronunciationLocalPath?: string; // æœ¬åœ°ç¼“å­˜è·¯å¾„
    
    // å¤šåª’ä½“èµ„æº
    letterImageUrl?: string;        // å­—æ¯å›¾ç‰‡URL (é¢„ç•™)
    
    // æè¿°ä¿¡æ¯
    description?: string;           // é¢å¤–æè¿°ä¿¡æ¯ (å¯é€‰)

    // è¯¾ç¨‹ç¼–æ’ï¼ˆæ¥è‡ª letters_final.enriched.jsonï¼‰
    usageTag?: string;                     // ä½¿ç”¨æ ‡ç­¾: core / rare / supplement ç­‰
    lessonGroup?: string;                  // è¯¾ç¨‹ç»„åˆ«: core / supplement ç­‰
    curriculumLessonIds?: string[];        // æ‰€å±è¯¾ç¨‹ ID åˆ—è¡¨ï¼Œä¾‹å¦‚ ['lesson1', 'lesson3']
    curriculumLessonOrders?: number[];     // å„è¯¾ç¨‹å†…æ’åºåºå·
    primaryCurriculumLessonId?: string;    // ä¸»è¯¾ç¨‹ IDï¼Œä¾‹å¦‚ 'lesson1'
    primaryCurriculumLessonOrder?: number; // ä¸»è¯¾ç¨‹ä¸­çš„æ’åº
}

/**
 * LetterListItem - ç®€åŒ–ç‰ˆå­—æ¯æ•°æ® (ç”¨äºåˆ—è¡¨æ˜¾ç¤º)
 */
export interface LetterListItem {
    _id: string;
    thaiChar: string;
    nameThai: string;
    nameEnglish: string;
    type: LetterType;
    class: ConsonantClass | null;
    lessonId?: string;
    category: LetterCategory;
    isMastered?: boolean;           // å‰ç«¯æ·»åŠ : æ˜¯å¦å·²æŒæ¡
}

/**
 * LetterProgress - å­—æ¯å­¦ä¹ è¿›åº¦
 */
export interface LetterProgress {
    masteredCount: number;          // å·²æŒæ¡æ•°é‡
    totalCount: number;             // æ€»æ•°é‡ (80ä¸ª)
    accuracy: number;               // æ­£ç¡®ç‡ (0-100)
    masteredIds: string[];          // å·²æŒæ¡çš„å­—æ¯IDåˆ—è¡¨
}

/**
 * LetterStatistics - å­—æ¯ç»Ÿè®¡ä¿¡æ¯
 */
export interface LetterStatistics {
    total: number;
    consonants: number;
    vowels: number;
    tones: number;
    byLesson: {
        lesson1: number;
        lesson2: number;
        lesson3: number;
        lesson4: number;
        lesson5: number;
        lesson6: number;
        lesson7: number;
    };
    byClass: {
        mid: number;
        high: number;
        low: number;
    };
}

/**
 * LetterFilter - å­—æ¯æœç´¢/è¿‡æ»¤æ¡ä»¶
 */
export interface LetterFilter {
    type?: LetterType;
    lessonId?: string;
    class?: ConsonantClass;
    category?: LetterCategory;
    subCategory?: string;
    excludeIds?: string[];
}

// ==================== è¾…åŠ©ç±»å‹ ====================

/**
 * éŸ³é¢‘URLä¼˜å…ˆçº§ç±»å‹
 */
export type AudioUrlPriority = {
    primary: string | undefined;    // fullSoundUrl
    secondary: string | undefined;  // letterPronunciationUrl
    fallback: string;               // audioPath
};

/**
 * å­—æ¯æ˜¾ç¤ºä¿¡æ¯ (ç”¨äºUIç»„ä»¶)
 */
export interface LetterDisplayInfo {
    char: string;                   // æ³°æ–‡å­—ç¬¦
    name: string;                   // åç§° (ä¼˜å…ˆæ³°æ–‡)
    pronunciation: string;          // å‘éŸ³ (ä¼˜å…ˆletterNamePronunciation)
    example: string;                // å®Œæ•´ä¾‹è¯ (åŒ…å«ä¸­æ–‡)
    audioUrl: string;               // éŸ³é¢‘URL (å·²å¤„ç†ä¼˜å…ˆçº§)
    keyboardHint?: string;          // é”®ç›˜æç¤º
}
````

## File: src/stores/vocabularyStore.ts
````typescript
// src/stores/vocabularyStore.ts

/**
 * å•è¯å­¦ä¹  Store
 * 
 * åŠŸèƒ½ï¼š
 * 1. ä»åç«¯è·å–ä»Šæ—¥å•è¯å­¦ä¹ ä»»åŠ¡
 * 2. ç®¡ç†å•è¯å­¦ä¹ ä¼šè¯æµç¨‹
 * 3. æäº¤å­¦ä¹ ç»“æœåˆ°åç«¯
 * 4. æœ¬åœ°è¿›åº¦è¿½è¸ª
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { apiClient } from '@/src/utils/apiClient';
import { API_ENDPOINTS } from '@/src/config/api.endpoints';
import { useUserStore } from './userStore';
import { useModuleAccessStore, type ModuleType } from './moduleAccessStore';
import type {
    Vocabulary,
    VocabularyLearningState,
    TodayVocabularyResponse,
    VocabularyProgress,
} from '@/src/entities/types/vocabulary.types';
import { LearningPhase } from '@/src/entities/enums/LearningPhase.enum';
import {
    QualityButton,
    QUALITY_SCORE_MAP,
    ATTEMPTS_INCREMENT_MAP,
} from '@/src/entities/enums/QualityScore.enum';

interface VocabularyStore {
    // ===== å­¦ä¹ ä¼šè¯çŠ¶æ€ =====
    phase: LearningPhase;
    reviewQueue: VocabularyLearningState[];
    currentVocabulary: VocabularyLearningState | null;
    currentCourseSource: string | null; // Added: Track current course source

    // ===== æœ¬åœ°è¿›åº¦ =====
    progress: VocabularyProgress;
    courseProgressMap: Record<string, VocabularyProgress>;

    // ===== å­¦ä¹ ä¼šè¯æ“ä½œ =====
    initSession: (userId: string) => Promise<void>;
    submitAnswer: (quality: QualityButton) => Promise<void>;
    moveToNext: () => void;
    finishSession: () => void;
    startCourse: (source: string, moduleType?: ModuleType) => Promise<void>; // Modified: Accept moduleType for access check

    // ===== æœ¬åœ°è¿›åº¦æ“ä½œ =====
    markAsMastered: (vocabularyId: string) => void;
    resetProgress: () => void;
}

const defaultProgress: VocabularyProgress = {
    masteredCount: 0,
    totalCount: 0,
    accuracy: 0,
    masteredIds: [],
};

export const useVocabularyStore = create<VocabularyStore>()(
    persist(
        (set, get) => ({
            // ===== åˆå§‹çŠ¶æ€ =====
            phase: LearningPhase.IDLE,
            reviewQueue: [],
            currentVocabulary: null,
            currentCourseSource: null, // Initial state
            progress: defaultProgress,
            courseProgressMap: {},

            // ===== åˆå§‹åŒ–å­¦ä¹ ä¼šè¯ =====
            initSession: async (userId: string) => {
                try {
                    console.log('ğŸ” å¼€å§‹è·å–ä»Šæ—¥å•è¯ï¼ŒuserId:', userId);

                    const { currentCourseSource } = get();
                    const endpoint = API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES;
                    const result = await apiClient.post<TodayVocabularyResponse>(
                        endpoint,
                        {
                            userId,
                            limit: 10,
                            source: currentCourseSource // Added: Filter by course source
                        }
                    );

                    console.log('ğŸ” API å“åº”:', result);

                    if (result.success && (result.data as any)?.items?.length > 0) {
                        const data = result.data as any;
                        const reviewQueue: VocabularyLearningState[] = data.items.map(
                            (item: any) => ({
                                vocabularyId: item._id,
                                thaiWord: item.entity.thaiWord,
                                pronunciation: item.entity.pronunciation,
                                meaning: item.entity.meaning,
                                exampleSentence: item.entity.exampleSentence,
                                audioPath: item.entity.audioPath,
                                currentAttempts: 0,
                                requiredAttempts: 3,
                                qualityHistory: [],
                                isCompleted: false,
                                timestamp: new Date().toISOString(),
                            })
                        );

                        set({
                            phase: LearningPhase.IDLE,
                            reviewQueue,
                            currentVocabulary: reviewQueue[0] || null,
                        });

                        console.log('âœ… æˆåŠŸåŠ è½½', reviewQueue.length, 'ä¸ªå•è¯');
                    } else {
                        // æ²¡æœ‰æ•°æ®æ—¶çš„å¤„ç†
                        console.log('â„¹ï¸ ä»Šæ—¥æ²¡æœ‰éœ€è¦å¤ä¹ çš„å•è¯');
                        set({
                            phase: LearningPhase.COMPLETED,
                            reviewQueue: [],
                            currentVocabulary: null,
                        });
                    }
                } catch (error) {
                    console.error('âŒ initSession error:', error);
                    // é™çº§å¤„ç†ï¼šæ˜¾ç¤ºé”™è¯¯çŠ¶æ€
                    set({
                        phase: LearningPhase.IDLE,
                        reviewQueue: [],
                        currentVocabulary: null,
                    });
                    throw error;
                }
            },

            // ===== å¼€å§‹è¯¾ç¨‹ =====
            startCourse: async (source: string, moduleType: ModuleType = 'word') => {
                // ğŸ”’ Strict Safety Net: éªŒè¯æ˜¯å¦æœ‰æƒé™è®¿é—®è¯¥æ¨¡å—
                const allowed = useModuleAccessStore.getState().checkAccessLocally(moduleType);
                if (!allowed) {
                    console.warn(`ğŸš« Access Denied: Module '${moduleType}' is locked. Cannot start course '${source}'.`);
                    return; // â›”ï¸ å¼ºåˆ¶ä¸­æ–­ï¼Œä¸æ‰§è¡Œä»»ä½•åˆ‡æ¢é€»è¾‘
                }

                const { currentCourseSource, progress, courseProgressMap } = get();

                // If switching to a different course, reset progress
                if (currentCourseSource !== source) {
                    console.log(`ğŸ”„ Switching course from ${currentCourseSource} to ${source}. Caching current progress.`);

                    const cachedProgress = courseProgressMap[source];
                    const updatedCache = currentCourseSource
                        ? { ...courseProgressMap, [currentCourseSource]: progress }
                        : { ...courseProgressMap };

                    // 1. Update local state
                    set({
                        courseProgressMap: updatedCache,
                        currentCourseSource: source,
                        progress: cachedProgress || defaultProgress,
                        reviewQueue: [],
                        currentVocabulary: null,
                        phase: LearningPhase.IDLE // Or START?
                    });

                    // 2. Reset remote progress (if applicable)
                    // Note: The requirement says "clear Basic Thai 1's progress". 
                    // Since we have a single 'wordProgress' in user_progress, we likely need to reset that.
                    // However, 'user_progress' seems to be managed by moduleAccessStore/userStore mostly.
                    // We might need an API call here to reset the backend progress for the user.
                    // For now, we'll assume the 'initSession' or a specific 'resetProgress' API call handles this.
                    // Let's call a reset endpoint if it exists, or just rely on local reset + future updates overwriting.

                    // Ideally call an API to reset wordProgress on backend
                    try {
                        const userId = useUserStore.getState().currentUser?.userId;
                        if (userId) {
                            // Assuming we reuse the progress update endpoint to set progress to 0
                            // Or if there's a specific reset endpoint. 
                            // Based on available endpoints, we might need to use PROGRESS.UPDATE
                            /*
                            await apiClient.post(API_ENDPOINTS.PROGRESS.UPDATE, {
                                userId,
                                wordProgress: 0,
                                wordUnlocked: false // Maybe?
                            });
                            */
                            // For now, just logging as the backend logic for "resetting" isn't fully exposed in the snippets.
                            // We will rely on the fact that we are starting fresh.
                        }
                    } catch (e) {
                        console.error("Failed to reset remote progress", e);
                    }
                } else {
                    console.log(`â–¶ï¸ Continuing course ${source}`);
                }
            },

            // ===== æäº¤ç­”æ¡ˆ =====
            submitAnswer: async (quality: QualityButton) => {
                const { currentVocabulary, reviewQueue } = get();
                if (!currentVocabulary) return;

                const qualityScore = QUALITY_SCORE_MAP[quality];
                const attemptsIncrement = ATTEMPTS_INCREMENT_MAP[quality];

                // æ›´æ–°å½“å‰å•è¯çŠ¶æ€
                const updatedVocabulary: VocabularyLearningState = {
                    ...currentVocabulary,
                    currentAttempts: currentVocabulary.currentAttempts + attemptsIncrement,
                    qualityHistory: [...currentVocabulary.qualityHistory, qualityScore],
                    timestamp: new Date().toISOString(),
                };

                // åˆ¤æ–­æ˜¯å¦å®Œæˆ
                if (updatedVocabulary.currentAttempts >= 3) {
                    updatedVocabulary.isCompleted = true;
                    updatedVocabulary.currentAttempts = 3;

                    // æ ‡è®°ä¸ºå·²æŒæ¡ï¼ˆæœ¬åœ°ï¼‰
                    get().markAsMastered(currentVocabulary.vocabularyId);

                    // æäº¤åˆ°åç«¯
                    const avgQuality = Math.round(
                        updatedVocabulary.qualityHistory.reduce((a, b) => a + b, 0) /
                        updatedVocabulary.qualityHistory.length
                    );

                    const endpoint = API_ENDPOINTS.MEMORY.SUBMIT_MEMORY_RESULT;
                    apiClient
                        .post(endpoint, {
                            userId: useUserStore.getState().currentUser?.userId,
                            vocabularyId: currentVocabulary.vocabularyId,
                            quality: avgQuality,
                        })
                        .then((result: any) => {
                            console.log('âœ… æäº¤ç»“æœæˆåŠŸ:', result);
                        })
                        .catch((err: any) => console.error('âŒ æäº¤å¤±è´¥:', err));
                }

                // æ›´æ–°é˜Ÿåˆ—
                const currentIndex = reviewQueue.findIndex(
                    (v) => v.vocabularyId === currentVocabulary.vocabularyId
                );
                const newQueue = [...reviewQueue];
                newQueue[currentIndex] = updatedVocabulary;

                set({ reviewQueue: newQueue });

                // è‡ªåŠ¨è·³è½¬
                get().moveToNext();
            },

            // ===== ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå•è¯ =====
            moveToNext: () => {
                const { reviewQueue } = get();
                const nextVocabulary = reviewQueue.find((v) => !v.isCompleted);

                if (nextVocabulary) {
                    set({ currentVocabulary: nextVocabulary });
                } else {
                    set({ phase: LearningPhase.COMPLETED });
                }
            },

            // ===== å®Œæˆä¼šè¯ =====
            finishSession: () => {
                set({ phase: LearningPhase.COMPLETED });
            },

            // ===== æ ‡è®°ä¸ºå·²æŒæ¡ =====
            markAsMastered: (vocabularyId: string) => {
                const { progress } = get();
                if (!progress.masteredIds.includes(vocabularyId)) {
                    const newMasteredIds = [...progress.masteredIds, vocabularyId];
                    set({
                        progress: {
                            ...progress,
                            masteredIds: newMasteredIds,
                            masteredCount: newMasteredIds.length,
                        },
                    });
                }
            },

            // ===== é‡ç½®è¿›åº¦ =====
            resetProgress: () => {
                set({ progress: defaultProgress });
            },
        }),
        {
            name: 'vocabulary-learning-storage',
            storage: createJSONStorage(() => AsyncStorage),
            // åªæŒä¹…åŒ–å…³é”®æ•°æ®
            partialize: (state) => ({
                progress: state.progress,
                currentCourseSource: state.currentCourseSource, // Persist current course
            }),
        }
    )
);
````

## File: src/utils/apiClient.ts
````typescript
// src/utils/apiClient.ts

import {
  getApiBaseUrl,
  CURRENT_BACKEND,
  logBackendInfo,
} from '../config/backend.config';
import { getEndpoint, replacePathParams } from '../config/api.endpoints';
import type { EndpointMap } from '../config/api.endpoints';
import { API_TIMEOUT, ERROR_MESSAGES } from '../config/constants';
import type { ApiResponse } from '../entities/types/api.types';

interface RequestOptions {
  timeout?: number;
  headers?: Record<string, string>;
  pathParams?: Record<string, string>;  // è·¯å¾„å‚æ•°
}

// Cloud Function è°ƒç”¨å¯é€‰å‚æ•°
export interface CloudFunctionOptions {
  /**
   * äº‘å‡½æ•°çš„ HTTP è§¦å‘è·¯å¾„ï¼Œé»˜è®¤å€¼ä¸º '/learn-vocab'ã€‚
   * è‹¥é¡¹ç›®ä¸­å­˜åœ¨å…¶ä»–äº‘å‡½æ•°ï¼ˆå¦‚ '/memory-engine'ï¼‰ï¼Œè¯·åœ¨è°ƒç”¨æ—¶æ˜¾å¼ä¼ å…¥ã€‚
   */
  endpoint?: string | EndpointMap;
}

class ApiClient {
  private baseUrl: string;
  private authToken: string | null = null;

  constructor() {
    this.baseUrl = getApiBaseUrl();

    // æ‰“å°åç«¯ä¿¡æ¯ï¼ˆä»…å¼€å‘ç¯å¢ƒï¼‰
    logBackendInfo();
  }

  // ==================== Token ç®¡ç† ====================

  setAuthToken(token: string | null) {
    this.authToken = token;
    if (__DEV__) {
      console.log('ğŸ”‘ Token å·²è®¾ç½®:', token ? token.substring(0, 20) + '...' : 'null');
    }
  }

  getAuthToken(): string | null {
    return this.authToken;
  }

  // ==================== æ„å»ºå®Œæ•´ URL ====================

  private buildUrl(
    endpoint: string | EndpointMap,
    pathParams?: Record<string, string>
  ): string {
    let path: string;

    // å¦‚æœæ˜¯ç«¯ç‚¹æ˜ å°„å¯¹è±¡ï¼Œæ ¹æ®å½“å‰åç«¯é€‰æ‹©è·¯å¾„
    if (typeof endpoint === 'object') {
      path = getEndpoint(endpoint, CURRENT_BACKEND);
    } else {
      path = endpoint;
    }

    // æ›¿æ¢è·¯å¾„å‚æ•°ï¼ˆå¦‚ /api/courses/:idï¼‰
    if (pathParams) {
      path = replacePathParams(path, pathParams);
    }

    // æ‹¼æ¥å®Œæ•´ URL
    const fullUrl = `${this.baseUrl}${path}`;

    return fullUrl;
  }

  // ==================== é€šç”¨è¯·æ±‚æ–¹æ³• ====================

  private async request<T>(
    endpoint: string | EndpointMap,
    method: 'GET' | 'POST' | 'PUT' | 'DELETE',
    data?: any,
    options: RequestOptions = {}
  ): Promise<ApiResponse<T>> {
    const {
      timeout = API_TIMEOUT.DEFAULT,
      headers = {},
      pathParams,
    } = options;

    // æ„å»ºè¯·æ±‚å¤´
    const authToken = this.getAuthToken();
    const requestHeaders: Record<string, string> = {
      'Content-Type': 'application/json',
      ...headers,
    };

    // æ·»åŠ  Authorization å¤´
    if (authToken) {
      requestHeaders['Authorization'] = `Bearer ${authToken}`;
    }

    // æ„å»º URL
    const url = this.buildUrl(endpoint, pathParams);

    // è¶…æ—¶æ§åˆ¶
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
      if (__DEV__) {
        console.log(`ğŸ“¤ [${method}] ${url}`);
        if (data) console.log('ğŸ“¦ Request data:', data);
      }

      // å‘é€è¯·æ±‚
      const response = await fetch(url, {
        method,
        headers: requestHeaders,
        body: method !== 'GET' ? JSON.stringify(data) : undefined,
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (__DEV__) {
        console.log(`ğŸ“¥ Response status: ${response.status}`);
      }

      // è§£æå“åº”
      let responseData;
      try {
        responseData = await response.json();
      } catch (parseError) {
        console.error('âŒ è§£æå“åº”å¤±è´¥:', parseError);
        return {
          success: false,
          error: ERROR_MESSAGES.SERVER_ERROR,
          code: 'PARSE_ERROR',
        };
      }

      // æ£€æŸ¥ HTTP çŠ¶æ€ç 
      if (!response.ok) {
        // 401 Unauthorized - Token å¤±æ•ˆ
        if (response.status === 401) {
          return {
            success: false,
            error: responseData.error || ERROR_MESSAGES.TOKEN_EXPIRED,
            code: 'TOKEN_EXPIRED',
          };
        }

        // å…¶ä»–é”™è¯¯
        return {
          success: false,
          error: responseData.error || responseData.message || ERROR_MESSAGES.SERVER_ERROR,
          code: responseData.code || 'SERVER_ERROR',
        };
      }

      // è¿”å›æˆåŠŸå“åº”
      if (__DEV__) {
        console.log('âœ… Response data:', responseData);
      }

      return {
        success: true,
        data: responseData.data || responseData,
      };

    } catch (error: any) {
      clearTimeout(timeoutId);

      // è¶…æ—¶é”™è¯¯
      if (error.name === 'AbortError') {
        console.error('â±ï¸ è¯·æ±‚è¶…æ—¶');
        return {
          success: false,
          error: ERROR_MESSAGES.TIMEOUT_ERROR,
          code: 'TIMEOUT',
        };
      }

      // ç½‘ç»œé”™è¯¯
      if (!navigator.onLine) {
        console.error('ğŸ“¡ ç½‘ç»œæœªè¿æ¥');
        return {
          success: false,
          error: ERROR_MESSAGES.NETWORK_ERROR,
          code: 'NETWORK_ERROR',
        };
      }

      // å…¶ä»–é”™è¯¯
      console.error('âŒ è¯·æ±‚å¤±è´¥:', error);
      return {
        success: false,
        error: error.message || ERROR_MESSAGES.UNKNOWN_ERROR,
        code: 'UNKNOWN_ERROR',
      };
    }
  }

  // ==================== HTTP æ–¹æ³• ====================

  async get<T>(
    endpoint: string | EndpointMap,
    options?: RequestOptions
  ): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, 'GET', undefined, options);
  }

  async post<T>(
    endpoint: string | EndpointMap,
    data?: any,
    options?: RequestOptions
  ): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, 'POST', data, options);
  }

  async put<T>(
    endpoint: string | EndpointMap,
    data?: any,
    options?: RequestOptions
  ): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, 'PUT', data, options);
  }

  async delete<T>(
    endpoint: string | EndpointMap,
    options?: RequestOptions
  ): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, 'DELETE', undefined, options);
  }
}

// ==================== å¯¼å‡ºå•ä¾‹ ====================
export const apiClient = new ApiClient();

// ==================== Cloud Function é€‚é…å™¨ ====================

/**
 * é€šç”¨ CloudBase äº‘å‡½æ•°è°ƒç”¨å·¥å…·ï¼Œé€‚ç”¨äºæ‰€æœ‰åŸºäº `action` å‚æ•°çš„äº‘å‡½æ•°ã€‚
 *
 * è¯´æ˜ï¼ˆç»“åˆ V9 å¿«ç…§ï¼‰ï¼š
 * - å¯¹äºå¤š action äº‘å‡½æ•°ï¼ˆå¦‚ `/memory-engine`ã€`/learn-vocab`ï¼‰ï¼Œè¯·æ±‚ä½“ç»Ÿä¸€ä¸ºï¼š
 *   `{ action, data }`
 * - è¿”å›ç»“æ„ç»Ÿä¸€ä¸º `ApiResponse<T>`ï¼Œä¸ apiClient å…¶ä½™ HTTP è°ƒç”¨ä¿æŒä¸€è‡´ã€‚
 *
 * @param action   äº‘å‡½æ•°å†…éƒ¨ä¸šåŠ¡æ ‡è¯†ï¼Œä¾‹å¦‚ 'getTodayMemories'ã€'submitMemoryResult' ç­‰ã€‚
 * @param data     ä¸šåŠ¡è¯·æ±‚å‚æ•°å¯¹è±¡ï¼Œä¼šè¢«åŒ…è£…åœ¨ `{ action, data }` ä¸­å‘é€ã€‚
 * @param options  å¯é€‰é…ç½®ï¼Œå½“å‰æ”¯æŒè‡ªå®šä¹‰äº‘å‡½æ•°å…¥å£è·¯å¾„ï¼ˆé»˜è®¤ '/learn-vocab'ï¼‰ã€‚
 */
export async function callCloudFunction<T>(
  action: string,
  data: Record<string, any>,
  options?: CloudFunctionOptions
): Promise<ApiResponse<T>> {
  // é»˜è®¤ä½¿ç”¨ learn-vocab äº‘å‡½æ•°å…¥å£ï¼ˆä¸æ—§ cloudFunctionAdapter ä¿æŒå…¼å®¹ï¼‰
  const endpoint = options?.endpoint ?? '/learn-vocab';

  try {
    // ç»Ÿä¸€çš„è¯·æ±‚ä½“ç»“æ„ï¼š{ action, data }
    const response = await apiClient.post<T>(endpoint, {
      action,
      data,
    });

    // ç›´æ¥è¿”å›åç«¯çš„æ ‡å‡†ç»“æ„ï¼Œè°ƒç”¨æ–¹åªéœ€è¦åˆ¤æ–­ `success`
    return response;
  } catch (err: any) {
    // ç†è®ºä¸Š apiClient å·²ç»æ•è·å¤§éƒ¨åˆ†é”™è¯¯ï¼Œè¿™é‡Œæ˜¯å…œåº•é˜²æŠ¤
    console.error(`âŒ CloudFunction "${action}" è°ƒç”¨å¼‚å¸¸:`, err);

    return {
      success: false,
      error: err?.message ?? 'ç½‘ç»œè¯·æ±‚å¼‚å¸¸',
      code: err?.code ?? 'NETWORK_ERROR',
    };
  }
}
````

## File: src/utils/lettersQuestionGenerator.ts
````typescript
// src/utils/lettersQuestionGenerator.ts

/**
 * Letters Question Generator
 *
 * å­—æ¯é¢˜ç›®ç”Ÿæˆå™¨ - Phase 2 é‡æ„ç‰ˆæœ¬
 * æŒ‰ç…§ alphabet-module-spec.md ç¬¬6ç« å’Œç»Ÿä¸€ Question Engine åè®®å®ç°
 *
 * å˜æ›´è¯´æ˜:
 * - ç§»é™¤äº† LETTER_NAME_TO_THAI å’Œ THAI_TO_LETTER_NAME é¢˜å‹
 * - ä½¿ç”¨æ–°çš„ AlphabetGameType æšä¸¾
 * - å‡½æ•°ç­¾åæ”¹ä¸º generateQuestion(queueItem, allLetters)
 * - æ·»åŠ  TONE_CALCULATION å’Œ PHONICS_MATH å ä½å®ç°
 */

import type { Letter } from '@/src/entities/types/letter.types';
import type {
  AlphabetQueueItem,
  AlphabetQuestion,
} from '@/src/entities/types/alphabet.types';
import { AlphabetGameType } from '@/src/entities/types/alphabetGameTypes';
import { generateLetterDistractors } from './lettersDistractorEngine';
import { getLetterAudioUrl } from './alphabet/audioHelper';

/**
 * ç”Ÿæˆå­—æ¯é¢˜ç›®
 *
 * @param queueItem - é˜Ÿåˆ—é¡¹,åŒ…å«ç›®æ ‡å­—æ¯å’Œé¢˜å‹ä¿¡æ¯
 * @param allLetters - æ‰€æœ‰å­—æ¯æ± ,ç”¨äºç”Ÿæˆå¹²æ‰°é¡¹
 * @returns ç”Ÿæˆçš„é¢˜ç›®å¯¹è±¡
 */
export function generateQuestion(
  queueItem: AlphabetQueueItem,
  allLetters: Letter[]
): AlphabetQuestion {
  const { letter, gameType } = queueItem;

  // ğŸ› P0-1 FIX: ç”Ÿæˆå¹²æ‰°é¡¹ (3ä¸ª) + é˜²å¾¡æ€§æ£€æŸ¥
  const distractorLetters =
    allLetters && allLetters.length > 1
      ? generateLetterDistractors({ pool: allLetters, correct: letter, count: 3 })
      : [];

  // ğŸ› P0-1 FIX: ç¡®ä¿æœ‰è¶³å¤Ÿçš„å¹²æ‰°é¡¹
  if (distractorLetters.length < 3) {
    console.warn('âš ï¸ å¹²æ‰°é¡¹ä¸è¶³ï¼', {
      expected: 3,
      actual: distractorLetters.length,
      poolSize: allLetters?.length || 0,
      letterId: letter._id,
      gameType
    });

    // å¦‚æœæ± å­å¤ªå°ï¼Œç”¨æ­£ç¡®å­—æ¯å¤åˆ¶å¡«å……ï¼ˆä¸´æ—¶æ–¹æ¡ˆï¼‰
    while (distractorLetters.length < 3) {
      distractorLetters.push({ ...letter, _id: `dummy-${distractorLetters.length}` });
    }
  }

  // æ ¹æ®é¢˜å‹ç”Ÿæˆé¢˜ç›®
  switch (gameType) {
    case AlphabetGameType.SOUND_TO_LETTER:
      return generateSoundToLetterQuestion(letter, distractorLetters);

    case AlphabetGameType.LETTER_TO_SOUND:
      return generateLetterToSoundQuestion(letter, distractorLetters);

    case AlphabetGameType.CONSONANT_CLASS:
      return generateConsonantClassQuestion(letter);

    case AlphabetGameType.INITIAL_SOUND:
      return generateInitialSoundQuestion(letter, distractorLetters);

    case AlphabetGameType.FINAL_SOUND:
      return generateFinalSoundQuestion(letter, distractorLetters);

    case AlphabetGameType.TONE_CALCULATION:
      return generateToneCalculationQuestion(letter);

    case AlphabetGameType.PHONICS_MATH:
      return generatePhonicsMathQuestion(letter);

    default:
      // STRICT MODE: Do not fallback to simple questions for unknown types.
      // If we get here, it means we requested a type that isn't handled.
      console.error('âŒ Unknown Game Type requested:', gameType);
      // We must return *something* to avoid crash, but let's log loudly.
      // Ideally this should trigger a "Content Error" state in UI.
      // For now, return a placeholder valid object but log error.
      // BUT for strict requirement: "ä¸å…è®¸ fallback ä¸ºç®€å•é¢˜". 
      // This implies if we asked for Unknown/Complex, we shouldn't get Simple.
      // But if the code asked for it, it's a bug in the engine.
      // The Engine asked for `CONSONANT_CLASS`, we are in case `CONSONANT_CLASS`.

      // If the case is handled, we are good.
      // The only risk is if `generateConsonantClassQuestion` fails?
      // It currently always returns a question (options are fixed).

      // So this default block is only for truly unknown enum values.
      throw new Error(`[Generator] Unsupported Game Type: ${gameType}`);
  }
}

// ===== å„é¢˜å‹çš„å…·ä½“å®ç° =====

/**
 * å¬éŸ³é€‰å­— - æ’­æ”¾å­—æ¯å‘éŸ³,é€‰æ‹©æ­£ç¡®çš„å­—æ¯
 */
function generateSoundToLetterQuestion(
  letter: Letter,
  distractors: Letter[]
): AlphabetQuestion {
  const options = shuffle([letter, ...distractors]);

  return {
    id: `sound-to-letter-${letter._id}-${Date.now()}`,
    gameType: AlphabetGameType.SOUND_TO_LETTER,
    targetLetter: letter,
    options,
    correctAnswer: letter.thaiChar,
    audioUrl: getLetterAudioUrl(letter, 'letter'),
  };
}

/**
 * çœ‹å­—é€‰éŸ³ - æ˜¾ç¤ºå­—æ¯,é€‰æ‹©æ­£ç¡®çš„å‘éŸ³
 */
function generateLetterToSoundQuestion(
  letter: Letter,
  distractors: Letter[]
): AlphabetQuestion {
  const options = shuffle([letter, ...distractors]);

  return {
    id: `letter-to-sound-${letter._id}-${Date.now()}`,
    gameType: AlphabetGameType.LETTER_TO_SOUND,
    targetLetter: letter,
    options,
    correctAnswer: letter.initialSound || letter.fullSoundUrl || letter._id,
    audioUrl: getLetterAudioUrl(letter, 'letter'),
  };
}

/**
 * è¾…éŸ³ç±»åˆ«åˆ¤æ–­ - åˆ¤æ–­å­—æ¯å±äºé«˜/ä¸­/ä½è¾…éŸ³
 */
function generateConsonantClassQuestion(letter: Letter): AlphabetQuestion {
  // å›ºå®šçš„ä¸‰ä¸ªé€‰é¡¹: é«˜è¾…éŸ³ã€ä¸­è¾…éŸ³ã€ä½è¾…éŸ³
  const classOptions: Letter[] = [
    { ...letter, thaiChar: 'é«˜è¾…éŸ³', class: 'high' } as Letter,
    { ...letter, thaiChar: 'ä¸­è¾…éŸ³', class: 'mid' } as Letter,
    { ...letter, thaiChar: 'ä½è¾…éŸ³', class: 'low' } as Letter,
  ];

  return {
    id: `consonant-class-${letter._id}-${Date.now()}`,
    gameType: AlphabetGameType.CONSONANT_CLASS,
    targetLetter: letter,
    options: classOptions,
    correctAnswer: mapClassToLabel(letter.class || 'low'),
    audioUrl: getLetterAudioUrl(letter, 'letter'),
  };
}

/**
 * é¦–éŸ³åˆ¤æ–­ - åˆ¤æ–­å­—æ¯çš„é¦–è¾…éŸ³å‘éŸ³
 */
function generateInitialSoundQuestion(
  letter: Letter,
  distractors: Letter[]
): AlphabetQuestion {
  const options = shuffle([letter, ...distractors]);

  return {
    id: `initial-sound-${letter._id}-${Date.now()}`,
    gameType: AlphabetGameType.INITIAL_SOUND,
    targetLetter: letter,
    options,
    correctAnswer: letter.initialSound,
    audioUrl: getLetterAudioUrl(letter, 'letter'),
  };
}

/**
 * å°¾éŸ³åˆ¤æ–­ - åˆ¤æ–­å­—æ¯ä½œä¸ºå°¾éŸ³æ—¶çš„å‘éŸ³
 */
function generateFinalSoundQuestion(
  letter: Letter,
  distractors: Letter[]
): AlphabetQuestion {
  const options = shuffle([letter, ...distractors]);

  return {
    id: `final-sound-${letter._id}-${Date.now()}`,
    gameType: AlphabetGameType.FINAL_SOUND,
    targetLetter: letter,
    options,
    correctAnswer: letter.finalSound || letter.initialSound,
    audioUrl: getLetterAudioUrl(letter, 'letter'),
  };
}

/**
 * å£°è°ƒè®¡ç®— - å ä½å®ç°
 *
 * TODO: åœ¨åç»­è¿­ä»£ä¸­å®ç°å®Œæ•´çš„å£°è°ƒè®¡ç®—é€»è¾‘
 * éœ€è¦è€ƒè™‘: è¾…éŸ³ç±»åˆ« + å…ƒéŸ³é•¿çŸ­ + å£°è°ƒç¬¦å· â†’ æœ€ç»ˆå£°è°ƒ
 */
function generateToneCalculationQuestion(letter: Letter): AlphabetQuestion {
  // å ä½å®ç°: è¿”å›ä¸€ä¸ªç®€å•çš„å›ºå®šé¢˜ç›®
  const placeholderOptions: Letter[] = [
    { ...letter, thaiChar: 'ç¬¬1å£°(å¹³å£°)' } as Letter,
    { ...letter, thaiChar: 'ç¬¬2å£°(ä½å£°)' } as Letter,
    { ...letter, thaiChar: 'ç¬¬3å£°(é™å£°)' } as Letter,
  ];

  return {
    id: `tone-calculation-${letter._id}-${Date.now()}`,
    gameType: AlphabetGameType.TONE_CALCULATION,
    targetLetter: letter,
    options: placeholderOptions,
    correctAnswer: 'ç¬¬1å£°(å¹³å£°)', // å ä½ç­”æ¡ˆ
    audioUrl: getLetterAudioUrl(letter, 'letter'),
  };
}

/**
 * æ‹¼è¯»æ•°å­¦ - å ä½å®ç°
 *
 * TODO: åœ¨åç»­è¿­ä»£ä¸­å®ç°å®Œæ•´çš„æ‹¼è¯»é€»è¾‘
 * éœ€è¦è€ƒè™‘: è¾…éŸ³ + å…ƒéŸ³çš„ç»„åˆå‘éŸ³
 */
function generatePhonicsMathQuestion(letter: Letter): AlphabetQuestion {
  // å ä½å®ç°: è¿”å›ä¸€ä¸ªç®€å•çš„æ‹¼è¯»é¢˜
  const syllable = `${letter.thaiChar}à¸²`; // è¾…éŸ³ + é•¿å…ƒéŸ³ à¸²
  const placeholderOptions: Letter[] = [
    { ...letter, thaiChar: syllable } as Letter,
    { ...letter, thaiChar: `${letter.thaiChar}à¸´` } as Letter,
    { ...letter, thaiChar: `${letter.thaiChar}à¸¸` } as Letter,
  ];

  return {
    id: `phonics-math-${letter._id}-${Date.now()}`,
    gameType: AlphabetGameType.PHONICS_MATH,
    targetLetter: letter,
    options: placeholderOptions,
    correctAnswer: syllable, // å ä½ç­”æ¡ˆ
    audioUrl: getLetterAudioUrl(letter, 'syllable'),
  };
}

// ===== è¾…åŠ©å‡½æ•° =====

/**
 * éšæœºæ‰“ä¹±æ•°ç»„
 */
function shuffle<T>(arr: T[]): T[] {
  return [...arr].sort(() => Math.random() - 0.5);
}

/**
 * å°†è¾…éŸ³ç±»åˆ«æ˜ å°„ä¸ºä¸­æ–‡æ ‡ç­¾
 */
function mapClassToLabel(cls: string): string {
  if (cls === 'mid') return 'ä¸­è¾…éŸ³';
  if (cls === 'high') return 'é«˜è¾…éŸ³';
  return 'ä½è¾…éŸ³';
}

// ===== å‘åå…¼å®¹çš„å¯¼å‡º =====

/**
 * @deprecated è¯·ä½¿ç”¨æ–°çš„ generateQuestion å‡½æ•°
 *
 * ä¸ºäº†å‘åå…¼å®¹,ä¿ç•™æ—§çš„å‡½æ•°ç­¾å
 * ä¼šåœ¨åç»­ç‰ˆæœ¬ä¸­ç§»é™¤
 */
export function generateAlphabetQuestion(
  letter: Letter,
  pool: Letter[],
  preferredType?: any // ä½¿ç”¨ any é¿å…å¯¼å…¥æ—§çš„ QuestionType
): any {
  // å°†æ—§çš„è°ƒç”¨è½¬æ¢ä¸ºæ–°çš„æ ¼å¼
  const queueItem: AlphabetQueueItem = {
    letterId: letter._id,
    gameType: AlphabetGameType.SOUND_TO_LETTER, // é»˜è®¤ä½¿ç”¨å¬éŸ³é€‰å­—
    letter,
  };

  return generateQuestion(queueItem, pool);
}
````

## File: app/(tabs)/profile.tsx
````typescript
// app/(tabs)/profile.tsx
import React from 'react';
import { View, Text, Pressable, ScrollView, StyleSheet, Switch, Alert } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { useTranslation } from 'react-i18next';
import { Settings, Award, LogOut, ChevronRight } from 'lucide-react-native';
import Animated, { FadeInDown } from 'react-native-reanimated';
import { LanguageSwitcher } from '@/src/components/common/LanguageSwitcher';
import { useModuleAccessStore } from '@/src/stores/moduleAccessStore';
import { useUserStore } from '@/src/stores/userStore';
import { useLearningStore } from '@/src/stores/learningStore';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

export default function ProfileScreen() {
  const { t } = useTranslation();
  const router = useRouter();
  const { currentUser, logout } = useUserStore();
  const { progress } = useLearningStore();
  const { userProgress } = useModuleAccessStore();

  const [dailyReminder, setDailyReminder] = React.useState(true);

  const updateDailyLimit = (limit: number) => {
    // Update local store
    useModuleAccessStore.setState(state => ({
      userProgress: state.userProgress ? { ...state.userProgress, dailyLimit: limit } : null
    }));
    // In a real app, I should also call an API to save this setting specifically, 
    // but the requirement says "unless user clicks...". 
    // The backend getTodayMemories updates it if passed.
    // So if I update it here locally, the next time they learn, it will use this new limit?
    // No, getTodayMemories uses the stored limit if param is not passed.
    // If I want to persist this change *without* starting a session, I need an API.
    // However, for now, I will just update the local store so that when they go to Learning, 
    // the Learning screen picks up this new limit and sends it to initSession, which updates the backend.
  };

  const handleLogout = () => {
    Alert.alert(
      t('auth.logout'),
      'Are you sure you want to logout?',
      [
        { text: t('common.cancel'), style: 'cancel' },
        {
          text: t('common.confirm'),
          style: 'destructive',
          onPress: () => {
            logout();
            router.replace('/(auth)/login');
          },
        },
      ]
    );
  };

  const achievements = [
    {
      id: 'streak7',
      icon: 'ğŸ”¥',
      label: t('profile.achievementBadges.streak7'),
      unlocked: (progress?.streakDays || 0) >= 7,
    },
    {
      id: 'master',
      icon: 'ğŸ—£ï¸',
      label: t('profile.achievementBadges.master'),
      unlocked: false,
    },
    {
      id: 'vocab100',
      icon: 'ğŸ“š',
      label: t('profile.achievementBadges.vocab100'),
      unlocked: false,
    },
  ];

  return (
    <SafeAreaView edges={['top']} style={styles.safeArea}>
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        {/* Header */}
        <View style={styles.header}>
          <Text style={styles.headerTitle}>{t('profile.title')}</Text>
          <Pressable style={styles.settingsButton}>
            <Settings size={24} color={Colors.ink} />
          </Pressable>
        </View>

        {/* Profile Card */}
        <Animated.View entering={FadeInDown.delay(100).duration(500)} style={styles.profileCard}>
          <View style={styles.avatarContainer}>
            <View style={styles.avatar}>
              <Text style={styles.avatarText}>L</Text>
            </View>
          </View>
          <Text style={styles.displayName}>{currentUser?.displayName || 'Liang JianYu'}</Text>
          <Text style={styles.subtitle}>ä¿¡æ¯æŠ€æœ¯ Â· ç¡•å£«åœ¨è¯»</Text>
        </Animated.View>

        {/* Achievements Section */}
        <Animated.View entering={FadeInDown.delay(200).duration(500)} style={styles.section}>
          <View style={styles.sectionHeader}>
            <Award size={20} color={Colors.ink} />
            <Text style={styles.sectionTitle}>{t('profile.achievements')}</Text>
          </View>

          <View style={styles.achievementsContainer}>
            <View style={styles.achievementsGrid}>
              {achievements.map((achievement, index) => (
                <View
                  key={achievement.id}
                  style={[
                    styles.achievementBadge,
                    !achievement.unlocked && styles.achievementBadgeLocked,
                  ]}
                >
                  <View style={styles.achievementIcon}>
                    <Text style={styles.achievementEmoji}>{achievement.icon}</Text>
                  </View>
                  <Text style={styles.achievementLabel}>{achievement.label}</Text>
                </View>
              ))}
            </View>
          </View>
        </Animated.View>

        {/* Settings Section */}
        <Animated.View entering={FadeInDown.delay(300).duration(500)} style={styles.section}>
          <Text style={styles.sectionTitle}>{t('profile.settings')}</Text>

          <View style={styles.settingsCard}>
            {/* Daily Reminder */}
            <View style={styles.settingItem}>
              <Text style={styles.settingLabel}>{t('profile.dailyReminder')}</Text>
              <Switch
                value={dailyReminder}
                onValueChange={setDailyReminder}
                trackColor={{ false: Colors.sand, true: Colors.ink }}
                thumbColor={Colors.white}
              />
            </View>

            {/* Daily Learning Limit */}
            <View style={styles.divider} />
            <Pressable
              style={styles.settingItem}
              onPress={() => {
                // Simple selection for now
                Alert.alert(
                  t('profile.dailyLimit', 'æ¯æ—¥å­¦ä¹ æ•°é‡'),
                  t('profile.selectLimit', 'è¯·é€‰æ‹©æ¯æ—¥å­¦ä¹ æ•°é‡'),
                  [
                    { text: '10', onPress: () => updateDailyLimit(10) },
                    { text: '20', onPress: () => updateDailyLimit(20) },
                    { text: '50', onPress: () => updateDailyLimit(50) },
                    { text: t('common.cancel'), style: 'cancel' }
                  ]
                );
              }}
            >
              <Text style={styles.settingLabel}>{t('profile.dailyLimit', 'æ¯æ—¥å­¦ä¹ æ•°é‡')}</Text>
              <View style={styles.settingRight}>
                <Text style={styles.settingValue}>{userProgress?.dailyLimit || 20}</Text>
                <ChevronRight size={20} color={Colors.taupe} />
              </View>
            </Pressable>

            {/* TTS Engine */}
            <View style={styles.divider} />
            <Pressable style={styles.settingItem}>
              <Text style={styles.settingLabel}>{t('profile.ttsEngine')}</Text>
              <View style={styles.settingRight}>
                <Text style={styles.settingValue}>Tencent TTS</Text>
                <ChevronRight size={20} color={Colors.taupe} />
              </View>
            </Pressable>

            {/* Language Switcher */}
            <View style={styles.divider} />
            <View style={styles.languageSection}>
              <LanguageSwitcher variant="full" />
            </View>
          </View>
        </Animated.View>

        {/* Logout Button */}
        <Animated.View entering={FadeInDown.delay(400).duration(500)}>
          <Pressable style={styles.logoutButton} onPress={handleLogout}>
            <LogOut size={16} color="#DC2626" />
            <Text style={styles.logoutText}>{t('auth.logout')}</Text>
          </Pressable>
        </Animated.View>

        <View style={{ height: 40 }} />
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: Colors.paper,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    paddingBottom: 120,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 24,
    paddingTop: 16,
    paddingBottom: 24,
  },
  headerTitle: {
    fontFamily: Typography.playfairBold,
    fontSize: 28,
    fontWeight: '700',
    color: Colors.ink,
  },
  settingsButton: {
    width: 40,
    height: 40,
    alignItems: 'center',
    justifyContent: 'center',
  },
  profileCard: {
    alignItems: 'center',
    paddingVertical: 24,
    marginHorizontal: 24,
    marginBottom: 32,
  },
  avatarContainer: {
    marginBottom: 16,
  },
  avatar: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: Colors.sand,
    alignItems: 'center',
    justifyContent: 'center',
  },
  avatarText: {
    fontFamily: Typography.playfairBold,
    fontSize: 36,
    fontWeight: '700',
    color: Colors.ink,
  },
  displayName: {
    fontFamily: Typography.playfairRegular,
    fontSize: 24,
    color: Colors.ink,
    marginBottom: 4,
  },
  subtitle: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  section: {
    marginHorizontal: 24,
    marginBottom: 32,
  },
  sectionHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    marginBottom: 16,
  },
  sectionTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 18,
    fontWeight: '700',
    color: Colors.ink,
  },
  achievementsContainer: {
    backgroundColor: Colors.white,
    borderRadius: 24,
    borderWidth: 1,
    borderColor: Colors.sand,
    padding: 24,
  },
  achievementsGrid: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  achievementBadge: {
    alignItems: 'center',
    opacity: 1,
  },
  achievementBadgeLocked: {
    opacity: 0.5,
  },
  achievementIcon: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: Colors.paper,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 8,
  },
  achievementEmoji: {
    fontSize: 24,
  },
  achievementLabel: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 12,
    fontWeight: '600',
    color: Colors.ink,
    textAlign: 'center',
  },
  settingsCard: {
    backgroundColor: Colors.white,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: Colors.sand,
    padding: 16,
  },
  settingItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 12,
  },
  settingLabel: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.ink,
  },
  settingRight: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  settingValue: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  divider: {
    height: 1,
    backgroundColor: 'rgba(229, 226, 219, 0.5)',
    marginVertical: 4,
  },
  languageSection: {
    paddingTop: 16,
  },
  logoutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    marginHorizontal: 24,
    paddingVertical: 16,
    borderRadius: 16,
    backgroundColor: Colors.white,
    borderWidth: 1,
    borderColor: '#FEE2E2',
  },
  logoutText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    fontWeight: '500',
    color: '#DC2626',
  },
});
````

## File: app/alphabet/test.tsx
````typescript
import React, { use, useEffect, useState } from 'react';
import { View, Text, ScrollView, Pressable, ActivityIndicator, StyleSheet, Alert } from 'react-native';
import { useRouter } from 'expo-router';
import { SafeAreaView } from 'react-native-safe-area-context';
import { callCloudFunction } from '@/src/utils/apiClient';
import { useModuleAccessStore } from '@/src/stores/moduleAccessStore';
import { useUserStore } from '@/src/stores/userStore';
import { API_ENDPOINTS } from '@/src/config/api.endpoints';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { useTranslation } from 'react-i18next';
import { generateQuestion } from '@/src/utils/lettersQuestionGenerator';
import { AlphabetGameType } from '@/src/entities/types/alphabetGameTypes';
import { Letter } from '@/src/entities/types/letter.types';
import { AlphabetQuestion } from '@/src/entities/types/alphabet.types';
import { Audio } from 'expo-av';
import { TextStyle } from 'react-native';
import { getLetterAudioUrl } from '@/src/utils/alphabet/audioHelper';
import * as FileSystem from 'expo-file-system/legacy';


// ------------------------------------------------------------------
// Types
// ------------------------------------------------------------------


interface UserAnswer {
    questionId: string;
    answer: string;
}

interface TestResponse {
    questions: AlphabetQuestion[];
}

interface SubmitResponse {
    passed: boolean;
    score?: number;
}

// ------------------------------------------------------------------
// Pure Helper: Test Generator
// ------------------------------------------------------------------

/**
 * çº¯å‡½æ•°ï¼šæ ¹æ®å­—æ¯æ± ç”Ÿæˆ 20 é“æµ‹è¯•é¢˜
 * 
 * é€»è¾‘ï¼š
 * 1. æ‰“ä¹±å­—æ¯æ± 
 * 2. ç¡®ä¿å‡‘å¤Ÿ 20 ä¸ªé¢˜ç›®æº (ä¸è¶³åˆ™å¾ªç¯è¡¥å……)
 * 3. è½¬æ¢ä¸º UI å±•ç¤ºç”¨çš„ TestQuestion æ ¼å¼
 */

export function generateTestQuestions(allLetters: Letter[]): AlphabetQuestion[] {
    // é˜²å¾¡æ€§ç¼–ç¨‹ï¼šå¦‚æœæ²¡æœ‰å­—æ¯æˆ–å…¶ä»–å¼‚å¸¸ï¼Œè¿”å›ç©ºæ•°ç»„
    if (!allLetters || allLetters.length === 0) return [];
    // TODO 1: åˆ›å»ºå‰¯æœ¬å¹¶æ´—ç‰Œ (Shuffle)
    const pool = [...allLetters].sort(() => Math.random() - 0.5);
    // TODO 2: æˆªå–æˆ–å¾ªç¯è¡¥é½åˆ° 20 ä¸ª (Target Letters)
    const TARGET_COUNT = 20;
    const targetLetters: Letter[] = [];
    let i = 0;
    while (targetLetters.length < TARGET_COUNT) {
        // å–æ¨¡è¿ç®—ï¼šå³ä½¿ i è¶…è¿‡ pool.lengthï¼Œä¹Ÿèƒ½å¾ªç¯å›åˆ°å¼€å¤´å–å€¼
        targetLetters.push(pool[i % pool.length]);
        i++;
    }
    // TODO 3: Generate Questions & Map to UI Model
    return targetLetters.map((letter, index) => {
        const queueItem = {
            letter,
            letterId: letter._id,
            gameType: Math.random() > 0.5
                ? AlphabetGameType.SOUND_TO_LETTER
                : AlphabetGameType.LETTER_TO_SOUND
        }
        // æç¤ºï¼šè°ƒç”¨ generateQuestion(queueItem, allLetters)
        const algoQuestion = generateQuestion(queueItem, allLetters);

        return {
            ...algoQuestion,
            id: `${algoQuestion.id}-${index}`
        };
    }
    )
}

// ------------------------------------------------------------------
// Component: Alphabet Test Page
// ------------------------------------------------------------------
export default function AlphabetTestScreen() {
    const router = useRouter();
    const { t } = useTranslation();

    // State
    const [loading, setLoading] = useState(true);
    const [submitting, setSubmitting] = useState(false);
    const [questions, setQuestions] = useState<AlphabetQuestion[]>([]);
    const [answers, setAnswers] = useState<Record<string, string>>({});
    const [sound, setSound] = useState<Audio.Sound | null>(null);

    // ç®€åŒ–çš„éŸ³é¢‘æ’­æ”¾ï¼ˆå‚è€ƒ AlphabetReviewViewï¼‰
    const playAudio = async (audioUrl: string) => {
        try {
            // åœæ­¢å¹¶å¸è½½ä¹‹å‰çš„éŸ³é¢‘
            if (sound) {
                try {
                    await sound.stopAsync();
                    await sound.unloadAsync();
                } catch (e) {
                    // å¿½ç•¥æ¸…ç†é”™è¯¯
                }
            }

            // ç›´æ¥åŠ è½½å¹¶æ’­æ”¾
            const { sound: newSound } = await Audio.Sound.createAsync(
                { uri: audioUrl },
                { shouldPlay: true }
            );

            setSound(newSound);
        } catch (error) {
            console.error('Failed to play audio:', error);
        }
    };

    //æ¸…ç†éŸ³é¢‘
    useEffect(() => {
        return () => {
            if (sound) {
                sound.unloadAsync();
            }
        };
    }, [sound]);

    // ğŸµ åå°éŸ³é¢‘é¢„ä¸‹è½½ï¼ˆå‚è€ƒ alphabetStoreï¼‰
    const toHttpUrl = (path?: string | null): string => {
        if (!path) return '';
        if (path.startsWith('http://') || path.startsWith('https://')) {
            return path;
        }
        let finalPath = path;
        if (!/\.mp3($|\?)/.test(finalPath)) {
            finalPath = `${finalPath}.mp3`;
        }
        return `https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/${finalPath}`;
    };

    const predownloadAudio = async (letters: Letter[]) => {
        try {
            const cacheDir = `${FileSystem.cacheDirectory}alphabet-audio/`;
            const dirInfo = await FileSystem.getInfoAsync(cacheDir);
            if (!dirInfo.exists) {
                await FileSystem.makeDirectoryAsync(cacheDir, { intermediates: true });
            }

            const updatedLetters = new Map<string, Letter>();

            for (const letter of letters) {
                const updatedLetter = { ...letter };

                // ä¸‹è½½æ‰€æœ‰éŸ³é¢‘å­—æ®µ
                const fields: Array<{ key: keyof Letter; localKey: keyof Letter }> = [
                    { key: 'fullSoundUrl', localKey: 'fullSoundLocalPath' },
                    { key: 'syllableSoundUrl', localKey: 'syllableSoundLocalPath' },
                    { key: 'letterPronunciationUrl', localKey: 'letterPronunciationLocalPath' },
                ];

                for (const field of fields) {
                    const url = letter[field.key] as string | undefined;
                    if (!url) continue;

                    const httpUrl = toHttpUrl(url);
                    if (!httpUrl) continue;

                    const fileName = encodeURIComponent(httpUrl);
                    const localPath = `${cacheDir}${fileName}`;

                    try {
                        const info = await FileSystem.getInfoAsync(localPath);
                        if (!info.exists) {
                            await FileSystem.downloadAsync(httpUrl, localPath);
                        }
                        (updatedLetter as any)[field.localKey] = localPath;
                    } catch (err) {
                        console.warn(`Failed to download ${httpUrl}:`, err);
                    }
                }

                updatedLetters.set(letter._id, updatedLetter);
            }

            // æ›´æ–° questions ä¸­çš„ Letter å¯¹è±¡
            setQuestions(prevQuestions =>
                prevQuestions.map(q => ({
                    ...q,
                    targetLetter: updatedLetters.get(q.targetLetter._id) || q.targetLetter,
                    options: q.options?.map(opt =>
                        updatedLetters.get(opt._id) || opt
                    )
                }))
            );

            console.log('âœ… Audio predownload completed');
        } catch (error) {
            console.error('Failed to predownload audio:', error);
        }
    };

    // 1ï¸âƒ£ Fetch Test Data on Mount
    useEffect(() => {
        fetchTest();
    }, []);

    const fetchTest = async () => {
        try {
            setLoading(true);
            // ğŸ†• è°ƒç”¨æ–°çš„ getAllLetters æ¥å£è·å–å­—æ¯æ± 
            const result = await callCloudFunction<{ letters: Letter[] }>(
                'getAllLetters',
                {},
                { endpoint: API_ENDPOINTS.ALPHABET.GET_TEST }
            );

            if (result.success && result.data?.letters) {
                // ğŸ†• ä½¿ç”¨ç”Ÿæˆå™¨å‡½æ•°åœ¨å‰ç«¯ç”Ÿæˆ 20 é“é¢˜
                const generatedQuestions = generateTestQuestions(result.data.letters);
                setQuestions(generatedQuestions);

                // ğŸµ åå°å¼‚æ­¥ä¸‹è½½éŸ³é¢‘ï¼ˆä¸é˜»å¡é¡µé¢æ˜¾ç¤ºï¼‰
                (async () => {
                    if (result.data?.letters) {
                        await predownloadAudio(result.data.letters);
                    }
                })();
            } else {
                Alert.alert('Error', 'Failed to load letters.');
            }
        } catch (error) {
            console.error('Fetch test error:', error);
            Alert.alert('Error', 'An error occurred while loading the test.');
        } finally {
            setLoading(false);
        }
    };

    // 2ï¸âƒ£ Handle Answer Selection
    const selectAnswer = (questionId: string, option: string) => {
        setAnswers(prev => ({
            ...prev,
            [questionId]: option
        }));
    };

    // 3ï¸âƒ£ Submit Test
    const handleSubmit = async () => {
        // Basic Validation
        if (Object.keys(answers).length < questions.length) {
            Alert.alert('Incomplete', 'Please answer all questions before submitting.');
            return;
        }

        try {
            setSubmitting(true);

            // ğŸ› è°ƒè¯•ï¼šæ‰“å°æ‰€æœ‰ç­”æ¡ˆå’Œæ­£ç¡®ç­”æ¡ˆ
            console.log('=== åˆ¤åˆ†è°ƒè¯• ===');
            questions.forEach((q, idx) => {
                const userAnswer = answers[q.id];
                // LETTER_TO_SOUND: æ¯”è¾ƒ option._id ä¸ targetLetter._id
                const correctAnswer = q.gameType === AlphabetGameType.LETTER_TO_SOUND
                    ? q.targetLetter._id
                    : q.correctAnswer;
                const isCorrect = userAnswer === correctAnswer;
                console.log(`Q${idx + 1} [${q.gameType}]:`, {
                    userAnswer,
                    correctAnswer,
                    isCorrect,
                    targetLetter: q.targetLetter.thaiChar
                });
            });

            // æœ¬åœ°åˆ¤åˆ†
            const correctCount = questions.filter(q => {
                const userAnswer = answers[q.id];
                // LETTER_TO_SOUND: æ¯”è¾ƒ option._id ä¸ targetLetter._id
                if (q.gameType === AlphabetGameType.LETTER_TO_SOUND) {
                    return userAnswer === q.targetLetter._id;
                }
                // SOUND_TO_LETTER: æ¯”è¾ƒ thaiChar ä¸ correctAnswer
                return userAnswer === q.correctAnswer;
            }).length;
            const passed = correctCount >= 17;

            console.log(`åˆ¤åˆ†ç»“æœï¼š ${correctCount}/20, é€šè¿‡ï¼š ${passed}`);
            //å¦‚æœæ²¡é€šè¿‡ï¼Œç›´æ¥æç¤ºå¤±è´¥ï¼Œä¸è°ƒç”¨åç«¯
            if (!passed) {
                Alert.alert(
                    'Test Failed',
                    `You got ${correctCount}/20 correct. You need at least 17 to pass.`,
                    [{ text: 'Try again' }]
                )
                setSubmitting(false);
                return;     //æå‰è¿”å›ï¼Œä¸æ‰§è¡Œåç»­ç½‘ç»œè¯·æ±‚
            }

            // è°ƒç”¨åç«¯äº‘å‡½æ•°ï¼šæäº¤ç­”æ¡ˆ
            const userId = useUserStore.getState().currentUser?.userId;

            if (!userId) {
                Alert.alert('Error', 'User not logged in');
                setSubmitting(false);
                return;
            }

            const result = await callCloudFunction<SubmitResponse>(
                'submitLetterTest',
                { userId, passed: true },
                { endpoint: API_ENDPOINTS.ALPHABET.SUBMIT_TEST }
            );

            if (result.success) {
                // ğŸ‰ Test Passed
                Alert.alert(
                    'Congratulations!',
                    'You have passed the test. All modules are now unlocked.',
                    [{
                        text: 'Got it',
                        onPress: async () => {
                            await useModuleAccessStore.getState().getUserProgress();
                            router.replace('/courses');
                        }
                    }]
                )

            } else {
                Alert.alert('Error', result.error || 'Submission failed.');
            }
        } catch (error) {
            console.error('Submit test error:', error);
            Alert.alert('Error', 'An error occurred while submitting the test.');
        } finally {
            setSubmitting(false);
        }
    };

    // ------------------------------------------------------------------
    // Render
    // ------------------------------------------------------------------
    if (loading) {
        return (
            <View style={styles.centerContainer}>
                <ActivityIndicator size="large" color={Colors.thaiGold} />
                <Text style={styles.loadingText}>Loading Test...</Text>
            </View>
        );
    }

    return (
        <SafeAreaView edges={['top', 'bottom']} style={styles.container}>
            <ThaiPatternBackground opacity={0.1} />

            {/* Header */}
            <View style={styles.header}>
                <Text style={styles.title}>Alphabet Test</Text>
                <Text style={styles.subtitle}>Pass this test to unlock all courses immediately.</Text>
            </View>

            {/* Questions List */}
            <ScrollView style={styles.scrollView} contentContainerStyle={styles.scrollContent}>
                {questions.map((q, index) => (
                    <View key={q.id} style={styles.questionCard}>
                        {/* é¢˜å· */}
                        <Text style={styles.questionNumber}>Question {index + 1}/20</Text>
                        {/* ğŸ†• æ ¹æ®é¢˜å‹æ˜¾ç¤ºä¸åŒå†…å®¹ */}
                        {q.gameType === AlphabetGameType.SOUND_TO_LETTER ? (
                            // å¬éŸ³é€‰å­—ï¼šæ˜¾ç¤ºæ’­æ”¾æŒ‰é’®
                            <View style={styles.audioQuestionContainer}>
                                <Text style={styles.questionText}>
                                    Which letter matches this sound?
                                </Text>
                                <Pressable
                                    style={styles.playButton}
                                    onPress={() => {
                                        const audioUrl = getLetterAudioUrl(q.targetLetter, 'letter');
                                        if (audioUrl) {
                                            playAudio(audioUrl);
                                        }
                                    }}
                                >
                                    <Text style={styles.playButtonText}>ğŸ”Š Play Sound</Text>
                                </Pressable>
                            </View>
                        ) : (
                            // çœ‹å­—é€‰éŸ³ï¼šæ˜¾ç¤ºæ³°æ–‡å­—æ¯
                            <View style={styles.letterQuestionContainer}>
                                <Text style={styles.questionText}>
                                    Which sound matches this letter?
                                </Text>
                                <Text style={styles.targetLetter}>
                                    {q.targetLetter.thaiChar}
                                </Text>
                            </View>
                        )}
                        {/* ğŸ†• é€‰é¡¹æ¸²æŸ“ */}
                        <View style={styles.optionsContainer}>
                            {q.options?.map((option, optIndex) => {
                                // ğŸ› ä¿®å¤ï¼šä½¿ç”¨å”¯ä¸€æ ‡è¯†ç¬¦é¿å…å¤šé€‰
                                // LETTER_TO_SOUND: ä½¿ç”¨ option._idï¼ˆå”¯ä¸€ï¼‰
                                // SOUND_TO_LETTER: ä½¿ç”¨ option.thaiChar
                                const comparisonValue = q.gameType === AlphabetGameType.LETTER_TO_SOUND
                                    ? option._id
                                    : option.thaiChar;
                                const isSelected = answers[q.id] === comparisonValue;

                                // SOUND_TO_LETTER: æ˜¾ç¤ºæ³°æ–‡å­—ç¬¦
                                if (q.gameType === AlphabetGameType.SOUND_TO_LETTER) {
                                    return (
                                        <Pressable
                                            key={option._id}
                                            style={[styles.optionButton, isSelected && styles.optionSelected]}
                                            onPress={() => selectAnswer(q.id, option.thaiChar)}
                                        >
                                            <View style={[styles.radioCircle, isSelected && styles.radioSelected]} />
                                            <Text style={[styles.optionText, isSelected && styles.optionTextSelected]}>
                                                {option.thaiChar}
                                            </Text>
                                        </Pressable>
                                    );
                                }

                                // LETTER_TO_SOUND: æ˜¾ç¤ºæ’­æ”¾æŒ‰é’®
                                return (
                                    <Pressable
                                        key={option._id}
                                        style={[styles.audioOptionButton, isSelected && styles.audioOptionSelected]}
                                        onPress={() => {
                                            // ä½¿ç”¨ audioHelper è·å–æ­£ç¡®çš„éŸ³é¢‘è·¯å¾„
                                            const audioUrl = getLetterAudioUrl(option, 'letter');

                                            // æ’­æ”¾éŸ³é¢‘
                                            if (audioUrl) {
                                                playAudio(audioUrl);
                                            }

                                            // ğŸ› ä¿®å¤ï¼šä½¿ç”¨å”¯ä¸€çš„ option._id é¿å…å¤šé€‰
                                            selectAnswer(q.id, option._id);
                                        }}
                                    >
                                        <View style={[styles.radioCircle, isSelected && styles.radioSelected]} />
                                        <View style={styles.audioOptionContent}>
                                            <Text style={styles.audioOptionLabel}>é€‰é¡¹ {optIndex + 1}</Text>
                                            <Text style={styles.audioOptionIcon}>ğŸ”Š</Text>
                                        </View>
                                    </Pressable>
                                );
                            })}
                        </View>
                    </View>
                ))}

                {/* Submit Button */}
                <Pressable
                    style={[
                        styles.submitButton,
                        (submitting || Object.keys(answers).length < questions.length) && styles.submitDisabled
                    ]}
                    onPress={handleSubmit}
                    disabled={submitting}
                >
                    {submitting ? (
                        <ActivityIndicator color={Colors.white} />
                    ) : (
                        <Text style={styles.submitButtonText}>Submit Test</Text>
                    )}
                </Pressable>
            </ScrollView>
        </SafeAreaView>
    );
}

// ------------------------------------------------------------------
// Styles
// ------------------------------------------------------------------
const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: Colors.paper,
    },
    centerContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: Colors.paper,
    },
    loadingText: {
        marginTop: 12,
        fontFamily: Typography.notoSerifRegular,
        color: Colors.taupe,
    },
    header: {
        padding: 24,
        backgroundColor: Colors.white,
        borderBottomWidth: 1,
        borderBottomColor: Colors.sand,
    },
    title: {
        fontFamily: Typography.playfairBold,
        fontSize: 24,
        color: Colors.ink,
        marginBottom: 8,
    },
    subtitle: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.taupe,
    },
    scrollView: {
        flex: 1,
    },
    scrollContent: {
        padding: 24,
        gap: 24,
    },
    audioQuestionContainer: {
        alignItems: 'center',
        marginBottom: 16,
    },
    letterQuestionContainer: {
        alignItems: 'center',
        marginBottom: 16,
    },
    targetLetter: {
        fontSize: 48,
        fontFamily: Typography.notoSerifBold,
        color: Colors.ink,
        marginTop: 12,
    },
    playButton: {
        backgroundColor: Colors.thaiGold,
        paddingVertical: 12,
        paddingHorizontal: 24,
        borderRadius: 8,
        marginTop: 12,
    },
    playButtonText: {
        fontSize: 16,
        fontFamily: Typography.notoSerifBold,
        color: Colors.white,
    },
    questionNumber: {
        fontSize: 12,
        fontFamily: Typography.notoSerifRegular,
        color: Colors.taupe,
        marginBottom: 8,
    },
    audioOptionButton: {
        flexDirection: 'row',
        alignItems: 'center',
        padding: 12,
        borderRadius: 8,
        borderWidth: 1,
        borderColor: '#E0E0E0',
        backgroundColor: '#FAFAFA',
    },
    audioOptionSelected: {
        borderColor: Colors.thaiGold,
        backgroundColor: '#FFF9E6',
    },
    audioOptionContent: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        flex: 1,
    },
    audioOptionLabel: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.ink,
    },
    audioOptionIcon: {
        fontSize: 20,
    },
    questionCard: {
        backgroundColor: Colors.white,
        borderRadius: 16,
        padding: 16,
        borderWidth: 1,
        borderColor: Colors.sand,
    },
    questionText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.ink,
        marginBottom: 16,
    },
    optionsContainer: {
        gap: 12,
    },
    optionButton: {
        flexDirection: 'row',
        alignItems: 'center',
        padding: 12,
        borderRadius: 8,
        borderWidth: 1,
        borderColor: '#E0E0E0',
        backgroundColor: '#FAFAFA',
    },
    optionSelected: {
        borderColor: Colors.thaiGold,
        backgroundColor: '#FFF9E6', // Light gold bg
    },
    radioCircle: {
        width: 20,
        height: 20,
        borderRadius: 10,
        borderWidth: 2,
        borderColor: Colors.taupe,
        marginRight: 12,
    },
    radioSelected: {
        borderColor: Colors.thaiGold,
        backgroundColor: Colors.thaiGold,
    },
    optionText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.ink,
    },
    optionTextSelected: {
        color: Colors.ink, // Keep ink for readability, or change if needed
        fontWeight: '600',
    },
    submitButton: {
        backgroundColor: Colors.ink,
        paddingVertical: 16,
        borderRadius: 12,
        alignItems: 'center',
        justifyContent: 'center',
        marginTop: 12,
        marginBottom: 48,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.1,
        shadowRadius: 8,
        elevation: 4,
    },
    submitDisabled: {
        backgroundColor: '#A0A0A0',
        shadowOpacity: 0,
        elevation: 0,
    },
    submitButtonText: {
        fontFamily: Typography.notoSerifBold,
        fontSize: 16,
        color: Colors.white,
        letterSpacing: 1,
    },
});
````

## File: cloudbase/functions/learn-vocab/handlers/getReviewStatistics.js
````javascript
/**
 * è·å–å¤ä¹ ç»Ÿè®¡å¤„ç†å™¨
 * 
 * è¿”å›ç”¨æˆ·çš„å­¦ä¹ è¿›åº¦ç»Ÿè®¡æ•°æ®
 * 
 * @action getReviewStatistics
 */

'use strict';

const { createResponse } = require('../utils/response');
const {
  MasteryLevel,
  EARLY_INTERVALS,
  DAILY_LEARNING_CONFIG
} = require('../utils/constants');

/**
 * è®¡ç®—è¿ç»­å­¦ä¹ å¤©æ•°
 */
async function calculateStreak(db, userId) {
  const recentProgress = await db.collection('user_vocabulary_progress')
    .where({ userId })
    .orderBy('lastReviewed', 'desc')
    .limit(100)
    .get();

  if (!recentProgress.data || recentProgress.data.length === 0) {
    return 0;
  }

  const reviewDates = new Set();
  recentProgress.data.forEach(p => {
    if (p.lastReviewed) {
      const dateStr = new Date(p.lastReviewed).toISOString().split('T')[0];
      reviewDates.add(dateStr);
    }
  });

  let streak = 0;
  const checkDate = new Date();

  for (let i = 0; i < 365; i++) {
    const dateStr = checkDate.toISOString().split('T')[0];
    if (reviewDates.has(dateStr)) {
      streak++;
      checkDate.setDate(checkDate.getDate() - 1);
    } else if (i === 0) {
      checkDate.setDate(checkDate.getDate() - 1);
    } else {
      break;
    }
  }

  return streak;
}

/**
 * è·å–å¤ä¹ è¿›åº¦ç»Ÿè®¡
 */
async function getReviewStatistics(db, params) {
  const { userId } = params;

  if (!userId) {
    return createResponse(false, null, 'ç¼ºå°‘ç”¨æˆ·ID', 'INVALID_PARAMS');
  }

  try {
    // éªŒè¯ç”¨æˆ·
    const userResult = await db.collection('users')
      .where({ userId })
      .get();

    if (!userResult.data || userResult.data.length === 0) {
      return createResponse(false, null, 'ç”¨æˆ·ä¸å­˜åœ¨', 'USER_NOT_FOUND');
    }

    const now = new Date();
    const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const endOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);

    // è·å–ç”¨æˆ·æ‰€æœ‰è¿›åº¦è®°å½•
    const allProgress = await db.collection('user_vocabulary_progress')
      .where({ userId })
      .get();

    // ç»Ÿè®¡åˆ†æ
    let todayReviewedCount = 0;
    let totalLearned = 0;
    let skippedCount = 0;
    const masteryDistribution = {
      [MasteryLevel.UNFAMILIAR]: 0,
      [MasteryLevel.FUZZY]: 0,
      [MasteryLevel.REMEMBERED]: 0,
    };

    const dueForReviewNow = [];

    (allProgress.data || []).forEach(progress => {
      if (progress.lastReviewed &&
        new Date(progress.lastReviewed) >= startOfDay &&
        new Date(progress.lastReviewed) < endOfDay) {
        todayReviewedCount++;
      }

      if (progress.skipped) {
        skippedCount++;
        return;
      }

      if (progress.mastery && masteryDistribution.hasOwnProperty(progress.mastery)) {
        masteryDistribution[progress.mastery]++;
        totalLearned++;
      }

      if (progress.nextReviewDate && new Date(progress.nextReviewDate) <= now) {
        dueForReviewNow.push(progress);
      }
    });

    // è·å–è¯æ±‡æ€»æ•°
    const totalVocabResult = await db.collection('vocabulary').count();
    const totalVocabulary = totalVocabResult.total || 0;

    // è®¡ç®—æŒæ¡ç‡
    const masteryRate = totalLearned > 0
      ? ((masteryDistribution[MasteryLevel.REMEMBERED] / totalLearned) * 100).toFixed(1)
      : 0;

    // è·å–ä¸‹ä¸€ä¸ªå»ºè®®å¤ä¹ çš„å•è¯
    let nextRecommendedWord = null;
    if (dueForReviewNow.length > 0) {
      const priorityOrder = {
        [MasteryLevel.UNFAMILIAR]: 0,
        [MasteryLevel.FUZZY]: 1,
        [MasteryLevel.REMEMBERED]: 2,
      };

      dueForReviewNow.sort((a, b) => {
        return (priorityOrder[a.mastery] ?? 3) - (priorityOrder[b.mastery] ?? 3);
      });

      const nextProgress = dueForReviewNow[0];
      const vocabResult = await db.collection('vocabulary')
        .where({ _id: nextProgress.vocabularyId })
        .limit(1)
        .get();

      if (vocabResult.data && vocabResult.data.length > 0) {
        const vocab = vocabResult.data[0];
        nextRecommendedWord = {
          vocabularyId: vocab._id,
          thaiWord: vocab.thaiWord,
          meaning: vocab.meaning,
          mastery: nextProgress.mastery,
          lastReviewed: nextProgress.lastReviewed,
          reviewCount: nextProgress.reviewCount,
        };
      }
    }

    // è®¡ç®—è¿ç»­å­¦ä¹ å¤©æ•°
    const streakDays = await calculateStreak(db, userId);

    // è®¡ç®—å¹³å‡å¤ä¹ æ¬¡æ•°
    const avgReviewCount = totalLearned > 0
      ? ((allProgress.data || []).reduce((sum, p) => sum + (p.reviewCount || 0), 0) / totalLearned).toFixed(1)
      : 0;

    return createResponse(true, {
      today: {
        reviewed: todayReviewedCount,
        remaining: dueForReviewNow.length,
        target: DAILY_LEARNING_CONFIG.TOTAL_WORDS_LIMIT,
      },
      overall: {
        totalLearned,
        totalVocabulary,
        progressPercentage: totalVocabulary > 0 ? ((totalLearned / totalVocabulary) * 100).toFixed(1) : 0,
        skipped: skippedCount,
        avgReviewCount: parseFloat(avgReviewCount),
      },
      masteryDistribution,
      masteryRate: parseFloat(masteryRate),
      nextRecommendedWord,
      streakDays,
    }, 'è·å–ç»Ÿè®¡æ•°æ®æˆåŠŸ');

  } catch (error) {
    console.error('getReviewStatistics error:', error);
    return createResponse(false, null, error.message, 'SERVER_ERROR');
  }
}

module.exports = getReviewStatistics;
````

## File: cloudbase/functions/learn-vocab/handlers/getSkippedWords.js
````javascript
/**
 * è·å–å·²åˆ’æ‰å•è¯å¤„ç†å™¨
 * @action getSkippedWords
 */
'use strict';

const { createResponse } = require('../utils/response');

/**
 * æ ¼å¼åŒ–è¯æ±‡ä¸ºåˆ—è¡¨é¡¹
 */
function formatVocabularyForList(vocab) {
  return {
    vocabularyId: vocab.vocabularyId || vocab._id, // å…¼å®¹å­—æ®µå
    thaiWord: vocab.thaiWord,
    meaning: vocab.meaning,
    pronunciation: vocab.pronunciation,
    audioPath: vocab.audioPath,
    partOfSpeech: vocab.partOfSpeech,
    level: vocab.level,
    lessonNumber: vocab.lessonNumber,
  };
}

/**
 * è·å–å·²åˆ’æ‰çš„å•è¯åˆ—è¡¨
 * @param {Object} db - æ•°æ®åº“å®ä¾‹ (ç”± index.js ä¼ å…¥)
 * @param {Object} params - è¯·æ±‚å‚æ•°
 * @param {string} params.userId - ç”¨æˆ·ID
 * @param {number} params.limit - è¿”å›æ•°é‡
 * @param {number} params.offset - åˆ†é¡µåç§»
 */
async function getSkippedWords(db, params) {
  // 1. è§£æ„å‚æ•° (æ³¨æ„ï¼šè¿™é‡Œ params æ˜¯ç¬¬äºŒä¸ªå‚æ•°)
  const { userId, limit = 20, offset = 0 } = params;

  if (!userId) {
    return createResponse(false, null, 'ç¼ºå°‘ç”¨æˆ·ID', 'INVALID_PARAMS');
  }

  try {
    // 2. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å®Œæˆå­—æ¯å­¦ä¹ 
    const { checkModuleAccess } = require('../utils/memoryEngine');
    const accessResult = await checkModuleAccess(db, userId, 'word');

    if (!accessResult.allowed) {
      return createResponse(false, null, accessResult.message, accessResult.errorCode);
    }

    // 3. è·å–å·²åˆ’æ‰å•è¯æ€»æ•°
    const countResult = await db.collection('user_vocabulary_progress')
      .where({ userId, skipped: true })
      .count();
    const total = countResult.total;

    // 4. æŸ¥è¯¢åˆ†é¡µè¿›åº¦
    const skippedProgressResult = await db.collection('user_vocabulary_progress')
      .where({ userId, skipped: true })
      .skip(offset)
      .limit(limit)
      .get();

    const skippedProgress = skippedProgressResult.data || [];

    if (skippedProgress.length === 0) {
      return createResponse(true, {
        words: [],
        pagination: { total, limit, offset, hasMore: false }
      }, 'æ²¡æœ‰å·²åˆ’æ‰çš„å•è¯');
    }

    // 5. è·å–å¯¹åº”çš„è¯æ±‡è¯¦æƒ…
    const vocabIds = skippedProgress.map(p => p.vocabularyId);

    // æ³¨æ„ï¼šè¿™é‡Œä½¿ç”¨å®é™…å­˜åœ¨çš„ vocabulary é›†åˆï¼ˆä¸»é”®ä¸º _idï¼‰
    const vocabResult = await db.collection('vocabulary')
      .where({
        // å‡è®¾ vocabularyId å­—æ®µå­˜å‚¨çš„æ˜¯è¯æ±‡çš„ _id
        _id: db.command.in(vocabIds)
      })
      .get();

    const vocabMap = new Map(vocabResult.data.map(v => [v._id, v]));

    // 6. ç»„è£…æ•°æ®
    const words = skippedProgress.map(progress => {
      const vocab = vocabMap.get(progress.vocabularyId);
      if (!vocab) return null;

      return {
        ...formatVocabularyForList(vocab),
        skippedAt: progress.updatedAt,
      };
    }).filter(Boolean);

    return createResponse(true, {
      words,
      pagination: {
        total,
        limit,
        offset,
        hasMore: offset + limit < total,
      }
    }, 'è·å–å·²åˆ’æ‰å•è¯æˆåŠŸ');

  } catch (error) {
    console.error('getSkippedWords error:', error);
    return createResponse(false, null, `æœåŠ¡å™¨å†…éƒ¨é”™è¯¯: ${error.message}`, 'SERVER_ERROR');
  }
}

module.exports = getSkippedWords;
````

## File: cloudbase/functions/learn-vocab/index.js
````javascript
/**
 * learn-vocab äº‘å‡½æ•° - ç»Ÿä¸€è®°å¿†å¼•æ“ç‰ˆæœ¬
 * æ”¯æŒå­—æ¯/å•è¯/å¥å­çš„ç»Ÿä¸€å­¦ä¹ ç®¡ç†
 * ç‰ˆæœ¬: 2.0.0 (UME - Unified Memory Engine)
 * 
 * è§¦å‘æ–¹å¼: HTTP è§¦å‘å™¨
 */

const cloud = require('wx-server-sdk');
cloud.init({ env: cloud.SYMBOL_CURRENT_ENV });
const db = cloud.database();

// ===== åŸæœ‰handlers (ä¿ç•™) =====
const getTodayWords = require('./handlers/getTodayWords');
const updateMastery = require('./handlers/updateMastery');
const toggleSkipWord = require('./handlers/toggleSkipWord');
const getVocabularyDetail = require('./handlers/getVocabularyDetail');
const getReviewStatistics = require('./handlers/getReviewStatistics');
const getVocabularyList = require('./handlers/getVocabularyList');
const getSkippedWords = require('./handlers/getSkippedWords');

// ===== æ–°å¢handlers (ç»Ÿä¸€è®°å¿†å¼•æ“) =====
// (å·²è¿ç§»è‡³ memory-engine äº‘å‡½æ•°)

// ===== å·¥å…·å‡½æ•° =====
const { createResponse } = require('./utils/response');

/**
 * äº‘å‡½æ•°ä¸»å…¥å£
 * æ”¯æŒ HTTP è§¦å‘å™¨è°ƒç”¨
 * 
 * @param {Object} event - è¯·æ±‚äº‹ä»¶
 * @param {Object} context - ä¸Šä¸‹æ–‡
 */
exports.main = async (event, context) => {
  // ===== è§£æ HTTP è¯·æ±‚ =====
  let requestData = event;

  // HTTP è§¦å‘å™¨ï¼šbody å¯èƒ½æ˜¯å­—ç¬¦ä¸²æˆ–å¯¹è±¡
  if (event.body) {
    if (typeof event.body === 'string') {
      try {
        requestData = JSON.parse(event.body);
      } catch (e) {
        console.error('[learn-vocab] JSON è§£æå¤±è´¥:', e.message);
        return createResponse(false, null, 'Invalid JSON in request body', 'INVALID_JSON');
      }
    } else if (typeof event.body === 'object') {
      requestData = event.body;
    }
  }

  const { action, data = {} } = requestData;

  console.log(`[learn-vocab] Action: ${action}`, JSON.stringify(data));

  // éªŒè¯ action å‚æ•°
  if (!action) {
    return createResponse(
      false,
      null,
      'ç¼ºå°‘å¿…å¡«å‚æ•°: action',
      'MISSING_ACTION'
    );
  }

  try {
    // ===== åŸæœ‰APIè·¯ç”± (7ä¸ª) =====
    if (action === 'getTodayWords') {
      return await getTodayWords(db, data);
    }

    if (action === 'updateMastery') {
      return await updateMastery(data);
    }

    if (action === 'toggleSkipWord') {
      return await toggleSkipWord(db, data);
    }

    if (action === 'getVocabularyDetail') {
      return await getVocabularyDetail(db, data);
    }

    if (action === 'getReviewStatistics') {
      return await getReviewStatistics(db, data);
    }

    if (action === 'getVocabularyList') {
      return await getVocabularyList(db, data);
    }

    if (action === 'getSkippedWords') {
      return await getSkippedWords(db, data);
    }

    // ===== å·²è¿ç§»è‡³ memory-engine çš„è·¯ç”± =====
    if (['getTodayMemories', 'submitMemoryResult', 'checkModuleAccess', 'getUserProgress'].includes(action)) {
      return createResponse(
        false,
        null,
        `Action '${action}' has been moved to 'memory-engine' cloud function. Please update your client.`,
        'MOVED_PERMANENTLY'
      );
    }

    // ===== æœªçŸ¥Action =====
    const supportedActions = [
      'getTodayWords',
      'updateMastery',
      'toggleSkipWord',
      'getVocabularyDetail',
      'getReviewStatistics',
      'getVocabularyList',
      'getSkippedWords'
    ];

    return createResponse(
      false,
      { supportedActions },
      `æœªçŸ¥çš„æ“ä½œç±»å‹: ${action}`,
      'UNKNOWN_ACTION'
    );

  } catch (error) {
    console.error(`[learn-vocab] äº‘å‡½æ•°é”™è¯¯:`, error);
    console.error('é”™è¯¯å †æ ˆ:', error.stack);

    return createResponse(
      false,
      null,
      error.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      'SERVER_ERROR'
    );
  }
};
````

## File: cloudbase/functions/memory-engine/handlers/checkModuleAccess.js
````javascript
/**
 * æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™
 * Action: checkModuleAccess
 */

const { checkModuleAccess } = require('../utils/memoryEngine');
const { validateParams } = require('../utils/validators');
const { createResponse } = require('../utils/response');

async function checkModuleAccessHandler(db, params) {

  const devForceUnlock = process.env.FORCE_UNLOCK === 'true';
  console.log('ğŸ”§ FORCE_UNLOCK å½“å‰å€¼:', process.env.FORCE_UNLOCK, '=>', devForceUnlock);
  if (devForceUnlock) {
    return createResponse(true, {
      allowed: true,
      moduleType: params.moduleType,
      progress: 100
    }, 'ã€å¼€å‘æ¨¡å¼ã€‘æ¨¡å—å·²å¼ºåˆ¶æ”¾è¡Œ');
  }

  // ================== ä»¥ä¸‹ä¸ºæ­£å¼ç”Ÿäº§é€»è¾‘ ==================

  // 1ï¸âƒ£ å‚æ•°éªŒè¯
  const validation = validateParams(params, ['userId', 'moduleType']);
  if (!validation.isValid) {
    return createResponse(false, null, validation.message, 'INVALID_PARAMS');
  }

  const { userId, moduleType } = params;

  // 2ï¸âƒ£ éªŒè¯ moduleType åˆæ³•æ€§
  const validModules = ['letter', 'word', 'sentence', 'article'];
  if (!validModules.includes(moduleType)) {
    return createResponse(
      false,
      null,
      `æ— æ•ˆçš„æ¨¡å—ç±»å‹: ${moduleType}`,
      'INVALID_MODULE_TYPE'
    );
  }

  try {
    // 3ï¸âƒ£ æ­£å¼æ ¡éªŒæ¨¡å—æƒé™
    const accessResult = await checkModuleAccess(db, userId, moduleType);

    if (!accessResult.allowed) {
      return createResponse(false, accessResult, accessResult.message, accessResult.errorCode);
    }

    // 4ï¸âƒ£ å…è®¸è®¿é—®
    return createResponse(true, {
      allowed: true,
      moduleType,
      progress: accessResult.progress
    }, 'æ¨¡å—å·²è§£é”,å¯ä»¥è®¿é—®');

  } catch (error) {
    console.error('checkModuleAccess é”™è¯¯:', error);
    return createResponse(false, null, error.message || 'æœåŠ¡å™¨é”™è¯¯', 'SERVER_ERROR');
  }
}

module.exports = checkModuleAccessHandler;
````

## File: cloudbase/functions/memory-engine/handlers/submitMemoryResult.js
````javascript
/**
 * æäº¤å­¦ä¹ ç»“æœï¼ˆæ”¯æŒå•æ¡ + æ‰¹é‡ï¼‰
 * 
 * æ”¯æŒä¸¤ç§è¯·æ±‚æ ¼å¼ï¼š
 * 1ï¼‰æ—§ç‰ˆå•æ¡ï¼š
 * {
 *   userId,
 *   entityType,
 *   entityId,
 *   quality
 * }
 * 
 * 2ï¼‰æ–°ç‰ˆæ‰¹é‡ï¼š
 * {
 *   userId,
 *   results: [
 *     { entityType, entityId, quality },
 *     ...
 *   ]
 * }
 */

'use strict';

const { createResponse } = require('../utils/response');
const { updateMemoryAfterReview } = require('../utils/memoryEngine');

const MAX_RESULTS = 30;
const BATCH_SIZE = 5;

/**
 * @param {Object} db     - cloud.database()
 * @param {Object} params - è¯·æ±‚å‚æ•°ï¼ˆæ¥è‡ª index.js ä¸­çš„ dataï¼‰
 */
async function submitMemoryResult(db, params) {
  const start = Date.now();
  const {
    userId,
    entityType,
    entityId,
    quality,
    results
  } = params || {};

  // 1. åŸºæœ¬æ ¡éªŒï¼šå¿…é¡»æœ‰ userId
  if (!userId) {
    return createResponse(
      false,
      null,
      'ç¼ºå°‘å¿…å¡«å‚æ•°: userId',
      'INVALID_PARAMS'
    );
  }

  // 2. è§„èŒƒåŒ–ä¸ºç»Ÿä¸€çš„æ•°ç»„æ ¼å¼ items[]
  let items = [];

  // 2.1 æ–°ç‰ˆï¼šdata.results æ˜¯æ•°ç»„
  if (Array.isArray(results) && results.length > 0) {
    if (results.length > MAX_RESULTS) {
      return createResponse(
        false,
        null,
        `å•æ¬¡æœ€å¤šæäº¤ ${MAX_RESULTS} æ¡ç»“æœï¼Œè¯·åˆ†æ‰¹æäº¤`,
        'RESULTS_TOO_MANY'
      );
    }
    items = results.map((r) => ({
      entityType: r.entityType,
      entityId: r.entityId,
      quality: r.quality
    }));
  }
  // 2.2 å…¼å®¹æ—§ç‰ˆï¼šå•æ¡å‚æ•°
  else if (entityType && entityId && quality) {
    items = [{ entityType, entityId, quality }];
  } else {
    // ä¸¤ç§æ ¼å¼éƒ½ä¸æ»¡è¶³
    return createResponse(
      false,
      null,
      'ç¼ºå°‘å¿…å¡«å‚æ•°: entityType, entityId, quality æˆ– results[]',
      'INVALID_PARAMS'
    );
  }

  try {
    const updatedMemories = [];

    // 3. åˆ†æ‰¹å¹¶å‘æ›´æ–°è®°å¿†çŠ¶æ€ï¼ˆé˜²æ­¢è¶…æ—¶ï¼‰
    for (let i = 0; i < items.length; i += BATCH_SIZE) {
      const batch = items.slice(i, i + BATCH_SIZE);

      const batchResults = await Promise.all(
        batch.map(async (item) => {
          const { entityType, entityId, quality } = item;

          // é˜²å¾¡æ€§æ ¡éªŒï¼Œé¿å… results é‡Œæ··å…¥ç©ºå¯¹è±¡
          if (!entityType || !entityId || !quality) return null;

          const memoryState = await updateMemoryAfterReview(
            db,
            userId,
            entityType,
            entityId,
            quality
          );

          return {
            entityType,
            entityId,
            quality,
            memoryState
          };
        })
      );

      batchResults
        .filter(Boolean)
        .forEach((res) => updatedMemories.push(res));
    }

    if (updatedMemories.length === 0) {
      return createResponse(
        false,
        null,
        'results ä¸­æ²¡æœ‰æœ‰æ•ˆçš„è®°å½•',
        'INVALID_PARAMS'
      );
    }

    // 4. è¿”å›ç»Ÿä¸€ç»“æ„
    const response = createResponse(
      true,
      { updatedMemories },
      'æäº¤å­¦ä¹ ç»“æœæˆåŠŸ'
    );
    console.log('[FunctionCost] submitMemoryResult', Date.now() - start, 'ms');
    return response;

  } catch (error) {
    console.error('[submitMemoryResult] error:', error);
    console.log('[FunctionCost] submitMemoryResult', Date.now() - start, 'ms');

    return createResponse(
      false,
      null,
      error.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      'SERVER_ERROR'
    );
  }
}

module.exports = submitMemoryResult;
````

## File: src/entities/types/alphabet.types.ts
````typescript
// src/entities/types/alphabet.types.ts

/**
 * å­—æ¯å­¦ä¹ ç›¸å…³ç±»å‹
 * 
 * è¯´æ˜: æ­¤æ–‡ä»¶å®šä¹‰å­—æ¯å­¦ä¹ ä¼šè¯(Session)ç›¸å…³çš„ç±»å‹
 * ä¸è¦ä¸letter.types.tsé‡å¤å®šä¹‰LetteråŸºç¡€ç»“æ„
 */

import type { Letter } from './letter.types';

// ==================== å­¦ä¹ ä¼šè¯ç›¸å…³ ====================

/**
 * AlphabetLearningState - å­—æ¯å­¦ä¹ çŠ¶æ€
 *
 * ç”¨äºå­¦ä¹ ä¼šè¯ä¸­è¿½è¸ªå•ä¸ªå­—æ¯çš„å­¦ä¹ è¿›åº¦
 */
export interface AlphabetLearningState {
    // åŸºç¡€ä¿¡æ¯
    alphabetId: string;             // å­—æ¯ID (å¯¹åº”Letter._id)
    thaiChar: string;               // æ³°æ–‡å­—ç¬¦
    category: string;               // ç±»åˆ«
    pronunciation: string;          // å‘éŸ³
    example: string;                // ä¾‹è¯ (å·²åŒ…å«ä¸­æ–‡)
    audioPath: string;              // éŸ³é¢‘URL

    // å­¦ä¹ è¿›åº¦
    currentAttempts: number;        // å½“å‰å°è¯•æ¬¡æ•°
    requiredAttempts: number;       // éœ€è¦è¾¾åˆ°çš„æ¬¡æ•° (é»˜è®¤3)
    qualityHistory: number[];       // è´¨é‡è¯„åˆ†å†å² (1-5)
    isCompleted: boolean;           // æ˜¯å¦å®Œæˆ
    timestamp: string;              // æœ€åæ›´æ–°æ—¶é—´ (ISOæ ¼å¼)

    // åç«¯è®°å¿†çŠ¶æ€ (å¯é€‰,æ¥è‡ªåç«¯getTodayMemories)
    memoryState?: MemoryStatus;

    // â­ æ–°å¢: ä¿ç•™å®Œæ•´Letterå¯¹è±¡,æ–¹ä¾¿è®¿é—®æ‰€æœ‰å­—æ®µ
    letterData?: Letter;
}

// ==================== Phase 2 ç»Ÿä¸€é¢˜å‹åè®® ====================

import type { AlphabetGameType } from '@/src/entities/types/alphabetGameTypes';

/**
 * AlphabetQueueItem - é¢˜ç›®é˜Ÿåˆ—é¡¹
 *
 * ç”¨äº Question Engine çš„ç»Ÿä¸€é˜Ÿåˆ—é¡¹åè®®
 * åŒ…å«å­—æ¯ä¿¡æ¯å’Œé¢˜å‹ä¿¡æ¯
 */
export interface AlphabetQueueItem {
    /** å­—æ¯ID */
    letterId: string;

    /** é¢˜å‹ */
    gameType: AlphabetGameType;

    /** å®Œæ•´çš„å­—æ¯å¯¹è±¡,ä¾›é¢˜ç›®ç”Ÿæˆå™¨ä½¿ç”¨ */
    letter: Letter;
}

/**
 * AlphabetQuestion - ç»Ÿä¸€é¢˜ç›®åè®®
 *
 * ç”± lettersQuestionGenerator ç”Ÿæˆçš„æ ‡å‡†é¢˜ç›®ç»“æ„
 */
export interface AlphabetQuestion {
    /** é¢˜ç›®ID (å¯ç”¨äºè¿½è¸ª) */
    id: string;

    /** é¢˜å‹ */
    gameType: AlphabetGameType;

    /** ç›®æ ‡å­—æ¯ (æ­£ç¡®ç­”æ¡ˆå¯¹åº”çš„å­—æ¯å¯¹è±¡) */
    targetLetter: Letter;

    /** é€‰é¡¹ (é€‰æ‹©é¢˜ä½¿ç”¨,æ‹¼å†™é¢˜å¯ä¸ºç©º) */
    options?: Letter[];

    /** æ­£ç¡®ç­”æ¡ˆ (å­—æ¯çš„ thaiChar æˆ–å…¶ä»–å±æ€§å€¼) */
    correctAnswer: string;

    /** éŸ³é¢‘URL (å¦‚æœé¢˜ç›®éœ€è¦æ’­æ”¾éŸ³é¢‘) */
    audioUrl?: string;
}

/**
 * MemoryStatus - åç«¯è®°å¿†çŠ¶æ€
 * 
 * æ¥è‡ªç»Ÿä¸€è®°å¿†å¼•æ“çš„è®°å¿†çŠ¶æ€
 */
export interface MemoryStatus {
    easinessFactor: number;         // éš¾åº¦å› å­ (1.3-2.5)
    interval: number;               // å¤ä¹ é—´éš”(å¤©)
    repetitions: number;            // é‡å¤æ¬¡æ•°
    nextReviewDate: string;         // ä¸‹æ¬¡å¤ä¹ æ—¥æœŸ (ISOæ ¼å¼)
    lastReviewDate?: string;        // æœ€åå¤ä¹ æ—¥æœŸ
}

/**
 * UnlockInfo - è§£é”ä¿¡æ¯
 * 
 * ç”¨äºç»Ÿä¸€è®°å¿†å¼•æ“çš„è§£é”ç³»ç»Ÿ
 */
export interface UnlockInfo {
    letterProgress: number;         // å­—æ¯å­¦ä¹ è¿›åº¦ (0-1 æ¯”ä¾‹å€¼)
    wordUnlocked: boolean;          // æ˜¯å¦è§£é”å•è¯å­¦ä¹ 
    unlocked?: boolean;             // æ˜¯å¦åˆšåˆšè§£é” (ç”¨äºå¼¹çª—æç¤º)
}

/**
 * TodayLettersResponse - ä»Šæ—¥å­—æ¯å­¦ä¹ å“åº”
 * 
 * åç«¯getTodayMemoriesè¿”å›çš„æ•°æ®ç»“æ„
 */
export interface TodayLettersResponse {
    items: Array<{
        entityId: string;           // å­—æ¯ID
        memoryState: MemoryStatus;
    }>;
    unlockInfo: UnlockInfo;
}

/**
 * SubmitLetterResultRequest - æäº¤å­—æ¯å­¦ä¹ ç»“æœ
 * 
 * æäº¤åˆ°åç«¯è®°å¿†å¼•æ“çš„æ•°æ®ç»“æ„
 */
export interface SubmitLetterResultRequest {
    userId: string;
    entityType: 'letter';
    entityId: string;
    quality: number;                // 1-5çš„è´¨é‡è¯„åˆ†
}

/**
 * SubmitLetterResultResponse - æäº¤ç»“æœå“åº”
 */
export interface SubmitLetterResultResponse {
    success: boolean;
    data?: {
        nextReviewDate: string;
        interval: number;
        repetitions: number;
        unlockInfo?: UnlockInfo;
    };
    message?: string;
    errorCode?: string;
}

// ==================== æµ‹è¯•ç›¸å…³ ====================

/**
 * AlphabetTest - å­—æ¯æµ‹è¯•æ•°æ®
 */
export interface AlphabetTest {
    testId: string;
    userId: string;
    questions: AlphabetTestQuestion[];
    totalQuestions: number;
    passingScore: number;           // åŠæ ¼åˆ†æ•° (é»˜è®¤80)
    createdAt: string;
}

/**
 * AlphabetTestQuestion - æµ‹è¯•é¢˜ç›®
 */
export interface AlphabetTestQuestion {
    questionId: string;
    type: 'recognition' | 'pronunciation' | 'writing';
    letterId: string;
    thaiChar: string;
    options?: string[];             // é€‰é¡¹ (é€‰æ‹©é¢˜)
    correctAnswer: string;
}

/**
 * AlphabetTestResult - æµ‹è¯•ç»“æœ
 */
export interface AlphabetTestResult {
    testId: string;
    userId: string;
    score: number;                  // å¾—åˆ† (0-100)
    correctCount: number;
    totalQuestions: number;
    passed: boolean;                // æ˜¯å¦é€šè¿‡
    answers: Array<{
        questionId: string;
        userAnswer: string;
        correctAnswer: string;
        isCorrect: boolean;
    }>;
    unlocked?: boolean;             // æ˜¯å¦è§£é”äº†ä¸‹ä¸€æ¨¡å—
    completedAt: string;
}

// ==================== å­¦ä¹ ä¼šè¯æ§åˆ¶ ====================

/**
 * LearningSessionState - å­¦ä¹ ä¼šè¯çŠ¶æ€
 * 
 * ç”¨äºAlphabetStoreç®¡ç†æ•´ä¸ªå­¦ä¹ æµç¨‹
 */
export interface LearningSessionState {
    phase: LearningPhase;
    reviewQueue: AlphabetLearningState[];
    currentAlphabet: AlphabetLearningState | null;
    completedCount: number;
    totalCount: number;
}

/**
 * LearningPhase - å­¦ä¹ é˜¶æ®µæšä¸¾
 */
export enum LearningPhase {
    IDLE = 'IDLE',                  // ç©ºé—²
    LOADING = 'LOADING',            // åŠ è½½ä¸­
    REVIEW = 'REVIEW',              // å¤ä¹ ä¸­
    TEST_PROMPT = 'TEST_PROMPT',    // æµ‹è¯•æç¤º
    TESTING = 'TESTING',            // æµ‹è¯•ä¸­
    TEST_RESULT = 'TEST_RESULT',    // æµ‹è¯•ç»“æœ
    COMPLETED = 'COMPLETED'         // å®Œæˆ
}

/**
 * QualityScore - è´¨é‡è¯„åˆ†æ˜ å°„
 */
export enum QualityButton {
    AGAIN = 'AGAIN',                // å®Œå…¨å¿˜è®°
    HARD = 'HARD',                  // å›°éš¾
    GOOD = 'GOOD',                  // è‰¯å¥½
    EASY = 'EASY'                   // ç®€å•
}

/**
 * è´¨é‡è¯„åˆ†æ˜ å°„è¡¨
 */
export const QUALITY_SCORE_MAP: Record<QualityButton, number> = {
    [QualityButton.AGAIN]: 1,
    [QualityButton.HARD]: 3,
    [QualityButton.GOOD]: 4,
    [QualityButton.EASY]: 5,
};

/**
 * å°è¯•æ¬¡æ•°å¢é‡æ˜ å°„è¡¨
 */
export const ATTEMPTS_INCREMENT_MAP: Record<QualityButton, number> = {
    [QualityButton.AGAIN]: 0,       // ä¸å¢åŠ 
    [QualityButton.HARD]: 1,        // +1
    [QualityButton.GOOD]: 1,        // +1
    [QualityButton.EASY]: 2,        // +2 (è·³è¿‡ä¸€æ¬¡)
};

// ==================== Phase 2 é”™é¢˜ç»Ÿè®¡ ====================

/**
 * RoundErrorSummary - è½®æ¬¡é”™é¢˜ç»Ÿè®¡
 *
 * ç”¨äºåœ¨ Round ç»“æœé¡µå±•ç¤ºé”™è¯¯æœ€å¤šçš„å­—æ¯
 */
export interface RoundErrorSummary {
    /** å­—æ¯ID */
    letterId: string;

    /** å®Œæ•´çš„å­—æ¯å¯¹è±¡ */
    letter: Letter;

    /** é”™è¯¯æ¬¡æ•° */
    wrongCount: number;

    /** æ€»å°è¯•æ¬¡æ•° */
    totalAttempts: number;

    /** é”™è¯¯ç‡ (wrongCount / totalAttempts) */
    errorRate?: number;
}
````

## File: app.json
````json
{
  "expo": {
    "name": "ThaiLearningApp",
    "slug": "ThaiLearningApp",
    "scheme": "thailearningapp",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "newArchEnabled": false,
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.asherlliang.ThaiLearningApp"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "edgeToEdgeEnabled": true,
      "predictiveBackGestureEnabled": false,
      "package": "com.asherlliang.ThaiLearningApp"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      "expo-localization",
      "expo-font"
    ]
  }
}
````

## File: cloudbase/functions/learn-vocab/handlers/getTodayWords.js
````javascript
/**
 * è·å–ä»Šæ—¥å•è¯å¤„ç†å™¨
 * 
 * è¿”å›ç”¨æˆ·ä»Šæ—¥éœ€è¦å­¦ä¹ /å¤ä¹ çš„å•è¯åˆ—è¡¨
 * 
 * @action getTodayWords
 */

'use strict';

const { createResponse } = require('../utils/response');
const {
  COLLECTIONS,
  MasteryLevel,
  SM2_PARAMS,
  EARLY_INTERVALS,
  DAILY_LEARNING_CONFIG
} = require('../utils/constants');

const MAX_DAILY_WORDS = 200; // é™é…æ¨¡å¼ç¡¬ä¸Šé™ï¼Œé˜²æ­¢ 3s è¶…æ—¶

/**
 * æ ¼å¼åŒ–è¯æ±‡ä¸ºåˆ—è¡¨é¡¹ (ç²¾ç®€ç‰ˆ)
 */
function formatVocabularyForList(vocab) {
  return {
    vocabularyId: vocab._id || vocab.vocabularyId,
    thaiWord: vocab.thaiWord,
    meaning: vocab.meaning,
    pronunciation: vocab.pronunciation,
    audioPath: vocab.audioPath,
    partOfSpeech: vocab.partOfSpeech,
    level: vocab.level,
    lessonNumber: vocab.lessonNumber,
  };
}

/**
 * è·å–ä»Šæ—¥å•è¯åˆ—è¡¨
 * 
 * ä¸šåŠ¡é€»è¾‘:
 * 1. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å®Œæˆå­—æ¯å­¦ä¹ 
 * 2. è·å–ç”¨æˆ·æ‰€æœ‰æœªåˆ’æ‰çš„è¿›åº¦è®°å½•
 * 3. ç­›é€‰ä»Šæ—¥éœ€å¤ä¹ çš„å•è¯å’Œæ–°è¯
 * 4. æŒ‰ä¼˜å…ˆçº§æ’åº: é™Œç”Ÿ > æ¨¡ç³Š > è®°å¾— > æ–°è¯
 * 5. åº”ç”¨åˆ†é¡µè¿”å›
 */
async function getTodayWords(db, params) {
  const start = Date.now();
  const { userId, limit = 30, offset = 0, level = null } = params;
  const safeLimit = Math.max(1, Math.min(limit, MAX_DAILY_WORDS));

  // éªŒè¯å‚æ•°
  if (!userId) {
    return createResponse(false, null, 'ç¼ºå°‘ç”¨æˆ·ID', 'INVALID_PARAMS');
  }

  try {
    // ===== Step 1: æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨ =====
    const userResult = await db.collection('users')
      .where({ userId })
      .get();

    if (!userResult.data || userResult.data.length === 0) {
      return createResponse(false, null, 'ç”¨æˆ·ä¸å­˜åœ¨', 'USER_NOT_FOUND');
    }

    // ===== Step 2: æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å®Œæˆå­—æ¯å­¦ä¹ ï¼ˆæƒé™æ£€æŸ¥ï¼‰=====
    const { checkModuleAccess } = require('../utils/memoryEngine');
    const accessResult = await checkModuleAccess(db, userId, 'word');

    if (!accessResult.allowed) {
      return createResponse(
        false,
        null,
        accessResult.message,
        accessResult.errorCode
      );
    }

    // ===== Step 3: è·å–ç”¨æˆ·æ‰€æœ‰æœªåˆ’æ‰çš„è¿›åº¦è®°å½• =====
    const allProgressResult = await db.collection('user_vocabulary_progress')
      .where({
        userId,
        skipped: db.command.neq(true)
      })
      .get();

    const allProgress = allProgressResult.data || [];

    // ===== Step 4: åˆ†ç¦»éœ€è¦å¤ä¹ çš„è¯å’Œå·²å­¦ä¹ çš„è¯ =====
    const dueForReview = [];
    const learnedVocabIds = new Set();
    const now = new Date();

    allProgress.forEach(progress => {
      learnedVocabIds.add(progress.vocabularyId);

      // æ£€æŸ¥æ˜¯å¦ä»Šæ—¥éœ€è¦å¤ä¹ 
      if (progress.nextReviewDate && new Date(progress.nextReviewDate) <= now) {
        dueForReview.push(progress);
      }
    });

    // ===== Step 5: è·å–æ–°è¯ (ç”¨æˆ·ä»æœªå­¦è¿‡çš„è¯æ±‡) =====
    const maxNewWords = (DAILY_LEARNING_CONFIG && DAILY_LEARNING_CONFIG.MAX_NEW_WORDS) || 10;

    let newWordsQuery = db.collection('vocabulary');

    if (learnedVocabIds.size > 0) {
      newWordsQuery = newWordsQuery.where({
        _id: db.command.nin([...learnedVocabIds])
      });
    }

    if (level) {
      newWordsQuery = newWordsQuery.where({ level });
    }

  const newVocabsResult = await newWordsQuery
    .orderBy('lessonNumber', 'asc')
    .limit(Math.min(maxNewWords, MAX_DAILY_WORDS))
    .get();

    const newVocabularies = newVocabsResult.data || [];

    // ===== Step 6: æŒ‰ä¼˜å…ˆçº§æ’åºå¤ä¹ è¯ (é™Œç”Ÿ > æ¨¡ç³Š > è®°å¾—) =====
    const priorityOrder = {
      [MasteryLevel.UNFAMILIAR]: 0,
      [MasteryLevel.FUZZY]: 1,
      [MasteryLevel.REMEMBERED]: 2,
    };

    dueForReview.sort((a, b) => {
      return (priorityOrder[a.mastery] ?? 3) - (priorityOrder[b.mastery] ?? 3);
    });

    // ===== Step 7: ç»„åˆä»Šæ—¥å•è¯åˆ—è¡¨ =====
    const todayList = [];

    // æ·»åŠ éœ€è¦å¤ä¹ çš„è¯
    if (dueForReview.length > 0) {
      const reviewVocabIds = dueForReview.map(p => p.vocabularyId);
      const reviewVocabsResult = await db.collection('vocabulary')
        .where({ _id: db.command.in(reviewVocabIds) })
        .get();

      const vocabMap = new Map(
        (reviewVocabsResult.data || []).map(v => [v._id, v])
      );

      dueForReview.forEach(progress => {
        const vocab = vocabMap.get(progress.vocabularyId);
        if (vocab) {
          todayList.push({
            ...formatVocabularyForList(vocab),
            learningStatus: {
              mastery: progress.mastery,
              reviewCount: progress.reviewCount,
              lastReviewed: progress.lastReviewed,
              nextReviewDate: progress.nextReviewDate,
              intervalDays: progress.intervalDays,
              isReview: true,
              isNew: false,
            },
          });
        }
      });
    }

    // æ·»åŠ æ–°è¯
    newVocabularies.forEach(vocab => {
      todayList.push({
        ...formatVocabularyForList(vocab),
        learningStatus: {
          mastery: null,
          reviewCount: 0,
          lastReviewed: null,
          nextReviewDate: null,
          intervalDays: 0,
          isReview: false,
          isNew: true,
        },
      });
    });

    // ===== Step 8: åº”ç”¨åˆ†é¡µ =====
    const totalCount = todayList.length;
    const validOffset = Math.max(0, offset);
    const validLimit = Math.max(1, Math.min(safeLimit, 100));

    const paginatedList = todayList.slice(validOffset, validOffset + validLimit);

    const response = createResponse(true, {
      words: paginatedList,
      pagination: {
        total: totalCount,
        limit: validLimit,
        offset: validOffset,
        hasMore: validOffset + validLimit < totalCount,
      },
      summary: {
        reviewCount: dueForReview.length,
        newCount: newVocabularies.length,
        totalToday: totalCount,
      },
    }, 'è·å–ä»Šæ—¥å•è¯æˆåŠŸ');
    console.log('[FunctionCost] getTodayWords', Date.now() - start, 'ms');
    return response;

  } catch (error) {
    console.error('getTodayWords error:', error);
    console.log('[FunctionCost] getTodayWords', Date.now() - start, 'ms');
    return createResponse(false, null, error.message || 'æœåŠ¡å™¨é”™è¯¯', 'SERVER_ERROR');
  }
}

module.exports = getTodayWords;
````

## File: cloudbase/functions/memory-engine/utils/memoryEngine.js
````javascript
/**
 * ç»Ÿä¸€è®°å¿†å¼•æ“æ ¸å¿ƒæ¨¡å—
 * æ”¯æŒå­—æ¯/å•è¯/å¥å­çš„ç»Ÿä¸€è®°å¿†ç®¡ç†
 * 
 * ä¿®å¤ï¼šwx-server-sdk ä¸æ”¯æŒ getOne()ï¼Œæ”¹ç”¨ get() + data[0]
 */

const { calculateSM2Optimized } = require('./sm2');

/**
 * åˆ›å»ºæ–°çš„è®°å¿†è®°å½•
 */
async function createMemoryRecord(db, userId, entityType, entityId, isLocked = false) {

    // éªŒè¯å‚æ•°
    if (!userId || !entityType || !entityId) {
        console.error('[createMemoryRecord] å‚æ•°ç¼ºå¤±:', { userId, entityType, entityId });
        throw new Error('userId, entityType, entityId éƒ½æ˜¯å¿…éœ€å‚æ•°');
    }

    const now = new Date();
    const nextReviewAt = isLocked ? null : new Date(now.getTime() + 24 * 60 * 60 * 1000).toISOString();

    const memoryRecord = {
        userId,
        entityType,
        entityId,
        masteryLevel: 0.0,
        reviewStage: 0,
        easinessFactor: 2.5,
        intervalDays: 1,
        lastReviewAt: null,
        nextReviewAt,
        correctCount: 0,
        wrongCount: 0,
        streakCorrect: 0,
        isLocked,
        createdAt: now.toISOString(),
        updatedAt: now.toISOString()
    };

    try {
        // å°è¯•æ’å…¥
        const result = await db.collection('memory_status').add(memoryRecord);

        console.log('[createMemoryRecord] åˆ›å»ºæˆåŠŸ:', { userId, entityType, entityId });

        return {
            _id: result._id,
            ...memoryRecord
        };
    } catch (error) {
        // å¦‚æœæ˜¯é‡å¤é”®é”™è¯¯ï¼ŒæŸ¥è¯¢å¹¶è¿”å›ç°æœ‰è®°å½•
        if (error.errCode === -502001 || error.message.includes('duplicate key')) {
            console.log('[createMemoryRecord] è®°å½•å·²å­˜åœ¨ï¼ŒæŸ¥è¯¢è¿”å›:', { userId, entityType, entityId });

            const existingResult = await db.collection('memory_status')
                .where({ userId, entityType, entityId })
                .get();

            if (existingResult.data && existingResult.data.length > 0) {
                return existingResult.data[0];
            }
        }

        // å…¶ä»–é”™è¯¯ç»§ç»­æŠ›å‡º
        console.error('[createMemoryRecord] åˆ›å»ºå¤±è´¥:', error);
        throw error;
    }
}

/**
 * è·å–æˆ–åˆ›å»ºè®°å¿†è®°å½•
 * ä¿®å¤ï¼šä½¿ç”¨ get() ä»£æ›¿ getOne()
 */
async function getOrCreateMemory(db, userId, entityType, entityId, isLocked = false) {
    // 1. å°è¯•æŸ¥è¯¢ç°æœ‰è®°å½•
    const existingMemory = await db.collection('memory_status')
        .where({
            userId,
            entityType,
            entityId
        })
        .get();

    // 2. å¦‚æœå­˜åœ¨,ç›´æ¥è¿”å›ç¬¬ä¸€æ¡
    if (existingMemory.data && existingMemory.data.length > 0) {
        return existingMemory.data[0];
    }

    // 3. ä¸å­˜åœ¨åˆ™åˆ›å»ºæ–°è®°å½•
    return await createMemoryRecord(db, userId, entityType, entityId, isLocked);
}

/**
 * æ›´æ–°è®°å¿†çŠ¶æ€(ç­”é¢˜åè°ƒç”¨)
 */
async function updateMemoryAfterReview(db, userId, entityType, entityId, quality) {
    console.log('ã€æµ‹è¯•ã€‘updateMemoryAfterReview è¢«è°ƒç”¨äº†ï¼', { userId, quality });
    console.log('=== [updateMemoryAfterReview] å¼€å§‹ ===');
    console.log('å‚æ•°:', JSON.stringify({ userId, entityType, entityId, quality }));

    try {
        // 1. è·å–å½“å‰è®°å¿†è®°å½•
        console.log('æ­¥éª¤1: è·å–è®°å¿†è®°å½•');
        const memory = await getOrCreateMemory(db, userId, entityType, entityId);
        console.log('è®°å¿†è®°å½•:', JSON.stringify(memory));

        // 2. æ˜ å°„è´¨é‡åˆ°SM-2è¯„åˆ†
        console.log('æ­¥éª¤2: æ˜ å°„è´¨é‡');
        const qualityMap = {
            'é™Œç”Ÿ': 1,
            'æ¨¡ç³Š': 3,
            'è®°å¾—': 5
        };
        const sm2Quality = qualityMap[quality] || 3;
        console.log('SM-2è´¨é‡:', sm2Quality);

        // 3. è®¡ç®—æ–°çš„SM-2å‚æ•°
        console.log('æ­¥éª¤3: è°ƒç”¨ calculateSM2Optimized');
        console.log('è°ƒç”¨å‚æ•°:', {
            quality,
            intervalDays: memory.intervalDays,
            easinessFactor: memory.easinessFactor,
            reviewStage: memory.reviewStage
        });

        const sm2Result = calculateSM2Optimized(
            quality,
            memory.intervalDays,
            memory.easinessFactor,
            memory.reviewStage
        );

        console.log('SM-2ç»“æœ:', JSON.stringify(sm2Result));

        // 4. æ›´æ–°æŒæ¡åº¦
        console.log('æ­¥éª¤4: è®¡ç®—æ–°æŒæ¡åº¦');
        let newMasteryLevel = memory.masteryLevel;
        if (quality === 'è®°å¾—') {
            newMasteryLevel = Math.min(1.0, memory.masteryLevel + 0.15);
        } else if (quality === 'æ¨¡ç³Š') {
            newMasteryLevel = Math.max(0.0, memory.masteryLevel + 0.05);
        } else {
            newMasteryLevel = Math.max(0.0, memory.masteryLevel - 0.2);
        }
        console.log('æ–°æŒæ¡åº¦:', newMasteryLevel);

        // 5. æ›´æ–°è¿èƒœå’Œè®¡æ•°
        console.log('æ­¥éª¤5: è®¡ç®—è¿èƒœ');
        const newStreakCorrect = quality === 'è®°å¾—' ? memory.streakCorrect + 1 : 0;
        const newCorrectCount = quality === 'è®°å¾—' ? memory.correctCount + 1 : memory.correctCount;
        const newWrongCount = quality === 'é™Œç”Ÿ' ? memory.wrongCount + 1 : memory.wrongCount;

        // 6. è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´
        console.log('æ­¥éª¤6: è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´');
        const now = new Date();
        const nextReviewAt = new Date(now.getTime() + sm2Result.interval * 24 * 60 * 60 * 1000);
        console.log('ä¸‹æ¬¡å¤ä¹ æ—¶é—´:', nextReviewAt);

        // 7. å‡†å¤‡æ›´æ–°æ•°æ®
        console.log('æ­¥éª¤7: å‡†å¤‡æ›´æ–°æ•°æ®åº“');
        const updateData = {
            masteryLevel: newMasteryLevel,
            reviewStage: sm2Result.repetitions,
            easinessFactor: sm2Result.easinessFactor,
            intervalDays: sm2Result.interval,
            lastReviewAt: now.toISOString(),
            nextReviewAt: nextReviewAt.toISOString(),
            correctCount: newCorrectCount,
            wrongCount: newWrongCount,
            streakCorrect: newStreakCorrect,
            updatedAt: now.toISOString()
        };

        console.log('æ›´æ–°æ•°æ®å¯¹è±¡:', JSON.stringify(updateData));

        // æ£€æŸ¥æ˜¯å¦æœ‰ undefined
        for (const [key, value] of Object.entries(updateData)) {
            if (value === undefined) {
                console.error(`âŒ å‘ç° undefined å€¼: ${key}`);
            }
        }

        // 8. æ‰§è¡Œæ›´æ–°
        console.log('æ­¥éª¤8: æ‰§è¡Œæ•°æ®åº“æ›´æ–°');
        await db.collection('memory_status')
            .where({
                userId,
                entityType,
                entityId
            })
            .update({
                data: updateData   // âœ… CloudBase å¿…é¡»è¿™æ ·å†™
            });

        console.log('âœ… æ›´æ–°æˆåŠŸ');

        return {
            entityId,
            entityType,
            masteryLevel: newMasteryLevel,
            reviewStage: sm2Result.repetitions,
            easinessFactor: sm2Result.easinessFactor,
            intervalDays: sm2Result.interval,
            nextReviewAt: nextReviewAt.toISOString(),
            correctCount: newCorrectCount,
            wrongCount: newWrongCount,
            streakCorrect: newStreakCorrect
        };

    } catch (error) {
        console.error('âŒ [updateMemoryAfterReview] é”™è¯¯:', error);
        console.error('é”™è¯¯å †æ ˆ:', error.stack);
        throw error;
    }
}

/**
 * è·å–ä»Šæ—¥å¾…å¤ä¹ çš„å®ä½“
 */
async function getTodayReviewEntities(db, userId, entityType, limit = 20) {
    const now = new Date();

    const result = await db.collection('memory_status')
        .where({
            userId,
            entityType,
            isLocked: false,
            nextReviewAt: db.command.lte(now)
        })
        .orderBy('nextReviewAt', 'asc')
        .limit(limit)
        .get();

    return result.data || [];
}

/**
 * æ£€æŸ¥å¹¶è§£é”ä¸‹ä¸€é˜¶æ®µå­¦ä¹ 
 */
// async function checkAndUnlockNextStage(db, userId) {

//   if (process.env.FORCE_UNLOCK === 'true') {
//     return {
//       allowed: true,
//       progress: 100,
//       stage: "all",
//       message: 'ã€è°ƒè¯•æ¨¡å¼ã€‘å¼ºåˆ¶è§£é”'
//     };
//   }

//   // ä¿®å¤ï¼šä½¿ç”¨ get() + data[0]
//   const progressResult = await db.collection('user_progress')
//     .where({ userId })
//     .get();

//   if (!progressResult.data || progressResult.data.length === 0) {
//     await initUserProgress(db, userId);
//     return {
//       unlocked: false,
//       stage: 'letter',
//       message: 'åˆå§‹åŒ–å­¦ä¹ è¿›åº¦æˆåŠŸ'
//     };
//   }

//   const progress = progressResult.data[0];

//   if (!progress.letterCompleted) {
//     const letterMemories = await db.collection('memory_status')
//       .where({
//         userId,
//         entityType: 'letter'
//       })
//       .get();

//     const totalLetters = 44;
//     const masteredLetters = letterMemories.data.filter(m => m.masteryLevel >= 0.7).length;
//     const letterProgress = masteredLetters / totalLetters;

//     if (letterProgress >= 0.95) {
//       await db.collection('user_progress').where({ userId }).update({
//         data: {
//           letterCompleted: true,
//           letterProgress: 1.0,
//           wordUnlocked: true,
//           currentStage: 'word',
//           updatedAt: new Date().toISOString()
//         }
//       });

//       await db.collection('memory_status')
//         .where({
//           userId,
//           entityType: 'word',
//           isLocked: true
//         })
//         .update({
//           data: {
//             isLocked: false,
//             nextReviewAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
//           }
//         });

//       return {
//         unlocked: true,
//         stage: 'word',
//         message: 'æ­å–œ!å­—æ¯å­¦ä¹ å®Œæˆ,å•è¯å­¦ä¹ å·²è§£é”!'
//       };
//     }

//     return {
//       unlocked: false,
//       stage: 'letter',
//       progress: letterProgress,
//       remaining: Math.ceil((0.95 - letterProgress) * totalLetters),
//       message: `è¿˜éœ€æŒæ¡ ${Math.ceil((0.95 - letterProgress) * totalLetters)} ä¸ªå­—æ¯`
//     };
//   }

//   return {
//     unlocked: false,
//     stage: progress.currentStage,
//     message: 'ç»§ç»­åŠ æ²¹!'
//   };
// }

/**
 * åˆå§‹åŒ–ç”¨æˆ·çš„å­¦ä¹ è¿›åº¦è®°å½•
 */
async function initUserProgress(db, userId) {
    const now = new Date();

    const progressRecord = {
        userId,
        letterCompleted: false,
        letterProgress: 0.0,
        wordUnlocked: false,
        wordProgress: 0.0,
        sentenceUnlocked: false,
        sentenceProgress: 0.0,
        articleUnlocked: false,
        currentStage: 'letter',
        totalStudyDays: 0,
        streakDays: 0,
        lastStudyDate: null,
        createdAt: now,
        updatedAt: now
    };

    await db.collection('user_progress').add(progressRecord);
    return progressRecord;
}

/**
 * æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™
 * ä¿®å¤ï¼šä½¿ç”¨ get() + data[0]
 */
async function checkModuleAccess(db, userId, moduleType) {
    const forceUnlock = process.env.FORCE_UNLOCK === 'true';

    // ç‰¹æ®Šå¤„ç†ï¼šå¼€å‘é˜¶æ®µçš„æœ¬åœ°æµ‹è¯•ç”¨æˆ·
    // å‰ç«¯åœ¨æœªç™»å½•æƒ…å†µä¸‹ä¼šä½¿ç”¨ userId = 'test-user' è¿›å…¥å­—æ¯æ¨¡å—ï¼Œ
    // æ­¤æ—¶ CloudBase ä¸­å¹¶ä¸å­˜åœ¨å¯¹åº”çš„ user / user_progress è®°å½•ï¼Œ
    // å¦‚æœç›´æ¥è®¿é—®æ•°æ®åº“ä¼šè§¦å‘å„ç§çº¦æŸé”™è¯¯ï¼ˆä¾‹å¦‚å”¯ä¸€ç´¢å¼•ï¼‰ã€‚
    //
    // è¿™é‡Œç›´æ¥æ”¾è¡Œè¯¥ç”¨æˆ·ï¼Œå¹¶è¿”å›ä¸€ä¸ªæœ€å°åŒ–çš„è¿›åº¦å¯¹è±¡ï¼Œä»…ç”¨äºæœ¬åœ°è°ƒè¯•ã€‚
    if (userId === 'test-user') {
        console.warn('â„¹ï¸ checkModuleAccess: ä½¿ç”¨å¼€å‘æµ‹è¯•ç”¨æˆ· test-user, ç›´æ¥æ”¾è¡Œæ¨¡å—:', moduleType);
        const progress = {
            userId,
            letterCompleted: false,
            letterProgress: 0,
            wordUnlocked: false,
            wordProgress: 0,
            sentenceUnlocked: false,
            sentenceProgress: 0,
            articleUnlocked: false,
            articleProgress: 0,
            currentStage: moduleType,
        };
        return {
            allowed: true,
            progress,
        };
    }

    // 1. è·å–ç”¨æˆ·è¿›åº¦è®°å½•
    const progressResult = await db.collection('user_progress')
        .where({ userId })
        .limit(1)
        .get();

    if (!progressResult.data || progressResult.data.length === 0) {
        // æ²¡æœ‰è¿›åº¦è®°å½•ï¼š
        // - å¦‚æœå¼€å¯ FORCE_UNLOCKï¼Œä»ç„¶æ”¾è¡Œå¹¶è¿”å›ä¸€ä¸ªé»˜è®¤è¿›åº¦å¯¹è±¡ï¼›
        // - å¦‚æœæ˜¯å­—æ¯æ¨¡å—ï¼Œåˆ™è‡ªåŠ¨åˆå§‹åŒ– user_progress åæ”¾è¡Œï¼›
        // - å…¶ä»–æ¨¡å—ä¿æŒåŸæœ‰è¡Œä¸ºï¼ˆæ‹’ç»è®¿é—®ï¼‰ã€‚
        if (forceUnlock) {
            console.warn('âš ï¸ FORCE_UNLOCK å·²å¼€å¯, ä½†æœªæ‰¾åˆ° user_progress è®°å½•, ä½¿ç”¨é»˜è®¤è¿›åº¦:', moduleType);
            const progress = {
                userId,
                letterCompleted: true,
                letterProgress: 1,
                wordUnlocked: true,
                wordProgress: 1,
                sentenceUnlocked: true,
                sentenceProgress: 1,
                articleUnlocked: true,
                articleProgress: 1,
                currentStage: moduleType,
            };
            return {
                allowed: true,
                progress,
            };
        }

        // å­—æ¯æ¨¡å—ï¼šè‡ªåŠ¨åˆå§‹åŒ–è¿›åº¦è®°å½•ï¼Œé¿å…ç¬¬ä¸€æ¬¡è¿›å…¥å­—æ¯æ¨¡å—å°±è¢«æ‹’ç»
        if (moduleType === 'letter') {
            console.warn('â„¹ï¸ æœªæ‰¾åˆ° user_progress è®°å½•, ä¸ºå­—æ¯æ¨¡å—è‡ªåŠ¨åˆå§‹åŒ–è¿›åº¦:', userId);
            const progress = await initUserProgress(db, userId);
            return {
                allowed: true,
                progress,
            };
        }

        // éå­—æ¯æ¨¡å—ï¼šä»ç„¶è¦æ±‚å…ˆæœ‰è¿›åº¦è®°å½•
        return {
            allowed: false,
            errorCode: 'USER_PROGRESS_NOT_FOUND',
            message: 'ç”¨æˆ·å­¦ä¹ è¿›åº¦ä¸å­˜åœ¨,è¯·è”ç³»ç®¡ç†å‘˜',
        };
    }

    const progress = progressResult.data[0];
    const letterProgress = typeof progress.letterProgress === 'number'
        ? progress.letterProgress
        : 0;

    // 2. è°ƒè¯•æ€»å¼€å…³ï¼šä¸€é”®è§£é”æ‰€æœ‰æ¨¡å—
    if (forceUnlock) {
        console.warn('âš ï¸ FORCE_UNLOCK å·²å¼€å¯, å¼ºåˆ¶æ”¾è¡Œæ¨¡å—:', moduleType);
        return {
            allowed: true,
            progress: {
                ...progress,
                letterCompleted: true,
                letterProgress: 1,
                wordUnlocked: true,
                sentenceUnlocked: true,
                articleUnlocked: true,
                currentStage: moduleType,
            },
        };
    }

    // 3. å­—æ¯æ¨¡å—æ°¸è¿œå…è®¸è®¿é—®
    if (moduleType === 'letter') {
        return {
            allowed: true,
            progress,
        };
    }

    // 4. å…¶ä»–æ¨¡å—ï¼šç»Ÿä¸€ä½¿ç”¨ã€ŒäºŒé€‰ä¸€ã€è§„åˆ™
    // - letterCompleted === true
    // - æˆ– letterProgress >= 0.8 (å³ 80%)
    const finishedByTest = !!progress.letterCompleted;
    const finishedByProgress = letterProgress >= 0.8;

    if (!finishedByTest && !finishedByProgress) {
        return {
            allowed: false,
            errorCode: 'MODULE_LOCKED',
            message: `è¯·å…ˆå®Œæˆå­—æ¯å­¦ä¹ ï¼ˆå½“å‰è¿›åº¦ï¼š${Math.round(letterProgress * 100)}%ï¼‰`,
            progress,
        };
    }

    return {
        allowed: true,
        progress,
    };
}

module.exports = {
    createMemoryRecord,
    getOrCreateMemory,
    updateMemoryAfterReview,
    getTodayReviewEntities,
    // checkAndUnlockNextStage,
    initUserProgress,
    checkModuleAccess
};
````

## File: cloudbase/functions/user-register/index.js
````javascript
const cloud = require('wx-server-sdk');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
});

const db = cloud.database();
const _ = db.command;

//JWT Secret
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';
const JWT_EXPIRES_IN = '7d'; // 7 days

exports.main = async (event, context) => {
  // Parse request body if coming from HTTP trigger
  let requestData = event;
  if (typeof event.body === 'string') {
    try {
      requestData = JSON.parse(event.body);
    } catch (e) {
      return {
        success: false,
        message: 'Invalid JSON in request body',
        code: 'INVALID_JSON'
      };
    }
  } else if (event.body && typeof event.body === 'object') {
    requestData = event.body;
  }

  const { email, password, displayName, role = 'LEARNER' } = requestData;

  // Validate required fields
  if (!email || !password || !displayName) {
    return {
      success: false,
      message: 'Missing required fields: email, password, displayName',
      code: 'MISSING_FIELDS'
    };
  }

  try {
    // Check if email already exists 
    const existingUser = await db.collection('users').where({
      email: email.toLowerCase()
    }).count();

    if (existingUser.count > 0) {
      return {
        success: false,
        message: 'é‚®ç®±å·²å­˜åœ¨ \n Email already exists',
        code: 'EMAIL_EXISTS'
      };
    }

    // ===== Hash password =====
    const salt = await bcrypt.genSalt(10);
    const passwordHash = await bcrypt.hash(password, salt);

    // åˆ›å»ºæ–°ç”¨æˆ·
    const userId = `u_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const registrationDate = new Date().toISOString();
    const userDoc = {
      userId,
      email: email.toLowerCase(),
      passwordHash,
      displayName,
      role,
      registrationDate,
      lastLogin: registrationDate,
      isActive: true,
      preferences: {
        language: 'zh',
        notificationsEnabled: true
      }
    };
    // ===== Save to database =====
    await db.collection('users').add({
      data: userDoc
    });

    // åˆå§‹åŒ–ç”¨æˆ·æ•´ä½“å­¦ä¹ è¿›åº¦ (ç»Ÿä¸€è¿›åº¦è¡¨)
    await db.collection('user_progress').add({
      data: {
        userId,
        letterCompleted: false,
        debugSkipLetter: false,
        letterProgress: 0.0,
        wordProgress: 0.0,
        sentenceProgress: 0.0,
        totalStudyDays: 0,
        streakDays: 0,
        lastStudyDate: null,
        createdAt: registrationDate,
        updatedAt: registrationDate
      }
    });

    // åˆå§‹åŒ–å­—æ¯æ¨¡å—ä¸“ç”¨è¿›åº¦è¡¨
    // è¯´æ˜:
    // - letterProgress: 0â€“1 ä¹‹é—´çš„å°æ•°, 0.8 ä»£è¡¨ 80%
    // - letterCompleted: ä¸‰è½®å…¨éƒ¨å®Œæˆåç”±è®°å¿†å¼•æ“æ›´æ–°ä¸º true
    // - completedLessons: å·²å®Œæˆçš„å­—æ¯è¯¾ç¨‹IDåˆ—è¡¨ (ä¾‹å¦‚: ["alphabet-lesson1"])
    // - masteredLetterCount: å·²æŒæ¡çš„å­—æ¯æ•°é‡
    // - totalLetterCount: å­—æ¯æ€»æ•° (å½“å‰çº¦ 80, é¢„ç•™ç»™æœªæ¥æ‰©å±•)
    await db.collection('user_alphabet_progress').add({
      data: {
        userId,
        letterProgress: 0.0,
        letterCompleted: false,
        completedLessons: [],
        masteredLetterCount: 0,
        totalLetterCount: 80,
        currentRound: 1,          // ğŸ”¥ æ–°å¢ï¼šé»˜è®¤ä»ç¬¬1è½®å¼€å§‹
        roundHistory: [],         // ğŸ”¥ æ–°å¢ï¼šè½®æ¬¡å†å²è®°å½•
        createdAt: registrationDate,
        updatedAt: registrationDate,
      }
    });

    // ===== Generate JWT token =====
    const token = jwt.sign(
      {
        userId,
        email: email.toLowerCase(),
        role
      },
      JWT_SECRET,
      { expiresIn: JWT_EXPIRES_IN }
    );
    // ===== Return user data (exclude password hash) =====
    const { passwordHash: _, ...userResponse } = userDoc;

    return {
      success: true,
      data: {
        user: userResponse,
        token,
        expiresIn: 604800 // 7 days in seconds
      }
    };

  } catch (error) {
    console.error('æ³¨å†Œå¤±è´¥:', error);
    return {
      success: false,
      message: 'æ³¨å†Œå¤±è´¥: ' + error.message
    };
  }
};
````

## File: src/components/learning/alphabet/AlphabetLearningView.tsx
````typescript
// src/components/learning/alphabet/AlphabetLearningView.tsx

import React, { memo, useCallback, useRef, useEffect, useState } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  ScrollView,
  Platform,
} from 'react-native';
import { Audio } from 'expo-av';
import { Volume2, Play } from 'lucide-react-native';

import type { AlphabetLearningState } from '@/src/stores/alphabetStore';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

interface AlphabetLearningViewProps {
  alphabet: AlphabetLearningState;
  onNext: () => void;
  onBack?: () => void;
}

export const AlphabetLearningView = memo(function AlphabetLearningView({
  alphabet,
  onNext,
  onBack,
}: AlphabetLearningViewProps) {
  const soundRef = useRef<Audio.Sound | null>(null);
  const audioModeConfiguredRef = useRef(false);
  const autoPlayCounter = useRef(0);
  const [isPlaying, setIsPlaying] = useState(false);

  const letter = alphabet.letter;
  const lessonOrder = letter.primaryCurriculumLessonOrder;

  const thaiChar = letter.thaiChar;
  const nameEnglish = letter.nameEnglish;

  const syllableSoundName = letter.syllableSoundName;

  const initialSound = letter.initialSound;
  const finalSound = letter.finalSound;

  const exampleWord = letter.exampleWord;
  const exampleMeaning = letter.exampleMeaning;
  const syllableSoundUrl = letter.syllableSoundUrl;
  const endSyllableSoundUrl = letter.endSyllableSoundUrl;

  const fullSoundLocalPath = letter.fullSoundLocalPath;
  const coreSyllableLocalPath = letter.syllableSoundLocalPath;
  const endSyllableSoundLocalPath = letter.endSyllableSoundLocalPath;
  const exampleWordLocalPath = letter.letterPronunciationLocalPath;

  // --- Audio Logic ---

  const resolveAudioPath = useCallback(
    (primary?: string | null) => {
      //  relaxes strict file:// check, allowing any valid path string
      if (primary && primary.length > 0) return primary;
      if (alphabet.audioUrl && alphabet.audioUrl.length > 0)
        return alphabet.audioUrl;
      return null;
    },
    [alphabet.audioUrl]
  );


  const playLocalAudio = useCallback(async (localPath?: string | null) => {
    // Relaxes check: allow any string path
    if (!localPath) return;


    try {
      setIsPlaying(true);
      if (!audioModeConfiguredRef.current) {
        await Audio.setAudioModeAsync({
          allowsRecordingIOS: false,
          playsInSilentModeIOS: true,
          staysActiveInBackground: false,
          shouldDuckAndroid: true,
          playThroughEarpieceAndroid: false,
        });
        audioModeConfiguredRef.current = true;
      }

      if (soundRef.current) {
        await soundRef.current.unloadAsync().catch(() => { });
        soundRef.current = null;
      }

      const { sound } = await Audio.Sound.createAsync(
        { uri: localPath },
        { shouldPlay: true }
      );
      soundRef.current = sound;

      sound.setOnPlaybackStatusUpdate((status) => {
        if (status.isLoaded && status.didJustFinish) {
          setIsPlaying(false);
        }
      });
    } catch (e) {
      console.warn('âŒ Playback failed:', e);
      setIsPlaying(false);
    }
  }, []);

  const handlePlayFullLetter = useCallback(() => {
    const path = resolveAudioPath(fullSoundLocalPath);
    void playLocalAudio(path);
  }, [fullSoundLocalPath, resolveAudioPath, playLocalAudio]);

  const handlePlayCoreSyllable = useCallback(() => {
    const path = resolveAudioPath(coreSyllableLocalPath);
    void playLocalAudio(path);
  }, [coreSyllableLocalPath, resolveAudioPath, playLocalAudio]);

  const handlePlayEndSyllable = useCallback(() => {
    const path = resolveAudioPath(
      endSyllableSoundLocalPath || coreSyllableLocalPath
    );
    void playLocalAudio(path);
  }, [endSyllableSoundLocalPath, coreSyllableLocalPath, resolveAudioPath, playLocalAudio]);

  // Position Sound Handlers
  const handlePlayInitialSound = useCallback(() => {
    // Priority: Local Cache -> Remote Specific URL -> (resolveAudioPath Fallback to Full)
    const path = resolveAudioPath(coreSyllableLocalPath || syllableSoundUrl);
    void playLocalAudio(path);
  }, [coreSyllableLocalPath, syllableSoundUrl, resolveAudioPath, playLocalAudio]);

  const handlePlayFinalSound = useCallback(() => {
    // Priority: Local Final -> Remote Final -> Local Syllable -> Remote Syllable
    const path = resolveAudioPath(
      endSyllableSoundLocalPath || endSyllableSoundUrl || coreSyllableLocalPath || syllableSoundUrl
    );
    void playLocalAudio(path);
  }, [endSyllableSoundLocalPath, endSyllableSoundUrl, coreSyllableLocalPath, syllableSoundUrl, resolveAudioPath, playLocalAudio]);

  const handlePlayExampleWord = useCallback(() => {
    const path = resolveAudioPath(
      exampleWordLocalPath || fullSoundLocalPath || coreSyllableLocalPath
    );
    void playLocalAudio(path);
  }, [exampleWordLocalPath, fullSoundLocalPath, coreSyllableLocalPath, resolveAudioPath, playLocalAudio]);


  // --- Auto-Play Logic (2 times) ---

  useEffect(() => {
    // Reset counter on letter change
    autoPlayCounter.current = 0;

    const playTwice = async () => {
      const path = resolveAudioPath(fullSoundLocalPath);
      if (!path) return;

      // First play
      await playLocalAudio(path);

      // Wait a bit before second play
      setTimeout(async () => {
        // Check if still mounted/same letter context basically (ref check)
        if (autoPlayCounter.current < 2) {
          await playLocalAudio(path);
          autoPlayCounter.current = 2; // Mark done
        }
      }, 1500); // 1.5s delay
    };

    void playTwice();

    return () => {
      if (soundRef.current) {
        soundRef.current.unloadAsync().catch(() => { });
      }
    };
  }, [letter._id, resolveAudioPath, fullSoundLocalPath, playLocalAudio]);


  // --- Render ---

  return (
    <ScrollView
      style={styles.container}
      contentContainerStyle={styles.contentContainer}
      showsVerticalScrollIndicator={false}
    >
      {/* Top Header Label */}
      <View style={styles.header}>
        <Text style={styles.headerText}>
          {lessonOrder ? `Lesson ${lessonOrder} Â· ` : ''}Learning Letter
        </Text>
      </View>

      {/* Hero Card */}
      <View style={styles.heroCard}>
        <View style={styles.heroInner}>
          <Text style={styles.thaiChar}>{thaiChar}</Text>
          {nameEnglish && <Text style={styles.englishName}>{nameEnglish}</Text>}

          <TouchableOpacity
            style={[styles.mainPlayButton, isPlaying && styles.buttonActive]}
            onPress={handlePlayFullLetter}
            disabled={!resolveAudioPath(fullSoundLocalPath)}
          >
            <Volume2 size={24} color={Colors.white} />
            <Text style={styles.mainPlayText}>Play Full Sound</Text>
          </TouchableOpacity>
        </View>
      </View>

      {/* Details Card */}
      <View style={styles.detailsCard}>

        {/* Row 1: Syllable Sound */}
        <View style={styles.detailRow}>
          <View style={styles.detailLabelContainer}>
            <View style={styles.iconCircle}>
              <Text style={styles.iconText}>ğŸ”Š</Text>
            </View>
            <Text style={styles.detailLabel}>Core Sound</Text>
          </View>
          <TouchableOpacity
            style={styles.detailAction}
            onPress={handlePlayCoreSyllable}
            disabled={!resolveAudioPath(coreSyllableLocalPath)}
          >
            <Text style={styles.detailValue}>/{syllableSoundName || '-'}/</Text>
            <Play size={16} color={Colors.thaiGold} fill={Colors.thaiGold} />
          </TouchableOpacity>
        </View>

        <View style={styles.divider} />

        {/* Row 2: Initial / Final */}
        <View style={styles.detailRow}>
          <View style={styles.detailLabelContainer}>
            <View style={styles.iconCircle}>
              <Text style={styles.iconText}>ğŸ§©</Text>
            </View>
            <Text style={styles.detailLabel}>Position</Text>
          </View>
          <View style={styles.positionContainer}>
            <TouchableOpacity
              style={styles.positionBlock}
              onPress={handlePlayInitialSound}
              disabled={!resolveAudioPath(coreSyllableLocalPath || syllableSoundUrl)}
            >
              <Text style={styles.positionLabel}>Initial</Text>
              <View style={styles.positionValueRow}>
                <Text style={styles.positionValue}>/{initialSound || '-'}/</Text>
                <Play size={12} color={Colors.thaiGold} fill={Colors.thaiGold} style={{ marginLeft: 4 }} />
              </View>
            </TouchableOpacity>

            <View style={styles.verticalDivider} />

            <TouchableOpacity
              style={styles.positionBlock}
              onPress={handlePlayFinalSound}
              disabled={!resolveAudioPath(endSyllableSoundLocalPath || endSyllableSoundUrl || coreSyllableLocalPath || syllableSoundUrl)}
            >
              <Text style={styles.positionLabel}>Final</Text>
              <View style={styles.positionValueRow}>
                <Text style={styles.positionValue}>/{finalSound || '-'}/</Text>
                <Play size={12} color={Colors.thaiGold} fill={Colors.thaiGold} style={{ marginLeft: 4 }} />
              </View>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.divider} />

        {/* Row 3: Example Word */}
        <View style={styles.detailRow}>
          <View style={styles.detailLabelContainer}>
            <View style={styles.iconCircle}>
              <Text style={styles.iconText}>ğŸ“Œ</Text>
            </View>
            <Text style={styles.detailLabel}>Example</Text>
          </View>
          <TouchableOpacity
            style={styles.detailAction}
            onPress={handlePlayExampleWord}
            disabled={!resolveAudioPath(exampleWordLocalPath || fullSoundLocalPath)}
          >
            <View style={{ alignItems: 'flex-end' }}>
              <Text style={styles.exampleWord}>{exampleWord || '-'}</Text>
              {exampleMeaning && <Text style={styles.exampleMeaning}>{exampleMeaning}</Text>}
            </View>
            <Play size={16} color={Colors.thaiGold} fill={Colors.thaiGold} />
          </TouchableOpacity>
        </View>

      </View>

      {/* Footer Navigation */}
      <View style={styles.footer}>
        <TouchableOpacity style={styles.continueButton} onPress={onNext}>
          <Text style={styles.continueText}>Continue</Text>
        </TouchableOpacity>
      </View>

    </ScrollView>
  );
});

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F8F9FA',
  },
  contentContainer: {
    padding: 24,
    paddingBottom: 48,
  },
  header: {
    alignItems: 'center',
    marginBottom: 24,
    marginTop: 8,
  },
  headerText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
    letterSpacing: 1,
    textTransform: 'uppercase',
  },
  heroCard: {
    backgroundColor: Colors.white,
    borderRadius: 24,
    padding: 32,
    alignItems: 'center',
    marginBottom: 24,
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 8 },
        shadowOpacity: 0.08,
        shadowRadius: 16,
      },
      android: {
        elevation: 6,
      },
    }),
  },
  heroInner: {
    alignItems: 'center',
    width: '100%',
  },
  thaiChar: {
    fontFamily: Typography.playfairBold,
    fontSize: 96,
    color: Colors.ink,
    lineHeight: 110,
    marginBottom: 8,
  },
  englishName: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 18,
    color: Colors.taupe,
    marginBottom: 24,
  },
  mainPlayButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.thaiGold,
    paddingVertical: 14,
    paddingHorizontal: 32,
    borderRadius: 100,
    gap: 8,
    width: '100%',
    justifyContent: 'center',
  },
  buttonActive: {
    opacity: 0.8,
    transform: [{ scale: 0.98 }]
  },
  mainPlayText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
  },
  detailsCard: {
    backgroundColor: Colors.white,
    borderRadius: 20,
    padding: 24,
    marginBottom: 32,
    borderWidth: 1,
    borderColor: '#EFEFEF',
  },
  detailRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 12,
  },
  divider: {
    height: 1,
    backgroundColor: '#F0F0F0',
    marginVertical: 4,
  },
  detailLabelContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  iconCircle: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: '#F9FAFB',
    justifyContent: 'center',
    alignItems: 'center',
  },
  iconText: {
    fontSize: 16,
  },
  detailLabel: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 15,
    color: Colors.ink,
  },
  detailAction: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    backgroundColor: '#FFFCF5', // Light gold bg
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: 'rgba(212, 175, 55, 0.2)',
  },
  detailValue: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.ink,
  },
  positionContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 16,
  },
  positionBlock: {
    alignItems: 'center',
  },
  positionLabel: {
    fontSize: 10,
    color: Colors.taupe,
    textTransform: 'uppercase',
    marginBottom: 2,
    fontFamily: Typography.notoSerifRegular,
  },
  positionValue: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 15,
    color: Colors.ink,
  },
  verticalDivider: {
    width: 1,
    height: 24,
    backgroundColor: '#E0E0E0',
  },
  exampleWord: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.ink,
  },
  exampleMeaning: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 12,
    color: Colors.taupe,
  },
  positionValueRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },

  footer: {
    alignItems: 'center',
  },
  continueButton: {
    width: '100%',
    backgroundColor: Colors.ink,
    paddingVertical: 16,
    borderRadius: 16,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  continueText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
  },
});
````

## File: .gitignore
````
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
.kotlin/
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

# generated native folders
/ios
/android

# environment variables
.env

# Local reference data (do not commit)
assets/courses/
assets/data/

# docs
docs/Document/
docs/OLD/
/Rule
# Environment variables
.env.local
````

## File: README.md
````markdown
# ğŸ‡¹ğŸ‡­ ThaiLearningApp - æ³°è¯­å­¦ä¹ åº”ç”¨
âš ï¸ AI Development Rules

This project is governed by CLAUDE.md.
All AI-assisted changes must comply with it.

<div align="center">

![Version](https://img.shields.io/badge/version-1.0.0-blue.svg)
![React Native](https://img.shields.io/badge/React%20Native-0.76.9-61dafb.svg)
![Expo](https://img.shields.io/badge/Expo-~52.0.38-000020.svg)
![TypeScript](https://img.shields.io/badge/TypeScript-5.1.3-3178c6.svg)
![License](https://img.shields.io/badge/license-MIT-green.svg)

ä¸€æ¬¾ä¼˜é›…çš„æ³°è¯­å­¦ä¹ åº”ç”¨ï¼Œé‡‡ç”¨é—´éš”é‡å¤ç®—æ³•ï¼Œæä¾›æ²‰æµ¸å¼çš„å­¦ä¹ ä½“éªŒã€‚

[åŠŸèƒ½ç‰¹æ€§](#-åŠŸèƒ½ç‰¹æ€§) â€¢ [æŠ€æœ¯æ ˆ](#-æŠ€æœ¯æ ˆ) â€¢ [å¿«é€Ÿå¼€å§‹](#-å¿«é€Ÿå¼€å§‹) â€¢ [é¡¹ç›®ç»“æ„](#-é¡¹ç›®ç»“æ„) â€¢ [å¼€å‘æŒ‡å—](#-å¼€å‘æŒ‡å—)

</div>

---

## ğŸ“¸ åº”ç”¨æˆªå›¾

<div align="center">
  <img src="./docs/screenshots/home.png" width="250" alt="é¦–é¡µ" />
  <img src="./docs/screenshots/learning.png" width="250" alt="å­¦ä¹ é¡µé¢" />
  <img src="./docs/screenshots/review.png" width="250" alt="å¤ä¹ é¡µé¢" />
</div>

## âœ¨ åŠŸèƒ½ç‰¹æ€§

### ğŸ¯ æ ¸å¿ƒåŠŸèƒ½
- **ç»Ÿä¸€å­¦ä¹ ä¼šè¯**: å¤ä¹ æ—§è¯ + å­¦ä¹ æ–°è¯çš„å®Œæ•´å­¦ä¹ æµç¨‹
- **é—´éš”é‡å¤ç®—æ³•**: åŸºäºè®°å¿†æ›²çº¿çš„æ™ºèƒ½å¤ä¹ ç³»ç»Ÿï¼ˆæ¯ä¸ªå•è¯é‡å¤3æ¬¡ï¼‰
- **ä¸‰çº§è¯„ä¼°ç³»ç»Ÿ**: è®¤è¯†/æ¨¡ç³Š/å¿˜è®°äº† - ç²¾å‡†è®°å½•å­¦ä¹ çŠ¶æ€
- **è·³è¿‡å¤ä¹ **: çµæ´»çš„å­¦ä¹ èŠ‚å¥æ§åˆ¶

### ğŸŒ å›½é™…åŒ–æ”¯æŒ
- **å¤šè¯­è¨€ç•Œé¢**: å®Œæ•´æ”¯æŒä¸­æ–‡/English
- **è‡ªåŠ¨è¯­è¨€æ£€æµ‹**: æ ¹æ®è®¾å¤‡è¯­è¨€è‡ªåŠ¨åˆ‡æ¢
- **æŒä¹…åŒ–åå¥½**: è®°ä½ç”¨æˆ·çš„è¯­è¨€é€‰æ‹©

### ğŸ¨ UI/UX è®¾è®¡
- **æ³°å›½é£æ ¼ä¸»é¢˜**: é‡‘è‰² (#D4AF37) + å¢¨è‰² (#1A1A1A) ä¼˜é›…é…è‰²
- **æ¨¡ç³Šé®ç½©æ•ˆæœ**: æ¸è¿›å¼ä¿¡æ¯å±•ç¤ºï¼Œå¢å¼ºå­¦ä¹ ä½“éªŒ
- **æµç•…åŠ¨ç”»**: ä½¿ç”¨ `expo-blur` å’Œ `react-native-reanimated`
- **å“åº”å¼å¸ƒå±€**: é€‚é…å„ç§å±å¹•å°ºå¯¸

### ğŸ“š å­¦ä¹ åŠŸèƒ½
- **æ–°è¯å­¦ä¹ **: 
  - ä¸‰ä¸ªæ ‡ç­¾é¡µï¼šåŸºç¡€é‡Šä¹‰ã€ä¾‹å¥ç¤ºä¾‹ã€ç”¨æ³•è¯¦è§£
  - éŸ³é¢‘å‘éŸ³æŒ‰é’®ï¼ˆå‡†å¤‡æ¥å…¥ï¼‰
  - æ¸è¿›å¼å†…å®¹å±•ç¤º
- **å•è¯å¤ä¹ **:
  - ä¸Šä¸‹æ–‡ä¾‹å¥å±•ç¤º
  - ä¸‰æŒ‰é’®å¿«é€Ÿè¯„ä¼°
  - å³æ—¶åé¦ˆ

### ğŸ“Š è¿›åº¦è¿½è¸ª
- å­¦ä¹ å¤©æ•°ç»Ÿè®¡
- å­¦ä¹ æ—¶é•¿è®°å½•
- æŒæ¡å•è¯æ•°é‡
- è¿ç»­æ‰“å¡å¤©æ•°

## ğŸ›  æŠ€æœ¯æ ˆ

### å‰ç«¯æ¡†æ¶
- **React Native** 0.76.9 - è·¨å¹³å°ç§»åŠ¨åº”ç”¨æ¡†æ¶
- **Expo** ~52.0.38 - å¼€å‘å·¥å…·é“¾
- **Expo Router** ~4.0.20 - æ–‡ä»¶ç³»ç»Ÿè·¯ç”±
- **TypeScript** 5.1.3 - ç±»å‹å®‰å…¨

### UI ç»„ä»¶
- **expo-blur** - æ¨¡ç³Šæ•ˆæœ
- **lucide-react-native** - å›¾æ ‡åº“
- **react-native-svg** - SVG æ”¯æŒ
- **expo-linear-gradient** - æ¸å˜æ•ˆæœ

### çŠ¶æ€ç®¡ç† & æ•°æ®
- **Zustand** 5.0.8 - è½»é‡çº§çŠ¶æ€ç®¡ç†
- **i18next** 25.6.3 - å›½é™…åŒ–
- **react-i18next** 16.3.4 - React å›½é™…åŒ–ç»‘å®š
- **AsyncStorage** - æœ¬åœ°å­˜å‚¨

### å­—ä½“
- **Playfair Display** - è‹±æ–‡æ ‡é¢˜
- **Noto Serif SC** - ä¸­æ–‡æ­£æ–‡
- **Sarabun** - æ³°æ–‡ä¸“ç”¨

### åç«¯å‡†å¤‡
- **Tencent CloudBase** - äº‘å¼€å‘å¹³å°ï¼ˆå‡†å¤‡æ¥å…¥ï¼‰
- **Axios** - HTTP å®¢æˆ·ç«¯

## ğŸš€ å¿«é€Ÿå¼€å§‹

### ç¯å¢ƒè¦æ±‚
- Node.js >= 18.x
- npm æˆ– yarn
- iOS Simulator (macOS) æˆ– Android Emulator

### å®‰è£…æ­¥éª¤

1. **å…‹éš†ä»“åº“**
```bash
git clone https://github.com/yourusername/ThaiLearningApp.git
cd ThaiLearningApp
```

2. **å®‰è£…ä¾èµ–**
```bash
npm install
```

3. **å¯åŠ¨å¼€å‘æœåŠ¡å™¨**
```bash
npm start
```

4. **è¿è¡Œåº”ç”¨**
```bash
# iOS
npm run ios

# Android
npm run android

# Web
npm run web
```

### ç¯å¢ƒå˜é‡é…ç½®

åˆ›å»º `.env` æ–‡ä»¶ï¼š
```env
EXPO_PUBLIC_CLOUDBASE_ENV_ID=your_cloudbase_env_id
EXPO_PUBLIC_API_BASE_URL=your_api_base_url
```

## ğŸ“ é¡¹ç›®ç»“æ„

```
ThaiLearningApp/
â”œâ”€â”€ app/                          # Expo Router é¡µé¢
â”‚   â”œâ”€â”€ (auth)/                   # è®¤è¯æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ login.tsx
â”‚   â”‚   â”œâ”€â”€ register.tsx
â”‚   â”‚   â””â”€â”€ forgot-password.tsx
â”‚   â”œâ”€â”€ (tabs)/                   # ä¸»å¯¼èˆª
â”‚   â”‚   â”œâ”€â”€ index.tsx             # é¦–é¡µ
â”‚   â”‚   â”œâ”€â”€ courses.tsx           # è¯¾ç¨‹åˆ—è¡¨
â”‚   â”‚   â””â”€â”€ profile.tsx           # ä¸ªäººä¸­å¿ƒ
â”‚   â”œâ”€â”€ learning/                 # å­¦ä¹ æ¨¡å—
â”‚   â”‚   â””â”€â”€ index.tsx             # ç»Ÿä¸€å­¦ä¹ ä¼šè¯
â”‚   â””â”€â”€ _layout.tsx               # æ ¹å¸ƒå±€
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/               # ç»„ä»¶åº“
â”‚   â”‚   â”œâ”€â”€ common/               # é€šç”¨ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ learning/             # å­¦ä¹ ç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ NewWordView.tsx   # æ–°è¯å­¦ä¹ 
â”‚   â”‚   â”‚   â””â”€â”€ ReviewWordView.tsx # å¤ä¹ è§†å›¾
â”‚   â”‚   â”œâ”€â”€ progress/             # è¿›åº¦ç»„ä»¶
â”‚   â”‚   â””â”€â”€ pronunciation/        # å‘éŸ³ç»„ä»¶
â”‚   â”œâ”€â”€ constants/                # å¸¸é‡å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ colors.ts             # é¢œè‰²ç³»ç»Ÿ
â”‚   â”‚   â””â”€â”€ typography.ts         # å­—ä½“ç³»ç»Ÿ
â”‚   â”œâ”€â”€ i18n/                     # å›½é™…åŒ–
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ locales/
â”‚   â”‚       â”œâ”€â”€ zh.ts             # ä¸­æ–‡
â”‚   â”‚       â””â”€â”€ en.ts             # è‹±æ–‡
â”‚   â”œâ”€â”€ stores/                   # Zustand çŠ¶æ€
â”‚   â”‚   â”œâ”€â”€ authStore.ts
â”‚   â”‚   â”œâ”€â”€ languageStore.ts
â”‚   â”‚   â””â”€â”€ learningStore.ts
â”‚   â”œâ”€â”€ entities/                 # ç±»å‹å®šä¹‰
â”‚   â””â”€â”€ utils/                    # å·¥å…·å‡½æ•°
â”œâ”€â”€ cloudbase/                    # äº‘å¼€å‘
â”‚   â””â”€â”€ functions/                # äº‘å‡½æ•°
â”œâ”€â”€ docs/                         # æ–‡æ¡£
â”‚   â”œâ”€â”€ project-snapshot-v5.md    # é¡¹ç›®å¿«ç…§
â”‚   â””â”€â”€ screenshots/              # æˆªå›¾
â””â”€â”€ assets/                       # é™æ€èµ„æº
```

## ğŸ¨ è®¾è®¡ç³»ç»Ÿ

### é¢œè‰²è§„èŒƒ
```typescript
Colors = {
  paper: '#FAF9F6',      // èƒŒæ™¯è‰²
  ink: '#1A1A1A',        // ä¸»æ–‡æœ¬
  sand: '#E5E2DB',       // è¾¹æ¡†
  taupe: '#8E8B82',      // æ¬¡è¦æ–‡æœ¬
  thaiGold: '#D4AF37',   // å¼ºè°ƒè‰²
  accent: '#B8956A',     // è¾…åŠ©è‰²
}
```

### å­—ä½“è§„èŒƒ
- **æ ‡é¢˜**: Playfair Display (è‹±æ–‡) / Noto Serif SC (ä¸­æ–‡)
- **æ­£æ–‡**: Noto Serif SC
- **æ³°æ–‡**: Sarabun

### ç»„ä»¶è§„èŒƒ
è¯¦è§ [é¡¹ç›®å¿«ç…§ v5](./docs/project-snapshot-v5.md)

## ğŸ’» å¼€å‘æŒ‡å—

### æ·»åŠ æ–°é¡µé¢
ä½¿ç”¨ Expo Router æ–‡ä»¶ç³»ç»Ÿè·¯ç”±ï¼š
```bash
# åˆ›å»ºæ–°é¡µé¢
touch app/new-page.tsx
```

### æ·»åŠ æ–°ç»„ä»¶
```bash
# åˆ›å»ºç»„ä»¶
touch src/components/MyComponent.tsx
```

### å›½é™…åŒ–
1. åœ¨ `src/i18n/locales/zh.ts` å’Œ `en.ts` æ·»åŠ ç¿»è¯‘é”®
2. åœ¨ç»„ä»¶ä¸­ä½¿ç”¨ï¼š
```tsx
import { useTranslation } from 'react-i18next';

const MyComponent = () => {
  const { t } = useTranslation();
  return <Text>{t('myKey')}</Text>;
};
```

### çŠ¶æ€ç®¡ç†
ä½¿ç”¨ Zustandï¼š
```tsx
import { create } from 'zustand';

const useMyStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}));
```

## ï¿½ åç«¯æ¥å…¥

### æ•°æ®ç»“æ„

#### å•è¯ (Word)
```typescript
interface WordData {
  id: string;
  thai: string;           // æ³°æ–‡
  phonetic: string;       // ç½—é©¬éŸ³
  type: string;           // è¯æ€§
  meaning: string;        // é‡Šä¹‰
  definitions: {
    basic: string;
    examples: { thai: string; meaning: string }[];
    usage: { /* ... */ };
  };
}
```

### API æ¥å£

#### è·å–å­¦ä¹ é˜Ÿåˆ—
```typescript
GET /api/learning/queue
Response: {
  reviewWords: WordData[];
  newWords: WordData[];
}
```

#### æäº¤å­¦ä¹ ç»“æœ
```typescript
POST /api/learning/submit
Body: {
  wordId: string;
  quality: 'know' | 'unsure' | 'forgot';
  timestamp: number;
}
```

è¯¦ç»†åç«¯æ¥å…¥æŒ‡å—è¯·å‚è€ƒ [é¡¹ç›®å¿«ç…§ v5](./docs/project-snapshot-v5.md#åç«¯æ¥å…¥æŒ‡å—)

## ğŸ“ å¼€å‘è§„èŒƒ

### ä»£ç é£æ ¼
- ä½¿ç”¨ TypeScript ä¸¥æ ¼æ¨¡å¼
- ç»„ä»¶ä½¿ç”¨å‡½æ•°å¼ç»„ä»¶ + Hooks
- æ ·å¼ä½¿ç”¨ StyleSheet.create()
- æ‰€æœ‰ç”¨æˆ·å¯è§æ–‡æœ¬å¿…é¡»å›½é™…åŒ–

### å‘½åè§„èŒƒ
- ç»„ä»¶æ–‡ä»¶: `PascalCase.tsx`
- å·¥å…·æ–‡ä»¶: `camelCase.ts`
- å¸¸é‡æ–‡ä»¶: `camelCase.ts`
- æ ·å¼å: `camelCase`

### Git æäº¤è§„èŒƒ
```
feat: æ–°åŠŸèƒ½
fix: ä¿®å¤bug
docs: æ–‡æ¡£æ›´æ–°
style: ä»£ç æ ¼å¼è°ƒæ•´
refactor: é‡æ„
test: æµ‹è¯•ç›¸å…³
chore: æ„å»º/å·¥å…·é“¾ç›¸å…³
```

## ğŸ—º è·¯çº¿å›¾

### v1.1 (è®¡åˆ’ä¸­)
- [ ] æ¥å…¥çœŸå®åç«¯ API
- [ ] å®ç°éŸ³é¢‘æ’­æ”¾åŠŸèƒ½
- [ ] æ·»åŠ å­¦ä¹ ç»Ÿè®¡å›¾è¡¨
- [ ] å®ç°ç¦»çº¿ç¼“å­˜

### v1.2 (è®¡åˆ’ä¸­)
- [ ] å®ç° SM-2 é—´éš”é‡å¤ç®—æ³•
- [ ] æ·»åŠ å•è¯æ”¶è—åŠŸèƒ½
- [ ] å®ç°å­¦ä¹ æé†’é€šçŸ¥
- [ ] æ·»åŠ ç¤¾äº¤åˆ†äº«åŠŸèƒ½

### v2.0 (è§„åˆ’ä¸­)
- [ ] AI è¯­éŸ³è¯„æµ‹
- [ ] ä¸ªæ€§åŒ–å­¦ä¹ è·¯å¾„
- [ ] ç¤¾åŒºäº’åŠ¨åŠŸèƒ½
- [ ] æ¸¸æˆåŒ–å­¦ä¹ 

## ğŸ¤ è´¡çŒ®æŒ‡å—

æ¬¢è¿è´¡çŒ®ä»£ç ï¼è¯·éµå¾ªä»¥ä¸‹æ­¥éª¤ï¼š

1. Fork æœ¬ä»“åº“
2. åˆ›å»ºç‰¹æ€§åˆ†æ”¯ (`git checkout -b feature/AmazingFeature`)
3. æäº¤æ›´æ”¹ (`git commit -m 'feat: Add some AmazingFeature'`)
4. æ¨é€åˆ°åˆ†æ”¯ (`git push origin feature/AmazingFeature`)
5. å¼€å¯ Pull Request

## ğŸ“„ è®¸å¯è¯

æœ¬é¡¹ç›®é‡‡ç”¨ MIT è®¸å¯è¯ - è¯¦è§ [LICENSE](LICENSE) æ–‡ä»¶

## ğŸ‘¥ å›¢é˜Ÿ

- **å¼€å‘è€…**: Liang Jianyu
- **è®¾è®¡**: ThaiLearningApp Team

## ğŸ“§ è”ç³»æ–¹å¼

- é¡¹ç›®ä¸»é¡µ: [GitHub](https://github.com/yourusername/ThaiLearningApp)
- é—®é¢˜åé¦ˆ: [Issues](https://github.com/yourusername/ThaiLearningApp/issues)

## ğŸ™ è‡´è°¢

- [Expo](https://expo.dev/) - ä¼˜ç§€çš„å¼€å‘å·¥å…·é“¾
- [React Native](https://reactnative.dev/) - å¼ºå¤§çš„è·¨å¹³å°æ¡†æ¶
- [Lucide Icons](https://lucide.dev/) - ç²¾ç¾çš„å›¾æ ‡åº“
- æ‰€æœ‰è´¡çŒ®è€…å’Œæ”¯æŒè€…

---

<div align="center">

**[â¬† å›åˆ°é¡¶éƒ¨](#-thailearningapp---æ³°è¯­å­¦ä¹ åº”ç”¨)**

Made with â¤ï¸ by ThaiLearningApp Team

</div>
````

## File: tsconfig.json
````json
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "jsx": "react-native",
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules"
  ]
}
````

## File: app/(tabs)/_layout.tsx
````typescript
// app/(tabs)/_layout.tsx
import { Tabs } from 'expo-router';
import { View, Text, Pressable, Platform, StyleSheet } from 'react-native';
import { Home, BookOpen, User } from 'lucide-react-native';
import { BlurView } from 'expo-blur';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

interface TabButtonProps {
  icon: React.ComponentType<any>;
  label: string;
  isActive: boolean;
  onPress: () => void;
}

function TabButton({ icon: Icon, label, isActive, onPress }: TabButtonProps) {
  return (
    <Pressable onPress={onPress} style={styles.tabButton}>
      <Icon
        size={22}
        strokeWidth={isActive ? 2 : 1.5}
        color={isActive ? Colors.ink : Colors.taupe}
      />
      <Text
        style={[
          styles.tabLabel,
          {
            color: isActive ? Colors.ink : Colors.taupe,
            fontFamily: Typography.notoSerifRegular,
          }
        ]}
      >
        {label}
      </Text>
    </Pressable>
  );
}

interface CustomTabBarProps {
  state: any;
  descriptors: any;
  navigation: any;
}

function CustomTabBar({ state, navigation }: CustomTabBarProps) {

  const insets = useSafeAreaInsets();

  return (
    <View
      style={[
        styles.tabBarContainer,
        {
          height: 64 + insets.bottom,
          paddingBottom: insets.bottom,
        }
      ]}
    >
      {Platform.OS === 'ios' && (
        <BlurView
          intensity={80}
          tint="light"
          style={StyleSheet.absoluteFill}
        />
      )}

      <View style={styles.tabBarContent}>
        {/* Left: Learn */}
        <TabButton
          icon={BookOpen}
          label="å­¦ä¹ "
          isActive={state.index === 1}
          onPress={() => navigation.navigate('courses')}
        />

        {/* Center: Home (Protruding) */}
        <View style={[styles.centerButtonContainer]}>
          <Pressable
            onPress={() => navigation.navigate('index')}
            style={[
              styles.centerButton,
              {
                backgroundColor: state.index === 0 ? Colors.ink : Colors.white,
              }
            ]}
          >
            <Home
              size={40}
              strokeWidth={2}
              color={state.index === 0 ? Colors.white : Colors.taupe}

            />
          </Pressable>
        </View>

        {/* Right: Profile */}
        <TabButton
          icon={User}
          label="æˆ‘çš„"
          isActive={state.index === 2}
          onPress={() => navigation.navigate('profile')}
        />
      </View>
    </View>
  );
}

export default function TabsLayout() {
  return (
    <Tabs
      screenOptions={{
        headerShown: false,
      }}
      tabBar={(props) => <CustomTabBar {...props} />}
    >
      <Tabs.Screen name="index" />
      <Tabs.Screen name="courses" />
      {/* profile è·¯ç”±ç”±æ–‡ä»¶ç³»ç»Ÿè‡ªåŠ¨åˆ›å»ºï¼Œæ— éœ€æ‰‹åŠ¨å£°æ˜ */}
    </Tabs>
  );
}

const styles = StyleSheet.create({
  tabBarContainer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    borderTopWidth: 1,
    borderTopColor: Colors.sand,
    backgroundColor: Platform.OS === 'ios' ? 'transparent' : Colors.white,
  },
  tabBarContent: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 48,
  },
  tabButton: {
    flexDirection: 'column',
    alignItems: 'center',
    gap: 4,
  },
  tabLabel: {
    fontSize: 10,
    fontWeight: '500',
    letterSpacing: 1.5,
  },
  centerButtonContainer: {
    position: 'absolute',
    left: '60%',
    marginLeft: -42,
  },
  centerButton: {
    width: 90,
    height: 90,
    borderRadius: 45,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 4,
    borderColor: Colors.paper,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 8,
  },
});
````

## File: app/alphabet/index.tsx
````typescript
// app/alphabet/index.tsx
// å­—æ¯è¯¾ç¨‹æ€»è§ˆé¡µï¼ˆè¯¾ç¨‹å…¥å£ â†’ Lesson 1~5ï¼‰

import React, { useEffect, useState, useRef, useMemo, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  Pressable,
  ActivityIndicator,
  Modal,
  Animated,
  Dimensions,
  TouchableWithoutFeedback
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { ArrowLeft, X, BookOpen, ChevronRight } from 'lucide-react-native';

import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { getAllLessons } from '@/src/config/alphabet/lessonMetadata.config';
import type { LessonMetadata } from '@/src/entities/types/phonicsRule.types';
import { callCloudFunction } from '@/src/utils/apiClient';
import { API_ENDPOINTS } from '@/src/config/api.endpoints';
import { useModuleAccessStore } from '@/src/stores/moduleAccessStore';

const { height: SCREEN_HEIGHT } = Dimensions.get('window');

interface LessonCardProps {
  id: string;
  title: string;
  description: string;
  letterKeys: string[];
  lessonData: LessonMetadata; // Store full metadata for drawer
  isCurrent: boolean;
  progress?: {
    completed: number;
    total: number;
  };
}

// --- Drawer Component ---

interface LessonDrawerProps {
  visible: boolean;
  lesson: LessonCardProps | null;
  onClose: () => void;
  onStart: () => void;
  unlocked: boolean;
}

const LessonDrawer = ({ visible, lesson, onClose, onStart, unlocked }: LessonDrawerProps) => {
  const slideAnim = useRef(new Animated.Value(SCREEN_HEIGHT)).current;
  const fadeAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (visible) {
      Animated.parallel([
        Animated.timing(slideAnim, {
          toValue: 0,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      Animated.parallel([
        Animated.timing(slideAnim, {
          toValue: SCREEN_HEIGHT,
          duration: 250,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 0,
          duration: 250,
          useNativeDriver: true,
        }),
      ]).start();
    }
  }, [visible, slideAnim, fadeAnim]);

  if (!lesson) return null;

  const { lessonData } = lesson;
  const allLetters = [
    ...lessonData.consonants,
    ...lessonData.vowels,
    ...lessonData.tones
  ];

  return (
    <Modal transparent visible={visible} onRequestClose={onClose}>
      <View style={drawerStyles.overlay}>
        <TouchableWithoutFeedback onPress={onClose}>
          <Animated.View style={[drawerStyles.backdrop, { opacity: fadeAnim }]} />
        </TouchableWithoutFeedback>

        <Animated.View
          style={[
            drawerStyles.sheet,
            { transform: [{ translateY: slideAnim }] }
          ]}
        >
          <View style={drawerStyles.handle} />

          {/* Header */}
          <View style={drawerStyles.header}>
            <View style={{ flex: 1 }}>
              <Text style={drawerStyles.title}>{lesson.title}</Text>
              <Text style={drawerStyles.subtitle}>Expected time: 15 mins</Text>
            </View>
            <Pressable onPress={onClose} style={drawerStyles.closeButton}>
              <X size={24} color={Colors.taupe} />
            </Pressable>
          </View>

          <ScrollView contentContainerStyle={drawerStyles.content}>
            <Text style={drawerStyles.sectionTitle}>Description</Text>
            <Text style={drawerStyles.description}>{lesson.description}</Text>

            <Text style={drawerStyles.sectionTitle}>Content Preview ({allLetters.length} items)</Text>
            <View style={drawerStyles.grid}>
              {allLetters.map((char, index) => (
                <View key={index} style={drawerStyles.gridItem}>
                  <Text style={drawerStyles.gridChar}>{char}</Text>
                </View>
              ))}
            </View>
          </ScrollView>

          {/* Footer Action */}
          <View style={drawerStyles.footer}>
            <Pressable
              style={[drawerStyles.startButton, !unlocked && drawerStyles.disabledBtn]}
              onPress={onStart}
              disabled={!unlocked}
            >
              <Text style={drawerStyles.startButtonText}>
                {unlocked ? 'Start Learning' : 'Locked'}
              </Text>
              {unlocked && <ChevronRight size={20} color={Colors.white} />}
            </Pressable>
          </View>
        </Animated.View>
      </View>
    </Modal>
  );
};

// --- Main Screen ---

export default function AlphabetCoursesScreen() {
  const router = useRouter();

  const [lessons, setLessons] = useState<LessonCardProps[]>([]);
  const [loading, setLoading] = useState<boolean>(true);

  // Drawer State
  const [selectedLesson, setSelectedLesson] = useState<LessonCardProps | null>(null);
  const [drawerVisible, setDrawerVisible] = useState(false);

  // ğŸ”¥ TODO-07: ä½¿ç”¨ moduleAccessStore è¯»å–å·²å®Œæˆè¯¾ç¨‹åˆ—è¡¨
  const { userProgress, getUserProgress } = useModuleAccessStore();
  const completedLessons = userProgress?.completedAlphabetLessons ?? [];

  // ğŸ”¥ TODO-07: ç¡®ä¿è¿›å…¥é¡µé¢æ—¶åŠ è½½ç”¨æˆ·è¿›åº¦
  useEffect(() => {
    getUserProgress();
  }, [getUserProgress]);

  useEffect(() => {
    let mounted = true;

    const mapLessons = (list: LessonMetadata[]): LessonCardProps[] =>
      list.map((lesson) => {
        const letterKeys = [
          ...lesson.consonants,
          ...lesson.vowels,
          ...lesson.tones,
        ];

        return {
          id: lesson.lessonId,
          title: lesson.title,
          description: lesson.description,
          letterKeys,
          lessonData: lesson,
          isCurrent: false,
          progress: {
            completed: 0,
            total: lesson.totalCount,
          },
        };
      });

    (async () => {
      try {
        const res = await callCloudFunction<{ lessons: LessonMetadata[] }>(
          'getAlphabetLessons',
          {},
          {
            endpoint: API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase,
          },
        );

        const list: LessonMetadata[] =
          (res.success && res.data?.lessons) || getAllLessons();

        if (!mounted) return;
        setLessons(mapLessons(list));
      } catch {
        if (!mounted) return;
        setLessons(mapLessons(getAllLessons()));
      } finally {
        if (mounted) setLoading(false);
      }
    })();

    return () => {
      mounted = false;
    };
  }, []);

  // ğŸ”¥ TODO-07: è¿›åº¦ç™¾åˆ†æ¯”åŸºäºå·²å®Œæˆè¯¾ç¨‹æ•°,è€Œéå­—æ¯æ•°
  const totalLessons = lessons.length;
  const overallProgressPercent =
    totalLessons > 0
      ? Math.min(100, Math.round((completedLessons.length / totalLessons) * 100))
      : 0;

  const handleCardPress = (lesson: LessonCardProps) => {
    setSelectedLesson(lesson);
    setDrawerVisible(true);
  };

  const handleStartLesson = (lessonId: string) => {
    setDrawerVisible(false);
    router.push(`/alphabet/${lessonId}`);
  };

  // ğŸ”¥ TODO-07: è¯¾ç¨‹è§£é”é€»è¾‘åªä¾èµ– completedAlphabetLessons
  // è§„åˆ™: lesson1 æ°¸è¿œè§£é”, lessonN éœ€è¦ lesson(N-1) å·²å®Œæˆ
  const isLessonUnlocked = useCallback((lessonIndex: number): boolean => {
    if (lessonIndex === 0) return true; // lesson1 æ°¸è¿œè§£é”
    const prevLessonId = lessons[lessonIndex - 1]?.id;
    return prevLessonId ? completedLessons.includes(prevLessonId) : false;
  }, [lessons, completedLessons]);

  // Helper to check unlocked status for modal
  const isSelectedUnlocked = useMemo(() => {
    if (!selectedLesson) return false;
    const index = lessons.findIndex(l => l.id === selectedLesson.id);
    if (index === -1) return false;
    return isLessonUnlocked(index);
  }, [selectedLesson, lessons, isLessonUnlocked]);


  return (
    <SafeAreaView edges={['top', 'bottom']} style={styles.container}>

      <View style={styles.backRow}>
        <Pressable onPress={() => router.back()} style={styles.backButton}>
          <ArrowLeft size={24} color={Colors.taupe} />
          <Text style={styles.backText}>Back</Text>
        </Pressable>
      </View>

      <View style={styles.headerContainer}>
        <Text style={styles.headerTitle}>Alphabet Course</Text>
        <Text style={styles.headerSubtitle}>
          {lessons.length} Lessons Â· {overallProgressPercent}% Completed
        </Text>
      </View>

      {loading ? (
        <View style={{ flex: 1, justifyContent: 'center' }}>
          <ActivityIndicator size="large" color={Colors.thaiGold} />
        </View>
      ) : (
        <View style={{ flex: 1 }}>
          <ScrollView style={styles.scroll} contentContainerStyle={styles.inner}>
            <ThaiPatternBackground opacity={0.12} />

            {lessons.map((lesson, index) => {
              // ğŸ”¥ TODO-07: è§£é”é€»è¾‘ç»Ÿä¸€ä¸º completedAlphabetLessons
              const unlocked = isLessonUnlocked(index);

              // ğŸ”¥ TODO-07: "å½“å‰è¯¾ç¨‹" = ç¬¬ä¸€ä¸ªå·²è§£é”ä½†æœªå®Œæˆçš„è¯¾ç¨‹
              const isCompleted = completedLessons.includes(lesson.id);
              const isCurrent = unlocked && !isCompleted;

              return (
                <Pressable
                  key={lesson.id}
                  style={[styles.card, isCurrent && styles.activeCard]}
                  onPress={() => handleCardPress(lesson)}
                >
                  <View style={styles.cardPressable}>
                    <View style={styles.info}>
                      <View style={styles.cardHeader}>
                        <Text style={styles.title} numberOfLines={1}>
                          {lesson.title}
                        </Text>
                        {isCurrent && (
                          <View style={styles.currentBadge}>
                            <Text style={styles.currentBadgeText}>Current</Text>
                          </View>
                        )}
                      </View>

                      <Text style={styles.description} numberOfLines={2}>
                        {lesson.description}
                      </Text>

                      <View style={styles.footer}>
                        <View style={styles.metaColumn}>
                          <Text style={styles.lessonMeta}>
                            {lesson.letterKeys.length} letters
                          </Text>
                        </View>

                        {/* Start Learning Button - Direct Access */}
                        <Pressable
                          disabled={!unlocked}
                          style={[
                            styles.startBtn,
                            isCurrent && styles.activeStartBtn,
                            !unlocked && styles.disabledStartBtn,
                          ]}
                          // Stop propagation to prevent opening drawer when clicking Start directly
                          onPress={(e) => {
                            e.stopPropagation();
                            router.push(`/alphabet/${lesson.id}`);
                          }}
                        >
                          <Text
                            style={[
                              styles.startBtnText,
                              isCurrent && styles.activeStartBtnText,
                            ]}
                          >
                            {unlocked ? 'Start' : 'Locked'}
                          </Text>
                        </Pressable>
                      </View>
                    </View>
                  </View>
                </Pressable>
              );
            })}

            <View style={{ height: 100 }} />
          </ScrollView>

          {/* Fixed Footer for Test Entry */}
          <View style={styles.footerContainer}>
            <Pressable
              style={({ pressed }) => [
                styles.unlockAllBtn,
                pressed && { opacity: 0.9, transform: [{ scale: 0.98 }] }
              ]}
              onPress={() => router.push('/alphabet/test')}
            >
              <Text style={styles.unlockAllText}>
                Take Test to Unlock All
              </Text>
            </Pressable>
          </View>
        </View>
      )}

      {/* Detail Drawer */}
      <LessonDrawer
        visible={drawerVisible}
        lesson={selectedLesson}
        unlocked={isSelectedUnlocked}
        onClose={() => setDrawerVisible(false)}
        onStart={() => selectedLesson && handleStartLesson(selectedLesson.id)}
      />

    </SafeAreaView >
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.paper,
  },
  headerContainer: {
    alignItems: "center",
    marginBottom: 8,
  },
  scroll: {
    flex: 1,
  },
  inner: {
    paddingHorizontal: 24,
    paddingVertical: 16,
    gap: 16,
    paddingBottom: 48,
  },
  backRow: {
    width: '100%',
    paddingHorizontal: 16,
    paddingVertical: 8,
    alignItems: 'flex-start',
  },
  backButton: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 8,
    borderRadius: 8,
  },
  backText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.taupe,
    marginLeft: 4,
  },
  headerTitle: {
    fontFamily: Typography.playfairBold,
    fontSize: 28,
    color: Colors.ink,
    marginBottom: 4,
  },
  headerSubtitle: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  card: {
    flexDirection: 'row',
    backgroundColor: Colors.white,
    borderRadius: 16,
    overflow: 'hidden',
    borderWidth: 1,
    borderColor: '#EFEFEF',
    minHeight: 120,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 8,
    elevation: 3,
  },
  activeCard: {
    borderColor: Colors.thaiGold,
    borderWidth: 1.5,
    backgroundColor: '#FFFCF5',
  },
  cardPressable: {
    flex: 1,
    flexDirection: 'row',
  },
  info: {
    flex: 1,
    padding: 16,
    justifyContent: 'space-between',
    gap: 8,
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    gap: 8,
  },
  title: {
    flex: 1,
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.ink,
  },
  currentBadge: {
    paddingHorizontal: 8,
    paddingVertical: 2,
    backgroundColor: 'rgba(212, 175, 55, 0.1)',
    borderRadius: 4,
  },
  currentBadgeText: {
    fontSize: 10,
    color: Colors.thaiGold,
    fontFamily: Typography.notoSerifBold,
    textTransform: 'uppercase',
  },
  description: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 13,
    color: Colors.taupe,
    lineHeight: 18,
  },
  lessonMeta: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 12,
    color: Colors.taupe,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 8,
  },
  metaColumn: {
    flex: 1,
  },
  startBtn: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: Colors.ink,
    borderRadius: 20,
  },
  activeStartBtn: {
    backgroundColor: Colors.thaiGold,
  },
  startBtnText: {
    fontSize: 12,
    color: Colors.white,
    fontFamily: Typography.notoSerifBold,
  },
  activeStartBtnText: {
    color: Colors.white,
  },
  disabledStartBtn: {
    backgroundColor: '#E0E0E0',
  },
  // Footer Button Styles
  footerContainer: {
    padding: 24,
    paddingBottom: 34, // Extra padding for safe area
    backgroundColor: Colors.white,
    borderTopWidth: 1,
    borderTopColor: Colors.sand,
  },
  unlockAllBtn: {
    width: '100%',
    backgroundColor: Colors.ink,
    paddingVertical: 16,
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 12,
    elevation: 8,
  },
  unlockAllText: {
    fontFamily: Typography.playfairBold,
    fontSize: 16,
    color: Colors.white,
    letterSpacing: 0.5,
  },
});

const drawerStyles = StyleSheet.create({
  overlay: {
    flex: 1,
    justifyContent: 'flex-end',
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  backdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'black',
  },
  sheet: {
    backgroundColor: Colors.paper,
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    maxHeight: '80%',
    minHeight: '50%',
    paddingBottom: 34,
  },
  handle: {
    width: 40,
    height: 4,
    backgroundColor: '#E0E0E0',
    borderRadius: 2,
    alignSelf: 'center',
    marginTop: 12,
    marginBottom: 8,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    paddingHorizontal: 24,
    paddingTop: 16,
    paddingBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#F0F0F0',
  },
  title: {
    fontFamily: Typography.playfairBold,
    fontSize: 24,
    color: Colors.ink,
    marginBottom: 4,
  },
  subtitle: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  closeButton: {
    padding: 4,
  },
  content: {
    padding: 24,
  },
  sectionTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.ink,
    marginBottom: 12,
    marginTop: 8,
  },
  description: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 15,
    color: Colors.taupe,
    lineHeight: 22,
    marginBottom: 24,
  },
  grid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 12,
  },
  gridItem: {
    width: 48,
    height: 48,
    borderRadius: 12,
    backgroundColor: Colors.white,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#EFEFEF',
  },
  gridChar: {
    fontFamily: Typography.playfairBold,
    fontSize: 20,
    color: Colors.ink,
  },
  footer: {
    padding: 24,
    borderTopWidth: 1,
    borderTopColor: '#F0F0F0',
  },
  startButton: {
    backgroundColor: Colors.thaiGold,
    borderRadius: 16,
    paddingVertical: 16,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    gap: 8,
    shadowColor: Colors.thaiGold,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 4,
  },
  startButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 18,
    color: Colors.white,
  },
  disabledBtn: {
    backgroundColor: '#E0E0E0',
    shadowOpacity: 0,
  }
});
````

## File: app/_layout.tsx
````typescript
import { Stack, useRouter, useSegments, useRootNavigationState } from 'expo-router';
import { useEffect, useRef } from 'react';
import { useFonts } from 'expo-font';
import * as SplashScreen from 'expo-splash-screen';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { useUserStore } from '@/src/stores/userStore';
import { useModuleAccessStore } from '@/src/stores/moduleAccessStore';
import '../global.css';
import { useState } from 'react';

// Prevent the splash screen from auto-hiding before asset loading
SplashScreen.preventAutoHideAsync();

export default function RootLayout() {
  const segments = useSegments();
  const router = useRouter();
  const navigationState = useRootNavigationState();
  const { isAuthenticated } = useUserStore();
  const { checkAccess, getUserProgress } = useModuleAccessStore();
  const [navReady, setNavReady] = useState(false);
  const didInitDevAccessRef = useRef(false);

  const [fontsLoaded, fontError] = useFonts({
    // Font loading temporarily disabled - font files not found
  });

  useEffect(() => {
    if (fontsLoaded || fontError) {
      SplashScreen.hideAsync();
    }
  }, [fontsLoaded, fontError]);

  useEffect(() => {
    const ready =
      !!navigationState?.key &&
      Array.isArray((navigationState as any)?.routes) &&
      (navigationState as any).routes.length > 0;
    if (ready) {
      setNavReady(true);
    }
  }, [navigationState?.key, (navigationState as any)?.routes?.length]);

  useEffect(() => {
    // ç­‰å¾…æ ¹å¯¼èˆªå®Œæ•´æŒ‚è½½ï¼ˆkey å­˜åœ¨ä¸” routes éç©ºï¼‰åå†åšè·³è½¬ï¼Œé¿å…â€œæœªæŒ‚è½½å…ˆå¯¼èˆªâ€å´©æºƒ
    if (!navReady) return;
    if (!fontsLoaded && !fontError) return;
    const inAuthGroup = segments[0] === '(auth)';

    if (!isAuthenticated && !inAuthGroup) {
      router.replace('/(auth)/login');
    } else if (isAuthenticated && inAuthGroup) {
      router.replace('/(tabs)');
    }
  }, [isAuthenticated, segments, fontsLoaded, fontError, navReady, router]);

  useEffect(() => {
    if (!__DEV__) return;
    if (!isAuthenticated) return;
    if (didInitDevAccessRef.current) return;
    didInitDevAccessRef.current = true;

    (async () => {
      try {
        await getUserProgress();
        await checkAccess('word');
      } catch (error) {
        console.warn('âš ï¸ Dev access warmup failed:', error);
      }
    })();
  }, [isAuthenticated, checkAccess, getUserProgress]);

  if (!fontsLoaded && !fontError) {
    return null;
  }

  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <Stack screenOptions={{ headerShown: false }}>
        <Stack.Screen name="(auth)" />
        <Stack.Screen name="(tabs)" />
        <Stack.Screen
          name="review-modal"
          options={{
            presentation: 'fullScreenModal',
            animation: 'slide_from_bottom',
          }}
        />
      </Stack>
    </GestureHandlerRootView>
  );
}
````

## File: src/components/learning/alphabet/AlphabetLearningEngineView.tsx
````typescript
// src/components/learning/alphabet/AlphabetLearningEngineView.tsx

import React from 'react';
import { View, ActivityIndicator, Text, SafeAreaView, TouchableOpacity } from 'react-native';
import { ChevronLeft } from 'lucide-react-native';

import { AlphabetLearningView } from '@/src/components/learning/alphabet/AlphabetLearningView';
import { AlphabetReviewView } from '@/src/components/learning/alphabet/AlphabetReviewView';
import { PhonicsRuleCard } from '@/src/components/learning/alphabet/PhonicsRuleCard';
import { SessionRecoveryCard } from '@/src/components/learning/alphabet/SessionRecoveryCard';
import { AlphabetCompletionView } from '@/src/components/learning/alphabet/AlphabetCompletionView';
import { RoundCompletionView } from '@/src/components/learning/alphabet/RoundCompletionView';
import type { AlphabetQueueItem } from '@/src/stores/alphabetStore';

import type { Phase } from '@/src/hooks/useAlphabetLearningEngine';
import type { QuestionType } from '@/src/entities/enums/QuestionType.enum';
import type { Letter } from '@/src/entities/types/letter.types';
import type {
  PhonicsRule,
  RoundEvaluationState,
} from '@/src/entities/types/phonicsRule.types';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

interface AlphabetLearningEngineViewProps {
  phase: Phase;
  initialized: boolean;
  currentRound: number;
  roundEvaluation?: RoundEvaluationState;
  currentItem: AlphabetQueueItem | null;
  currentQuestionType: QuestionType | null;
  letterPool?: Letter[];
  onAnswer: (isCorrect: boolean, questionType: QuestionType) => void;
  onNext: () => void;
  // REMOVED: onStartNextRound (Manual start happens in Lesson Page now)
  onBack?: () => void;
  phonicsRule?: PhonicsRule | null;
  showPhonicsRuleCard?: boolean;
  onCompletePhonicsRule?: () => void;

  // Recovery
  pendingRecoverySession?: any;
  resolveRecovery?: (choice: 'continue' | 'restart') => void;

  // New props for Observability
  queueIndex?: number;
  totalQueue?: number;

  onSkipYesterdayReview?: () => void;
}

// Helper to get friendly phase name
const getPhaseLabel = (phase: Phase) => {
  switch (phase) {
    case 'new-learning': return 'New Letters';
    case 'mini-review': return 'Quick Review';
    case 'final-review': return 'Final Review';
    case 'error-review': return 'Fix Mistakes';
    // ğŸ”¥ TODO-03: ç»Ÿä¸€ä½¿ç”¨ 'previous-review'
    case 'previous-review': return 'Warm Up';
    case 'round-completed': return 'Round Done';
    case 'finished': return 'Finished';
    default: return phase;
  }
};

function RoundHeader({
  currentRound,
  phase,
  queueIndex,
  totalQueue,
  onBack,
  onSkipYesterdayReview
}: {
  currentRound: number;
  phase: Phase;
  queueIndex?: number;
  totalQueue?: number;
  onBack?: () => void;
  onSkipYesterdayReview?: () => void;
}) {
  return (
    <View
      style={{
        paddingHorizontal: 16,
        paddingTop: 12,
        paddingBottom: 4,
        flexDirection: 'column',
        justifyContent: 'center',
        alignItems: 'center',
      }}
    >
      <View style={{ flexDirection: 'row', justifyContent: 'space-between', width: '100%', alignItems: 'center' }}>
        {/* Left: Back Button or Spacer */}
        <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>
          {onBack && (
            <TouchableOpacity onPress={onBack} hitSlop={12}>
              <ChevronLeft size={24} color={Colors.taupe} />
            </TouchableOpacity>
          )}
          <Text
            style={{
              fontFamily: Typography.notoSerifRegular,
              fontSize: 14,
              color: Colors.taupe,
            }}
          >
            Round {currentRound} / 3
          </Text>
        </View>

        {/* Visible Phase Label */}
        <View style={{
          backgroundColor: '#F0F0F0',
          paddingHorizontal: 8,
          paddingVertical: 4,
          borderRadius: 4
        }}>
          <Text style={{
            fontFamily: Typography.notoSerifBold,
            fontSize: 12,
            color: Colors.ink
          }}>
            {getPhaseLabel(phase)}
          </Text>
        </View>

        {/* Skip/Bury Button for previous-review */}
        {phase === 'previous-review' && onSkipYesterdayReview && (
          <TouchableOpacity
            style={{
              marginLeft: 8,
              paddingHorizontal: 12,
              paddingVertical: 4,
              backgroundColor: '#FFF0F0',
              borderRadius: 4,
              borderWidth: 1,
              borderColor: '#FFD0D0'
            }}
            onPress={onSkipYesterdayReview}
          >
            <Text style={{
              fontSize: 12,
              color: '#D00000',
              fontWeight: '600'
            }}>
              Skip (Bury)
            </Text>
          </TouchableOpacity>
        )}
      </View>
    </View>
  );
}



export function AlphabetLearningEngineView({
  phase,
  initialized,
  currentRound,
  roundEvaluation,
  currentItem,
  currentQuestionType,
  letterPool,
  onAnswer,
  onNext,
  // onStartNextRound, // Removed
  onBack,
  phonicsRule,
  showPhonicsRuleCard,
  onCompletePhonicsRule,
  onSkipYesterdayReview,
  pendingRecoverySession,
  resolveRecovery,

  queueIndex,
  totalQueue,
}: AlphabetLearningEngineViewProps) {

  // åŠ è½½çŠ¶æ€
  if (!initialized || !currentItem) {
    return (
      <SafeAreaView style={{ flex: 1, justifyContent: 'center' }}>
        <ActivityIndicator size="large" />
      </SafeAreaView>
    );
  }

  if (phase === 'finished') {
    return (
      <AlphabetCompletionView
        roundEvaluation={roundEvaluation}
        onFinish={onBack || (() => { })} // Fallback to no-op if onBack missing, but it handles router.back
      />
    );
  }

  if (phase === 'round-completed') {
    return (
      <RoundCompletionView
        roundNumber={currentRound}
        onFinish={onBack || (() => { console.warn('No Back Handler'); })}
      />
    );
  }

  const source = (currentItem as any)?.source;
  // ğŸ”¥ TODO-03: ç»Ÿä¸€ä½¿ç”¨ 'new-learning'
  const isNewLetter = source === 'new-learning';

  const hasValidRule = !!(phonicsRule && phonicsRule.title && phonicsRule.content?.length > 0);

  const shouldShowPhonicsRule =
    isNewLetter &&
    showPhonicsRuleCard &&
    hasValidRule &&
    onCompletePhonicsRule;

  const renderMainView = () => {

    if (shouldShowPhonicsRule) {
      return <PhonicsRuleCard rule={phonicsRule} onComplete={onCompletePhonicsRule} />;
    }

    if (!isNewLetter) {
      // Use currentQuestionType provided by engine, fallback to SoundToLetter if null
      return (
        <AlphabetReviewView
          alphabet={currentItem}
          letterPool={letterPool}
          preferredType={currentQuestionType ?? undefined}
          onAnswer={onAnswer}
          onNext={onNext}
          onBack={onBack}
        />
      );
    }

    return <AlphabetLearningView alphabet={currentItem} onNext={onNext} onBack={onBack} />;
  };

  return (
    <SafeAreaView style={{ flex: 1 }}>


      {/* ä¼˜å…ˆæ˜¾ç¤ºæ¢å¤å¼¹çª— */}
      {pendingRecoverySession && resolveRecovery && (
        <SessionRecoveryCard
          onContinue={() => resolveRecovery('continue')}
          onRestart={() => resolveRecovery('restart')}
        />
      )}

      <RoundHeader currentRound={currentRound} phase={phase} queueIndex={queueIndex} totalQueue={totalQueue} onSkipYesterdayReview={onSkipYesterdayReview} />

      {renderMainView()}
    </SafeAreaView>
  );
}
````

## File: app/(auth)/login.tsx
````typescript
// app/(auth)/login.tsx
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, Pressable, StyleSheet, KeyboardAvoidingView, Platform, Alert } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { useTranslation } from 'react-i18next';
import Animated, { FadeInDown } from 'react-native-reanimated';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { LanguageSwitcher } from '@/src/components/common/LanguageSwitcher';
import { useUserStore } from '@/src/stores/userStore';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

export default function LoginScreen() {
  const { t } = useTranslation();
  const router = useRouter();
  const { login, isLoading, error, clearError } = useUserStore();

  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  // Clear error when component unmounts
  useEffect(() => {
    return () => {
      clearError();
    };
  }, []);

  // Show error alert if error changes
  useEffect(() => {
    if (error) {
      Alert.alert(t('common.error'), error);
    }
  }, [error]);

  const handleLogin = async () => {
    // Basic validation
    if (!email || !password) {
      Alert.alert(t('common.error'), 'Please fill in all fields');
      return;
    }

    // Email format validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      Alert.alert(t('common.error'), 'Please enter a valid email address');
      return;
    }

    // Call login action
    const success = await login({ email, password });

    if (success) {
      // Navigate to main app
      router.replace('/(tabs)');
    }
    // Error is handled by useEffect above
  };
  const handleForgotPassword = () => {
    router.push('/(auth)/forgot-password');
  };

  return (
    <SafeAreaView style={styles.container}>
      <ThaiPatternBackground opacity={0.08} />

      {/* Language Switcher */}
      <View style={styles.languageSwitcherContainer}>
        <LanguageSwitcher />
      </View>

      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
      >
        <View style={styles.content}>
          {/* Logo & Title */}
          <Animated.View entering={FadeInDown.delay(100).duration(500)} style={styles.headerSection}>
            <Text style={styles.logo}>à¸Šà¸²</Text>
            <Text style={styles.title}>Thai Learning</Text>
            <Text style={styles.subtitle}>{t('auth.login')}</Text>
          </Animated.View>

          {/* Login Form */}
          <Animated.View entering={FadeInDown.delay(200).duration(500)} style={styles.formSection}>
            <View style={styles.inputContainer}>
              <Text style={styles.label}>{t('auth.email')}</Text>
              <TextInput
                style={styles.input}
                placeholder={t('auth.emailPlaceholder')}
                placeholderTextColor={Colors.taupe}
                value={email}
                onChangeText={setEmail}
                keyboardType="email-address"
                autoCapitalize="none"
                autoCorrect={false}
              />
            </View>

            <View style={styles.inputContainer}>
              <Text style={styles.label}>{t('auth.password')}</Text>
              <TextInput
                style={styles.input}
                placeholder={t('auth.passwordPlaceholder')}
                placeholderTextColor={Colors.taupe}
                value={password}
                onChangeText={setPassword}
                secureTextEntry
                autoCapitalize="none"
              />
            </View>

            <Pressable
              style={styles.forgotPassword}
              onPress={handleForgotPassword}
            >
              <Text style={styles.forgotPasswordText}>{t('auth.forgotPassword')}</Text>
            </Pressable>

            <Pressable
              style={[styles.loginButton, isLoading && styles.loginButtonDisabled]}
              onPress={handleLogin}
              disabled={isLoading}
            >
              <Text style={styles.loginButtonText}>
                {isLoading ? t('auth.logining') : t('auth.loginButton')}
              </Text>
            </Pressable>

            <View style={styles.registerSection}>
              <Text style={styles.registerText}>{t('auth.noAccount')}</Text>
              <Pressable onPress={() => router.push('/(auth)/register')}>
                <Text style={styles.registerLink}>{t('auth.register')}</Text>
              </Pressable>
            </View>
          </Animated.View>
        </View>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.paper,
  },
  languageSwitcherContainer: {
    position: 'absolute',
    top: 60,
    right: 24,
    zIndex: 10,
  },
  keyboardView: {
    flex: 1,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    paddingHorizontal: 32,
  },
  headerSection: {
    alignItems: 'center',
    marginBottom: 48,
  },
  logo: {
    fontFamily: Typography.sarabunBold,
    fontSize: 72,
    color: Colors.thaiGold,
    marginBottom: 8,
  },
  title: {
    fontFamily: Typography.playfairBold,
    fontSize: 28,
    color: Colors.ink,
    marginBottom: 4,
  },
  subtitle: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.taupe,
  },
  formSection: {
    width: '100%',
  },
  inputContainer: {
    marginBottom: 20,
  },
  label: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.ink,
    marginBottom: 8,
  },
  input: {
    fontFamily: Typography.notoSerifRegular,
    height: 56,
    backgroundColor: Colors.white,
    borderWidth: 1,
    borderColor: Colors.sand,
    borderRadius: 16,
    paddingHorizontal: 20,
    fontSize: 16,
    color: Colors.ink,
  },
  forgotPassword: {
    alignSelf: 'flex-end',
    marginBottom: 24,
  },
  forgotPasswordText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.thaiGold,
  },
  loginButton: {
    height: 56,
    backgroundColor: Colors.ink,
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  loginButtonDisabled: {
    opacity: 0.6,
  },
  loginButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
    fontWeight: '600',
  },
  registerSection: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 24,
    gap: 8,
  },
  registerText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  registerLink: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    color: Colors.thaiGold,
    fontWeight: '600',
  },
});
````

## File: app/learning/index.tsx
````typescript
import React, { useEffect, useState } from 'react';
import { useTranslation } from 'react-i18next';
import { View, Text, StyleSheet, Pressable, Alert } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter, useLocalSearchParams } from 'expo-router';
import { X } from 'lucide-react-native';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { NewWordView, WordData } from '@/src/components/learning/NewWordView';
import { ReviewWordView } from '@/src/components/learning/ReviewWordView';
import { AlphabetLearningView } from '@/src/components/learning/alphabet/AlphabetLearningView';
import { AlphabetReviewView } from '@/src/components/learning/alphabet/AlphabetReviewView';
import { useVocabularyStore } from '@/src/stores/vocabularyStore';
import { useLearningPreferenceStore } from '@/src/stores/learningPreferenceStore';
import { useAlphabetStore } from '@/src/stores/alphabetStore';
import { LearningPhase } from '@/src/entities/enums/LearningPhase.enum';
import { useUserStore } from '@/src/stores/userStore';


// --- Mock Data ---

const MOCK_OLD_WORDS: WordData[] = [
    {
        id: 'old1',
        thai: 'à¸à¸´à¸™',
        phonetic: 'Kin',
        type: 'åŠ¨è¯',
        meaning: 'åƒ',
        definitions: {
            basic: 'åƒï¼Œé£Ÿç”¨',
            examples: [
                { thai: 'à¸à¸´à¸™à¸‚à¹‰à¸²à¸§à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡', meaning: 'åƒé¥­äº†å—ï¼Ÿ' },
                { thai: 'à¸Šà¸­à¸šà¸à¸´à¸™à¹€à¸œà¹‡à¸”', meaning: 'å–œæ¬¢åƒè¾£' }
            ],
            usage: {
                grammar: [],
                diff: 'æ— ',
                mistakes: 'å£è¯­å¸¸ç”¨ï¼Œæ­£å¼åœºåˆå¯ç”¨ à¸£à¸±à¸šà¸›à¸£à¸°à¸—à¸²à¸™',
                similar: 'à¸—à¸²à¸™ (æ›´ç¤¼è²Œ)'
            }
        }
    },
    {
        id: 'old2',
        thai: 'à¸™à¸­à¸™',
        phonetic: 'Non',
        type: 'åŠ¨è¯',
        meaning: 'ç¡',
        definitions: {
            basic: 'ç¡è§‰ï¼Œèºº',
            examples: [
                { thai: 'à¸™à¸­à¸™à¸«à¸¥à¸±à¸šà¸à¸±à¸™à¸”à¸µ', meaning: 'ç¡ä¸ªå¥½è§‰ (æ™šå®‰)' },
                { thai: 'à¸‚à¸µà¹‰à¹€à¸à¸µà¸¢à¸ˆà¸™à¸­à¸™à¸•à¸·à¹ˆà¸™à¸ªà¸²à¸¢', meaning: 'æ‡’å¾—ç¡æ‡’è§‰' }
            ],
            usage: {
                grammar: [],
                diff: 'æ— ',
                mistakes: 'æ— ',
                similar: 'à¸«à¸¥à¸±à¸š (ç¡ç€)'
            }
        }
    },
    {
        id: 'old3',
        thai: 'à¹„à¸›',
        phonetic: 'Pai',
        type: 'åŠ¨è¯',
        meaning: 'å»',
        definitions: {
            basic: 'å»ï¼Œå¾€ï¼Œç¦»å¼€',
            examples: [
                { thai: 'à¹„à¸›à¹„à¸«à¸™', meaning: 'å»å“ªé‡Œï¼Ÿ' },
                { thai: 'à¹„à¸›à¸—à¸³à¸‡à¸²à¸™', meaning: 'å»å·¥ä½œ' }
            ],
            usage: {
                grammar: [],
                diff: 'å¯ä½œè¶‹å‘è¡¥è¯­',
                mistakes: 'æ— ',
                similar: 'æ— '
            }
        }
    },
    {
        id: 'old4',
        thai: 'à¸¡à¸²',
        phonetic: 'Ma',
        type: 'åŠ¨è¯',
        meaning: 'æ¥',
        definitions: {
            basic: 'æ¥ï¼Œæ¥åˆ°',
            examples: [
                { thai: 'à¸¡à¸²à¸ˆà¸²à¸à¹„à¸«à¸™', meaning: 'æ¥è‡ªå“ªé‡Œï¼Ÿ' },
                { thai: 'à¸¡à¸²à¸™à¸µà¹ˆ', meaning: 'æ¥è¿™é‡Œ' }
            ],
            usage: {
                grammar: [],
                diff: 'å¯ä½œè¶‹å‘è¡¥è¯­',
                mistakes: 'æ— ',
                similar: 'æ— '
            }
        }
    },
    {
        id: 'old5',
        thai: 'à¸£à¸±à¸',
        phonetic: 'Rak',
        type: 'åŠ¨è¯',
        meaning: 'çˆ±',
        definitions: {
            basic: 'çˆ±ï¼Œå–œçˆ±',
            examples: [
                { thai: 'à¸‰à¸±à¸™à¸£à¸±à¸à¸„à¸¸à¸“', meaning: 'æˆ‘çˆ±ä½ ' },
                { thai: 'à¸£à¸±à¸à¸Šà¸²à¸•à¸´', meaning: 'çˆ±å›½' }
            ],
            usage: {
                grammar: [],
                diff: 'æ— ',
                mistakes: 'æ— ',
                similar: 'à¸Šà¸­à¸š (å–œæ¬¢)'
            }
        }
    }
];

const MOCK_NEW_WORDS: WordData[] = [
    {
        id: 'new1',
        thai: 'à¸—à¸³à¸‡à¸²à¸™',
        phonetic: 'Tham Ngan',
        type: 'åŠ¨è¯',
        meaning: 'å·¥ä½œ',
        definitions: {
            basic: 'å·¥ä½œï¼Œå¹²æ´»',
            examples: [
                { thai: 'à¸§à¸±à¸™à¸™à¸µà¹‰à¸—à¸³à¸‡à¸²à¸™à¹„à¸«à¸¡', meaning: 'ä»Šå¤©å·¥ä½œå—ï¼Ÿ' },
                { thai: 'à¸—à¸³à¸‡à¸²à¸™à¸«à¸™à¸±à¸', meaning: 'å·¥ä½œåŠªåŠ›/è¾›è‹¦' }
            ],
            usage: {
                grammar: [],
                diff: 'æ— ',
                mistakes: 'æ— ',
                similar: 'à¸‡à¸²à¸™ (åè¯: å·¥ä½œ)'
            }
        }
    },
    {
        id: 'new2',
        thai: 'à¹€à¸£à¸µà¸¢à¸™',
        phonetic: 'Rian',
        type: 'åŠ¨è¯',
        meaning: 'å­¦ä¹ ',
        definitions: {
            basic: 'å­¦ä¹ ï¼Œè¯»ä¹¦',
            examples: [
                { thai: 'à¹€à¸£à¸µà¸¢à¸™à¸ à¸²à¸©à¸²à¹„à¸—à¸¢', meaning: 'å­¦æ³°è¯­' },
                { thai: 'à¹„à¸›à¹‚à¸£à¸‡à¹€à¸£à¸µà¸¢à¸™', meaning: 'å»å­¦æ ¡' }
            ],
            usage: {
                grammar: [],
                diff: 'ä¾§é‡äºåœ¨å­¦æ ¡å­¦ä¹ æˆ–ä¸Šè¯¾',
                mistakes: 'è‡ªå­¦é€šå¸¸ç”¨ à¸¨à¸¶à¸à¸©à¸²',
                similar: 'à¸¨à¸¶à¸à¸©à¸² (ç ”ç©¶/è¿›ä¿®)'
            }
        }
    },
    {
        id: 'new3',
        thai: 'à¹€à¸¥à¹ˆà¸™',
        phonetic: 'Len',
        type: 'åŠ¨è¯',
        meaning: 'ç©',
        definitions: {
            basic: 'ç©ï¼Œæ¸¸æˆï¼Œæ¼”å¥',
            examples: [
                { thai: 'à¹€à¸¥à¹ˆà¸™à¹€à¸à¸¡', meaning: 'ç©æ¸¸æˆ' },
                { thai: 'à¸à¸¹à¸”à¹€à¸¥à¹ˆà¸™', meaning: 'å¼€ç©ç¬‘ (è¯´ç©)' }
            ],
            usage: {
                grammar: [],
                diff: 'èŒƒå›´å¾ˆå¹¿ï¼Œå¯æŒ‡ç©è€ã€æ¼”å¥ä¹å™¨ã€å¼€ç©ç¬‘ç­‰',
                mistakes: 'æ— ',
                similar: 'à¹€à¸—à¸µà¹ˆà¸¢à¸§ (å»ç©/æ—…æ¸¸)'
            }
        }
    },
    {
        id: 'new4',
        thai: 'à¸à¸¹à¸”',
        phonetic: 'Phut',
        type: 'åŠ¨è¯',
        meaning: 'è¯´',
        definitions: {
            basic: 'è¯´ï¼Œè®²',
            examples: [
                { thai: 'à¸à¸¹à¸”à¸ à¸²à¸©à¸²à¹„à¸—à¸¢à¹„à¸”à¹‰à¹„à¸«à¸¡', meaning: 'ä¼šè¯´æ³°è¯­å—ï¼Ÿ' },
                { thai: 'à¸à¸¹à¸”à¸Šà¹‰à¸²à¹† à¸«à¸™à¹ˆà¸­à¸¢', meaning: 'è¯·è¯´æ…¢ä¸€ç‚¹' }
            ],
            usage: {
                grammar: [],
                diff: 'ä¾§é‡äºè¯´è¯çš„åŠ¨ä½œ',
                mistakes: 'æ— ',
                similar: 'à¸šà¸­à¸ (å‘Šè¯‰)'
            }
        }
    },
    {
        id: 'new5',
        thai: 'à¸­à¹ˆà¸²à¸™',
        phonetic: 'Aan',
        type: 'åŠ¨è¯',
        meaning: 'è¯»',
        definitions: {
            basic: 'é˜…è¯»ï¼Œå¿µ',
            examples: [
                { thai: 'à¸­à¹ˆà¸²à¸™à¸«à¸™à¸±à¸‡à¸ªà¸·à¸­', meaning: 'è¯»ä¹¦' },
                { thai: 'à¸­à¹ˆà¸²à¸™à¸­à¸­à¸à¹€à¸ªà¸µà¸¢à¸‡', meaning: 'æœ—è¯»' }
            ],
            usage: {
                grammar: [],
                diff: 'æ— ',
                mistakes: 'æ— ',
                similar: 'à¸¨à¸¶à¸à¸©à¸² (å­¦ä¹ /ç ”ç©¶)'
            }
        }
    }
];

// --- Types ---

type SessionMode = 'REVIEW' | 'LEARN_NEW';
// ä¸åç«¯ä¿æŒä¸€è‡´ï¼Œå­—æ¯æ¨¡å—ä½¿ç”¨ 'letter'
type ModuleVariant = 'letter' | 'word';

interface QueueItem {
    word: WordData;
    type: 'review' | 'new';
    repetitionsLeft: number;
}

export default function LearningSession() {
    const params = useLocalSearchParams();
    const moduleParam = typeof params.module === 'string' ? params.module : 'word';
    const moduleType: ModuleVariant = moduleParam === 'letter' ? 'letter' : 'word';
    const courseSource = typeof params.source === 'string' ? params.source : undefined;
    const { startCourse, currentCourseSource } = useVocabularyStore();

    useEffect(() => {
        if (!courseSource) return;

        // â­ 1. å­—æ¯æ¨¡å—ï¼šä¸åœ¨è¿™é‡Œè‡ªåŠ¨ startCourse
        if (moduleType === 'letter') {
            return;
        }

        // â­ 2. åªæœ‰å½“å½“å‰æ²¡æœ‰è¯¾ç¨‹æ—¶ï¼Œæ‰åˆå§‹åŒ–ä¸€æ¬¡
        if (!currentCourseSource) {
            startCourse(courseSource);
        }
    }, [moduleType, courseSource, currentCourseSource, startCourse]);

    if (moduleType === 'letter') {
        return <AlphabetSession />;
    }

    return <WordSession />;
}

function WordSession() {
    const { t } = useTranslation();
    const router = useRouter();
    const [queue, setQueue] = useState<QueueItem[]>([]);
    const [currentIndex, setCurrentIndex] = useState(0);
    const [mode, setMode] = useState<SessionMode>('REVIEW');
    const [isSessionComplete, setIsSessionComplete] = useState(false);
    const { dailyLimits } = useLearningPreferenceStore();

    // Initialize Session
    useEffect(() => {
        const dailyLimit = dailyLimits.word || 20;
        const reviewCap = Math.min(MOCK_OLD_WORDS.length, Math.max(1, Math.floor(dailyLimit / 2)));
        const limitedReview = MOCK_OLD_WORDS.slice(0, reviewCap);

        const remaining = Math.max(1, dailyLimit - limitedReview.length);
        const limitedNew = MOCK_NEW_WORDS.slice(0, Math.min(MOCK_NEW_WORDS.length, remaining));

        const reviewItems: QueueItem[] = limitedReview.map(w => ({
            word: w,
            type: 'review',
            repetitionsLeft: 3,
        }));

        const newItems: QueueItem[] = limitedNew.map(w => ({
            word: w,
            type: 'new',
            repetitionsLeft: 3,
        }));

        setQueue([...reviewItems, ...newItems]);
    }, [dailyLimits.word]);

    const currentItem = queue[currentIndex];

    // Determine current mode based on item type
    useEffect(() => {
        if (currentItem) {
            if (currentItem.type === 'review' && mode !== 'REVIEW') {
                setMode('REVIEW');
            } else if (currentItem.type === 'new' && mode !== 'LEARN_NEW') {
                setMode('LEARN_NEW');
            }
        }
    }, [currentItem, mode]);

    const handleNext = () => {
        if (!currentItem) return;

        const nextQueue = [...queue];
        const currentQueueItem = nextQueue[currentIndex];

        // Decrease repetitions
        currentQueueItem.repetitionsLeft -= 1;

        if (currentQueueItem.repetitionsLeft > 0) {
            nextQueue.push({ ...currentQueueItem });
        }

        if (currentIndex < nextQueue.length - 1) {
            setQueue(nextQueue);
            setCurrentIndex(prev => prev + 1);
        } else {
            setIsSessionComplete(true);
        }
    };

    const handleSkipReview = () => {
        const newQueue = queue.filter(item => item.type === 'new');

        if (newQueue.length === 0) {
            Alert.alert(t('learning.noNewWordsTitle'), t('learning.noNewWordsMessage'));
            router.back();
            return;
        }

        setQueue(newQueue);
        setCurrentIndex(0);
        setMode('LEARN_NEW');
    };

    const handleClose = () => {
        Alert.alert(
            t('learning.endSessionTitle'),
            t('learning.endSessionMessage'),
            [
                { text: t('common.cancel'), style: "cancel" },
                { text: t('learning.quit'), style: "destructive", onPress: () => router.back() }
            ]
        );
    };

    if (isSessionComplete) {
        return (
            <SafeAreaView style={styles.container}>
                <View style={styles.completeContainer}>
                    <Text style={styles.completeTitle}>{t('learning.sessionComplete')}</Text>
                    <Pressable style={styles.completeButton} onPress={() => router.back()}>
                        <Text style={styles.completeButtonText}>{t('learning.backToHome')}</Text>
                    </Pressable>
                </View>
            </SafeAreaView>
        );
    }

    if (!currentItem) {
        return (
            <SafeAreaView style={styles.container}>
                <Text>{t('common.loading')}</Text>
            </SafeAreaView>
        );
    }

    const progress = Math.round(((currentIndex) / queue.length) * 100);

    return (
        <SafeAreaView edges={['top', 'bottom']} style={styles.container}>
            <ThaiPatternBackground opacity={0.05} />

            {/* Header */}
            <View style={styles.header}>
                <Pressable onPress={handleClose} style={styles.closeButton}>
                    <X size={24} color={Colors.taupe} />
                </Pressable>

                <View style={styles.progressBarContainer}>
                    <View style={[styles.progressBarFill, { width: `${progress}%` }]} />
                </View>

                {mode === 'REVIEW' ? (
                    <Pressable onPress={handleSkipReview}>
                        <Text style={styles.skipText}>{t('learning.skipReview')}</Text>
                    </Pressable>
                ) : (
                    <View style={{ width: 60 }} />
                )}
            </View>

            {/* Main Content */}
            <View style={styles.content}>
                {currentItem.type === 'review' ? (
                    <ReviewWordView
                        key={`${currentItem.word.id}-review-${currentIndex}`}
                        word={currentItem.word}
                        onAnswer={(quality) => {
                            console.log(`Answered ${quality} for ${currentItem.word.thai}`);
                        }}
                        onNext={handleNext}
                    />
                ) : (
                    <NewWordView
                        key={`${currentItem.word.id}-new-${currentIndex}`}
                        word={currentItem.word}
                        onNext={handleNext}
                    />
                )}
            </View>
        </SafeAreaView>
    );
}

function AlphabetSession() {
    const { t } = useTranslation();
    const router = useRouter();
    const { currentUser } = useUserStore();
    const { dailyLimits } = useLearningPreferenceStore();
    const [hasViewedIntro, setHasViewedIntro] = useState(false);
    const [sessionStarted, setSessionStarted] = useState(false);

    const {
        phase,
        isLoading,
        initializeSession,
        submitResult,
        reset,
        completedCount,
        totalCount,
        currentItem,
    } = useAlphabetStore();

    const currentAlphabet = currentItem;

    useEffect(() => {
        setHasViewedIntro(false);
    }, [currentAlphabet?.alphabetId]);

    useEffect(() => {
        const start = async () => {
            if (sessionStarted || isLoading) return;
            const userId = currentUser?.userId || 'user_123';
            await initializeSession(userId, {
              limit: dailyLimits.letter || 30,
            });
            setSessionStarted(true);
        };

        start();
    }, [sessionStarted, isLoading, initializeSession, currentUser?.userId, dailyLimits.letter]);

    const handleClose = () => {
        Alert.alert(
            t('learning.endSessionTitle', 'ç»“æŸå­¦ä¹ ?'),
            t('learning.endSessionMessage', 'å½“å‰è¿›åº¦å°†ä¸ä¼šä¿å­˜'),
            [
                { text: t('common.cancel', 'å–æ¶ˆ'), style: "cancel" },
                {
                    text: t('learning.quit', 'é€€å‡º'),
                    style: "destructive",
                    onPress: () => {
                        reset();
                        router.back();
                    }
                }
            ]
        );
    };

    if (isLoading && !sessionStarted) {
        return (
            <SafeAreaView style={styles.container}>
                <View style={styles.centerContent}>
                    <Text>{t('common.loading', 'åŠ è½½ä¸­...')}</Text>
                </View>
            </SafeAreaView>
        );
    }

    if (phase === LearningPhase.COMPLETED) {
        return (
            <SafeAreaView style={styles.container}>
                <View style={styles.centerContent}>
                    <Text style={styles.completeTitle}>{t('learning.sessionComplete', 'ä»Šæ—¥å­¦ä¹ å®Œæˆ!')}</Text>
                    <Pressable style={styles.completeButton} onPress={() => router.back()}>
                        <Text style={styles.completeButtonText}>{t('learning.backToHome', 'è¿”å›é¦–é¡µ')}</Text>
                    </Pressable>
                </View>
            </SafeAreaView>
        );
    }

    if (!currentAlphabet) {
        return (
            <SafeAreaView style={styles.container}>
                <View style={styles.centerContent}>
                    <Text>{t('common.loading', 'åŠ è½½ä¸­...')}</Text>
                </View>
            </SafeAreaView>
        );
    }

    const isNew = !currentAlphabet.memoryState || currentAlphabet.memoryState.isNew;
    const showIntro = isNew && !hasViewedIntro && currentAlphabet.currentAttempts === 0;
    const progress = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;

    return (
        <SafeAreaView edges={['top', 'bottom']} style={styles.container}>
            <ThaiPatternBackground opacity={0.05} />

            <View style={styles.header}>
                <Pressable onPress={handleClose} style={styles.closeButton}>
                    <X size={24} color={Colors.taupe} />
                </Pressable>

                <View style={styles.progressBarContainer}>
                    <View style={[styles.progressBarFill, { width: `${progress}%` }]} />
                </View>

                <View style={{ width: 60 }} />
            </View>

            <View style={styles.content}>
                {showIntro ? (
                    <AlphabetLearningView
                        alphabet={currentAlphabet}
                        onNext={() => setHasViewedIntro(true)}
                    />
                ) : (
                    <AlphabetReviewViewWrapper
                        key={currentAlphabet.alphabetId}
                        alphabet={currentAlphabet}
                        onSubmit={(quality) => {
                            const userId = currentUser?.userId || 'user_123';
                            submitResult(userId, quality);
                        }}
                    />
                )}
            </View>
        </SafeAreaView>
    );
}

function AlphabetReviewViewWrapper({ alphabet, onSubmit }: { alphabet: any, onSubmit: (q: any) => void }) {
    const [quality, setQuality] = useState<any>(null);

    return (
        <AlphabetReviewView
            alphabet={alphabet}
            onAnswer={(q) => setQuality(q)}
            onNext={() => {
                if (quality) onSubmit(quality);
            }}
        />
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: Colors.paper,
    },
    header: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        paddingHorizontal: 16,
        paddingVertical: 12,
        borderBottomWidth: 1,
        borderBottomColor: 'rgba(0,0,0,0.05)',
    },
    closeButton: {
        padding: 8,
    },
    progressBarContainer: {
        flex: 1,
        height: 6,
        backgroundColor: 'rgba(229, 226, 219, 0.5)',
        borderRadius: 3,
        marginHorizontal: 16,
        overflow: 'hidden',
    },
    progressBarFill: {
        height: '100%',
        backgroundColor: Colors.thaiGold,
        borderRadius: 3,
    },
    content: {
        flex: 1,
    },
    completeContainer: {
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
    },
    completeTitle: {
        fontFamily: Typography.playfairBold,
        fontSize: 24,
        color: Colors.ink,
        marginBottom: 24,
    },
    completeButton: {
        backgroundColor: Colors.ink,
        paddingHorizontal: 32,
        paddingVertical: 16,
        borderRadius: 12,
    },
    completeButtonText: {
        color: Colors.white,
        fontFamily: Typography.notoSerifBold,
    },
    centerContent: {
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
    },
    skipText: {
        fontFamily: Typography.notoSerifRegular,
        fontSize: 14,
        color: Colors.taupe,
    },
});
````

## File: cloudbase/functions/memory-engine/handlers/getUserProgress.js
````javascript
/**
 * è·å–ç”¨æˆ·å­¦ä¹ è¿›åº¦
 * Action: getUserProgress
 */
'use strict';

const { createResponse } = require('../utils/response');

/**
 * @param {Object} db - æ•°æ®åº“å®ä¾‹
 * @param {Object} params - è¯·æ±‚å‚æ•°
 */
async function getUserProgress(db, params) {
  const { userId } = params;

  // ğŸ” è°ƒè¯•æ—¥å¿—ï¼šæ‰“å°æ”¶åˆ°çš„ userId
  console.log('ğŸ“¥ [getUserProgress] æ”¶åˆ°è¯·æ±‚ï¼ŒuserId:', userId);

  if (!userId) {
    return createResponse(false, null, 'Missing userId', 'INVALID_PARAMS');
  }

  try {
    // 2. è·å–ç”¨æˆ·è¿›åº¦è®°å½•
    // âŒ ä¿®æ­£: ä¸è¦ç”¨ getOne(), ç”¨ limit(1).get()
    const progressResult = await db.collection('user_progress')
      .where({ userId })
      .limit(1)
      .get();

    if (!progressResult.data || progressResult.data.length === 0) {
      return createResponse(false, null, 'ç”¨æˆ·è¿›åº¦è®°å½•ä¸å­˜åœ¨', 'USER_PROGRESS_NOT_FOUND');
    }

    const progress = progressResult.data[0];

    // ğŸ”¥ è·å–å­—æ¯æ¨¡å—ä¸“å±è¿›åº¦ï¼ˆåŒ…å« currentRoundï¼‰
    let alphabetProgress = null;
    if (params.entityType === 'letter') {
      const alphabetProgressResult = await db.collection('user_alphabet_progress')
        .where({ userId })
        .limit(1)
        .get();

      console.log('ğŸ“Š [getUserProgress] alphabetProgressResult:', {
        found: alphabetProgressResult.data?.length > 0,
        data: alphabetProgressResult.data?.[0]
      });

      if (alphabetProgressResult.data && alphabetProgressResult.data.length > 0) {
        alphabetProgress = alphabetProgressResult.data[0];
        console.log('ğŸ“Š [getUserProgress] alphabetProgress.currentRound:', alphabetProgress.currentRound);
      } else {
        console.log('âš ï¸ [getUserProgress] No alphabet progress found for user:', userId);
      }
    }

    // 3. ç»Ÿè®¡å„æ¨¡å—å­¦ä¹ æ•°æ®
    // æ³¨æ„: å¦‚æœæ•°æ®é‡å¾ˆå¤§ï¼Œcount() æ¯” get() æ›´é«˜æ•ˆ
    const letterCountResult = await db.collection('memory_status')
      .where({ userId, entityType: 'letter' })
      .count();

    const letterMasteredResult = await db.collection('memory_status')
      .where({ userId, entityType: 'letter', masteryLevel: db.command.gte(0.7) })
      .count();

    const wordCountResult = await db.collection('memory_status')
      .where({ userId, entityType: 'word' })
      .count();

    const wordMasteredResult = await db.collection('memory_status')
      .where({ userId, entityType: 'word', masteryLevel: db.command.gte(0.7) })
      .count();

    // 4. ç»„è£…
    const result = {
      ...progress,
      // ğŸ”¥ åˆå¹¶å­—æ¯æ¨¡å—ä¸“å±å­—æ®µï¼ˆcurrentRound, completedLessons, roundHistoryï¼‰
      ...(alphabetProgress ? {
        currentRound: alphabetProgress.currentRound,
        completedLessons: alphabetProgress.completedLessons || [],  // ğŸ”¥ æ–°å¢å­—æ®µ
        roundHistory: alphabetProgress.roundHistory || []  // ğŸ”¥ P0-A: è¡¥å…… roundHistory
      } : {}),
      statistics: {
        letter: {
          total: 44,
          learned: letterCountResult.total,
          mastered: letterMasteredResult.total,
          progress: letterCountResult.total > 0 ? (letterMasteredResult.total / 44).toFixed(2) : 0
        },
        word: {
          total: 3500,
          learned: wordCountResult.total,
          mastered: wordMasteredResult.total,
          progress: wordCountResult.total > 0 ? (wordMasteredResult.total / 3500).toFixed(2) : 0
        }
      },
      unlockStatus: {
        letter: true,
        word: progress.wordUnlocked,
        sentence: progress.sentenceUnlocked,
        article: progress.articleUnlocked
      }
    };

    console.log('ğŸ“Š [getUserProgress] roundHistory returned:', (alphabetProgress?.roundHistory || []).length);

    // ä¸å‰ç«¯çº¦å®šï¼šdata.progress ä¸ºè¿›åº¦å¯¹è±¡
    return createResponse(true, { progress: result }, 'è·å–ç”¨æˆ·è¿›åº¦æˆåŠŸ');

  } catch (error) {
    console.error('getUserProgress error:', error);
    return createResponse(false, null, error.message, 'SERVER_ERROR');
  }
}

module.exports = getUserProgress;
````

## File: src/components/courses/AlphabetCourseCard.tsx
````typescript
// src/components/courses/AlphabetCourseCard.tsx
import React from 'react';
import { View, Text, StyleSheet, Pressable, Image, ImageSourcePropType } from 'react-native';
import { useRouter } from 'expo-router';
import { useTranslation } from 'react-i18next';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

interface AlphabetCourseCardProps {
  course: {
    id: string;
    source: string;
    title: string;
    description: string;
    level: string;
    imageSource: ImageSourcePropType;
    lessons: number;
  };
  isCurrent: boolean;
  progress?: {
    completed: number;
    total: number;
  };
  onStart: () => void;
}

export function AlphabetCourseCard({ course, isCurrent, progress, onStart }: AlphabetCourseCardProps) {
  const router = useRouter();
  const { t } = useTranslation();

  const progressPercent = (() => {
    if (!progress) {
      return null;
    }
    const completed = progress.completed || 0;
    const total = progress.total || 44; // Default total if not provided
    if (total === 0) {
      return 0; // Or null, depending on desired behavior for 0 total
    }
    return Math.min(100, Math.round((completed / total) * 100));
  })();

  return (
    <View style={[styles.card, isCurrent && styles.activeCard]}>
      <Pressable style={styles.cardPressable} onPress={onStart}>
        <Image source={course.imageSource} style={styles.image} />
        <View style={styles.info}>
          <View style={styles.header}>
            <Text style={styles.title} numberOfLines={1}>
              {course.title}
            </Text>
            <View style={styles.levelBadge}>
              <Text style={styles.levelText}>{course.level}</Text>
            </View>
          </View>

          <Text style={styles.description} numberOfLines={2}>
            {course.description}
          </Text>

          <View style={styles.footer}>
            <View style={styles.metaColumn}>
              {progressPercent !== null ? (
                <>
                  <View style={styles.progressBar}>
                    <View style={[styles.progressFill, { width: `${progressPercent}%` }]} />
                  </View>
                  <Text style={styles.metaText}>
                    {progress?.completed}/{progress?.total} ({progressPercent}%)
                  </Text>
                </>
              ) : (
                <Text style={styles.metaText}>{course.lessons} è¯¾æ—¶</Text>
              )}
            </View>

            {/* Start Learning æŒ‰é’® */}
            <Pressable
              style={[styles.startBtn, isCurrent && styles.activeStartBtn]}
              onPress={(e) => {
                e.stopPropagation();
                onStart();
              }}
            >
              <Text style={[styles.startBtnText, isCurrent && styles.activeStartBtnText]}>
                {isCurrent ? t('courses.continue', 'ç»§ç»­å­¦ä¹ ') : t('courses.startBtnText', 'å¼€å§‹å­¦ä¹ ')}
              </Text>
            </Pressable>
          </View>
        </View>
      </Pressable>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    flexDirection: 'row',
    backgroundColor: Colors.white,
    borderRadius: 16,
    overflow: 'hidden',
    borderWidth: 1,
    borderColor: Colors.sand,
    height: 136,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.05,
    shadowRadius: 8,
    elevation: 3,
  },
  activeCard: {
    borderColor: Colors.thaiGold,
    borderWidth: 2,
    backgroundColor: '#FFFCF5',
  },
  cardPressable: {
    flex: 1,
    flexDirection: 'row',
  },
  image: {
    width: 110,
    height: '100%',
    resizeMode: 'cover',
  },
  info: {
    flex: 1,
    padding: 12,
    justifyContent: 'space-between',
    gap: 8,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    gap: 8,
  },
  title: {
    flex: 1,
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.ink,
  },
  levelBadge: {
    paddingHorizontal: 6,
    paddingVertical: 2,
    backgroundColor: 'rgba(212, 175, 55, 0.1)',
    borderRadius: 4,
    borderWidth: 1,
    borderColor: 'rgba(212, 175, 55, 0.3)',
  },
  levelText: {
    fontSize: 10,
    color: Colors.thaiGold,
    fontFamily: Typography.notoSerifRegular,
  },
  description: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 12,
    color: Colors.taupe,
    lineHeight: 16,
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    gap: 12,
  },
  metaColumn: {
    flex: 1,
    gap: 6,
  },
  metaText: {
    fontSize: 11,
    color: Colors.taupe,
    fontFamily: Typography.notoSerifRegular,
  },
  progressBar: {
    height: 6,
    backgroundColor: '#F0F0F0',
    borderRadius: 3,
    overflow: 'hidden',
  },
  progressFill: {
    height: '100%',
    backgroundColor: Colors.thaiGold,
    borderRadius: 3,
  },
  startBtn: {
    paddingHorizontal: 14,
    paddingVertical: 10,
    backgroundColor: Colors.ink,
    borderRadius: 12,
  },
  activeStartBtn: {
    backgroundColor: Colors.thaiGold,
  },
  startBtnText: {
    fontSize: 12,
    color: Colors.white,
    fontFamily: Typography.notoSerifRegular,
  },
  activeStartBtnText: {
    color: Colors.white,
    fontWeight: '600',
  },
});
````

## File: src/components/learning/alphabet/AlphabetReviewView.tsx
````typescript
// src/components/learning/alphabet/AlphabetReviewView.tsx

import React, { useState, useCallback, useRef, useEffect } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  ActivityIndicator,
  Animated,
  Vibration,
  Platform,
} from 'react-native';
import { Audio } from 'expo-av';
import { Volume2, Check, X, AudioLines } from 'lucide-react-native';

import type { AlphabetLearningState } from '@/src/stores/alphabetStore';
import type { Letter } from '@/src/entities/types/letter.types';
import type { AlphabetQueueItem, AlphabetQuestion } from '@/src/entities/types/alphabet.types';

// Use strict new types
import { AlphabetGameType, ALPHABET_GAME_TYPE_LABELS } from '@/src/entities/types/alphabetGameTypes';
import { generateQuestion } from '@/src/utils/lettersQuestionGenerator';
import { getLetterAudioUrl } from '@/src/utils/alphabet/audioHelper';
// Legacy type for prop compatibility (mapped internally)
import { QuestionType } from '@/src/entities/enums/QuestionType.enum';

import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';

type AnswerState = 'idle' | 'correct' | 'wrong' | 'locked';

interface AlphabetReviewViewProps {
  alphabet: AlphabetLearningState;
  letterPool?: Letter[];
  preferredType?: QuestionType; // Legacy prop
  onAnswer: (isCorrect: boolean, questionType: any) => void;
  onNext: () => void;
  onBack?: () => void;
}

export function AlphabetReviewView({
  alphabet,
  letterPool,
  preferredType,
  onAnswer,
  onNext,
  onBack,
}: AlphabetReviewViewProps) {
  const [answerState, setAnswerState] = useState<AnswerState>('idle');
  // use index to track selection to avoid duplicate value issues
  const [selectedOptionIndex, setSelectedOptionIndex] = useState<number | null>(null);
  const [isPlaying, setIsPlaying] = useState(false);

  const soundRef = useRef<Audio.Sound | null>(null);
  const shakeX = useRef(new Animated.Value(0)).current;
  const wrongResetTimer = useRef<ReturnType<typeof setTimeout> | null>(null);
  const correctLockTimer = useRef<ReturnType<typeof setTimeout> | null>(null);

  const pool = letterPool || [];

  // --- 1. Question Generation & Type Mapping ---

  const mapLegacyType = (legacyType?: QuestionType): AlphabetGameType => {
    switch (legacyType) {
      case QuestionType.SOUND_TO_LETTER: return AlphabetGameType.SOUND_TO_LETTER;
      case QuestionType.LETTER_TO_SOUND: return AlphabetGameType.LETTER_TO_SOUND;
      case QuestionType.CLASS_CHOICE: return AlphabetGameType.CONSONANT_CLASS;
      case QuestionType.FINAL_CONSONANT: return AlphabetGameType.FINAL_SOUND;
      case QuestionType.SYLLABLE: return AlphabetGameType.SOUND_TO_LETTER;
      case QuestionType.ASPIRATED_CONTRAST: return AlphabetGameType.SOUND_TO_LETTER;
      case QuestionType.TONE_PERCEPTION: return AlphabetGameType.TONE_CALCULATION;
      case QuestionType.INITIAL_SOUND: return AlphabetGameType.INITIAL_SOUND;
      default: return AlphabetGameType.SOUND_TO_LETTER;
    }
  };

  const createQuestion = (): AlphabetQuestion => {
    const queueItem: AlphabetQueueItem = {
      letterId: alphabet.alphabetId,
      letter: alphabet.letter,
      gameType: mapLegacyType(preferredType),
    };
    return generateQuestion(queueItem, pool);
  };

  const [question, setQuestion] = useState<AlphabetQuestion>(createQuestion);
  const questionKey = question.id;

  // Debug Log
  useEffect(() => {
    // CONSONANT_CLASS has 3 options. Others usually 4.
    const minOptions = question.gameType === AlphabetGameType.CONSONANT_CLASS ? 3 : 4;
    // TONE_CALCULATION / PHONICS_MATH placeholders might also have fewer?
    // Let's safe guard.
    if (!question?.options || question.options.length < minOptions) {
      console.warn('âš ï¸ Options count low:', question?.options?.length || 0, 'Type:', question.gameType);
    }
  }, [question]);

  useEffect(() => {
    setQuestion(createQuestion());
    resetForNewQuestion();
  }, [alphabet.alphabetId, preferredType]);


  // --- 2. Audio Logic ---

  /* 
   * Stop audio safely handling potential race conditions
   * (e.g. concurrent calls where soundRef.current becomes null) 
   */
  const stopAudio = useCallback(async () => {
    const sound = soundRef.current;
    if (!sound) return;

    // Immediately detach ref to prevent other calls from accessing this instance
    soundRef.current = null;

    try {
      await sound.stopAsync().catch(() => { });
      await sound.unloadAsync().catch(() => { });
    } catch (ignore) {
      // Ignore errors during cleanup
    }
  }, []);

  const playAudio = useCallback(
    async (uri?: string | null) => {
      if (!uri) return;

      try {
        setIsPlaying(true);
        await stopAudio();
        const { sound } = await Audio.Sound.createAsync(
          { uri },
          { shouldPlay: true }
        );

        soundRef.current = sound;
        sound.setOnPlaybackStatusUpdate((status) => {
          if (status.isLoaded && status.didJustFinish) {
            setIsPlaying(false);
          }
        });
      } catch (error) {
        console.warn('[AlphabetReview] Playback failed:', error);
        setIsPlaying(false);
      }
    },
    [stopAudio]
  );

  useEffect(() => {
    resetForNewQuestion();

    const shouldAutoPlay = [
      AlphabetGameType.SOUND_TO_LETTER,
      AlphabetGameType.INITIAL_SOUND,
      AlphabetGameType.FINAL_SOUND
    ].includes(question.gameType);

    if (shouldAutoPlay && question.audioUrl) {
      void playAudio(question.audioUrl);
    }

    return () => {
      if (wrongResetTimer.current) clearTimeout(wrongResetTimer.current);
      if (correctLockTimer.current) clearTimeout(correctLockTimer.current);
      void stopAudio();
    };
  }, [questionKey]);


  // --- 3. Interaction Logic ---

  const resetForNewQuestion = useCallback(() => {
    setAnswerState('idle');
    setSelectedOptionIndex(null);
    shakeX.setValue(0);
    if (wrongResetTimer.current) clearTimeout(wrongResetTimer.current);
    if (correctLockTimer.current) clearTimeout(correctLockTimer.current);
  }, [shakeX]);

  const runShake = useCallback(() => {
    shakeX.setValue(0);
    Animated.sequence([
      Animated.timing(shakeX, { toValue: -10, duration: 40, useNativeDriver: true }),
      Animated.timing(shakeX, { toValue: 10, duration: 40, useNativeDriver: true }),
      Animated.timing(shakeX, { toValue: -6, duration: 40, useNativeDriver: true }),
      Animated.timing(shakeX, { toValue: 6, duration: 40, useNativeDriver: true }),
      Animated.timing(shakeX, { toValue: 0, duration: 40, useNativeDriver: true }),
    ]).start();
  }, [shakeX]);

  // MOVED checkAnswer UP to resolve hoisting error
  const checkAnswer = useCallback((optionValue: string, index: number) => {
    const isCorrect = optionValue === question.correctAnswer;
    setSelectedOptionIndex(index);

    if (isCorrect) {
      setAnswerState('correct');
      onAnswer(true, question.gameType);

      // Play success sound unless it's LetterToSound (where we already played)
      if (question.audioUrl && (question.gameType !== AlphabetGameType.LETTER_TO_SOUND)) {
        void playAudio(question.audioUrl);
      }

      correctLockTimer.current = setTimeout(() => {
        setAnswerState('locked');
      }, 500);
    } else {
      setAnswerState('wrong');
      onAnswer(false, question.gameType);
      runShake();
      Vibration.vibrate(50);

      wrongResetTimer.current = setTimeout(() => {
        setAnswerState('idle');
        setSelectedOptionIndex(null);
      }, 800);
    }
  }, [question, onAnswer, runShake, playAudio]);

  const handleOptionSelect = useCallback(
    (optionValue: string, index: number) => {
      if (answerState !== 'idle') return;

      const isAudioQuestion = question.gameType === AlphabetGameType.LETTER_TO_SOUND;

      if (isAudioQuestion) {
        // Play First Logic
        const targetLetter = question?.options?.[index];

        if (targetLetter) {
          const url = targetLetter.letterPronunciationUrl || targetLetter.fullSoundUrl || targetLetter.audioPath;
          if (url) {
            void playAudio(url);
          }
        }

        setSelectedOptionIndex(index);
        // Do NOT submit yet
        return;
      }

      // Default Immediate Feedback
      checkAnswer(optionValue, index);
    },
    [answerState, question, checkAnswer, playAudio]
  );

  const handleConfirmAnswer = useCallback(() => {
    if (selectedOptionIndex !== null && question.options) {
      // Get value from index
      const selectedItem = question.options[selectedOptionIndex];
      let val: string | undefined;

      switch (question.gameType) {
        case AlphabetGameType.LETTER_TO_SOUND:
          val = selectedItem.initialSound || selectedItem.fullSoundUrl || selectedItem._id;
          break;
        case AlphabetGameType.INITIAL_SOUND:
          val = selectedItem.initialSound;
          break;
        case AlphabetGameType.FINAL_SOUND:
          val = selectedItem.finalSound || selectedItem.initialSound;
          break;
        default:
          val = selectedItem.thaiChar;
      }

      if (val) checkAnswer(val, selectedOptionIndex);
    }
  }, [selectedOptionIndex, question, checkAnswer]);

  const handleNextQuestion = useCallback(() => {
    if (answerState !== 'locked') return;
    resetForNewQuestion();
    void stopAudio();
    onNext();
  }, [answerState, resetForNewQuestion, stopAudio, onNext]);


  // --- 4. Render Helpers ---

  const renderQuestionHeader = () => {
    const title = ALPHABET_GAME_TYPE_LABELS[question.gameType] || 'Review';
    let instruction = 'Select the correct answer';

    switch (question.gameType) {
      case AlphabetGameType.SOUND_TO_LETTER: instruction = 'Listen and choose the letter'; break;
      case AlphabetGameType.LETTER_TO_SOUND: instruction = 'Match the pronunciation'; break;
      case AlphabetGameType.CONSONANT_CLASS: instruction = 'Select the consonant class'; break;
      case AlphabetGameType.INITIAL_SOUND: instruction = 'Identify the initial sound'; break;
      case AlphabetGameType.FINAL_SOUND: instruction = 'Identify the final sound'; break;
      default: break;
    }

    return (
      <View style={styles.header}>
        <Text style={styles.headerTitle}>{title}</Text>
        <Text style={styles.headerInstruction}>{instruction}</Text>
      </View>
    );
  };

  const renderAudioButton = () => {
    // For Letter-to-Sound, the user must read the letter. Providing central audio defeats the visual recognition task.
    if (!question.audioUrl || question.gameType === AlphabetGameType.LETTER_TO_SOUND) return null;
    return (
      <TouchableOpacity
        style={[styles.audioButton, isPlaying && styles.audioButtonActive]}
        onPress={() => playAudio(question.audioUrl)}
      >
        <Volume2 size={32} color={Colors.white} />
      </TouchableOpacity>
    );
  };

  const renderStem = () => {
    if (question.gameType === AlphabetGameType.LETTER_TO_SOUND ||
      question.gameType === AlphabetGameType.CONSONANT_CLASS) {
      return (
        <View style={styles.stemContainer}>
          <Text style={styles.stemLetter}>{question.targetLetter.thaiChar}</Text>
        </View>
      );
    }
    return null;
  };

  const renderOptions = () => {
    const options = question.options || [];
    const minOptions = question.gameType === AlphabetGameType.CONSONANT_CLASS ? 3 : 4;

    if (!options || options.length < minOptions) {
      return (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>é¢˜ç›®é€‰é¡¹åŠ è½½å¤±è´¥</Text>
          <TouchableOpacity
            style={styles.retryButton}
            onPress={() => {
              setQuestion(createQuestion());
              resetForNewQuestion();
            }}
          >
            <Text style={styles.retryButtonText}>é‡æ–°ç”Ÿæˆé¢˜ç›®</Text>
          </TouchableOpacity>
        </View>
      );
    }

    return (
      <Animated.View
        style={[
          styles.optionsGrid,
          { transform: [{ translateX: shakeX }] }
        ]}
      >
        {options.map((optLetter, index) => {
          let displayValue = '';
          let comparisonValue = '';

          switch (question.gameType) {
            case AlphabetGameType.SOUND_TO_LETTER:
              displayValue = optLetter.thaiChar;
              comparisonValue = optLetter.thaiChar;
              break;
            case AlphabetGameType.LETTER_TO_SOUND:
              displayValue = `/${optLetter.initialSound || '...'} /`;
              comparisonValue = optLetter.initialSound || optLetter.fullSoundUrl || optLetter._id;
              break;
            case AlphabetGameType.INITIAL_SOUND:
              displayValue = `/${optLetter.initialSound}/`;
              comparisonValue = optLetter.initialSound;
              break;
            case AlphabetGameType.FINAL_SOUND:
              displayValue = `/${optLetter.finalSound || optLetter.initialSound}/`;
              comparisonValue = optLetter.finalSound || optLetter.initialSound;
              break;
            default:
              displayValue = optLetter.thaiChar;
              comparisonValue = optLetter.thaiChar;
          }

          const isSelected = selectedOptionIndex === index;
          const isCorrect = (answerState === 'correct' || answerState === 'locked') && comparisonValue === question.correctAnswer;
          const isWrong = answerState === 'wrong' && isSelected && comparisonValue !== question.correctAnswer;
          const isDimmed = (answerState === 'correct' || answerState === 'locked') && !isCorrect;

          return (
            <TouchableOpacity
              key={`${index}-${comparisonValue}`}
              style={[
                styles.optionCard,
                isSelected && styles.optionSelected,
                isCorrect && styles.optionCorrect,
                isWrong && styles.optionWrong,
                isDimmed && styles.optionDimmed,
              ]}
              onPress={() => {
                if (question.gameType === AlphabetGameType.LETTER_TO_SOUND) {
                  // Get normalized audio URL using helper
                  const url = getLetterAudioUrl(optLetter);

                  if (url) {
                    console.log('ğŸ”Š Playing Option Sound');
                    void playAudio(url);
                  } else {
                    console.warn('âš ï¸ No audio URL found for option:', optLetter.thaiChar);
                  }

                  handleOptionSelect(comparisonValue, index);
                } else {
                  handleOptionSelect(comparisonValue, index);
                }
              }}
              disabled={answerState !== 'idle' && answerState !== 'locked'}
            >
              {question.gameType === AlphabetGameType.LETTER_TO_SOUND ? (
                // Use AudioLines for "Voice Wave" style
                <View style={{ paddingBottom: 26 }}>
                  <AudioLines size={32} color={isSelected ? Colors.thaiGold : Colors.taupe} />
                </View>
              ) : (
                <Text
                  style={[
                    styles.optionText,
                    isCorrect && styles.optionTextCorrect,
                    isWrong && styles.optionTextWrong
                  ]}
                  adjustsFontSizeToFit
                  numberOfLines={1}
                >
                  {displayValue}
                </Text>
              )}

              <View style={styles.iconContainer}>
                {isCorrect && <Check size={20} color="#2A9D8F" />}
                {isWrong && <X size={20} color="#E63946" />}
              </View>
            </TouchableOpacity>
          );
        })}
      </Animated.View>
    );
  };

  return (
    <View style={styles.container}>
      {renderQuestionHeader()}

      <View style={styles.content}>
        {renderStem()}
        {renderAudioButton()}
        {renderOptions()}
      </View>

      <View style={styles.bottomArea}>
        {/* Confirm Button for Audio Questions */}
        {(question.gameType === AlphabetGameType.LETTER_TO_SOUND) && answerState === 'idle' && selectedOptionIndex !== null && (
          <TouchableOpacity style={styles.nextButton} onPress={handleConfirmAnswer}>
            <Text style={styles.nextButtonText}>Check Answer</Text>
          </TouchableOpacity>
        )}

        {answerState === 'locked' && (
          <TouchableOpacity style={styles.nextButton} onPress={handleNextQuestion}>
            <Text style={styles.nextButtonText}>Next Question â†’</Text>
          </TouchableOpacity>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 24,
    backgroundColor: Colors.paper,
  },
  header: {
    alignItems: 'center',
    marginBottom: 32,
  },
  headerTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.thaiGold,
    textTransform: 'uppercase',
    letterSpacing: 1,
    marginBottom: 8,
  },
  headerInstruction: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 18,
    color: Colors.ink,
    textAlign: 'center',
  },
  content: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'flex-start',
    paddingTop: 40,
  },
  stemContainer: {
    marginBottom: 32,
  },
  stemLetter: {
    fontFamily: Typography.playfairBold,
    fontSize: 88,
    color: Colors.ink,
  },
  audioButton: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: Colors.thaiGold,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 60,
    shadowColor: Colors.thaiGold,
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.3,
    shadowRadius: 16,
    elevation: 8,
  },
  audioButtonActive: {
    transform: [{ scale: 0.95 }],
    opacity: 0.9,
  },
  optionsGrid: {
    width: '100%',
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 16,
    justifyContent: 'center',
  },
  optionCard: {
    width: '47%',
    aspectRatio: 1.4,
    backgroundColor: Colors.white,
    borderRadius: 16,
    borderWidth: 2,
    borderColor: '#EFEFEF',
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative',
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.05,
        shadowRadius: 4,
      },
      android: { elevation: 2 }
    })
  },
  optionSelected: {
    borderColor: Colors.thaiGold,
    backgroundColor: '#FFFCF5',
  },
  optionCorrect: {
    borderColor: '#2A9D8F',
    backgroundColor: '#E8F5F3',
  },
  optionWrong: {
    borderColor: '#E63946',
    backgroundColor: '#FFE8EA',
  },
  optionDimmed: {
    opacity: 0.3,
  },
  optionText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 42,
    color: Colors.ink,
    textAlign: 'center',
    textAlignVertical: 'center',
    includeFontPadding: false,
    paddingBottom: 24, // Visual fix: Add bottom buffer to counteract font's top whitespace
  },
  optionTextCorrect: {
    color: '#2A9D8F',
  },
  optionTextWrong: {
    color: '#E63946',
  },
  iconContainer: {
    position: 'absolute',
    right: 8,
    top: 8,
  },
  bottomArea: {
    height: 80,
    justifyContent: 'center',
    alignItems: 'center',
  },
  nextButton: {
    backgroundColor: Colors.ink,
    paddingHorizontal: 32,
    paddingVertical: 14,
    borderRadius: 100,
    flexDirection: 'row',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 4,
  },
  nextButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
  },
  errorContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 32,
  },
  errorText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 18,
    color: '#E63946',
    marginBottom: 8,
    textAlign: 'center',
  },
  errorSubText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
    marginBottom: 24,
    textAlign: 'center',
  },
  retryButton: {
    backgroundColor: Colors.thaiGold,
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  retryButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 14,
    color: Colors.white,
  },
});
````

## File: src/config/api.endpoints.ts
````typescript
// src/config/api.endpoints.ts

/*
 * API ç«¯ç‚¹é…ç½®
 *
 * ä½œç”¨ï¼š
 * 1. ç»Ÿä¸€ç®¡ç†æ‰€æœ‰ API è·¯å¾„ï¼Œæ”¯æŒå¤šåç«¯åˆ‡æ¢
 * 2. æ˜¾å¼æ ‡è®°â€œCloudBase å®é™…å­˜åœ¨çš„äº‘å‡½æ•°â€å’Œâ€œä»…å ä½/ä»… Java åç«¯å¯ç”¨â€çš„ç«¯ç‚¹
 *
 * å½“å‰ CloudBase å·²éƒ¨ç½²çš„å‡½æ•°ï¼ˆæ¥è‡ª cloudbase/cloudbaserc.jsonï¼‰ï¼š
 * - user-register
 * - user-login
 * - user-reset-password
 * - user-update-profile
 * - learn-vocab          ï¼ˆå¤š actionï¼šè¯æ±‡å­¦ä¹  / æ¨¡å—è§£é” ç­‰ï¼‰
 * - memory-engine        ï¼ˆå¤š actionï¼šgetTodayMemories / submitMemoryResult / submitRoundEvaluation ç­‰ï¼‰
 * - alphabet             ï¼ˆå­—æ¯æµ‹è¯•ç­‰å•ç‹¬åŠŸèƒ½ï¼‰
 *
 * é™¤ä¸Šè¿°äº‘å‡½æ•°åä»¥å¤–çš„ cloudbase å­—æ®µï¼Œå‡è§†ä¸ºâ€œæœªå®ç°çš„äº‘å‡½æ•°åç§°å ä½â€ï¼Œ
 * ç›®å‰å‰ç«¯ä»£ç ä¸åº”è°ƒç”¨è¿™äº›å ä½ç«¯ç‚¹ã€‚
 */

// ==================== åç«¯ç±»å‹å®šä¹‰ ====================
export type BackendType = 'cloudbase' | 'java';

// ==================== ç«¯ç‚¹æ˜ å°„æ¥å£ ====================
export interface EndpointMap {
  cloudbase: string;  // CloudBase äº‘å‡½æ•°å
  java: string;       // Java Spring Boot è·¯å¾„
}

// ==================== è®¤è¯ API ====================
export const AUTH_ENDPOINTS = {
  // ç”¨æˆ·ç™»å½•
  // âœ… CloudBase: å·²å®ç° user-login äº‘å‡½æ•°
  LOGIN: {
    cloudbase: '/user-login',
    java: '/api/auth/login'
  } as EndpointMap, /*
                    as EndpointMap è¡¨ç¤ºç±»å‹æ–­è¨€
                    ä½œç”¨æ˜¯å‘Šè¯‰TypeScriptç¼–è¯‘å™¨ï¼Œè¿™ä¸ªå¯¹è±¡çš„ç±»å‹æ˜¯EndpointMap
                    */

  // ç”¨æˆ·æ³¨å†Œ
  // âœ… CloudBase: å·²å®ç° user-register äº‘å‡½æ•°
  REGISTER: {
    cloudbase: '/user-register',
    java: '/api/auth/register'
  } as EndpointMap,

  // é‡ç½®å¯†ç 
  // âœ… CloudBase: å·²å®ç° user-reset-password äº‘å‡½æ•°
  RESET_PASSWORD: {
    cloudbase: '/user-reset-password',
    java: '/api/auth/reset-password'
  } as EndpointMap,

  // æ›´æ–°ä¸ªäººèµ„æ–™
  // âœ… CloudBase: å·²å®ç° user-update-profile äº‘å‡½æ•°
  UPDATE_PROFILE: {
    cloudbase: '/user-update-profile',
    java: '/api/user/profile'
  } as EndpointMap,

  // ç™»å‡º
  // âš ï¸ CloudBase: ç›®å‰æ²¡æœ‰ user-logout äº‘å‡½æ•°ï¼Œå‰ç«¯ä»…æœ¬åœ°ç™»å‡ºï¼Œä¸ä¼šè°ƒç”¨è¯¥ cloudbase ç«¯ç‚¹
  LOGOUT: {
    cloudbase: '/user-logout',
    java: '/api/auth/logout'
  } as EndpointMap,
};

// ==================== è¯¾ç¨‹ç®¡ç† API ====================
// âš ï¸ è¯´æ˜ï¼š
// - ä¸‹åˆ— cloudbase å­—æ®µï¼ˆ/course-get-*ï¼‰ç›®å‰æ²¡æœ‰å¯¹åº”çš„äº‘å‡½æ•°ï¼Œä»…ä½œä¸ºæœªæ¥æ‰©å±•çš„å ä½ã€‚
// - å¦‚éœ€åœ¨ CloudBase ä¸Šå®ç°è¯¾ç¨‹ç®¡ç†ï¼Œè¯·æ–°å¢å¯¹åº”äº‘å‡½æ•°åï¼Œå†æ­£å¼å¯ç”¨è¿™äº›ç«¯ç‚¹ã€‚
export const COURSE_ENDPOINTS = {
  // è·å–æ‰€æœ‰è¯¾ç¨‹
  GET_ALL: {
    cloudbase: '/course-get-all',
    java: '/api/courses'
  } as EndpointMap,

  // è·å–è¯¾ç¨‹è¯¦æƒ…
  GET_DETAIL: {
    cloudbase: '/course-get-detail',
    java: '/api/courses/:id'
  } as EndpointMap,

  // è·å–è¯¾ç¨‹å†…å®¹
  GET_CONTENT: {
    cloudbase: '/course-get-content',
    java: '/api/courses/:id/content'
  } as EndpointMap,
};

// ==================== å­¦ä¹ åŠŸèƒ½ API ====================
// âš ï¸ è¯´æ˜ï¼š
// - ä¸‹åˆ— cloudbase å­—æ®µï¼ˆ/learning-*ï¼‰ç›®å‰æ²¡æœ‰å¯¹åº”çš„äº‘å‡½æ•°ï¼Œä»…ä½œä¸ºå ä½ï¼›
// - å½“å‰å®é™…çš„å­—æ¯ / å•è¯å­¦ä¹ ç»Ÿä¸€èµ° memory-engine / learn-vocab å¤š action äº‘å‡½æ•°ã€‚
export const LEARNING_ENDPOINTS = {
  // è·å–å­—æ¯è¡¨
  GET_ALPHABETS: {
    cloudbase: '/learning-get-alphabets',
    java: '/api/learning/alphabets'
  } as EndpointMap,

  // è·å–è¯æ±‡
  GET_VOCABULARY: {
    cloudbase: '/learning-get-vocabulary',
    java: '/api/learning/vocabulary'
  } as EndpointMap,

  // è·å–å¥å­
  GET_SENTENCES: {
    cloudbase: '/learning-get-sentences',
    java: '/api/learning/sentences'
  } as EndpointMap,

  // è·å–æ–‡ç« 
  GET_ARTICLES: {
    cloudbase: '/learning-get-articles',
    java: '/api/learning/articles'
  } as EndpointMap,

  // è®°å½•å­¦ä¹ å®Œæˆ
  RECORD_COMPLETION: {
    cloudbase: '/learning-record-completion',
    java: '/api/learning/record'
  } as EndpointMap,
};

// ==================== å‘éŸ³è¯„ä¼° API ====================
// âš ï¸ è¯´æ˜ï¼š
// - ä¸‹åˆ— cloudbase å­—æ®µï¼ˆ/pronunciation-*ï¼‰ç›®å‰æ²¡æœ‰å¯¹åº”äº‘å‡½æ•°ï¼Œä»… Java ç«¯æˆ–æœªæ¥æ‰©å±•ä½¿ç”¨ã€‚
export const PRONUNCIATION_ENDPOINTS = {
  // å‘éŸ³è¯„ä¼°
  ASSESS: {
    cloudbase: '/pronunciation-assess',
    java: '/api/pronunciation/assess'
  } as EndpointMap,

  // è·å–è¯„ä¼°å†å²
  GET_HISTORY: {
    cloudbase: '/pronunciation-get-history',
    java: '/api/pronunciation/history'
  } as EndpointMap,
};

// ==================== è¿›åº¦ç®¡ç† API ====================
// âš ï¸ è¯´æ˜ï¼š
// - ä¸‹åˆ— cloudbase å­—æ®µï¼ˆ/progress-*ï¼‰ç›®å‰æ²¡æœ‰å¯¹åº”äº‘å‡½æ•°ï¼›
// - è¿›åº¦ç›¸å…³é€»è¾‘æš‚ç”± memory-engine / learn-vocab å†…éƒ¨æ›´æ–° user_progressã€‚
export const PROGRESS_ENDPOINTS = {
  // è·å–è¿›åº¦
  GET: {
    cloudbase: '/progress-get',
    java: '/api/progress'
  } as EndpointMap,

  // æ›´æ–°è¿›åº¦
  UPDATE: {
    cloudbase: '/progress-update',
    java: '/api/progress'
  } as EndpointMap,

  // è·å–ç»Ÿè®¡æ•°æ®
  GET_STATISTICS: {
    cloudbase: '/progress-get-statistics',
    java: '/api/progress/statistics'
  } as EndpointMap,
};

// ==================== å¤ä¹ ç³»ç»Ÿ API ====================
// âš ï¸ è¯´æ˜ï¼š
// - ä¸‹åˆ— cloudbase å­—æ®µï¼ˆ/review-*ï¼‰ç›®å‰æ²¡æœ‰å¯¹åº”äº‘å‡½æ•°ï¼Œä»…ä½œä¸ºæœªæ¥å¤ä¹ ä¸­å¿ƒåŒ–æœåŠ¡çš„å ä½ã€‚
export const REVIEW_ENDPOINTS = {
  // è·å–åˆ°æœŸå¤ä¹ 
  GET_DUE: {
    cloudbase: '/review-get-due',
    java: '/api/reviews/due'
  } as EndpointMap,

  // æ›´æ–°å¤ä¹ è®°å½•
  UPDATE: {
    cloudbase: '/review-update',
    java: '/api/reviews/:id'
  } as EndpointMap,

  // è·å–å¤ä¹ å†å²
  GET_HISTORY: {
    cloudbase: '/review-get-history',
    java: '/api/reviews/history'
  } as EndpointMap,
};

// ==================== æ±‡æ€»æ‰€æœ‰ç«¯ç‚¹ ====================


// ==================== è¾…åŠ©å‡½æ•°ï¼šè·å–ç«¯ç‚¹ ====================
export function getEndpoint(
  endpoint: EndpointMap,
  backendType: BackendType
): string {
  return endpoint[backendType];
}

// ==================== è¾…åŠ©å‡½æ•°ï¼šæ›¿æ¢è·¯å¾„å‚æ•° ====================
/**
 * æ›¿æ¢è·¯å¾„ä¸­çš„å‚æ•°
 * 
 * @example
 * replacePathParams('/api/courses/:id', { id: '123' })
 * // è¿”å›: '/api/courses/123'
 */
export function replacePathParams(
  path: string,
  params: Record<string, string>
): string {
  let result = path;

  for (const [key, value] of Object.entries(params)) {
    result = result.replace(`:${key}`, value);
    result = result.replace(`{${key}}`, value);
  }

  return result;
}
// === å­—æ¯å­¦ä¹  API ===
// ==================== å­—æ¯å­¦ä¹  API ====================
// âš ï¸ è¯´æ˜ï¼š
// - å½“å‰å­—æ¯å­¦ä¹ ä¸»æµç¨‹èµ° memory-engine + getTodayMemoriesã€‚
// - è¿™é‡Œçš„ /vocabulary-get-* äº‘å‡½æ•°ååœ¨ CloudBase ä¸­å¹¶ä¸å­˜åœ¨ï¼Œä»…ä¸ºæœ€æ—©ç‰ˆæœ¬è®¾è®¡çš„å ä½ã€‚
// - ä¸å­—æ¯æµ‹è¯•ç›¸å…³çš„å®é™…äº‘å‡½æ•°ä¸º `alphabet`ï¼ˆå¤š actionï¼‰ï¼Œåç»­å¦‚éœ€å¯¹æ¥å¯åœ¨æ­¤é‡æ–°æ˜ å°„ã€‚
export const ALPHABET_ENDPOINTS = {
  GET_TODAY: {
    cloudbase: '/vocabulary-get-today-alphabets',
    java: '/api/vocabulary/alphabets/today'
  } as EndpointMap,

  SUBMIT_RESULT: {
    cloudbase: '/vocabulary-submit-alphabet-result',
    java: '/api/vocabulary/alphabets/result'
  } as EndpointMap,

  GET_TEST: {
    cloudbase: '/alphabet',  // âœ… ä¿®å¤ï¼šæ·»åŠ å‰å¯¼æ–œæ 
    java: '/api/vocabulary/alphabets/test'
  } as EndpointMap,

  SUBMIT_TEST: {
    cloudbase: '/alphabet',  // âœ… ä¿®å¤ï¼šæ·»åŠ å‰å¯¼æ–œæ 
    java: '/api/vocabulary/alphabets/test/submit'
  } as EndpointMap,
};

// ==================== æ¨¡å—æƒé™ API ====================
export const MODULE_ENDPOINTS = {
  // âœ… CloudBase: ä½¿ç”¨ learn-vocab å¤š action äº‘å‡½æ•°ï¼ˆCHECK_ACCESSï¼‰
  CHECK_ACCESS: {
    cloudbase: '/learn-vocab',
    java: '/api/modules/access'
  } as EndpointMap,
  // ğŸ”¥ ä¿®å¤: GET_USER_PROGRESS å·²è¿ç§»åˆ° memory-engine
  GET_USER_PROGRESS: {
    cloudbase: '/memory-engine',
    java: '/api/modules/progress'
  } as EndpointMap,
};

// ==================== å•è¯å­¦ä¹  API ====================
export const VOCABULARY_ENDPOINTS = {
  // âœ… CloudBase: ä½¿ç”¨ learn-vocab å¤š action äº‘å‡½æ•°ï¼ˆgetTodayWords / updateMastery / getVocabularyList ç­‰ï¼‰
  GET_TODAY_WORDS: {
    cloudbase: '/learn-vocab',
    java: '/api/vocabulary/today'
  } as EndpointMap,
  UPDATE_MASTERY: {
    cloudbase: '/learn-vocab',
    java: '/api/vocabulary/mastery'
  } as EndpointMap,
  GET_VOCABULARY_LIST: {
    cloudbase: '/learn-vocab',
    java: '/api/vocabulary/list'
  } as EndpointMap,
  TOGGLE_SKIP_WORD: {
    cloudbase: '/learn-vocab',
    java: '/api/vocabulary/skip'
  } as EndpointMap,
  GET_SKIPPED_WORDS: {
    cloudbase: '/learn-vocab',
    java: '/api/vocabulary/skipped'
  } as EndpointMap,
  GET_VOCABULARY_DETAIL: {
    cloudbase: '/learn-vocab',
    java: '/api/vocabulary/:id'
  } as EndpointMap,
  GET_REVIEW_STATISTICS: {
    cloudbase: '/learn-vocab',
    java: '/api/vocabulary/statistics'
  } as EndpointMap,
};

// ==================== ç»Ÿä¸€è®°å¿†å¼•æ“ API ====================
export const MEMORY_ENDPOINTS = {
  // âœ… CloudBase: ä½¿ç”¨ memory-engine å¤š action äº‘å‡½æ•°
  GET_TODAY_MEMORIES: {
    cloudbase: '/memory-engine',  // äº‘å‡½æ•°å
    java: '/api/memory/today'
  } as EndpointMap,
  SUBMIT_MEMORY_RESULT: {
    cloudbase: '/memory-engine',
    java: '/api/memory/result'
  } as EndpointMap,
  SUBMIT_ROUND_EVALUATION: {
    cloudbase: '/memory-engine',
    java: '/api/memory/round-evaluation'
  } as EndpointMap,
};

// ==================== ä¸‹è½½äº‘å­˜å‚¨ API ====================
export const STORAGE_ENDPOINTS = {
  GET_DOWNLOAD_URL: {
    cloudbase: '/storage-download',
    java: '/api/storage/get-download-url', // é¢„ç•™
  } as EndpointMap,
  BATCH_GET_DOWNLOAD_URLS: {
    cloudbase: '/storage-download',
    java: '/api/storage/batch-get-download-urls',
  } as EndpointMap,
};

// ==================== æ±‡æ€»æ‰€æœ‰ç«¯ç‚¹ ====================
export const API_ENDPOINTS = {
  AUTH: AUTH_ENDPOINTS,
  COURSE: COURSE_ENDPOINTS,
  LEARNING: LEARNING_ENDPOINTS,
  PRONUNCIATION: PRONUNCIATION_ENDPOINTS,
  PROGRESS: PROGRESS_ENDPOINTS,
  REVIEW: REVIEW_ENDPOINTS,
  ALPHABET: ALPHABET_ENDPOINTS,
  VOCABULARY: VOCABULARY_ENDPOINTS,
  MODULE: MODULE_ENDPOINTS,
  MEMORY: MEMORY_ENDPOINTS,
  STORAGE: STORAGE_ENDPOINTS,
};
````

## File: src/i18n/locales/en.ts
````typescript
// src/i18n/locales/en.ts
export default {
  common: {
    confirm: 'Confirm',
    cancel: 'Cancel',
    save: 'Save',
    delete: 'Delete',
    edit: 'Edit',
    loading: 'Loading...',
    error: 'Error',
    success: 'Success',
  },
  auth: {
    title: 'ThaiEasy',
    login: 'Login',
    register: 'Register',
    logout: 'Logout',
    email: 'Email',
    password: 'Password',
    emailPlaceholder: 'Enter your email',
    passwordPlaceholder: 'Enter your password',
    confirmPassword: 'Confirm Password',
    confirmPasswordPlaceholder: 'Re-enter your password',
    displayName: 'Display Name',
    displayNamePlaceholder: 'Enter your display name',
    loginButton: 'Login',
    registerButton: 'Register',
    forgotPassword: 'Forgot password?',
    noAccount: "Don't have an account?",
    hasAccount: 'Already have an account?',
    loginSuccess: 'Login successful',
    loginFailed: 'Login failed',
    alreadyHaveAccount: 'Already have an account?',
    logining: 'logining'
  },
  tabs: {
    home: 'Home',
    learn: 'Learn',
    courses: 'Courses',
    profile: 'Profile',
  },
  profile: {
    title: 'Profile',
    editProfile: 'Edit Profile',
    achievements: 'Achievements',
    settings: 'Settings',
    completedAlphabets: 'Alphabets Learned',
    completedVocabulary: 'Vocabulary Learned',
    completedSentences: 'Sentences Learned',
    completedArticles: 'Articles Read',
    totalScore: 'Total Score',
    studyTime: 'Study Time',
    streakDays: 'Streak Days',
    hours: 'hrs',
    days: 'days',
    selectLanguage: 'Select Language',
    chinese: 'ä¸­æ–‡',
    english: 'English',
    dailyReminder: 'Daily Reminder',
    ttsEngine: 'TTS Engine',
    achievementBadges: {
      streak7: '7-Day Streak',
      master: 'Tone Master',
      vocab100: 'Vocab 100',
    },
  },
  home: {
    greeting: 'Hello',
    todayProgress: "Today's learning goal completed",
    currentCourse: 'Current Course',
    recentMastered: 'Recently Mastered',
    mastered: 'Mastered',
    reviewDue: 'Reviews Due',
    streak: 'Current Streak',
    hoursThisWeek: 'Hours this week',
  },
  courses: {
    title: 'Choose a book, boy',
    subtitle: 'Start your Thai language journey',
    searchPlaceholder: 'Search courses...',
    startBtnText: 'Start Learning',
  },
  learning: {
    basicDefinition: 'Basic Definition',
    exampleSentences: 'Examples',
    usageDetails: 'Usage Details',
    grammarExamples: 'Grammar Examples:',
    diffWithChinese: 'Diff with Chinese:',
    commonMistakes: 'Common Mistakes:',
    similarWordsDiff: 'Similar Words:',
    viewDefinition: 'View Definition',
    nextEnter: 'Next (Enter)',
    next: 'Next',
    forgot: 'Forgot',
    unsure: 'Unsure',
    know: 'Know',
    skipReview: 'Skip Review',
    sessionComplete: 'Session Complete!',
    backToHome: 'Back to Home',
    noNewWordsTitle: 'No New Words',
    noNewWordsMessage: 'You have finished all new words!',
    endSessionTitle: 'End Session?',
    endSessionMessage: 'Are you sure you want to quit?',
    quit: 'Quit',
  },
  modules: {
    alphabet: 'Alphabet',
    word: 'Vocabulary',
    sentence: 'Sentences',
    article: 'Articles',
  },
  moduleAccess: {
    locked: 'Module Locked',
    lockedMessage: '{{module}} module is not yet unlocked',
    requirement: 'Unlock Requirement',
    prerequisite: {
      word: 'Complete alphabet learning and reach 95% progress',
      sentence: 'Complete vocabulary learning and reach 80% progress',
      article: 'Complete sentence learning and reach 80% progress',
    },
    currentProgress: 'Current Progress',
    remainingProgress: '{{remaining}}% remaining',
    progressComplete: 'Progress complete!',
    goBack: 'Go Back',
    noProgress: 'Please start learning first',
    unknownModule: 'Unknown module',
  },
  alphabet: {
    title: 'Thai Alphabet Learning',
    level: 'Basic',
    description: 'Learn 44 consonants and 32 vowels,æŒæ¡ standard pronunciation',
    continue: 'Continue Learning',
    start: 'Start Learning',
  },
  alphabetTest: {
    title: 'Alphabet Test',
    description: 'Test your alphabet knowledge',
    start: 'Start Test',
    submit: 'Submit',
    score: 'Score',
    passed: 'Pass',
    failed: 'Fail',
    retry: 'Retry',
    backToHome: 'Back to Home',
  }
};
````

## File: src/i18n/locales/zh.ts
````typescript
// src/i18n/locales/zh.ts
export default {
  common: {
    confirm: 'ç¡®è®¤',
    cancel: 'å–æ¶ˆ',
    save: 'ä¿å­˜',
    delete: 'åˆ é™¤',
    edit: 'ç¼–è¾‘',
    loading: 'åŠ è½½ä¸­...',
    error: 'é”™è¯¯',
    success: 'æˆåŠŸ',
  },
  auth: {
    title: 'æ³°Easy',
    login: 'ç™»å½•',
    register: 'æ³¨å†Œ',
    logout: 'é€€å‡ºç™»å½•',
    email: 'é‚®ç®±',
    password: 'å¯†ç ',
    emailPlaceholder: 'è¯·è¾“å…¥é‚®ç®±',
    passwordPlaceholder: 'è¯·è¾“å…¥å¯†ç ',
    confirmPassword: 'ç¡®è®¤å¯†ç ',
    confirmPasswordPlaceholder: 'è¯·å†æ¬¡è¾“å…¥å¯†ç ',
    displayName: 'æ˜µç§°',
    displayNamePlaceholder: 'è¯·è¾“å…¥æ˜µç§°',
    loginButton: 'ç™»å½•',
    registerButton: 'æ³¨å†Œ',
    forgotPassword: 'å¿˜è®°å¯†ç ï¼Ÿ',
    noAccount: 'è¿˜æ²¡æœ‰è´¦å·ï¼Ÿ',
    hasAccount: 'å·²æœ‰è´¦å·ï¼Ÿ',
    loginSuccess: 'ç™»å½•æˆåŠŸ',
    loginFailed: 'ç™»å½•å¤±è´¥',
    alreadyHaveAccount: 'å·²æœ‰è´¦å·ï¼Ÿ',
    logining: 'ç™»å½•ä¸­'
  },
  tabs: {
    home: 'é¦–é¡µ',
    learn: 'å­¦ä¹ ',
    courses: 'è¯¾ç¨‹',
    profile: 'æˆ‘çš„',
  },
  profile: {
    title: 'ä¸ªäººä¸­å¿ƒ',
    editProfile: 'ç¼–è¾‘èµ„æ–™',
    achievements: 'å­¦ä¹ æˆå°±',
    settings: 'è®¾ç½®',
    completedAlphabets: 'å·²å­¦å­—æ¯',
    completedVocabulary: 'å·²å­¦è¯æ±‡',
    completedSentences: 'å·²å­¦å¥å­',
    completedArticles: 'å·²è¯»æ–‡ç« ',
    totalScore: 'æ€»åˆ†',
    studyTime: 'å­¦ä¹ æ—¶é•¿',
    streakDays: 'è¿ç»­å¤©æ•°',
    hours: 'å°æ—¶',
    days: 'å¤©',
    selectLanguage: 'é€‰æ‹©è¯­è¨€',
    chinese: 'ä¸­æ–‡',
    english: 'English',
    dailyReminder: 'æ¯æ—¥æé†’',
    ttsEngine: 'éŸ³é¢‘åé¦ˆå¼•æ“',
    achievementBadges: {
      streak7: '7å¤©è¿èƒœ',
      master: 'å£°è°ƒå¤§å¸ˆ',
      vocab100: 'è¯æ±‡100',
    },
  },
  home: {
    greeting: 'àºªàº°àºšàº²àºàº”àºµ',
    todayProgress: 'ä»Šæ—¥å­¦ä¹ ç›®æ ‡å·²å®Œæˆ',
    currentCourse: 'å½“å‰è¯¾ç¨‹',
    recentMastered: 'æœ€è¿‘æŒæ¡',
    mastered: 'å·²æŒæ¡',
    reviewDue: 'å¾…å¤ä¹ å†…å®¹',
    streak: 'è¿ç»­æ‰“å¡',
    hoursThisWeek: 'æœ¬å‘¨å°æ—¶æ•°',
  },
  courses: {
    title: 'é€‰æ‹©ä¸€æœ¬å§å°‘å¹´',
    subtitle: 'å¼€å¯ä½ çš„æ³°è¯­å­¦ä¹ ä¹‹æ—…',
    searchPlaceholder: 'æœç´¢è¯¾ç¨‹...',
    startBtnText: 'å¼€å§‹å­¦ä¹ ',
  },
  learning: {
    basicDefinition: 'åŸºç¡€é‡Šä¹‰',
    exampleSentences: 'ä¾‹å¥ç¤ºä¾‹',
    usageDetails: 'ç”¨æ³•è¯¦è§£',
    grammarExamples: 'è¯­æ³•ç¤ºä¾‹:',
    diffWithChinese: 'ä¸ä¸­æ–‡å·®å¼‚:',
    commonMistakes: 'å¸¸è§é”™è¯¯:',
    similarWordsDiff: 'ç›¸ä¼¼è¯æ±‡åŒºåˆ«:',
    viewDefinition: 'æŸ¥çœ‹é‡Šä¹‰',
    nextEnter: 'ä¸‹ä¸€ä¸ª (Enter)',
    next: 'ä¸‹ä¸€ä¸ª',
    forgot: 'å¿˜è®°äº†',
    unsure: 'æ¨¡ç³Š',
    know: 'è®¤è¯†',
    skipReview: 'è·³è¿‡å¤ä¹ ',
    sessionComplete: 'å­¦ä¹ å®Œæˆï¼',
    backToHome: 'è¿”å›é¦–é¡µ',
    noNewWordsTitle: 'æ²¡æœ‰æ–°å•è¯',
    noNewWordsMessage: 'ä½ å·²ç»å­¦å®Œäº†æ‰€æœ‰æ–°å•è¯ï¼',
    endSessionTitle: 'ç»“æŸå­¦ä¹ ï¼Ÿ',
    endSessionMessage: 'ç¡®å®šè¦é€€å‡ºå—ï¼Ÿ',
    quit: 'é€€å‡º',
  },
  modules: {
    alphabet: 'å­—æ¯å­¦ä¹ ',
    word: 'å•è¯å­¦ä¹ ',
    sentence: 'å¥å­å­¦ä¹ ',
    article: 'æ–‡ç« é˜…è¯»',
  },
  moduleAccess: {
    locked: 'æ¨¡å—å·²é”å®š',
    lockedMessage: '{{module}}æ¨¡å—æš‚æœªè§£é”',
    requirement: 'è§£é”è¦æ±‚',
    prerequisite: {
      word: 'å®Œæˆå­—æ¯å­¦ä¹ å¹¶è¾¾åˆ° 95% è¿›åº¦',
      sentence: 'å®Œæˆå•è¯å­¦ä¹ å¹¶è¾¾åˆ° 80% è¿›åº¦',
      article: 'å®Œæˆå¥å­å­¦ä¹ å¹¶è¾¾åˆ° 80% è¿›åº¦',
    },
    currentProgress: 'å½“å‰è¿›åº¦',
    remainingProgress: 'è¿˜éœ€å®Œæˆ {{remaining}}%',
    progressComplete: 'è¿›åº¦å·²è¾¾æ ‡ï¼',
    goBack: 'è¿”å›',
    noProgress: 'è¯·å…ˆå¼€å§‹å­¦ä¹ ',
    unknownModule: 'æœªçŸ¥æ¨¡å—',
  },
  alphabet: {
    title: 'æ³°è¯­å­—æ¯å­¦ä¹ ',
    level: 'åŸºç¡€',
    description: 'å­¦ä¹ 44ä¸ªè¾…éŸ³å’Œ32ä¸ªå…ƒéŸ³ï¼ŒæŒæ¡æ ‡å‡†å‘éŸ³',
    continue: 'ç»§ç»­å­¦ä¹ ',
    start: 'å¼€å§‹å­¦ä¹ ',
  },
  alphabetTest: {
    title: 'å­—æ¯æµ‹è¯•',
    description: 'æµ‹è¯•ä½ çš„å­—æ¯æŒæ¡æƒ…å†µ',
    start: 'å¼€å§‹æµ‹è¯•',
    submit: 'æäº¤',
    score: 'å¾—åˆ†',
    passed: 'é€šè¿‡',
    failed: 'æœªé€šè¿‡',
    retry: 'é‡æ–°æµ‹è¯•',
    backToHome: 'è¿”å›é¦–é¡µ',
  }
};
````

## File: src/stores/userStore.ts
````typescript
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { apiClient } from '../utils/apiClient';
import { API_ENDPOINTS } from '../config/api.endpoints';
import type {
  LoginRequest,
  RegisterRequest,
  ResetPasswordRequest,
  LoginResponse,
  RegisterResponse,
  ResetPasswordResponse
} from '../entities/types/api.types';
import type { User } from '../entities/types/entities';

// Type definitions


interface UserState {
  // State
  currentUser: User | null;
  isAuthenticated: boolean;
  authToken: string | null;
  isLoading: boolean;
  error: string | null;

  // Actions
  register: (data: RegisterRequest) => Promise<boolean>;
  login: (data: LoginRequest) => Promise<boolean>;
  logout: () => void;
  requestPasswordReset: (data: ResetPasswordRequest) => Promise<boolean>;
  updateProfile: (data: { displayName?: string; avatar?: string }) => Promise<boolean>;
  setUser: (user: User, token: string) => void;
  checkAuth: () => boolean;
  clearError: () => void;
}

const validateEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

const validatePassword = (password: string): { valid: boolean; error?: string } => {
  if (password.length < 6) {
    return { valid: false, error: 'Password must be at least 6 characters' };
  }
  // å¯ä»¥æ·»åŠ æ›´å¤šè§„åˆ™
  return { valid: true };
};

// ==================== Store ====================

export const useUserStore = create<UserState>()(
  persist(
    (set, get) => ({
      // ==================== åˆå§‹çŠ¶æ€ ====================
      currentUser: null,
      isAuthenticated: false,
      authToken: null,
      isLoading: false,
      error: null,

      // ==================== æ³¨å†Œ ====================
      /**
       * Register a new user
       * 
       * Flow:
       * 1. Set loading state
       * 2. Call API
       * 3. If success: save user + token, set authenticated
       * 4. If fail: save error message
       * 
       * @param data Registration data (email, password, displayName)
       * @returns Success status
       */
      register: async (data: RegisterRequest) => {

        if (!validateEmail(data.email)) {
          set({ error: 'Invalid email format' });
          return false;
        }

        const passwordValidation = validatePassword(data.password);
        if (!passwordValidation.valid) {
          set({ error: passwordValidation.error });
          return false;
        }

        if (!data.displayName.trim()) {
          set({ error: 'Display name is required' });
          return false;
        }

        set({ isLoading: true, error: null });

        try {
          const response = await apiClient.post<RegisterResponse>(
            API_ENDPOINTS.AUTH.REGISTER,
            {
              email: data.email.toLowerCase().trim(),
              password: data.password,
              displayName: data.displayName,
            });

          if (response.success && response.data) {
            const { user, token } = response.data;

            // Save token to apiClient for future requests
            apiClient.setAuthToken(token);

            // Update store state
            set({
              currentUser: user as User,
              authToken: token,
              isAuthenticated: true,
              isLoading: false,
              error: null,
            });

            // ğŸ” è°ƒè¯•æ—¥å¿—ï¼šæ³¨å†ŒæˆåŠŸåæ‰“å° userId
            console.log('âœ… [æ³¨å†ŒæˆåŠŸ] currentUser.userId:', user.userId);

            return true;

          } else {
            set({
              error: response.error || 'æ³¨å†Œå¤±è´¥',
              isLoading: false,
            });
            return false;
          }
        } catch (error: any) {
          set({
            error: error.message || 'æ³¨å†Œå¤±è´¥',
            isLoading: false,
          });
          return false;
        }
      },

      // ==================== ç™»å½• ====================
      /**
       * Authenticate user
       * 
       * Flow:
       * 1. Set loading state
       * 2. Call API
       * 3. If success: save user + token, set authenticated
       * 4. If fail: save error message
       * 
       * @param email User email
       * @param password User password
       * @returns Success status
       */
      login: async (data: LoginRequest) => {

        if (!validateEmail(data.email)) {
          set({ error: 'Invalid email format' });
          return false;
        }

        const passwordValidation = validatePassword(data.password);
        if (!passwordValidation.valid) {
          set({ error: passwordValidation.error });
          return false;
        }

        set({ isLoading: true, error: null });

        try {
          const response = await apiClient.post<LoginResponse>(API_ENDPOINTS.AUTH.LOGIN, {
            email: data.email.toLowerCase().trim(),
            password: data.password,
          });

          if (response.success && response.data) {
            const { user, token } = response.data;

            // Save token to apiClient for future requests
            apiClient.setAuthToken(token);

            // Update store state
            set({
              currentUser: user as User,
              authToken: token,
              isAuthenticated: true,
              isLoading: false,
              error: null,
            });

            // ğŸ” è°ƒè¯•æ—¥å¿—ï¼šç™»å½•æˆåŠŸåæ‰“å° userId
            console.log('âœ… [ç™»å½•æˆåŠŸ] currentUser.userId:', user.userId);

            return true;
          } else {
            set({
              error: response.error || 'Login failed',
              isLoading: false,
            });
            return false;
          }
        } catch (error: any) {
          set({
            error: error.message || 'Login failed',
            isLoading: false,
          });
          return false;
        }
      },

      // ==================== ç™»å‡º ====================
      /**
       * Logout current user
       * 
       * Flow:
       * 1. Clear apiClient token
       * 2. Clear store state
       * 3. Clear AsyncStorage (via persist middleware)
       */
      logout: () => {
        // Clear token from apiClient
        apiClient.setAuthToken(null);

        // Clear store state
        set({
          currentUser: null,
          authToken: null,
          isAuthenticated: false,
          error: null,
        });
      },

      // ==================== é‡ç½®å¯†ç  ====================
      /**
       * Request password reset email
       * 
       * @param email User email
       * @returns Success status
       */
      requestPasswordReset: async (data: ResetPasswordRequest) => {
        if (!validateEmail(data.email)) {
          set({ error: 'Invalid email format', isLoading: false });
          return false;
        }

        set({ isLoading: true, error: null });

        try {
          const response = await apiClient.post<ResetPasswordResponse>(
            API_ENDPOINTS.AUTH.RESET_PASSWORD,
            { email: data.email.toLowerCase().trim() }
          );

          if (response.success) {
            set({ isLoading: false, error: null });
            return true;
          } else {
            set({
              error: response.error || 'Password reset failed',
              isLoading: false,
            });
            return false;
          }
        } catch (error: any) {
          set({
            error: error.message || 'Password reset failed',
            isLoading: false,
          });
          return false;
        }
      },

      // ==================== æ›´æ–°ä¸ªäººèµ„æ–™ ====================
      /**
       * Update user profile
       * 
       * @param data Profile data to update
       * @returns Success status
       */
      updateProfile: async (data: { displayName?: string; avatar?: string }) => {
        const currentUser = get().currentUser;
        if (!currentUser) {
          set({ error: 'No user logged in' });
          return false;
        }

        set({ isLoading: true, error: null });

        try {
          const response = await apiClient.put<{ user: User }>(
            API_ENDPOINTS.AUTH.UPDATE_PROFILE,
            {
              userId: currentUser.userId,
              ...data,
            });

          if (response.success && response.data) {
            set({
              currentUser: {
                ...currentUser,
                ...(data.displayName && { displayName: data.displayName }),
                ...(data.avatar && { avatar: data.avatar }),
              },
              isLoading: false,
              error: null,
            });
            return true;
          } else {
            set({
              error: response.error || 'Profile update failed',
              isLoading: false,
            });
            return false;
          }
        } catch (error: any) {
          set({
            error: error.message || 'Profile update failed',
            isLoading: false,
          });
          return false;
        }
      },

      // ===== Set User (Direct) =====
      /**
       * Directly set user and token
       * Used for: OAuth flows, token refresh
       * 
       * @param user User object
       * @param token Auth token
       */
      setUser: (user: User, token: string) => {
        apiClient.setAuthToken(token);

        set({
          currentUser: user,
          authToken: token,
          isAuthenticated: true,
          error: null,
        });
      },

      // ===== Check Auth Status =====
      /**
       * Check if user is authenticated
       * 
       * @returns Authentication status
       */
      checkAuth: () => {
        const state = get();
        return state.isAuthenticated && state.authToken !== null;
      },

      // ===== Clear Error =====
      /**
       * Clear error message
       */
      clearError: () => {
        set({ error: null });
      },
    }),
    {
      name: 'user-storage', // AsyncStorage key
      storage: createJSONStorage(() => AsyncStorage),

      // Restore auth token to apiClient on rehydration
      onRehydrateStorage: () => {
        return (state) => {
          if (state?.authToken) {
            apiClient.setAuthToken(state.authToken);
          }
        };
      },
    }
  )
);
````

## File: app/alphabet/[lessonId].tsx
````typescript
// app/alphabet/lesson/[lessonId].tsx

import { useLocalSearchParams, useRouter } from 'expo-router';
import React, { useEffect, useMemo, useState } from 'react';
import { View, Text, ActivityIndicator, StyleSheet, Pressable } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { ArrowLeft, Lock } from 'lucide-react-native'; // Assuming Lock icon exists or use fallback

import { useAlphabetLearningEngine } from '@/src/hooks/useAlphabetLearningEngine';
import { AlphabetLearningEngineView } from '@/src/components/learning/alphabet/AlphabetLearningEngineView';
import { useModuleAccessStore } from '@/src/stores/moduleAccessStore';
import { getLessonMetadata, getAllLessons } from '@/src/config/alphabet/lessonMetadata.config';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';

export default function AlphabetLessonFlow() {
  const { lessonId } = useLocalSearchParams<{ lessonId: string }>();
  const router = useRouter();

  // Access Control & Progress
  const { userProgress, getUserProgress } = useModuleAccessStore();
  const [isCheckingAccess, setIsCheckingAccess] = useState(true);

  useEffect(() => {
    let mounted = true;
    (async () => {
      await getUserProgress();
      if (mounted) setIsCheckingAccess(false);
    })();
    return () => { mounted = false; };
  }, [getUserProgress]);

  // Unlock Logic
  const isUnlocked = useMemo(() => {
    if (!lessonId) return false;
    // Always load progress before deciding (unless lesson1, but let's be consistent)
    if (isCheckingAccess && !userProgress) return false;

    const currentMetadata = getLessonMetadata(lessonId);
    if (!currentMetadata) return false; // Invalid lesson ID

    // Rule 1: Lesson 1 always unlocked
    if (currentMetadata.order === 1) return true;

    // Rule 2: Lesson N requires Lesson N-1 completed
    const allLessons = getAllLessons();
    const prevLesson = allLessons.find(l => l.order === currentMetadata.order - 1);

    // Safety: If no prev lesson found (logic error?), default to locked or unlocked? 
    // Strict default: Locked.
    if (!prevLesson) return false;

    const completed = userProgress?.completedAlphabetLessons ?? [];
    return completed.includes(prevLesson.lessonId);
  }, [lessonId, userProgress, isCheckingAccess]);


  // Engine Hook - Only initialize if unlocked to prevent side effects
  // We conditionally call the hook? No, hooks must be unconditional.
  // But we can prevent it from doing work by passing a null or invalid ID if locked,
  // OR we rely on the component returning early before `useAlphabetLearningEngine` has side effects that matter.
  // Actually, `useAlphabetLearningEngine` has `initializeSession` in `useEffect`. 
  // We MUST prevent that useEffect if locked.
  // Easy way: pass `null` or `undefined` as lessonId to the hook if locked, but hook expects string.
  // Better way: The hook takes `lessonId`. If we pass a dummy or keep it as is, it's fine 
  // AS LONG AS we don't render the view that triggers start.
  // BUT the hook starts auto-initialization. 
  // Let's modify the hook call to key off `isUnlocked`.

  // Wait, I cannot conditionally call a hook. I must call it.
  // I will pass `isUnlocked ? lessonId : ''` to the hook? 
  // If I access `app/alphabet/lessonX`, lessonId is 'lessonX'.
  // If I early return NOT in the component body but RENDER a different component, the hook still runs.

  // Strict requirement: "ç‚¹å‡»ä¸å¾—è§¦å‘å¯¼èˆª / åˆå§‹åŒ– session" => "ä¸å…è®¸è§¦å‘å­¦ä¹ å¼•æ“".
  // If the hook runs `initializeSession`, it touches the backend.
  // I should check `isUnlocked` BEFORE calling the hook? No, I can't.

  // Solution: I will split the component? 
  // Or I can just verify that `useAlphabetLearningEngine` doesn't explode if I don't use the result?
  // It DOES `initializeSession`.

  // Best approach: A Guard Wrapper Component.
  // The default export will be the Guard. 
  // If unlocked, it renders the Engine Component (which calls the hook).

  if (isCheckingAccess) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: Colors.paper }}>
        <ActivityIndicator size="large" color={Colors.thaiGold} />
      </View>
    );
  }

  if (!isUnlocked) {
    return (
      <SafeAreaView style={styles.lockedContainer}>
        <ThaiPatternBackground opacity={0.1} />
        <View style={styles.lockedContent}>
          <Lock size={64} color={Colors.taupe} style={{ marginBottom: 24 }} />
          <Text style={styles.lockedTitle}>Lesson Locked</Text>
          <Text style={styles.lockedText}>
            Please complete the previous lesson to unlock this content.
          </Text>
          <Pressable onPress={() => router.replace('/alphabet')} style={styles.backButton}>
            <ArrowLeft size={20} color={Colors.white} />
            <Text style={styles.backButtonText}>Back to Courses</Text>
          </Pressable>
        </View>
      </SafeAreaView>
    );
  }

  // Only render the Engine (and trigger the hook) if verified unlocked
  return <AuthenticatedLessonFlow lessonId={lessonId!} />;
}

// Inner component that actually invokes the engine hook
function AuthenticatedLessonFlow({ lessonId }: { lessonId: string }) {
  const router = useRouter();

  const {
    phase,
    initialized,
    currentRound,
    roundEvaluation,
    currentItem,
    currentQuestionType,
    letterPool,
    onAnswer,
    onNext,
    phonicsRule,
    showPhonicsRuleCard,
    onCompletePhonicsRule,
    pendingRecoverySession,
    resolveRecovery,
    onFinishRound,
    onSkipYesterdayReview,
  } = useAlphabetLearningEngine(lessonId);

  const handleBack = async () => {
    // ğŸ”¥ åœ¨ç¦»å¼€é¡µé¢å‰æ¸…é™¤ session
    await onFinishRound();
    router.back();
  };

  return (
    <AlphabetLearningEngineView
      phase={phase}
      initialized={initialized}
      currentRound={currentRound}
      roundEvaluation={roundEvaluation}
      currentItem={currentItem}
      currentQuestionType={currentQuestionType}
      letterPool={letterPool}
      onAnswer={onAnswer}
      onNext={onNext}
      onBack={handleBack}
      phonicsRule={phonicsRule}
      showPhonicsRuleCard={showPhonicsRuleCard}
      onCompletePhonicsRule={onCompletePhonicsRule}
      pendingRecoverySession={pendingRecoverySession}
      resolveRecovery={resolveRecovery}
      onSkipYesterdayReview={onSkipYesterdayReview}
    />
  );
}

const styles = StyleSheet.create({
  lockedContainer: {
    flex: 1,
    backgroundColor: Colors.paper,
    justifyContent: 'center',
    alignItems: 'center',
  },
  lockedContent: {
    alignItems: 'center',
    padding: 32,
    backgroundColor: Colors.white,
    borderRadius: 24,
    width: '80%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 12,
    elevation: 8,
  },
  lockedTitle: {
    fontFamily: Typography.playfairBold,
    fontSize: 24,
    color: Colors.ink,
    marginBottom: 12,
  },
  lockedText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 16,
    color: Colors.taupe,
    textAlign: 'center',
    marginBottom: 32,
    lineHeight: 24,
  },
  backButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.thaiGold,
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 30,
    gap: 8,
  },
  backButtonText: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 16,
    color: Colors.white,
  },
});
````

## File: src/stores/moduleAccessStore.ts
````typescript
// src/stores/moduleAccessStore.ts

/**
 * æ¨¡å—è®¿é—®æ§åˆ¶ Store
 * 
 * åŠŸèƒ½ï¼š
 * 1. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æŸä¸ªæ¨¡å—
 * 2. ç¼“å­˜è®¿é—®æƒé™ç»“æœ
 * 3. æä¾›å…¨å±€è¿›åº¦æ•°æ®
 */

import { create } from 'zustand';
import { callCloudFunction } from '@/src/utils/apiClient';
import { API_ENDPOINTS } from '@/src/config/api.endpoints';
import { useUserStore } from './userStore';
import { LESSON_METADATA } from '@/src/config/alphabet/lessonMetadata.config';
import AsyncStorage from '@react-native-async-storage/async-storage';


const getCompletedLessonsStorageKey = (userId: string): string =>
    `@alphabet_completed_lessons_${userId}`;



// ==================== ç±»å‹å®šä¹‰ ====================

/**
 * æ¨¡å—ç±»å‹
 * 
 * æ³¨æ„ï¼š
 * - ä¸åç«¯ memory-engine.checkModuleAccess ä¿æŒä¸€è‡´ï¼Œå­—æ¯æ¨¡å—ä½¿ç”¨ 'letter'
 */
export type ModuleType = 'letter' | 'word' | 'sentence' | 'article';

/**
 * ç”¨æˆ·è¿›åº¦æ•°æ®
 */
export interface UserProgress {
    // å­—æ¯å­¦ä¹ è¿›åº¦
    letterProgress: number;           // 0-1 (åç«¯å­˜å‚¨ä¸ºæ¯”ä¾‹å€¼)
    letterCompleted: boolean;         // Added: Whether letter learning is completed
    letterMasteredCount: number;      // å·²æŒæ¡å­—æ¯æ•°
    letterTotalCount: number;         // æ€»å­—æ¯æ•°

    // å•è¯å­¦ä¹ è¿›åº¦
    wordProgress: number;             // 0-100
    wordMasteredCount: number;        // å·²æŒæ¡å•è¯æ•°
    wordTotalCount: number;           // æ€»å•è¯æ•°

    // å¥å­å­¦ä¹ è¿›åº¦
    sentenceProgress: number;         // 0-100
    sentenceMasteredCount: number;    // å·²æŒæ¡å¥å­æ•°
    sentenceTotalCount: number;       // æ€»å¥å­æ•°

    // æ–‡ç« å­¦ä¹ è¿›åº¦
    articleProgress: number;          // 0-100
    articleMasteredCount: number;     // å·²æŒæ¡æ–‡ç« æ•°
    articleTotalCount: number;        // æ€»æ–‡ç« æ•°

    // è§£é”çŠ¶æ€
    wordUnlocked: boolean;            // å•è¯æ¨¡å—æ˜¯å¦è§£é”
    sentenceUnlocked: boolean;        // å¥å­æ¨¡å—æ˜¯å¦è§£é”
    articleUnlocked: boolean;         // æ–‡ç« æ¨¡å—æ˜¯å¦è§£é”

    /**
     * å­—æ¯è¯¾ç¨‹å®Œæˆæƒ…å†µï¼ˆä»…å‰ç«¯ä½¿ç”¨ï¼‰
     * ä¾‹å¦‚: ['lesson1','lesson2',...]
     */
    completedAlphabetLessons?: string[];

    // è®¾ç½®
    dailyLimit?: number;              // æ¯æ—¥å­¦ä¹ æ•°é‡è®¾ç½®
}

/**
 * è®¿é—®æ£€æŸ¥å“åº”
 */
interface CheckAccessResponse {
    allowed: boolean;
    reason?: string;
    requiredProgress?: number;
    currentProgress?: number;
}

/**
 * ç”¨æˆ·è¿›åº¦å“åº”ï¼ˆåç«¯è¿”å›ï¼‰
 */
interface UserProgressResponse {
    progress: UserProgress & {
        completedLessons?: string[];  // ğŸ”¥ åç«¯è¿”å›å­—æ®µï¼ˆuser_alphabet_progress.completedLessonsï¼‰
    };
}

// ==================== Store å®šä¹‰ ====================

interface ModuleAccessStore {
    // ===== çŠ¶æ€ =====
    userProgress: UserProgress | null;
    accessCache: Map<ModuleType, boolean>;
    isLoading: boolean;
    error: string | null;

    // ===== æ–¹æ³• =====
    checkAccess: (moduleType: ModuleType) => Promise<boolean>;
    checkAccessLocally: (moduleType: ModuleType) => boolean;
    getUserProgress: () => Promise<void>;
    clearCache: () => void;
    setError: (error: string | null) => void;
    setDailyLimit: (moduleType: ModuleType, limit: number) => void;
    /**
     * æ ‡è®°æŸä¸ªå­—æ¯è¯¾ç¨‹å·²å®Œæˆï¼ˆä»…ç”¨äºå­—æ¯æ¨¡å—è§£é”é“¾è·¯ï¼‰
     */
    markAlphabetLessonCompleted: (lessonId: string) => void;
}

// ==================== é»˜è®¤è¿›åº¦æ•°æ® ====================

const defaultProgress: UserProgress = {
    letterProgress: 0,
    letterCompleted: false,
    letterMasteredCount: 0,
    letterTotalCount: 44,
    wordProgress: 0,
    wordMasteredCount: 0,
    wordTotalCount: 0,
    sentenceProgress: 0,
    sentenceMasteredCount: 0,
    sentenceTotalCount: 0,
    articleProgress: 0,
    articleMasteredCount: 0,
    articleTotalCount: 0,
    wordUnlocked: false,
    sentenceUnlocked: false,
    articleUnlocked: false,
};

// ==================== Store å®ç° ====================

export const useModuleAccessStore = create<ModuleAccessStore>()((set, get) => ({
    // ===== åˆå§‹çŠ¶æ€ =====
    userProgress: null,
    accessCache: new Map<ModuleType, boolean>(),
    isLoading: false,
    error: null,

    // ===== æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™ =====
    /**
     * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æŸä¸ªæ¨¡å—
     * 
     * @param moduleType æ¨¡å—ç±»å‹
     * @returns æ˜¯å¦æœ‰æƒé™è®¿é—®
     */
    checkAccess: async (moduleType: ModuleType): Promise<boolean> => {
        const { accessCache } = get();
        const userId = useUserStore.getState().currentUser?.userId;

        if (!userId) {
            console.warn('âš ï¸ ç”¨æˆ·æœªç™»å½•ï¼Œæ— æ³•æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™');
            return false;
        }

        // 1. æ£€æŸ¥ç¼“å­˜
        if (accessCache.has(moduleType)) {
            const cachedResult = accessCache.get(moduleType);
            console.log(`âœ… ä»ç¼“å­˜è·å– ${moduleType} è®¿é—®æƒé™:`, cachedResult);
            return cachedResult!;
        }

        try {
            set({ isLoading: true, error: null });

            // 2. è°ƒç”¨äº‘å‡½æ•°æ£€æŸ¥æƒé™
            const result = await callCloudFunction<CheckAccessResponse>(
                'checkModuleAccess',
                {
                    userId,
                    moduleType,
                },
                {
                    endpoint: API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase,
                }
            );

            if (result.success && result.data) {
                const allowed = result.data.allowed;

                // 3. ç¼“å­˜ç»“æœ
                const newCache = new Map(accessCache);
                newCache.set(moduleType, allowed);
                set({ accessCache: newCache, isLoading: false });

                console.log(`âœ… ${moduleType} è®¿é—®æƒé™æ£€æŸ¥å®Œæˆ:`, allowed);

                // å¦‚æœä¸å…è®¸ï¼Œè®°å½•åŸå› 
                if (!allowed && result.data.reason) {
                    console.log(`ğŸ“Œ æ‹’ç»åŸå› : ${result.data.reason}`);
                }

                return allowed;
            } else {
                // è¯·æ±‚å¤±è´¥ï¼Œé™çº§å¤„ç†
                console.warn('âš ï¸ äº‘å‡½æ•°è°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°é€»è¾‘åˆ¤æ–­');
                const localAllowed = get().checkAccessLocally(moduleType);

                // ç¼“å­˜æœ¬åœ°åˆ¤æ–­ç»“æœ
                const newCache = new Map(accessCache);
                newCache.set(moduleType, localAllowed);
                set({ accessCache: newCache, isLoading: false });

                return localAllowed;
            }
        } catch (error: any) {
            console.error('âŒ checkAccess error:', error);
            set({ error: error.message || 'æ£€æŸ¥æƒé™å¤±è´¥', isLoading: false });

            // é™çº§åˆ°æœ¬åœ°é€»è¾‘
            const localAllowed = get().checkAccessLocally(moduleType);

            // ç¼“å­˜æœ¬åœ°åˆ¤æ–­ç»“æœ
            const newCache = new Map(get().accessCache);
            newCache.set(moduleType, localAllowed);
            set({ accessCache: newCache });

            return localAllowed;
        }
    },

    // ===== æœ¬åœ°æƒé™æ£€æŸ¥é€»è¾‘ï¼ˆé™çº§æ–¹æ¡ˆï¼‰=====
    /**
     * æœ¬åœ°æƒé™æ£€æŸ¥é€»è¾‘ï¼ˆé™çº§æ–¹æ¡ˆï¼‰
     * 
     * @param moduleType æ¨¡å—ç±»å‹
     * @returns æ˜¯å¦æœ‰æƒé™è®¿é—®
     */
    checkAccessLocally: (moduleType: ModuleType): boolean => {
        const { userProgress } = get();

        if (!userProgress) {
            // å¦‚æœæ²¡æœ‰è¿›åº¦æ•°æ®ï¼Œå…è®¸è®¿é—®å­—æ¯æ¨¡å—ï¼Œå…¶ä»–æ¨¡å—ä¸å…è®¸
            return moduleType === 'letter';
        }

        // ä¸åç«¯ memory-engine.checkModuleAccess çš„æ„å›¾ä¿æŒä¸€è‡´ï¼š
        // - å­—æ¯æ¨¡å—å§‹ç»ˆå¯è®¿é—®
        // - åªè¦ letterCompleted ä¸º trueï¼Œæˆ– letterProgress â‰¥ 0.8ï¼Œæ‰€æœ‰éå­—æ¯æ¨¡å—ç»Ÿä¸€è§£é”
        if (moduleType === 'letter') {
            return true;
        }

        const finishedByTest = !!userProgress.letterCompleted;
        const finishedByProgress = (userProgress.letterProgress ?? 0) >= 0.8;

        return finishedByTest || finishedByProgress;
    },

    // ===== è·å–ç”¨æˆ·è¿›åº¦ =====
    // ===== è·å–ç”¨æˆ·è¿›åº¦ =====
    /**
     * ä»åç«¯è·å–ç”¨æˆ·è¿›åº¦æ•°æ®
     */
    getUserProgress: async (): Promise<void> => {
        const userId = useUserStore.getState().currentUser?.userId;

        if (!userId) {
            console.warn('âš ï¸ ç”¨æˆ·æœªç™»å½•ï¼Œæ— æ³•è·å–è¿›åº¦æ•°æ®');
            set({ userProgress: defaultProgress });
            return;
        }

        try {
            const oldKey = '@alphabet_completed_lessons';
            const oldData = await AsyncStorage.getItem(oldKey);
            if (oldData) {
                await AsyncStorage.removeItem(oldKey);
                console.log('Old key has been delete.');
            }
        } catch (e) {
            console.warn('åˆ é™¤æ—§keyå¤±è´¥ï¼š', e)
        }

        set({ isLoading: true, error: null });

        // Helper to try fetch
        const fetchProgress = async (endpoint: string) => {
            return await callCloudFunction<UserProgressResponse>(
                'getUserProgress',
                { userId, entityType: 'letter' },  // ğŸ”¥ æ·»åŠ  entityType å‚æ•°
                { endpoint }
            );
        };

        try {
            // 1. Try Primary Endpoint (memory-engine)
            let result = await fetchProgress(API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase);

            // 2. Fallback to Legacy Endpoint (learn-vocab) if failed
            if (!result.success) {
                console.warn(`âš ï¸ Primary endpoint failed (${result.error}), trying fallback...`);
                result = await fetchProgress(API_ENDPOINTS.MODULE.CHECK_ACCESS.cloudbase);
            }

            if (result.success && result.data) {
                // ğŸ”¥ Step 3: ä»¥åç«¯æ•°æ®ä¸ºå‡†ï¼Œæœ¬åœ°ä»…ä½œç¼“å­˜
                const remoteCompleted = result.data.progress.completedLessons || [];

                // ğŸ”¥ æ›´æ–°æœ¬åœ°ç¼“å­˜ï¼ˆç”¨äºç¦»çº¿æ—¶åŠ é€Ÿï¼‰
                const storageKey = getCompletedLessonsStorageKey(userId);
                AsyncStorage.setItem(storageKey, JSON.stringify(remoteCompleted)).catch(err => {
                    console.warn('âš ï¸ Failed to cache completed lessons:', err);
                });

                set({
                    userProgress: {
                        ...result.data.progress,
                        completedAlphabetLessons: remoteCompleted  // ğŸ”¥ å­—æ®µæ˜ å°„
                    },
                    isLoading: false,
                });
                console.log('âœ… ç”¨æˆ·è¿›åº¦æ•°æ®å·²æ›´æ–° (Backend-first):', {
                    ...result.data.progress,
                    completedAlphabetLessons: remoteCompleted
                });
            } else {
                // ğŸ”¥ åç«¯å¤±è´¥æ—¶ï¼Œå°è¯•ä»æœ¬åœ°ç¼“å­˜åŠ è½½ï¼ˆé™çº§æ–¹æ¡ˆï¼‰
                console.warn('âš ï¸ è·å–ç”¨æˆ·è¿›åº¦å¤±è´¥ (Primary & Fallback)ï¼Œå°è¯•ä»æœ¬åœ°ç¼“å­˜åŠ è½½');
                try {
                    const storageKey = getCompletedLessonsStorageKey(userId);
                    const cached = await AsyncStorage.getItem(storageKey);
                    const cachedCompleted = cached ? JSON.parse(cached) : [];

                    set({
                        userProgress: {
                            ...defaultProgress,
                            completedAlphabetLessons: cachedCompleted
                        },
                        isLoading: false,
                        error: result.error || 'Failed to fetch progress'
                    });
                    console.log('âš ï¸ ä½¿ç”¨æœ¬åœ°ç¼“å­˜æ•°æ®:', cachedCompleted);
                } catch (cacheError) {
                    set({
                        userProgress: defaultProgress,
                        isLoading: false,
                        error: result.error || 'Failed to fetch progress'
                    });
                }
            }
        } catch (error: any) {
            console.error('âŒ getUserProgress error:', error);

            // ğŸ”¥ å¼‚å¸¸æ—¶ï¼Œå°è¯•ä»æœ¬åœ°ç¼“å­˜åŠ è½½ï¼ˆé™çº§æ–¹æ¡ˆï¼‰
            try {
                const storageKey = getCompletedLessonsStorageKey(userId);
                const cached = await AsyncStorage.getItem(storageKey);
                const cachedCompleted = cached ? JSON.parse(cached) : [];

                set({
                    error: error.message || 'è·å–è¿›åº¦å¤±è´¥',
                    userProgress: {
                        ...defaultProgress,
                        completedAlphabetLessons: cachedCompleted
                    },
                    isLoading: false,
                });
                console.log('âš ï¸ å¼‚å¸¸æ—¶ä½¿ç”¨æœ¬åœ°ç¼“å­˜:', cachedCompleted);
            } catch (cacheError) {
                set({
                    error: error.message || 'è·å–è¿›åº¦å¤±è´¥',
                    userProgress: defaultProgress,
                    isLoading: false,
                });
            }
        }
    },

    // ===== æ¸…é™¤ç¼“å­˜ =====
    /**
     * æ¸…é™¤è®¿é—®æƒé™ç¼“å­˜
     * ç”¨äºï¼šç”¨æˆ·å®Œæˆå­¦ä¹ åéœ€è¦é‡æ–°æ£€æŸ¥æƒé™
     */
    clearCache: (): void => {
        set({ accessCache: new Map<ModuleType, boolean>() });
        console.log('ğŸ—‘ï¸ è®¿é—®æƒé™ç¼“å­˜å·²æ¸…é™¤');
    },

    // ===== è®¾ç½®é”™è¯¯ =====
    setError: (error: string | null): void => {
        set({ error });
    },

    // ===== æ›´æ–°æ¯æ—¥å­¦ä¹ é‡ï¼ˆå‰ç«¯ç¼“å­˜ï¼‰=====
    setDailyLimit: (moduleType: ModuleType, limit: number) => {
        set((state) => ({
            userProgress: {
                ...(state.userProgress || { ...defaultProgress }),
                dailyLimit: limit,
            },
        }));

        console.log(`ğŸ“Œ å·²æ›´æ–° ${moduleType} dailyLimit ä¸º ${limit}`);
    },

    // ===== æ ‡è®°å­—æ¯è¯¾ç¨‹å®Œæˆï¼ˆå‰ç«¯æœ¬åœ°ï¼‰=====
    markAlphabetLessonCompleted: (lessonId: string) => {
        const userId = useUserStore.getState().currentUser?.userId;
        if (!userId) {
            console.warn('âš ï¸ ç”¨æˆ·æœªç™»å½•ï¼Œæ— æ³•æ ‡è®°è¯¾ç¨‹å®Œæˆ');
            return;
        }

        const totalLessons = Object.keys(LESSON_METADATA).length;
        const coreLessons = 6; // å®Œæˆå‰ 6 è¯¾è§†ä¸ºâ€œæ ¸å¿ƒå­—æ¯å·²å­¦å®Œâ€

        set((state) => {
            const prev = state.userProgress || { ...defaultProgress };

            const prevCompleted = new Set(prev.completedAlphabetLessons ?? []);
            prevCompleted.add(lessonId);
            const completedAlphabetLessons = Array.from(prevCompleted);

            const completedCount = completedAlphabetLessons.length;
            const allLessonsDone = completedCount >= totalLessons;

            // è¿›åº¦ï¼š
            // - å®Œæˆ lesson1-4 è§†ä¸º 0.8
            // - å®Œæˆ lesson1-6 è§†ä¸º 0.9ï¼ˆæ ¸å¿ƒå­—æ¯å…¨éƒ¨å®Œæˆï¼‰
            // - å®Œæˆå…¨éƒ¨ 7 è¯¾è§†ä¸º 1.0ï¼ˆå«ç½•ç”¨/å¤ä½“å­—æ¯ï¼‰
            let nextLetterProgress = prev.letterProgress;
            if (completedCount >= 4 && nextLetterProgress < 0.8) {
                nextLetterProgress = 0.8;
            }
            if (completedCount >= coreLessons && nextLetterProgress < 0.9) {
                nextLetterProgress = 0.9;
            }
            if (completedCount >= totalLessons && nextLetterProgress < 1) {
                nextLetterProgress = 1;
            }

            // å®Œæˆå‰ 6 è¯¾å³è§†ä¸ºæ ¸å¿ƒå­—æ¯å­¦ä¹ å®Œæˆï¼Œ
            // lesson7 ä½œä¸ºè¡¥å……è¯¾ç¨‹ä¸å½±å“å…¶ä»–æ¨¡å—è§£é”
            const coreLessonsDone = completedCount >= coreLessons;
            const nextLetterCompleted =
                prev.letterCompleted || coreLessonsDone;

            const updated: UserProgress = {
                ...prev,
                completedAlphabetLessons,
                letterCompleted: nextLetterCompleted,
                letterProgress: nextLetterProgress,
            };

            // ğŸ”¥ Persist to AsyncStorage (Fire and forget)
            const storageKey = getCompletedLessonsStorageKey(userId);
            AsyncStorage.setItem(storageKey, JSON.stringify(completedAlphabetLessons)).catch(err => {
                console.error('âŒ Failed to persist completed alphabet lessons:', err);
            });

            return {
                userProgress: updated,
                accessCache: allLessonsDone
                    ? new Map<ModuleType, boolean>()
                    : state.accessCache,
            };
        });

        console.log(`âœ… å­—æ¯è¯¾ç¨‹å·²å®Œæˆ: ${lessonId}`);
    },
}));
````

## File: app/(tabs)/index.tsx
````typescript
// app/(tabs)/index.tsx
import React, { useState, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { ScrollView, View, Text, Pressable, StyleSheet } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { Play, TrendingUp, Clock, Award, Star, Wrench } from 'lucide-react-native';
import { BlurView } from 'expo-blur';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { FloatingBubbles } from '@/src/components/common/FloatingBubbles';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { ReviewItem } from '@/src/entities/types/entities';
import { useUserStore } from '@/src/stores/userStore';
import { useModuleAccessStore } from '@/src/stores/moduleAccessStore';

const MOCK_REVIEWS: ReviewItem[] = [
  { id: '1', char: 'à¸‚', phonetic: 'Khor Khai', type: 'Review', dueIn: 'Today' },
  { id: '2', char: 'à¸„', phonetic: 'Khor Khwai', type: 'Hard', dueIn: 'Today' },
  { id: '3', char: 'à¸‡', phonetic: 'Ngor Ngu', type: 'New', dueIn: 'Today' },
  { id: '4', char: 'à¸ˆ', phonetic: 'Jor Jan', type: 'Review', dueIn: 'Today' },
];

export default function HomeScreen() {
  const { t } = useTranslation();
  const [reviews, setReviews] = useState<ReviewItem[]>([]);
  const router = useRouter();

  // Stores
  const { currentUser } = useUserStore();
  const { userProgress } = useModuleAccessStore();

  useEffect(() => {
    setTimeout(() => setReviews(MOCK_REVIEWS), 800);
  }, []);

  const handleBubbleClick = () => {
    router.push('/review-modal');
    setTimeout(() => setReviews([]), 500);
  };

  // Helper to determine current course based on progress
  const getCurrentCourse = () => {
    if (!userProgress) {
      return {
        name: t('modules.alphabet'),
        level: t('alphabet.level'),
        progress: 0,
        route: '/learning' as const,
        module: 'letter' as const,
        thaiText: 'à¸à¸‚à¸ƒà¸„',
        translation: t('alphabet.description'),
      };
    }

    const { letterProgress, wordProgress, sentenceProgress } = userProgress;

    // 1. Alphabet Phase
    // åç«¯ letterProgress ä¸º 0-1ï¼Œè¿™é‡Œç”¨ 80% ä½œä¸ºé˜¶æ®µåˆ‡æ¢é˜ˆå€¼
    if (letterProgress < 0.8) {
      return {
        name: t('modules.alphabet'),
        level: t('alphabet.level'),
        progress: Math.round(letterProgress * 100),
        route: '/learning' as const,
        module: 'letter' as const,
        thaiText: 'à¸ à¸‚ à¸ƒ à¸„',
        translation: t('alphabet.description'),
      };
    }

    // 2. Vocabulary Phase
    if (wordProgress < 80) {
      return {
        name: t('modules.word'),
        level: 'Intermediate 1', // TODO: Add to i18n
        progress: wordProgress,
        route: '/learning' as const, // Points to app/learning/index.tsx
        module: 'word' as const,
        thaiText: 'à¸„à¸³à¸¨à¸±à¸à¸—à¹Œ',
        translation: 'Expand your vocabulary',
      };
    }

    // 3. Sentence Phase
    if (sentenceProgress < 80) {
      return {
        name: t('modules.sentence'),
        level: 'Intermediate 2',
        progress: sentenceProgress,
        route: '/learning' as const, // Placeholder
        module: 'sentence' as const,
        thaiText: 'à¸›à¸£à¸°à¹‚à¸¢à¸„',
        translation: 'Master sentence structures',
      };
    }

    // 4. Article Phase
    return {
      name: t('modules.article'),
      level: 'Advanced',
      progress: userProgress.articleProgress || 0,
      route: '/learning' as const, // Placeholder
      module: 'article' as const,
      thaiText: 'à¸šà¸—à¸„à¸§à¸²à¸¡',
      translation: 'Read authentic articles',
    };
  };

  const currentCourse = getCurrentCourse();
  const displayName = currentUser?.displayName || 'Student';

  return (
    <SafeAreaView edges={['top']} style={styles.safeArea}>
      <ThaiPatternBackground opacity={0.15} />

      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        {/* Header */}
        <View style={styles.header}>
          <BlurView intensity={80} tint="light" style={StyleSheet.absoluteFill} />

          <View style={styles.headerContent}>
            <View>
              <View style={styles.greetingContainer}>
                <Text style={styles.greetingText}>àºªàº°àºšàº²àºàº”àºµ, {displayName}</Text>
                <Text style={styles.greetingDot}>.</Text>
              </View>
              <Text style={styles.subtitleText}>
                {t('home.todayProgress')} {currentCourse.progress}%
              </Text>
            </View>

            <View style={styles.awardBadge}>
              {/* å³ä¸Šè§’è£èª‰å›¾æ ‡ */}
              <Award size={18} color={Colors.ink} />
            </View>
          </View>
        </View>

        <View style={styles.contentContainer}>
          {/* Floating Bubbles */}
          <FloatingBubbles reviews={reviews} onOpenReview={handleBubbleClick} />

          {/* Hero Progress Card */}
          <View>
            {(() => {
              // ğŸ”’ Lock Check for Hero Card
              const { checkAccessLocally } = useModuleAccessStore.getState();
              const isHeroLocked = currentCourse.module !== 'letter' && !checkAccessLocally(currentCourse.module);

              return (
                <Pressable
                  style={[styles.heroCard, isHeroLocked && { opacity: 0.8, backgroundColor: '#333' }]} // Visual feedback
                  disabled={isHeroLocked}
                  onPress={() => {
                    if (isHeroLocked) return;

                    router.push({
                      pathname: currentCourse.route,
                      params: { module: currentCourse.module }
                    });
                  }}
                >
                  <View style={styles.heroContent}>
                    <View style={styles.heroTopRow}>
                      <View>
                        <Text style={styles.courseLabel}>{t('home.currentCourse')}</Text>
                        <Text style={styles.courseName}>
                          {currentCourse.name} {isHeroLocked ? '(Locked)' : ''}
                        </Text>
                      </View>
                      <View style={styles.levelBadge}>
                        <Text style={styles.levelText}>{currentCourse.level}</Text>
                      </View>
                    </View>

                    <View style={styles.heroBottomRow}>
                      <View style={styles.heroTextContainer}>
                        <Text style={styles.thaiText}>{currentCourse.thaiText}</Text>
                        <Text style={styles.translationText}>{currentCourse.translation}</Text>
                      </View>

                      <View style={[styles.playButtonLarge, isHeroLocked && { backgroundColor: '#666' }]}>
                        <Play size={20} fill={isHeroLocked ? '#999' : Colors.ink} color={isHeroLocked ? '#999' : Colors.ink} />
                      </View>
                    </View>
                  </View>

                  <View style={styles.heroGradient1} />
                  <View style={styles.heroGradient2} />
                </Pressable>
              );
            })()}
          </View>

          {/* Stats Grid */}
          <View style={styles.statsGrid}>
            <View style={styles.statCard}>
              <View style={styles.statTopRow}>
                <View style={styles.statIconContainer}>
                  <TrendingUp size={20} color={Colors.ink} />
                </View>
                <Text style={styles.statLabel}>{t('profile.streakDays')}</Text>
              </View>
              <Text style={styles.statValue}>12</Text>
              <Text style={styles.statUnit}>{t('home.streak')}</Text>
            </View>

            <View style={styles.statCard}>
              <View style={styles.statTopRow}>
                <View style={styles.statIconContainer}>
                  <Clock size={20} color={Colors.ink} />
                </View>
                <Text style={styles.statLabel}>{t('profile.studyTime')}</Text>
              </View>
              <Text style={styles.statValue}>4.5</Text>
              <Text style={styles.statUnit}>{t('home.hoursThisWeek')}</Text>
            </View>
          </View>

          {/* Recent Achievements */}
          <View style={styles.achievementsSection}>
            <View style={styles.achievementsHeader}>
              <Star size={16} color={Colors.thaiGold} fill={Colors.thaiGold} />
              <Text style={styles.achievementsTitle}>{t('home.recentMastered')}</Text>
            </View>

            <View style={styles.achievementsList}>
              <AchievementItem
                char="à¸‚"
                name="Khor Khai (è›‹)"
                category="é«˜è¾…éŸ³"
              />
              <View style={styles.divider} />
              <AchievementItem
                char="à¸ªà¸µ"
                name="Sii (é¢œè‰²)"
                category="ä¸Šå£°"
              />
            </View>
          </View>
          {/* Dev Playground Entry - Only visible in DEV */}
          {__DEV__ && (
            <Pressable
              style={{
                marginTop: 20,
                padding: 12,
                backgroundColor: Colors.ink,
                borderRadius: 16,
                alignItems: 'center',
                flexDirection: 'row',
                justifyContent: 'center',
                gap: 8,
              }}
              onPress={() => router.push('/(dev)/playground')}
            >
              <Wrench size={16} color={Colors.thaiGold} />
              <Text style={{ color: Colors.white, fontFamily: Typography.notoSerifBold, fontSize: 12 }}>
                Open Dev Playground
              </Text>
            </Pressable>
          )}
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

interface AchievementItemProps {
  char: string;
  name: string;
  category: string;
}

const AchievementItem: React.FC<AchievementItemProps> = ({ char, name, category }) => (
  <Pressable style={styles.achievementItem}>
    <View style={styles.achievementLeft}>
      <View style={styles.achievementIconBox}>
        <Text style={styles.achievementChar}>{char}</Text>
      </View>
      <View>
        <Text style={styles.achievementName}>{name}</Text>
        <Text style={styles.achievementCategory}>{category}</Text>
      </View>
    </View>
    <View style={styles.masteredBadge}>
      <Text style={styles.masteredText}>å·²æŒæ¡</Text>
    </View>
  </Pressable>
);

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: Colors.paper,
  },
  scrollView: {
    flex: 1,
  },
  scrollContent: {
    paddingBottom: 120,
  },
  header: {
    paddingHorizontal: 24,
    paddingBottom: 24,
    paddingTop: 48,
    borderBottomWidth: 1,
    borderBottomColor: 'transparent',
  },
  headerContent: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    justifyContent: 'space-between',
    zIndex: 10,
  },
  greetingContainer: {
    flexDirection: 'row',
    alignItems: 'baseline',
    position: 'relative',
  },
  greetingText: {
    fontFamily: Typography.playfairRegular,
    fontSize: 30,
    letterSpacing: -0.5,
    color: Colors.ink,
  },
  greetingDot: {
    fontFamily: Typography.playfairRegular,
    position: 'absolute',
    right: -12,
    top: -4,
    fontSize: 20,
    color: Colors.thaiGold,
  },
  subtitleText: {
    fontFamily: Typography.notoSerifRegular,
    marginTop: 4,
    fontSize: 14,
    letterSpacing: 0.5,
    color: Colors.taupe,
  },
  awardBadge: {
    width: 40,
    height: 40,
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: 20,
    borderWidth: 1,
    borderColor: 'rgba(212, 175, 55, 0.2)',
    backgroundColor: 'rgba(212, 175, 55, 0.1)',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
    elevation: 1,
  },
  contentContainer: {
    paddingHorizontal: 24,
    width: '100%',
    maxWidth: 672,
    alignSelf: 'center',
  },
  heroCard: {
    backgroundColor: Colors.ink,
    padding: 32,
    borderRadius: 32,
    marginBottom: 32,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.15,
    shadowRadius: 16,
    elevation: 8,
  },
  heroContent: {
    zIndex: 10,
  },
  heroTopRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 48,
  },
  courseLabel: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 10,
    fontWeight: '700',
    letterSpacing: 1.5,
    color: Colors.thaiGold,
    marginBottom: 4,
    textTransform: 'uppercase',
  },
  courseName: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 20,
    color: Colors.white,
  },
  levelBadge: {
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  levelText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 10,
    color: Colors.sand,
  },
  heroBottomRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-end',
  },
  heroTextContainer: {
    flex: 1,
  },
  thaiText: {
    fontFamily: Typography.sarabunRegular,
    fontSize: 48,
    letterSpacing: 1,
    color: Colors.white,
    marginBottom: 8,
  },
  translationText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    fontWeight: '300',
    color: Colors.sand,
    opacity: 0.6,
  },
  playButtonLarge: {
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: Colors.thaiGold,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: 'rgba(212, 175, 55, 0.4)',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 1,
    shadowRadius: 15,
    elevation: 8,
  },
  heroGradient1: {
    position: 'absolute',
    right: -48,
    top: -48,
    width: 192,
    height: 192,
    borderRadius: 96,
    backgroundColor: 'rgba(212, 175, 55, 0.2)',
    opacity: 0.5,
  },
  heroGradient2: {
    position: 'absolute',
    left: -40,
    bottom: -40,
    width: 160,
    height: 160,
    borderRadius: 80,
    backgroundColor: 'rgba(184, 149, 106, 0.2)',
  },
  statsGrid: {
    flexDirection: 'row',
    gap: 16,
    marginBottom: 32,
  },
  statCard: {
    flex: 1,
    backgroundColor: 'rgba(255, 255, 255, 0.8)',
    padding: 24,
    borderRadius: 24,
    borderWidth: 1,
    borderColor: Colors.sand,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 4,
    elevation: 2,
  },
  statTopRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  statIconContainer: {
    padding: 8,
    backgroundColor: Colors.paper,
    borderRadius: 12,
  },
  statLabel: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 10,
    letterSpacing: 1.5,
    color: Colors.taupe,
    textTransform: 'uppercase',
  },
  statValue: {
    fontFamily: Typography.playfairRegular,
    fontSize: 36,
    color: Colors.ink,
  },
  statUnit: {
    fontFamily: Typography.notoSerifRegular,
    marginTop: 4,
    fontSize: 12,
    color: Colors.taupe,
  },
  achievementsSection: {
    paddingBottom: 24,
  },
  achievementsHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    marginBottom: 16,
  },
  achievementsTitle: {
    fontFamily: Typography.notoSerifBold,
    fontSize: 18,
    fontWeight: '700',
    color: Colors.ink,
  },
  achievementsList: {
    backgroundColor: 'rgba(255, 255, 255, 0.6)',
    borderRadius: 24,
    borderWidth: 1,
    borderColor: Colors.sand,
    padding: 8,
  },
  achievementItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 16,
    borderRadius: 16,
  },
  achievementLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 16,
  },
  achievementIconBox: {
    width: 48,
    height: 48,
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: 16,
    borderWidth: 1,
    borderColor: Colors.sand,
    backgroundColor: Colors.paper,
  },
  achievementChar: {
    fontFamily: Typography.sarabunRegular,
    fontSize: 20,
    color: Colors.ink,
  },
  achievementName: {
    fontFamily: Typography.playfairRegular,
    fontSize: 16,
    fontWeight: '500',
    color: Colors.ink,
  },
  achievementCategory: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 10,
    letterSpacing: 1,
    color: Colors.taupe,
    textTransform: 'uppercase',
  },
  masteredBadge: {
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: Colors.sand,
    backgroundColor: Colors.paper,
  },
  masteredText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 12,
    color: 'rgba(26, 26, 26, 0.6)',
  },
  divider: {
    width: '90%',
    height: 1,
    backgroundColor: 'rgba(229, 226, 219, 0.5)',
    alignSelf: 'center',
    marginVertical: 4,
  },
});
````

## File: cloudbase/functions/memory-engine/handlers/getTodayMemories.js
````javascript
/**
 * ç»Ÿä¸€è·å–ä»Šæ—¥å­¦ä¹ å†…å®¹ (å­—æ¯/å•è¯/å¥å­)
 * Action: getTodayMemories
 */
'use strict';

// å‡è®¾ memoryEngine å†…éƒ¨æ²¡æœ‰ä¸¥é‡çš„å…¨å±€å‰¯ä½œç”¨ï¼Œå¦‚æœæœ‰é—®é¢˜ï¼Œå¯èƒ½éœ€è¦æ£€æŸ¥ memoryEngine
const { getTodayReviewEntities, getOrCreateMemory, checkModuleAccess } = require('../utils/memoryEngine');
const { createResponse } = require('../utils/response');
const {
  getLessonMetadataFromDb,
  getPhonicsRuleByLessonFromDb,
} = require('../config/alphabetLessonConfig');

const MAX_NEW_LETTERS = 12; // å•è¯¾å®‰å…¨ä¸Šé™ï¼Œé˜²æ­¢ 3s è¶…æ—¶
const MAX_LETTER_DAILY_LIMIT = 20; // å­—æ¯æ¨¡å—æ¯æ—¥å­¦ä¹ ç¡¬ä¸Šé™ï¼ˆç¨³å®šæ¨¡å¼ï¼‰
const MAX_GENERIC_DAILY_LIMIT = 200; // å…¶ä»–æ¨¡å—çš„å…œåº•ä¸Šé™ï¼Œé˜²æ­¢æ— ç•Œè¯·æ±‚

/**
 * æ‡’åˆå§‹åŒ–ï¼šå­—æ¯è¿›åº¦è¡¨
 * å…¼å®¹æ—§ç”¨æˆ·ï¼šå¦‚æœ user_alphabet_progress ä¸­æ²¡æœ‰è®°å½•ï¼Œåˆ™æ’å…¥ä¸€æ¡é»˜è®¤è®°å½•
 *
 * @param {Object} db
 * @param {string} userId
 */
async function ensureUserAlphabetProgress(db, userId) {
  const col = db.collection('user_alphabet_progress');
  const existing = await col.where({ userId }).limit(1).get();

  if (!existing.data || existing.data.length === 0) {
    const now = new Date().toISOString();

    // ğŸ”¥ å¹¶å‘ä¿æŠ¤ï¼šäºŒæ¬¡æ£€æŸ¥é˜²æ­¢é‡å¤è®°å½•
    const checkAgain = await col.where({ userId }).limit(1).get();
    if (checkAgain.data && checkAgain.data.length > 0) {
      console.log('âš ï¸ [ensureUserAlphabetProgress] è®°å½•å·²è¢«å¹¶å‘åˆ›å»º, è·³è¿‡');
      return;
    }

    await col.add({
      data: {
        userId,
        letterProgress: 0.0,
        letterCompleted: false,
        completedLessons: [],
        masteredLetterCount: 0,
        totalLetterCount: 80,
        currentRound: 1,          // ğŸ”¥ æ–°å¢ï¼šé»˜è®¤ä»ç¬¬1è½®å¼€å§‹
        roundHistory: [],         // ğŸ”¥ æ–°å¢ï¼šè½®æ¬¡å†å²è®°å½•
        createdAt: now,
        updatedAt: now,
      },
    });
    console.log('âœ… [ensureUserAlphabetProgress] å·²åˆ›å»ºé»˜è®¤è¿›åº¦è®°å½•');
  }
}

/**
 * æ‡’åˆå§‹åŒ–ï¼šç”¨æˆ·è¯æ±‡è¿›åº¦è¡¨ï¼ˆä¼ ç»Ÿè¿›åº¦è¡¨ï¼‰
 * è¯´æ˜ï¼š
 * - è¯¥é›†åˆåŸæœ¬æŒ‰å•è¯ä¸€æ¡è®°å½•ï¼Œè¿™é‡Œåªä¸ºæ—§ç”¨æˆ·æ’å…¥ä¸€æ¡ã€Œå ä½è®°å½•ã€
 * - ä½¿ç”¨ skipped: trueï¼Œé¿å…å½±å“ getTodayWords ç­‰æŸ¥è¯¢é€»è¾‘
 *
 * @param {Object} db
 * @param {string} userId
 */
async function ensureUserVocabularyProgress(db, userId) {
  const col = db.collection('user_vocabulary_progress');
  const existing = await col.where({ userId }).limit(1).get();

  if (!existing.data || existing.data.length === 0) {
    const now = new Date().toISOString();
    await col.add({
      data: {
        userId,
        vocabularyId: null,
        mastery: null,
        reviewCount: 0,
        lastReviewed: null,
        nextReviewDate: null,
        intervalDays: 0,
        // å ä½è®°å½•é»˜è®¤æ ‡è®°ä¸º skippedï¼Œé¿å…è¢«å½“æˆçœŸå®å¤ä¹ æ•°æ®
        skipped: true,
        easinessFactor: 2.5,
        createdAt: now,
        updatedAt: now,
      },
    });
  }
}

/**
 * @param {Object} db - æ•°æ®åº“å®ä¾‹
 * @param {Object} params - è¯·æ±‚å‚æ•°
 */
async function getTodayMemories(db, params) {
  const start = Date.now();
  const { userId, entityType, limit = 30, includeNew = true, roundNumber } = params;

  // ğŸ” è°ƒè¯•æ—¥å¿—ï¼šæ‰“å°æ”¶åˆ°çš„ userId
  console.log('ğŸ“¥ [getTodayMemories] æ”¶åˆ°è¯·æ±‚ï¼ŒuserId:', userId, ', entityType:', entityType);

  if (!userId || !entityType) {
    return createResponse(false, null, 'Missing userId or entityType', 'INVALID_PARAMS');
  }

  try {
    // 0. æ‡’åˆå§‹åŒ–ç”¨æˆ·ç›¸å…³è¿›åº¦è¡¨ï¼ˆå…¼å®¹åœ¨æ–°å¢æ³¨å†Œé€»è¾‘ä¹‹å‰çš„è€ç”¨æˆ·ï¼‰
    if (entityType === 'letter') {
      await ensureUserAlphabetProgress(db, userId);
    } else if (entityType === 'word') {
      await ensureUserVocabularyProgress(db, userId);
    }

    // 1. æ£€æŸ¥æ¨¡å—è®¿é—®æƒé™
    // ä½¿ç”¨ memoryEngine ä¸­çš„ç»Ÿä¸€æƒé™æ£€æŸ¥
    const accessCheck = await checkModuleAccess(db, userId, entityType);
    if (!accessCheck.allowed) {
      return createResponse(false, null, accessCheck.message, accessCheck.errorCode);
    }

    // 1.5 è·å–/æ›´æ–°ç”¨æˆ·æ¯æ—¥å­¦ä¹ é‡è®¾ç½®
    // æ³¨æ„ï¼š
    // - å­—æ¯æ¨¡å—ï¼ˆentityType === 'letter'ï¼‰ä¸å†å…è®¸å‰ç«¯é€šè¿‡ limit åŠ¨æ€è°ƒæ•´æ¯æ—¥æ–°å­—æ¯æ•°é‡ï¼Œ
    //   åªä½¿ç”¨æœåŠ¡å™¨ç«¯å­˜å‚¨çš„ dailyLimitï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œå¦åˆ™é€€å›é»˜è®¤å€¼ï¼›
    // - å…¶ä»–å®ä½“ç±»å‹ä»æ²¿ç”¨åŸæœ‰é€»è¾‘ã€‚
    let effectiveLimit = limit;
    const userProgress = accessCheck.progress; // checkModuleAccess returns progress

    if (userProgress) {
      if (entityType === 'letter') {
        // å­—æ¯æ¨¡å—ï¼šå¿½ç•¥å‰ç«¯ä¼ å…¥çš„ limitï¼Œåªä½¿ç”¨å­˜å‚¨çš„ dailyLimitï¼ˆå¦‚æœæœ‰ï¼‰
        if (userProgress.dailyLimit) {
          effectiveLimit = Math.min(userProgress.dailyLimit, MAX_LETTER_DAILY_LIMIT);
        }
        effectiveLimit = Math.min(effectiveLimit, MAX_LETTER_DAILY_LIMIT);
      } else {
        // å…¶ä»–æ¨¡å—ï¼šä¿ç•™åŸæœ‰è¡Œä¸º
        if (params.limit && params.limit !== userProgress.dailyLimit) {
          await db.collection('user_progress').where({ userId }).update({
            data: {
              dailyLimit: params.limit,
              updatedAt: new Date().toISOString()
            }
          });
          effectiveLimit = Math.min(params.limit, MAX_GENERIC_DAILY_LIMIT);
        } else if (!params.limit && userProgress.dailyLimit) {
          effectiveLimit = Math.min(userProgress.dailyLimit, MAX_GENERIC_DAILY_LIMIT);
        }
      }
    }
    if (entityType !== 'letter') {
      effectiveLimit = Math.min(effectiveLimit, MAX_GENERIC_DAILY_LIMIT);
    }

    // 3. è·å–ä»Šæ—¥å¤ä¹ å®ä½“
    let reviewMemories = await getTodayReviewEntities(db, userId, entityType, effectiveLimit);

    // ğŸ”¥ P0-C: æ˜¾å¼è·å– Round1 è·¨è¯¾ç¨‹ previous-reviewï¼ˆåªåš round==1 ä¸” lesson>1ï¼‰
    let explicitPreviousCount = 0;

    if (entityType === 'letter' && roundNumber === 1 && params.lessonId && params.lessonId !== 'lesson1') {
      try {
        const currentLessonMeta = await getLessonMetadataFromDb(db, params.lessonId);
        if (currentLessonMeta && currentLessonMeta.order && currentLessonMeta.order > 1) {
          const prevLessonId = `lesson${currentLessonMeta.order - 1}`;

          // æŸ¥è¯¢ä¸Šä¸€è¯¾çš„å­—æ¯
          const prevLettersResult = await db.collection('letters')
            .where({ curriculumLessonIds: db.command.in([prevLessonId]) })
            .limit(20)
            .get();

          const explicitPrevMemories = [];

          // ğŸ”¥ è·å–è¿™äº›å­—æ¯çš„è®°å¿†çŠ¶æ€
          for (const letter of prevLettersResult.data) {
            const mem = await getOrCreateMemory(db, userId, entityType, letter._id, false);
            if (mem) {
              // ğŸ”¥ ç»†èŠ‚æ ¡æ­£3ï¼šæµ…æ‹·è´é¿å…å‰¯ä½œç”¨
              const patched = {
                ...mem,
                reviewStage: Math.max(mem.reviewStage || 0, 1)
              };
              explicitPrevMemories.push(patched);
            }
          }

          explicitPreviousCount = explicitPrevMemories.length;

          // ğŸ”¥ åˆå¹¶åˆ° reviewMemoriesï¼ˆå»é‡ï¼‰
          const existingIds = new Set(reviewMemories.map(m => m.entityId));
          const uniquePrev = explicitPrevMemories.filter(m => !existingIds.has(m.entityId));
          reviewMemories = [...uniquePrev, ...reviewMemories];

          console.log(`ğŸ” [P0-C] lessonId: ${params.lessonId}, prevLessonId: ${prevLessonId}, explicitPrevCount: ${explicitPreviousCount}`);
        }
      } catch (err) {
        console.warn('âš ï¸ [P0-C] è·å–ä¸Šä¸€è¯¾ç¨‹å­—æ¯å¤±è´¥:', err);
      }
    }

    // 4. è·å–æ–°å­¦ä¹ å†…å®¹
    let newMemories = [];
    if (includeNew && reviewMemories.length < effectiveLimit) {
      const remainingSlots = effectiveLimit - reviewMemories.length;

      const collectionMap = {
        letter: 'letters',
        word: 'vocabulary',
        sentence: 'sentences'
      };

      const collectionName = collectionMap[entityType];
      if (!collectionName) {
        return createResponse(false, null, `ä¸æ”¯æŒçš„å®ä½“ç±»å‹: ${entityType}`, 'INVALID_ENTITY_TYPE');
      }

      const query = db.collection(collectionName);
      let newEntities = [];

      // è·å–å·²å­˜åœ¨çš„å®ä½“ID (åŒ…æ‹¬å¤ä¹ é˜Ÿåˆ—ä¸­çš„)
      const existingEntityIds = reviewMemories.map(m => m.entityId);

      if (entityType === 'letter' && params.lessonId) {
        // å­—æ¯æ¨¡å—ï¼šæ ¹æ®è¯¾ç¨‹ä¸€æ¬¡æ€§å–å‡ºè¯¥è¯¾éœ€è¦çš„å…¨éƒ¨å­—æ¯ï¼ˆä¸å— limit é™åˆ¶ï¼‰
        const { lessonId } = params;
        const cmd = db.command;

        const whereCondition = {
          curriculumLessonIds: cmd.in([lessonId]),
        };

        // ğŸ”¥ Round2/3 æ—¶ä¸è¿‡æ»¤å·²æœ‰è®°å¿†çš„å­—æ¯ï¼ˆç”¨äºå¤ä¹ ï¼‰
        if (roundNumber === 1 && existingEntityIds.length > 0) {
          whereCondition._id = cmd.nin(existingEntityIds);
        }
        // Round2/3 æ—¶è¿”å›è¯¥è¯¾ç¨‹çš„å…¨éƒ¨å­—æ¯

        const newEntitiesResult = await query
          .where(whereCondition)
          // ä¸ºäº†å®‰å…¨èµ·è§ï¼Œä»åŠ ä¸€ä¸ªè¾ƒå¤§çš„ä¸Šé™ï¼ˆè¿œå¤§äºå®é™…å­—æ¯æ€»æ•°ï¼‰
          .limit(MAX_NEW_LETTERS)
          .get();

        newEntities = newEntitiesResult.data;
      } else {
        // å…¶ä»–æ¨¡å—æˆ–æœªæŒ‡å®š lessonIdï¼šæ²¿ç”¨åŸé€»è¾‘ï¼ŒæŒ‰å‰©ä½™åé¢å’Œ lessonNumber é¡ºåºè·å–
        let queryRef = query;
        const cmd = db.command;

        if (existingEntityIds.length > 0) {
          queryRef = queryRef.where({
            _id: cmd.nin(existingEntityIds)
          });
        }

        const newEntitiesResult = await queryRef
          .orderBy('lessonNumber', 'asc')
          .orderBy('_id', 'asc')
          .limit(Math.min(remainingSlots, MAX_GENERIC_DAILY_LIMIT))
          .get();

        newEntities = newEntitiesResult.data;
      }

      const cappedNewEntities =
        entityType === 'letter'
          ? newEntities.slice(0, MAX_NEW_LETTERS)
          : newEntities.slice(0, Math.min(remainingSlots, MAX_GENERIC_DAILY_LIMIT));

      const memoryTasks = cappedNewEntities.map((entity) =>
        getOrCreateMemory(db, userId, entityType, entity._id, false)
      );
      const memoryResults = await Promise.all(memoryTasks);
      newMemories = memoryResults.filter(Boolean);
    }

    // 5. åˆå¹¶ & ç©¿æ’ (Interleave)
    // "å•è¯å’Œå­—æ¯å­¦ä¹ å¼€å§‹å‰ï¼Œä¼˜å…ˆå¤ä¹ ä¹‹å‰å­¦çš„å†…å®¹" -> ä¼˜å…ˆæ”¾å…¥å¤ä¹ å†…å®¹
    // "è¿™éƒ¨åˆ†å†…å®¹å¤ä¹ å®Œåæ‰è¿›å…¥ä¸‰æ–°1å¤ä¹ çš„ç©¿æ’å­¦ä¹ " -> å¤ä¹ å®Œè€å†…å®¹åï¼Œæ–°å†…å®¹æŒ‰ 3æ–°:1å¤ä¹ (æ–°) ç©¿æ’
    let allMemories = [...reviewMemories];

    // å¤„ç†æ–°å†…å®¹ (3æ–° : 1å¤ä¹ )
    // è¿™é‡Œ "1å¤ä¹ " æŒ‡çš„æ˜¯å¯¹åˆšåˆšå­¦ä¹ çš„æ–°å†…å®¹çš„å·©å›ºå¤ä¹  (Intra-session repetition)
    // ä¾‹å¦‚: N1, N2, N3, N1(å¤ä¹ ), N4, N5, N6, N4(å¤ä¹ )...
    if (newMemories.length > 0) {
      for (let i = 0; i < newMemories.length; i++) {
        allMemories.push(newMemories[i]);

        // æ¯3ä¸ªæ–°è¯ï¼Œæ’å…¥ä¸€ä¸ªå¤ä¹  (å¤ä¹ è¿™ç»„çš„ç¬¬ä¸€ä¸ª)
        if ((i + 1) % 3 === 0) {
          // æ’å…¥ i-2 (å³è¿™ç»„çš„ç¬¬ä¸€ä¸ª) ä½œä¸ºå¤ä¹ 
          // æ³¨æ„ï¼šè¿™é‡Œç›´æ¥pushåŒä¸€ä¸ªå¯¹è±¡ï¼Œå‰ç«¯ä¼šå†æ¬¡æ¸²æŸ“å®ƒ
          allMemories.push(newMemories[i - 2]);
        }
      }
    }

    if (allMemories.length === 0) {
      return createResponse(true, { items: [], summary: { total: 0 } }, 'ä»Šæ—¥æ— å­¦ä¹ å†…å®¹');
    }

    // 6. è·å–è¯¦æƒ…
    const entityIds = allMemories.map(m => m.entityId);
    const collectionMap = {
      letter: 'letters',
      word: 'vocabulary',
      sentence: 'sentences'
    };

    const entitiesResult = await db.collection(collectionMap[entityType])
      .where({
        _id: db.command.in(entityIds)
      })
      .get();

    const entitiesMap = new Map(entitiesResult.data.map(e => [e._id, e]));

    // 7. ç»„è£…
    const data = allMemories.map(memory => {
      const entity = entitiesMap.get(memory.entityId);
      if (!entity) return null;

      return {
        ...entity,
        memoryState: {
          masteryLevel: memory.masteryLevel,
          reviewStage: memory.reviewStage,
          correctCount: memory.correctCount,
          wrongCount: memory.wrongCount,
          streakCorrect: memory.streakCorrect,
          nextReviewAt: memory.nextReviewAt,
          isNew: memory.reviewStage === 0
        }
      };
    }).filter(Boolean);

    const summary = {
      total: data.length,
      reviewCount: reviewMemories.length,
      newCount: newMemories.length,
      entityType,
    };

    // 8. é™„åŠ è¯¾ç¨‹å…ƒæ•°æ® & æ‹¼è¯»è§„åˆ™ï¼ˆçœŸå®é…ç½®ï¼‰
    let lessonMetadata = null;
    let phonicsRule = null;

    if (entityType === 'letter' && data.length > 0) {
      // ä¼˜å…ˆä½¿ç”¨å‰ç«¯ä¼ å…¥çš„ lessonIdï¼Œå…¶æ¬¡å°è¯•ä»å®ä½“å­—æ®µæ¨å¯¼
      const firstEntity = data[0];
      const lessonIdFromParam = params.lessonId;
      const lessonIdFromField = firstEntity.lessonId || null;
      const lessonIdFromCurriculum =
        (firstEntity.curriculumLessonIds &&
          firstEntity.curriculumLessonIds[0]) ||
        null;
      const lessonIdFromLegacy =
        typeof firstEntity.lessonNumber === 'number' &&
          firstEntity.lessonNumber > 0
          ? `lesson${firstEntity.lessonNumber}`
          : null;

      const resolvedLessonId =
        lessonIdFromParam ||
        lessonIdFromCurriculum ||
        lessonIdFromField ||
        lessonIdFromLegacy;

      if (resolvedLessonId) {
        lessonMetadata = await getLessonMetadataFromDb(db, resolvedLessonId);
        phonicsRule = await getPhonicsRuleByLessonFromDb(db, resolvedLessonId);
      }
    }

    return createResponse(
      true,
      {
        items: data,
        summary,
        lessonMetadata,
        phonicsRule,
      },
      'è·å–ä»Šæ—¥å­¦ä¹ å†…å®¹æˆåŠŸ',
    );

  } catch (error) {
    console.error('getTodayMemories error:', error);
    return createResponse(false, null, error.message, 'SERVER_ERROR');
  } finally {
    console.log('[FunctionCost] getTodayMemories', Date.now() - start, 'ms');
  }
}

module.exports = getTodayMemories;
````

## File: app/(tabs)/courses.tsx
````typescript
// app/(tabs)/courses.tsx
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { useRouter } from 'expo-router';
import { View, Text, StyleSheet, ScrollView, TextInput, ImageSourcePropType, Pressable } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Search, BookOpen, Type, Grid } from 'lucide-react-native';
import { ThaiPatternBackground } from '@/src/components/common/ThaiPatternBackground';
import { Colors } from '@/src/constants/colors';
import { Typography } from '@/src/constants/typography';
import { useTranslation } from 'react-i18next';
import { useVocabularyStore } from '@/src/stores/vocabularyStore';
import { CourseSelectionModal } from '@/src/components/courses/CourseSelectionModal';
import coursesData from '@/assets/courses/courses.json';
import alphabetCourses from '@/assets/courses/alphabetCourses.json';
import { CourseCard, type CourseCardData } from '@/src/components/courses/CourseCard';
import { AlphabetCourseCard } from '@/src/components/courses/AlphabetCourseCard';
import { useLearningPreferenceStore } from '@/src/stores/learningPreferenceStore';
import { useModuleAccessStore, type ModuleType } from '@/src/stores/moduleAccessStore';

const CATEGORIES = [
  { id: 'all', label: 'å…¨éƒ¨', icon: Grid },
  { id: 'letter', label: 'å­—æ¯', icon: Type },
  { id: 'word', label: 'å•è¯', icon: BookOpen },
];

type CourseItem = {
  id: string;
  source: string;
  title: string;
  description: string;
  level: string;
  image: string;
  category: string;
  lessons: number;
};

type CourseWithImage = CourseItem & {
  imageSource: ImageSourcePropType;
};

const COURSE_IMAGE_MAP: Record<string, ImageSourcePropType> = {
  'ThaiBase_1.png': require('@/assets/images/courses/ThaiBase_1.png'),
  'ThaiBase_2.png': require('@/assets/images/courses/ThaiBase_2.png'),
  'ThaiBase_3.png': require('@/assets/images/courses/ThaiBase_3.png'),
  'ThaiBase_4.png': require('@/assets/images/courses/ThaiBase_4.png'),
  'thai_alphabet.png': require('@/assets/images/courses/thai_alphabet.png'),
  default: require('@/assets/images/courses/ThaiBase_1.png'),
};

// åŒ…å«å­—æ¯è¯¾ç¨‹å’Œå•è¯è¯¾ç¨‹
const COURSES: CourseWithImage[] = (
  [
    ...(alphabetCourses as CourseItem[]),
    ...(coursesData as CourseItem[]),
  ]
).map((course) => ({
  ...course,
  imageSource: COURSE_IMAGE_MAP[course.image] || COURSE_IMAGE_MAP.default,
}));

export default function CoursesScreen() {
  const router = useRouter();
  const { t } = useTranslation();
  const [activeCategory, setActiveCategory] = useState('all');
  const [searchQuery, setSearchQuery] = useState('');

  const { currentCourseSource, startCourse } = useVocabularyStore();
  const { hasDailyLimit } = useLearningPreferenceStore();
  const { userProgress, getUserProgress, checkAccess, accessCache } = useModuleAccessStore();
  const [modalVisible, setModalVisible] = useState(false);
  const [pendingCourse, setPendingCourse] = useState<CourseWithImage | null>(null);
  const didDevAccessCheckRef = useRef(false);

  useEffect(() => {
    if (!userProgress) {
      getUserProgress().catch((err) => console.warn('Failed to fetch user progress', err));
    }
  }, [userProgress, getUserProgress]);

  useEffect(() => {
    if (!__DEV__) return;
    if (didDevAccessCheckRef.current) return;
    didDevAccessCheckRef.current = true;

    const uniqueModules = Array.from(new Set(COURSES.map(getModuleType)))
      .filter((moduleType) => moduleType !== 'letter');

    uniqueModules.forEach((moduleType) => {
      checkAccess(moduleType).catch((error) => {
        console.warn('âš ï¸ Dev module access check failed:', moduleType, error);
      });
    });
  }, [checkAccess]);

  const getModuleType = (course: CourseWithImage): ModuleType => {
    switch (course.category) {
      case 'letter':
        return 'letter';
      case 'sentence':
        return 'sentence';
      case 'article':
        return 'article';
      default:
        return 'word';
    }
  };

  const getCourseProgress = (course: CourseWithImage) => {
    if (!userProgress) return undefined;
    const moduleType = getModuleType(course);
    if (moduleType === 'letter') {
      return {
        completed: userProgress.letterMasteredCount,
        total: userProgress.letterTotalCount || course.lessons,
      };
    }
    if (moduleType === 'word') {
      return {
        completed: userProgress.wordMasteredCount,
        total: userProgress.wordTotalCount || course.lessons,
      };
    }
    return undefined;
  };

  const filteredCourses = useMemo(() => {
    return COURSES.filter(course => {
      const matchesCategory = activeCategory === 'all' || course.category === activeCategory;
      const matchesSearch =
        course.title.includes(searchQuery) || course.description.includes(searchQuery);
      return matchesCategory && matchesSearch;
    });
  }, [activeCategory, searchQuery]);



  // â­ ç»Ÿä¸€çš„ Start Learning é€»è¾‘ï¼šæ¥æ”¶ courseï¼Œè¿”å›ä¸€ä¸ªç‚¹å‡» handler
  const handleStartLearning = (course: CourseWithImage) => {
    return () => {
      const moduleType = getModuleType(course);

      // ğŸ”’ Double Check: UI Should be disabled, but logic must be safe
      const { checkAccessLocally, accessCache: cachedAccess } = useModuleAccessStore.getState();
      const devOverrideUnlocked = __DEV__ && cachedAccess.get(moduleType) === true;
      const isLocked = moduleType !== 'letter' && !devOverrideUnlocked && !checkAccessLocally(moduleType);
      if (isLocked) {
        console.warn('Course locked, double-check start prevented');
        return;
      }

      const needsDailySetup = !hasDailyLimit(moduleType);

      // âœ… åŒä¸€ä¸ªè¯¾ç¨‹ï¼šç›´æ¥æŒ‰ç…§æ˜¯å¦å·²è®¾ç½®æ—¥è®¡åˆ’è¿›è¡Œè·³è½¬
      if (currentCourseSource === course.source) {
        // Pass moduleType to startCourse for strict check
        startCourse(course.source, moduleType).then(() => {
          // Special routing for Alphabet, ignoring daily setup check
          if (moduleType === 'letter') {
            router.push('/alphabet');
          } else {
            router.push({
              pathname: needsDailySetup ? '/learning/setup' : '/learning',
              params: {
                module: moduleType,
                source: course.source,
              },
            });
          }
        });
        return;
      }

      // âœ… åˆ‡æ¢è¯¾ç¨‹ï¼šå¼¹ç¡®è®¤æ¡†
      setPendingCourse(course);
      setModalVisible(true);
    };
  };

  const confirmSwitchCourse = async () => {
    if (pendingCourse) {
      await proceedToCourse(pendingCourse);
    }
  };

  const proceedToCourse = async (course: CourseWithImage) => {
    const moduleType = getModuleType(course);
    const needsDailySetup = !hasDailyLimit(moduleType);

    await startCourse(course.source, moduleType);
    setModalVisible(false);
    setPendingCourse(null);

    // Special routing for Alphabet
    if (moduleType === 'letter') {
      router.push('/alphabet');
    } else {
      router.push({
        pathname: needsDailySetup ? '/learning/setup' : '/learning',
        params: {
          module: moduleType,
          source: course.source,
        },
      });
    }
  };

  return (
    <SafeAreaView edges={['top']} style={styles.safeArea}>
      <ThaiPatternBackground opacity={0.12} />

      <View style={styles.header}>
        <Text style={styles.headerTitle}>{t('courses.title')}</Text>
        <Text style={styles.headerSubtitle}>{t('courses.subtitle')}</Text>
      </View>

      <View style={styles.searchContainer}>
        <View style={styles.searchBar}>
          <Search size={20} color={Colors.taupe} />
          <TextInput
            style={styles.searchInput}
            placeholder={t('courses.searchPlaceholder')}
            placeholderTextColor={Colors.taupe}
            value={searchQuery}
            onChangeText={setSearchQuery}
          />
        </View>
      </View>

      <View style={styles.categoryContainer}>
        <ScrollView
          horizontal
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.categoryContent}
        >
          {CATEGORIES.map((cat) => {
            const isActive = activeCategory === cat.id;
            const Icon = cat.icon;
            return (
              <Pressable
                key={cat.id}
                style={[styles.categoryChip, isActive && styles.categoryChipActive]}
                onPress={() => setActiveCategory(cat.id)}
              >
                <Icon size={14} color={isActive ? Colors.white : Colors.taupe} />
                <Text style={[styles.categoryText, isActive && styles.categoryTextActive]}>
                  {cat.label}
                </Text>
              </Pressable>
            );
          })}
        </ScrollView>
      </View>

      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.listContent}
        showsVerticalScrollIndicator={false}
      >
        {/* æ‰€æœ‰è¯¾ç¨‹ï¼ˆåŒ…æ‹¬AlphabetCourseCardå’Œå•è¯è¯¾ç¨‹ï¼‰ */}
        {filteredCourses.map((course) => {
          const isCurrent = currentCourseSource === course.source;
          const moduleType = getModuleType(course);
          const progress = getCourseProgress(course);

          // ğŸ”’ Calculation: Alphabet always unlocked, others check store
          const { checkAccessLocally, accessCache: cachedAccess } = useModuleAccessStore.getState();
          const devOverrideUnlocked = __DEV__ && cachedAccess.get(moduleType) === true;
          const isLocked = moduleType !== 'letter' && !devOverrideUnlocked && !checkAccessLocally(moduleType);

          // å­—æ¯è¯¾ç¨‹ï¼šä½¿ç”¨ AlphabetCourseCardï¼Œç›´æ¥è¿›å…¥ /alphabet æµç¨‹
          if (course.category === 'letter') {
            return (
              <AlphabetCourseCard
                key={course.id}
                course={course}
                isCurrent={isCurrent}
                progress={progress}
                onStart={handleStartLearning(course)} // Connected handleStartLearning
              />
            );
          }

          // å•è¯è¯¾ç¨‹ï¼šä½¿ç”¨æ ‡å‡† CourseCard
          return (
            <CourseCard
              key={course.id}
              course={course as CourseCardData}
              isCurrent={isCurrent}
              progress={progress}
              onStart={handleStartLearning(course)}
              isLocked={isLocked} // Pass locked state
            />
          );
        })}
        <View style={{ height: 100 }} />
      </ScrollView>

      <CourseSelectionModal
        visible={modalVisible}
        courseTitle={pendingCourse?.title || ''}
        onConfirm={confirmSwitchCourse}
        onCancel={() => {
          setModalVisible(false);
          setPendingCourse(null);
        }}
      />
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: Colors.paper,
  },
  header: {
    paddingHorizontal: 24,
    paddingTop: 24,
    paddingBottom: 16,
  },
  headerTitle: {
    fontFamily: Typography.playfairBold,
    fontSize: 28,
    color: Colors.ink,
    marginBottom: 4,
  },
  headerSubtitle: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.taupe,
  },
  searchContainer: {
    paddingHorizontal: 24,
    marginBottom: 16,
  },
  searchBar: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Colors.white,
    borderRadius: 16,
    paddingHorizontal: 16,
    height: 48,
    borderWidth: 1,
    borderColor: Colors.sand,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.03,
    shadowRadius: 4,
    elevation: 2,
  },
  searchInput: {
    flex: 1,
    marginLeft: 12,
    fontFamily: Typography.notoSerifRegular,
    fontSize: 14,
    color: Colors.ink,
  },
  categoryContainer: {
    marginBottom: 16,
  },
  categoryContent: {
    paddingHorizontal: 24,
    gap: 20,
  },
  categoryChip: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: Colors.white,
    borderWidth: 1,
    borderColor: Colors.sand,
    gap: 6,
  },
  categoryChipActive: {
    backgroundColor: Colors.thaiGold,
    borderColor: Colors.thaiGold,
  },
  categoryText: {
    fontFamily: Typography.notoSerifRegular,
    fontSize: 13,
    color: Colors.taupe,
  },
  categoryTextActive: {
    color: Colors.white,
    fontWeight: '600',
  },
  scrollView: {
    flex: 1,
  },
  listContent: {
    paddingHorizontal: 24,
    paddingBottom: 24,
    gap: 16,
  },
});
````

## File: src/hooks/useAlphabetLearningEngine.ts
````typescript
// src/hooks/useAlphabetLearningEngine.ts

import { useState, useCallback, useEffect, useMemo, useRef } from 'react';
import { useAlphabetStore } from '@/src/stores/alphabetStore';
import { useModuleAccessStore } from '@/src/stores/moduleAccessStore';
import { useUserStore } from '@/src/stores/userStore';
import type { AlphabetLearningState, AlphabetQueueItem, AlphabetQueueSource } from '@/src/stores/alphabetStore';
import type {
  PhonicsRule,
  RoundEvaluationState,
} from '@/src/entities/types/phonicsRule.types';

// âœ… ä¿®å¤: ç»Ÿä¸€ä½¿ç”¨ enum ä¸­çš„ QuestionType
import { QuestionType } from '@/src/entities/enums/QuestionType.enum';
import { QualityButton } from '@/src/entities/enums/QualityScore.enum';
import { callCloudFunction } from '@/src/utils/apiClient';
import { API_ENDPOINTS } from '@/src/config/api.endpoints';
import { Alert, AppState } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';


// ğŸ”¥ TODO-03: Phase = AlphabetQueueSource + ç‰¹æ®ŠçŠ¶æ€
// Phase ä»…ç”¨äº UI å±•ç¤ºï¼Œä¸å‚ä¸æ‰§è¡Œå†³ç­–
export type Phase = AlphabetQueueSource | 'finished' | 'round-completed';

const SESSION_STORAGE_KEY = '@alphabet_learning_session';

interface SessionRecoveryState {
  lessonId: string;
  round: 1 | 2 | 3;
  phase: Phase;
  answeredCount: number;
  currentIndex: number; // ğŸ”¥ Bug 3 ä¿®å¤ï¼šæ·»åŠ  currentIndex
  status: 'in-progress' | 'completed';
}


// ===== Hook ä¸»ä½“ =====

export function useAlphabetLearningEngine(lessonId: string) {
  const {
    queue,
    currentItem,
    currentIndex,
    currentRound: storeCurrentRound, // ä» Store è¯»å– currentRound
    lessonMetadata,
    phonicsRule,
    initializeSession,
    submitRoundEvaluation: submitRoundToStore,
    next: nextInQueue,
    appendQueue,
    setCurrentIndex, // å¼•å…¥ setCurrentIndex æ–¹æ³•
    setCurrentRound: setStoreCurrentRound, // å¼•å…¥ setCurrentRound æ–¹æ³•
  } = useAlphabetStore();

  const { currentUser } = useUserStore();
  const { userProgress } = useModuleAccessStore();
  const userId = currentUser?.userId ?? 'test-user';

  const [initialized, setInitialized] = useState(false);
  // REMOVED explicit phase state. Phase is now derived.
  // const [phase, setPhase] = useState<Phase>('finished'); 

  // ğŸ”¥ TODO-03: ä»¥ä¸‹çŠ¶æ€ä»…ç”¨äº UI å±•ç¤ºï¼Œä¸å‚ä¸æ‰§è¡Œå†³ç­– (legacy UI only)
  const [isLessonFinished, setIsLessonFinished] = useState(false);
  const [explicitPhase, setExplicitPhase] = useState<Phase | null>(null);

  // ===== Phase Logic (Derived) =====
  // ğŸ”¥ TODO-03: derivedPhase ä»…ç”¨äº UI å±•ç¤ºï¼Œä¸å‚ä¸æ‰§è¡Œå†³ç­– (legacy UI only)
  const derivedPhase: Phase = useMemo(() => {
    if (explicitPhase) return explicitPhase;
    if (isLessonFinished) return 'finished';
    if (!currentItem) return 'finished';

    // ç›´æ¥è¿”å› sourceï¼Œä¸å†è¿›è¡Œæ˜ å°„è½¬æ¢
    return currentItem.source;
  }, [currentItem, isLessonFinished, explicitPhase]);

  const [phonicsRuleShown, setPhonicsRuleShown] = useState(false);
  const [showPhonicsRuleCard, setShowPhonicsRuleCard] = useState(false);

  const [learnedCount, setLearnedCount] = useState(0);
  const [todayList, setTodayList] = useState<AlphabetLearningState[]>([]);
  const [wrongAnswers, setWrongAnswers] = useState<Set<string>>(new Set());

  // âœ… ä¿®å¤: currentRound ç±»å‹ä¸º 1 | 2 | 3
  // ğŸ”¥ Bug 2 ä¿®å¤ï¼šåˆå§‹åŒ–æ—¶ä» Store è¯»å– currentRound
  const [currentRound, setCurrentRound] = useState<1 | 2 | 3>(storeCurrentRound || 1);
  const [roundEvaluation, setRoundEvaluation] = useState<RoundEvaluationState>({
    currentRound: 1,
    rounds: [],
    allRoundsPassed: false,
  });

  const roundMemoryResultsRef = useRef<Record<string, QualityButton>>({});
  const [answeredCount, setAnsweredCount] = useState(0);
  const [recoveryPrompted, setRecoveryPrompted] = useState(false);
  // æ–°å¢: å°†æ¢å¤çŠ¶æ€æš´éœ²ç»™ UI
  const [pendingRecoverySession, setPendingRecoverySession] = useState<SessionRecoveryState | null>(null);

  // ğŸ”¥ æ–°å¢: æ ‡è®°ç”¨æˆ·æ˜¯å¦å·²ç»å¼€å§‹ç­”é¢˜ï¼ˆç”¨äºå»¶è¿Ÿ session ä¿å­˜æ—¶æœºï¼‰
  const [hasStartedAnswering, setHasStartedAnswering] = useState(false);

  const prevRoundRef = useRef<1 | 2 | 3>(currentRound);


  // ğŸ› P0-2 FIX: é˜²æ­¢é‡å¤ç‚¹å‡»
  const [isProcessingNext, setIsProcessingNext] = useState(false);

  const writeSessionState = useCallback(async (state: SessionRecoveryState | null) => {
    try {
      if (state) {
        await AsyncStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(state));
      } else {
        await AsyncStorage.removeItem(SESSION_STORAGE_KEY);
      }
    } catch (error) {
      console.error('âš ï¸ å­—æ¯å­¦ä¹ ä¼šè¯çŠ¶æ€æŒä¹…åŒ–å¤±è´¥:', error);
    }
  }, []);

  const persistSessionState = useCallback(async () => {
    // ğŸ”¥ TODO-03: ä¸ä¾èµ– derivedPhaseï¼Œæ”¹ä¸ºåˆ¤æ–­ isLessonFinished å’Œ currentItem
    // å½“è¯¾ç¨‹ç»“æŸæˆ–æ²¡æœ‰å½“å‰é¢˜ç›®æ—¶ï¼Œæ¸…é™¤ session
    if (!lessonId || !initialized || isLessonFinished || !currentItem) {
      console.log('ğŸ’¾ [Persist] Clearing session (finished or no item)');
      await writeSessionState(null);
      return;
    }

    // ğŸ”¥ æ–°å¢ï¼šåªæœ‰ç”¨æˆ·å¼€å§‹ç­”é¢˜åï¼Œæ‰ä¿å­˜ session
    if (!hasStartedAnswering) {
      console.log('ğŸ’¾ [Persist] User has not started answering, skip persisting');
      return;
    }

    const sessionData: SessionRecoveryState = {
      lessonId,
      round: currentRound,
      phase: currentItem.source, // ğŸ”¥ TODO-03: ç›´æ¥ä½¿ç”¨ sourceï¼Œä¸å†æ˜ å°„
      answeredCount,
      currentIndex, // ğŸ”¥ Bug 3 ä¿®å¤ï¼šä¿å­˜ currentIndex
      status: 'in-progress', // é»˜è®¤çŠ¶æ€ä¸º in-progress
    };
    console.log('ğŸ’¾ [Persist] Writing session:', sessionData);
    await writeSessionState(sessionData);
  }, [lessonId, initialized, isLessonFinished, currentItem, currentRound, answeredCount, currentIndex, writeSessionState, hasStartedAnswering]);

  const clearStoredSessionState = useCallback(async () => {
    await writeSessionState(null);
  }, [writeSessionState]);

  const handleContinueStoredSession = useCallback((session: SessionRecoveryState) => {
    setCurrentRound(session.round);
    // setPhase(session.phase); // Phase derived from queue restoration
    setAnsweredCount(session.answeredCount ?? 0);
    setTodayList([]);
    setWrongAnswers(new Set());
    setRecoveryPrompted(true);

    // ğŸ”¥ æ¢å¤å­¦ä¹ æ—¶ï¼Œæ ‡è®°ä¸ºå·²ç»å¼€å§‹ç­”é¢˜ï¼ˆå› ä¸ºæ˜¯ä¸­æ–­åæ¢å¤ï¼‰
    setHasStartedAnswering(true);

    // ğŸ”¥ Bug 3 ä¿®å¤ï¼šæ¢å¤é˜Ÿåˆ—ä½ç½®
    if (session.currentIndex !== undefined && session.currentIndex >= 0) {
      setCurrentIndex(session.currentIndex);
      console.log(`ğŸ”„ æ¢å¤é˜Ÿåˆ—ä½ç½®: currentIndex = ${session.currentIndex}`);
    }
  }, [setCurrentIndex]);

  const handleRestartStoredSession = useCallback(async (session?: SessionRecoveryState) => {
    // ğŸ”¥ Bug 4 ä¿®å¤ï¼šé‡æ–°å¼€å§‹æœ¬è½®æ—¶ï¼Œéœ€è¦è°ƒç”¨ initializeSession é‡æ–°åŠ è½½é˜Ÿåˆ—
    // ä» Round1 çš„ç¬¬ä¸€ä¸ªé˜¶æ®µå¼€å§‹ï¼ˆprevious-round-review æˆ– new-learningï¼‰
    const targetRound = session?.round ?? 1;

    setCurrentRound(targetRound);
    setAnsweredCount(0);
    setTodayList([]);
    setWrongAnswers(new Set());
    setRecoveryPrompted(true);

    // ğŸ”¥ é‡æ–°å¼€å§‹æ—¶ï¼Œé‡ç½®ç­”é¢˜æ ‡è®°
    setHasStartedAnswering(false);

    // ğŸ”¥ æ¸…é™¤æ—§ session
    await clearStoredSessionState();

    // ğŸ”¥ é‡æ–°åˆå§‹åŒ–é˜Ÿåˆ—ï¼ŒæŒ‡å®š round
    try {
      await initializeSession(userId, { lessonId, round: targetRound });
      console.log(`ğŸ”„ é‡æ–°åŠ è½½é˜Ÿåˆ—: Round ${targetRound}`);
    } catch (error) {
      console.error('âŒ handleRestartStoredSession: initializeSession å¤±è´¥:', error);
    }
  }, [clearStoredSessionState, initializeSession, userId, lessonId]);

  // ===== åˆå§‹åŒ– =====
  useEffect(() => {
    let cancelled = false;

    // ğŸ”¥ æ¯æ¬¡é‡æ–°åˆå§‹åŒ–æ—¶ï¼Œé‡ç½®ç­”é¢˜æ ‡è®°
    setHasStartedAnswering(false);

    (async () => {
      try {
        await initializeSession(userId, { lessonId });
      } catch (e) {
        console.error('[useAlphabetLearningEngine] initializeSession å¤±è´¥:', e);
        if (cancelled) return;
        // åç«¯å¤±è´¥æ—¶ä¹Ÿä¸èƒ½æ°¸è¿œåœç•™åœ¨ loading
        setInitialized(true);
        // setPhase('finished');
        return;
      }

      if (cancelled) return;
      setInitialized(true);
    })();

    return () => {
      cancelled = true;
    };
  }, [lessonId, userId, initializeSession]);

  useEffect(() => {
    void persistSessionState();
  }, [persistSessionState]);

  useEffect(() => {
    const subscription = AppState.addEventListener('change', (nextState) => {
      if (nextState === 'background' || nextState === 'inactive') {
        void persistSessionState();
      }
    });

    return () => {
      void persistSessionState();
      subscription.remove();
    };
  }, [persistSessionState]);

  useEffect(() => {
    if (!initialized || recoveryPrompted || !lessonId) {
      console.log('ğŸ” [Recovery Check] Skipped:', { initialized, recoveryPrompted, lessonId });
      return;
    }

    console.log('ğŸ” [Recovery Check] Starting check...');

    let cancelled = false;
    (async () => {
      try {
        const stored = await AsyncStorage.getItem(SESSION_STORAGE_KEY);
        console.log('ğŸ” [Recovery Check] Stored session:', stored ? 'Found' : 'Not found');

        if (!stored) return;

        const parsed: SessionRecoveryState = JSON.parse(stored);
        console.log('ğŸ” [Recovery Check] Parsed session:', {
          lessonId: parsed.lessonId,
          round: parsed.round,
          phase: parsed.phase,
          status: parsed.status,
          currentIndex: parsed.currentIndex
        });

        // éªŒè¯ lessonId åŒ¹é…
        if (parsed.lessonId !== lessonId) {
          console.log('ğŸ” [Recovery Check] LessonId mismatch, clearing...');
          await clearStoredSessionState();
          return;
        }

        // ğŸ”¥ å…³é”®ä¿®å¤ï¼šä»…å½“ status === 'in-progress' æ—¶æ‰å¼¹å‡ºæ¢å¤æç¤º
        if (parsed.status !== 'in-progress') {
          console.log('ğŸ” [Recovery Check] Status not in-progress, clearing...', parsed.status);
          await clearStoredSessionState();
          return;
        }

        if (cancelled) return;

        // æ›¿æ¢ Alert.alert ä¸º UI çŠ¶æ€
        console.log('ğŸ” [Recovery Check] Showing recovery dialog');
        setPendingRecoverySession(parsed);
        setRecoveryPrompted(true);

      } catch (error) {
        console.error('âš ï¸ è¯»å–å­—æ¯å­¦ä¹ ä¼šè¯çŠ¶æ€å¤±è´¥:', error);
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [
    initialized,
    lessonId,
    recoveryPrompted,
    clearStoredSessionState,
  ]);

  // æ–°å¢: å¤„ç†ç”¨æˆ·çš„æ¢å¤é€‰æ‹©
  const handleResolveRecovery = useCallback((choice: 'continue' | 'restart') => {
    if (!pendingRecoverySession) return;

    if (choice === 'continue') {
      handleContinueStoredSession(pendingRecoverySession);
    } else {
      handleRestartStoredSession(pendingRecoverySession);
    }
    setPendingRecoverySession(null);
  }, [pendingRecoverySession, handleContinueStoredSession, handleRestartStoredSession]);

  // ğŸ”¥ Bug 2 ä¿®å¤ï¼šä» Store åŒæ­¥ currentRound åˆ° Hook æœ¬åœ°çŠ¶æ€
  useEffect(() => {
    if (storeCurrentRound && storeCurrentRound !== currentRound) {
      console.log(`ğŸ”„ Syncing currentRound from Store: ${storeCurrentRound}`);
      setCurrentRound(storeCurrentRound);
    }
  }, [storeCurrentRound, currentRound]);

  useEffect(() => {
    if (prevRoundRef.current !== currentRound) {
      prevRoundRef.current = currentRound;
      setAnsweredCount(0);
    }
  }, [currentRound]);

  // ===== é¦–æ¬¡è¿›å…¥ï¼šå¦‚æœæ²¡æœ‰ä»»ä½•â€œæ—§å­—æ¯â€ï¼Œè‡ªåŠ¨è·³è¿‡æ˜¨æ—¥å¤ä¹  =====
  useEffect(() => {
    if (!initialized) return;
    if (!currentItem) return;
    // setPhase(currentItem.source); // REMOVED: Phase is derived
  }, [initialized, currentItem, queue]);

  // ===== Today Learning é¦–æ¬¡æ˜¾ç¤ºæ‹¼è¯»è§„åˆ™ =====
  useEffect(() => {
    // ğŸ”¥ TODO-03: ç»Ÿä¸€ä½¿ç”¨ 'new-learning'
    const isNew = currentItem?.source === 'new-learning';
    if (isNew && !phonicsRuleShown && phonicsRule && learnedCount === 0) {
      setShowPhonicsRuleCard(true);
    }
  }, [phonicsRuleShown, phonicsRule, learnedCount, currentItem]);

  const handleCompletePhonicsRule = useCallback(() => {
    setShowPhonicsRuleCard(false);
    setPhonicsRuleShown(true);
  }, []);

  const recordMemoryResult = useCallback((letterId: string, quality: QualityButton) => {
    roundMemoryResultsRef.current[letterId] = quality;
  }, []);

  const submitAlphabetMemoryResults = useCallback(
    async (roundNumber: number) => {
      const entries = Object.entries(roundMemoryResultsRef.current);
      if (entries.length === 0) return;

      const results = entries.map(([entityId, quality]) => ({
        entityType: 'letter' as const,
        entityId,
        quality,
      }));

      try {
        await callCloudFunction(
          'submitMemoryResult',
          {
            userId,
            lessonId,
            roundNumber,
            results,
          },
          {
            endpoint: API_ENDPOINTS.MEMORY.SUBMIT_MEMORY_RESULT.cloudbase,
          }
        );
      } catch (error) {
        console.error('âŒ submitAlphabetMemoryResults error:', error);
      }
    },
    [lessonId, userId]
  );

  // ===== ç­”é¢˜å›è°ƒ =====
  const handleAnswer = useCallback(
    async (isCorrect: boolean, questionType: QuestionType) => {
      if (!currentItem) return;

      // ğŸ”¥ æ ‡è®°ç”¨æˆ·å·²ç»å¼€å§‹ç­”é¢˜ï¼ˆè§¦å‘ session ä¿å­˜ï¼‰
      if (!hasStartedAnswering) {
        setHasStartedAnswering(true);
        console.log('ğŸ¯ User started answering, session will now persist');
      }

      const quality = isCorrect ? QualityButton.KNOW : QualityButton.FORGET;
      recordMemoryResult(currentItem.alphabetId, quality);
      setAnsweredCount((prev) => prev + 1);

      const wrongKey = currentItem.alphabetId;

      setWrongAnswers((prev) => {
        const next = new Set(prev);
        if (isCorrect && currentItem.source === 'error-review') {
          next.delete(wrongKey);
        } else if (!isCorrect) {
          next.add(wrongKey);
        }
        return next;
      });
    },
    [currentItem, recordMemoryResult, hasStartedAnswering]
  );

  // REMOVED DUPLICATE derivedPhase definition from here (moved to top)


  // ===== Question Type Logic (Engine Driven) =====

  // ğŸ”¥ TODO-03: é¢˜å‹é€‰æ‹©åªèƒ½åŸºäº currentItem.sourceï¼Œä¸ä¾èµ– Phase
  const currentQuestionType = useMemo<QuestionType | null>(() => {
    if (!currentItem) return null;

    const source = currentItem.source;

    // 1. New Learning / Mini Review: ALLOW Simple Types
    if (source === 'new-learning') {
      return QuestionType.SOUND_TO_LETTER;
    }

    if (source === 'mini-review') {
      return Math.random() > 0.5 ? QuestionType.SOUND_TO_LETTER : QuestionType.LETTER_TO_SOUND;
    }

    // 2. Strict Review Phases: FORBID Simple Types (where possible)
    // ğŸ”¥ TODO-03: ç»Ÿä¸€ä½¿ç”¨ 'previous-review'
    if (source === 'previous-review' || source === 'final-review') {
      const complexTypes = [];

      // Only allow CONSONANT_CLASS for Consonants
      if (currentItem.letter.type === 'consonant') {
        complexTypes.push(QuestionType.CLASS_CHOICE); // CONSONANT_CLASS
        // Initial/Final sound usually applies to consonants acting as such
        if (currentItem.letter.initialSound) complexTypes.push(QuestionType.INITIAL_SOUND);
        if (currentItem.letter.finalSound) complexTypes.push(QuestionType.FINAL_CONSONANT);
      } else {
        // Vowels / Tones:
        // Currently we lack "Complex" types for vowels (Tone Calculation is TODO).
        // Fallback to LETTER_TO_SOUND (Reading) which is harder than Sound-to-Letter.
        // We cannot use CONSONANT_CLASS.
      }

      // TODO: Enable these when data/logic is ready
      // complexTypes.push(QuestionType.TONE_CALCULATION);

      if (complexTypes.length === 0) {
        // Fallback for Vowels in Strict Phase
        // Prefer LETTER_TO_SOUND (Reading)
        return QuestionType.LETTER_TO_SOUND;
      }

      const hash = currentItem.alphabetId.charCodeAt(0) + (currentItem.round || 0) + Date.now();
      return complexTypes[hash % complexTypes.length];
    }

    if (source === 'error-review') {
      // Error Review: Retry what they failed.
      // If we don't know what they failed, default to SOUND_TO_LETTER for safety?
      // Or make it strict if it was a strict phase failure?
      // For now, allow simple types to ensure they at least get the basics.
      return QuestionType.SOUND_TO_LETTER;
    }

    return QuestionType.SOUND_TO_LETTER;
  }, [currentItem]);


  // ===== ä¸‹ä¸€é¢˜ =====
  const handleNext = useCallback(async () => {
    // ğŸ› P0-2 FIX: é˜²æ­¢é‡å¤ç‚¹å‡»
    if (isProcessingNext) {
      console.log('ğŸš« é˜²æ­¢é‡å¤ç‚¹å‡» handleNext');
      return;
    }

    // ğŸ”¥ TODO-03: ä¸ä¾èµ– explicitPhaseï¼Œæ”¹ä¸ºåˆ¤æ–­ currentItem
    // å½“è½®æ¬¡å®Œæˆåï¼ŒcurrentItem ä¸º nullï¼Œæ— æ³•ç»§ç»­ç­”é¢˜
    if (!currentItem) {
      console.warn('âš ï¸ No current item, round may be completed.');
      return;
    }

    console.log('=== handleNext è°ƒç”¨ ===');
    console.log('è°ƒç”¨å‰çŠ¶æ€:', {
      phase: derivedPhase,
      currentRound,
      learnedCount,
      queueLength: queue.length,
      currentLetter: currentItem?.letter?.thaiChar || 'unknown',
      source: currentItem?.source,
      errorQueueSize: wrongAnswers.size, // Approximation of potential error queue
    });

    setIsProcessingNext(true);

    // ğŸ”¥ TODO-03: ç»Ÿä¸€ä½¿ç”¨ 'new-learning'
    const isCurrentNew = currentItem?.source === 'new-learning';
    // STRICT Condition: End of Queue
    const atEnd = currentIndex >= queue.length - 1;

    try {
      if (currentItem && isCurrentNew) {
        setTodayList((prev) => [...prev, currentItem]);
        setLearnedCount((prev) => prev + 1);
      }

      if (atEnd) {
        // 1. Check if we have pending errors
        if (wrongAnswers.size > 0) {
          const errorItems: AlphabetQueueItem[] = [];
          const wrongArray = Array.from(wrongAnswers);

          wrongArray.forEach((letterId) => {
            const target = queue.find((q) => q.alphabetId === letterId);
            if (target) {
              errorItems.push({ ...target, source: 'error-review', round: currentRound });
            }
          });

          if (errorItems.length > 0) {
            appendQueue(errorItems);
            console.log('ğŸ” è¿½åŠ é”™é¢˜å›é¡¾é˜Ÿåˆ—:', errorItems.map((i) => i.alphabetId));
            // Just move next to start error review
            nextInQueue();
            return;
          }
        }

        // 2. Strict Round Completion Check
        // Condition: End of Queue AND No Errors allowed
        if (wrongAnswers.size === 0) {
          console.log('âœ… Round Completed Check Passed.');
          await submitRoundResults();
          // DO NOT call nextInQueue, just stop here.
          return;
        }
      }

      nextInQueue();
    } finally {
      setTimeout(() => {
        setIsProcessingNext(false);
      }, 300);
    }
  }, [currentItem, learnedCount, nextInQueue, queue, currentRound, isProcessingNext, currentIndex, wrongAnswers, appendQueue]); // ğŸ”¥ TODO-03: ç§»é™¤ derivedPhase å’Œ explicitPhase ä¾èµ–

  // âœ… ä¿®å¤: submitRoundResults
  const submitRoundResults = useCallback(async () => {
    console.log(`ğŸš€ Submitting Round ${currentRound} Results...`);

    const totalQuestions = queue.length; // Note: includes error retries
    const correctCount = Math.max(0, totalQuestions - wrongAnswers.size); // Rough calc

    const accuracy = totalQuestions > 0 ? correctCount / totalQuestions : 0;
    const passed = wrongAnswers.size === 0; // Round passes only if no errors

    // ğŸ”¥ TODO-05: åˆ¤å®š modeï¼Œfree-play æ¨¡å¼ä¸‹ç¦æ­¢ä»»ä½•å†™å…¥
    const mode = userProgress?.letterCompleted ? 'free-play' : 'learning';

    if (mode === 'learning') {
      // ===== learning æ¨¡å¼ï¼šæ­£å¸¸å†™å…¥è¿›åº¦ =====

      // 1. Submit to Backend
      await submitRoundToStore({
        userId,
        lessonId,
        roundNumber: currentRound,
        totalQuestions,
        correctCount,
        accuracy: 1, // Hack: If they cleared error queue, they technically "passed".
      });

      // 2. Log
      console.log(`âœ… Round ${currentRound} Submit Success.`);

      // ğŸ”¥ Step 5: Round3 å®Œæˆååˆ·æ–°ç”¨æˆ·è¿›åº¦ï¼ˆä»åç«¯è·å–æœ€æ–° completedLessonsï¼‰
      if (currentRound === 3 && passed) {
        console.log('ğŸ“š Round3 completed! Refreshing user progress from backend...');

        // ğŸ”¥ åˆ·æ–°è¿›åº¦ï¼ˆä¼šä»åç«¯è·å–æœ€æ–°çš„ completedLessonsï¼‰
        await useModuleAccessStore.getState().getUserProgress();

        console.log('âœ… User progress refreshed from backend');
      }

      // 3. ğŸ”¥ æ¨è¿›åˆ°ä¸‹ä¸€è½®ï¼ˆRound1 â†’ Round2 â†’ Round3ï¼‰
      const nextRound = Math.min(currentRound + 1, 3) as 1 | 2 | 3;

      // ğŸ”¥ å…ˆæ›´æ–° Store çš„ currentRound (é¿å… useEffect åŒæ­¥æ—¶è¦†ç›–)
      setStoreCurrentRound(nextRound);
      console.log(`ğŸ”„ Store currentRound updated: ${nextRound}`);

      // ğŸ”¥ å†æ›´æ–° Hook çš„æœ¬åœ°çŠ¶æ€
      setCurrentRound(nextRound);

      // 4. ğŸ”¥ æ˜¾å¼æ¸…é™¤ sessionï¼ˆé¿å…ä¸‹æ¬¡è¿›å…¥æ—¶å¼¹å‡ºæ¢å¤å¼¹çª—ï¼‰
      await clearStoredSessionState();
      console.log('ğŸ—‘ï¸ Round completed, session cleared');

      // 5. ENTER 'round-completed' PHASE
      setExplicitPhase('round-completed');
    } else {
      // ===== free-play æ¨¡å¼ï¼šåªè¯»å­¦ä¹ ï¼Œä¸å†™å…¥ä»»ä½•è¿›åº¦ =====
      console.log(`ğŸ® free-play æ¨¡å¼ï¼šRound å®Œæˆï¼Œä½†ä¸å†™å…¥è¿›åº¦`);

      // ä»…æ¸…é™¤ sessionï¼Œä¸æ¨è¿› round
      await clearStoredSessionState();

      // æ˜¾ç¤ºå®Œæˆ UI
      setExplicitPhase('round-completed');
    }

  }, [currentRound, queue.length, wrongAnswers, userId, lessonId, submitRoundToStore, clearStoredSessionState, setStoreCurrentRound, userProgress, setCurrentRound, setExplicitPhase]);

  // REMOVED: handleStartNextRound. 
  // User must exit to Lesson page and restart to trigger next round init.
  /*
  const handleStartNextRound = useCallback(async () => { ... });
  */



  const letterPool = useMemo(() => queue.map((item) => item.letter), [queue]);

  // ğŸ”¥ æ–°å¢: åœ¨ RoundCompleted æˆ–è¯¾ç¨‹å®Œæˆæ—¶è°ƒç”¨ï¼Œæ¸…é™¤ session
  const handleFinishRound = useCallback(async () => {
    await clearStoredSessionState();
  }, [clearStoredSessionState]);

  // ğŸ”¥ æ–°å¢: Skip (Bury) functionality for previous-review
  const handleSkipYesterdayReview = useCallback(async () => {
    // Only valid in previous-review phase
    // ğŸ”¥ TODO-03: derivedPhase is legacy, check source directly
    if (currentItem?.source !== 'previous-review') {
      console.warn('âš ï¸ handleSkipYesterdayReview called outside of previous-review phase');
      return;
    }

    console.log('â­ï¸ Skipping (Burying) review item:', currentItem.alphabetId);

    // 1. Mark as Known (Correct) to "bury" it for this session quality-wise
    // Using currentQuestionType or fallback to SOUND_TO_LETTER
    await handleAnswer(true, currentQuestionType ?? QuestionType.SOUND_TO_LETTER);

    // 2. Advance to next item immediately
    console.log('â­ï¸ Item skipped, advancing...');
    await handleNext();
  }, [currentItem, currentQuestionType, handleAnswer, handleNext]);

  return {
    initialized,
    phase: derivedPhase,
    currentRound,
    queueIndex: currentIndex,
    totalQueue: queue.length,
    roundEvaluation,
    currentItem,
    currentQuestionType,
    letterPool,
    onAnswer: handleAnswer,
    onNext: handleNext,
    // onStartNextRound: handleStartNextRound, // REMOVED
    phonicsRule,
    showPhonicsRuleCard,
    onCompletePhonicsRule: handleCompletePhonicsRule,
    // é€å‡ºç»™ UI
    pendingRecoverySession,
    resolveRecovery: handleResolveRecovery,
    onFinishRound: handleFinishRound,
    onSkipYesterdayReview: handleSkipYesterdayReview,
  };
}
````

## File: src/stores/alphabetStore.ts
````typescript
// src/stores/alphabetStore.ts

/**
 * å­—æ¯å­¦ä¹  Storeï¼ˆV9 ç‰ˆæœ¬ï¼‰
 *
 * èŒè´£ï¼š
 * - é€šè¿‡ memory-engineï¼ˆ/memory-engine äº‘å‡½æ•°ï¼‰è·å–ä»Šæ—¥å­—æ¯é˜Ÿåˆ—
 * - ç»´æŠ¤å‰ç«¯ä¼šè¯çŠ¶æ€ï¼ˆå½“å‰å­—æ¯ã€å®Œæˆæ•°é‡ç­‰ï¼‰
 * - æ¥æ”¶ã€Œå¯¹ / é”™ã€ç»“æœï¼Œè‡ªåŠ¨æ˜ å°„ä¸º è®°å¾—/é™Œç”Ÿ å¹¶è°ƒç”¨ submitMemoryResult
 *
 * æ³¨æ„ï¼š
 * - ä¸å†ä¾èµ–æœ¬åœ° letterData.tsï¼Œæ‰€æœ‰å­—æ¯æ•°æ®æ¥è‡ªåç«¯ Letter æ–‡æ¡£
 * - æ–°å­—æ¯å­¦ä¹ ï¼ˆè¯¾ç¨‹ï¼‰è´Ÿè´£æŠŠå­—æ¯å¡è¿›è®°å¿†å¼•æ“ï¼›å¤ä¹ é˜Ÿåˆ—å®Œå…¨äº¤ç»™ getTodayMemories
 */

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import AsyncStorage from '@react-native-async-storage/async-storage';
// ä½¿ç”¨ expo-file-system çš„ legacy APIï¼Œé¿å… v54 æ–° File API
// æŠ›å‡ºçš„ getInfoAsync ç­‰æ–¹æ³•åºŸå¼ƒé”™è¯¯ã€‚
import * as FileSystem from 'expo-file-system/legacy';

import { callCloudFunction } from '@/src/utils/apiClient';
import { API_ENDPOINTS, MODULE_ENDPOINTS } from '@/src/config/api.endpoints';

import type { Letter } from '@/src/entities/types/letter.types';
import { buildAlphabetQueue } from '@/src/utils/alphabet/buildAlphabetQueue';
import type { ApiResponse } from '@/src/entities/types/api.types';
import { LearningPhase } from '@/src/entities/enums/LearningPhase.enum';
import {
  QualityButton,
  QUALITY_SCORE_MAP,
  ATTEMPTS_INCREMENT_MAP,
} from '@/src/entities/enums/QualityScore.enum';


// ==================== åç«¯è®°å¿†çŠ¶æ€ ====================

export interface MemoryStatus {
  masteryLevel: number;
  reviewStage: number;
  correctCount: number;
  wrongCount: number;
  streakCorrect: number;
  nextReviewAt: string;
  isNew: boolean;
}

// ==================== ä¼šè¯ä¸­çš„å­—æ¯çŠ¶æ€ ====================

export type AlphabetLearningMode = 'learning' | 'free-play';

export interface AlphabetLearningState {
  // åŸºç¡€
  alphabetId: string;
  _id: string; // Letter çš„ _idï¼Œç”¨äºé¢˜ç›®ç”Ÿæˆ
  letter: Letter;
  thaiChar: string;
  pronunciation: string;
  example: string;
  audioUrl: string;
  category: string;

  // å‘éŸ³ç›¸å…³å­—æ®µï¼ˆç”¨äºé¢˜ç›®ç”Ÿæˆï¼‰
  syllableSoundName?: string; // éŸ³èŠ‚å‘éŸ³åç§°ï¼ˆå¦‚: "d"ï¼‰
  initialSound?: string; // é¦–éŸ³ï¼ˆå¦‚: "d"ï¼‰
  syllableSoundUrl?: string; // éŸ³èŠ‚å‘éŸ³URL
  letterPronunciationUrl?: string; // å­—æ¯å‘éŸ³URL
  audioPath?: string; // æ—§ç‰ˆéŸ³é¢‘è·¯å¾„

  // ä¼šè¯è¿›åº¦
  currentAttempts: number;
  requiredAttempts: number;
  qualityHistory: number[];
  isCompleted: boolean;
  timestamp: string;

  // åç«¯è®°å¿†ä¿¡æ¯ï¼ˆåªè¯»ï¼‰
  memoryState?: MemoryStatus;
}

// ==================== é˜Ÿåˆ—é¡¹ï¼ˆå‰ç«¯æ„å»ºï¼‰ ====================

// ğŸ”¥ TODO-03: ç»Ÿä¸€ source å‘½åï¼Œä¸ ALPHABET_MODULE_IMPLEMENTATION_SKELETON.md å¯¹é½
export type AlphabetQueueSource =
  | 'previous-review'      // ä¹‹å‰è½®æ¬¡çš„å¤ä¹ 
  | 'new-learning'         // æ–°å­—æ¯å­¦ä¹ 
  | 'mini-review'          // è¿·ä½ å¤ä¹ ï¼ˆæ¯3ä¸ªå­—æ¯ï¼‰
  | 'final-review'         // æœ€ç»ˆå¤ä¹ 
  | 'error-review';        // é”™é¢˜å¤ä¹ 

export interface AlphabetQueueItem extends AlphabetLearningState {
  source: AlphabetQueueSource;
  round: number;
}

// ==================== åç«¯è¿”å›ç»“æ„ ====================

import type {
  LessonMetadata,
  PhonicsRule,
} from '@/src/entities/types/phonicsRule.types';

interface TodayLettersResponse {
  items: Array<Letter & { memoryState?: MemoryStatus }>;
  summary: {
    total: number;
    newCount: number;
    reviewCount: number;
    entityType: string;
  };
  unlockInfo?: Record<string, any>;
  lessonMetadata?: LessonMetadata | null;
  phonicsRule?: PhonicsRule | null;
}

// ==================== Store çŠ¶æ€å®šä¹‰ ====================

interface AlphabetStoreState {
  phase: LearningPhase;

  queue: AlphabetQueueItem[];
  currentIndex: number;
  currentItem: AlphabetQueueItem | null;

  completedCount: number;
  totalCount: number;

  isLoading: boolean;
  error: string | null;

  // å·²ç¼“å­˜çš„éŸ³é¢‘ URLï¼ˆç”¨äºé¿å…é‡å¤é¢„ä¸‹è½½ï¼‰
  cachedAudioKeys: string[];

  // å½“å‰è¯¾ç¨‹å…ƒæ•°æ® / æ‹¼è¯»è§„åˆ™ï¼ˆç”±åç«¯è¿”å›ï¼‰
  lessonMetadata: LessonMetadata | null;
  phonicsRule: PhonicsRule | null;

  // ğŸ”¥ Bug 2 ä¿®å¤ï¼šæ·»åŠ  currentRound å­—æ®µ
  currentRound: 1 | 2 | 3;

  // Actions
  initializeSession: (
    userId: string,
    options?: {
      limit?: number;
      lessonId?: string;
      round?: number;
    }
  ) => Promise<void>;
  /**
   * å‰ç«¯ç»„ä»¶åªå‘Šè¯‰æˆ‘è¿™é¢˜ã€Œå¯¹/é”™ã€
   * è¿™é‡Œè‡ªåŠ¨æ˜ å°„ä¸º QualityButton å¹¶è°ƒç”¨ submitMemoryResult
   */
  submitResult: (userId: string, isCorrect: boolean) => Promise<void>;
  submitRoundEvaluation: (params: {
    userId: string;
    lessonId: string;
    roundNumber: number;
    totalQuestions: number;
    correctCount: number;
    accuracy: number;
  }) => Promise<void>;

  next: () => void;
  appendQueue: (items: AlphabetQueueItem[]) => void;
  previous: () => void;
  // ğŸ”¥ Bug 3 ä¿®å¤ï¼šæ·»åŠ  setCurrentIndex æ–¹æ³•
  setCurrentIndex: (index: number) => void;
  // ğŸ”¥ Bug 2 ä¿®å¤ï¼šæ·»åŠ  setCurrentRound æ–¹æ³•
  setCurrentRound: (round: 1 | 2 | 3) => void;

  reset: () => void;
  clearError: () => void;
}

// ==================== éŸ³é¢‘ URL è§£æ ====================


// ==================== è¾…åŠ©ï¼šLetter â†’ AlphabetLearningState ====================

function mapLetterToState(
  letter: Letter,
  memoryState?: MemoryStatus
): AlphabetLearningState {
  const pronunciation =
    letter.letterNamePronunciation ||
    letter.syllableSoundName ||
    letter.initialSound ||
    '';

  const example =
    letter.exampleWord && letter.exampleMeaning
      ? `${letter.exampleWord}ï¼ˆ${letter.exampleMeaning}ï¼‰`
      : letter.exampleWord || '';

  const rawAudioKey =
    letter.fullSoundLocalPath ||
    letter.fullSoundUrl ||
    letter.letterPronunciationLocalPath ||
    letter.letterPronunciationUrl ||
    letter.syllableSoundLocalPath ||
    letter.syllableSoundUrl ||
    letter.audioPath ||
    '';

  // ä¸ºæ»¡è¶³ã€Œæ’­æ”¾åªä»æœ¬åœ°è¯»å–ã€çš„ç›®æ ‡ï¼ŒaudioUrl ä»…åœ¨é¢„ä¸‹è½½é˜¶æ®µè¢«è®¾ç½®ä¸º file:// è·¯å¾„ã€‚
  // è¿™é‡Œå¦‚æœå·²ç»æœ‰æœ¬åœ°è·¯å¾„ï¼ˆ*_LocalPathï¼‰ï¼Œå°±ä½¿ç”¨ï¼›å¦åˆ™å…ˆç½®ç©ºï¼Œç­‰å¾…é¢„ä¸‹è½½ä»»åŠ¡å¡«å……ã€‚
  const initialAudioUrl =
    (rawAudioKey.startsWith('file://') ? rawAudioKey : '');

  return {
    alphabetId: letter._id,
    _id: letter._id,
    letter,
    thaiChar: letter.thaiChar,
    pronunciation,
    example,
    audioUrl: initialAudioUrl,
    category: letter.category,

    // å‘éŸ³ç›¸å…³å­—æ®µ
    syllableSoundName: letter.syllableSoundName,
    initialSound: letter.initialSound,
    syllableSoundUrl: letter.syllableSoundUrl,
    letterPronunciationUrl: letter.letterPronunciationUrl,
    audioPath: letter.audioPath,

    currentAttempts: 0,
    requiredAttempts: 3,
    qualityHistory: [],
    isCompleted: false,
    timestamp: new Date().toISOString(),

    memoryState,
  };
}

// ==================== Store å®ç° ====================

export const useAlphabetStore = create<AlphabetStoreState>()(
  persist(
    (set, get) => ({
      phase: LearningPhase.IDLE,
      queue: [],
      currentIndex: 0,
      currentItem: null,
      completedCount: 0,
      totalCount: 0,
      isLoading: false,
      error: null,
      cachedAudioKeys: [],
      lessonMetadata: null,
      phonicsRule: null,
      // ğŸ”¥ Bug 2 ä¿®å¤ï¼šæ·»åŠ åˆå§‹å€¼
      currentRound: 1,

      // è·å–ä»Šæ—¥å­—æ¯å­¦ä¹ /å¤ä¹ é˜Ÿåˆ—
      initializeSession: async (
        userId: string,
        options?: { limit?: number; lessonId?: string; round?: number }
      ) => {
        set({ isLoading: true, error: null });

        const limit = options?.limit ?? 30;
        const lessonId = options?.lessonId;

        // ğŸ”¥ ä»åç«¯è¯»å–å½“å‰è½®æ¬¡ï¼ˆå¦‚æœæœªæ˜¾å¼ä¼ å…¥ï¼‰
        let round = options?.round ?? 1;
        let mode: AlphabetLearningMode = 'learning';

        try {
          // è¯»å– user_alphabet_progressï¼Œç»Ÿä¸€åˆ¤å®š currentRound ä¸ mode
          const progressCol = await callCloudFunction<any>(
            'getUserProgress',
            { userId, entityType: 'letter' },
            { endpoint: MODULE_ENDPOINTS.GET_USER_PROGRESS.cloudbase }
          );

          if (progressCol.success && progressCol.data?.progress) {
            const progress = progressCol.data.progress;

            // ğŸ”¥ P0-A: lesson-scoped round æ¨å¯¼ï¼ˆä¸å†ä½¿ç”¨å…¨å±€ currentRoundï¼‰
            if (!options?.round && lessonId) {
              const roundHistory = progress.roundHistory || [];

              // è¿‡æ»¤å‡ºå½“å‰è¯¾ç¨‹ä¸” passed çš„ round è®°å½•
              const lessonHistoryRounds = roundHistory
                .filter((r: any) => r.lessonId === lessonId && r.passed === true)
                .map((r: any) => r.roundNumber);

              const lastPassedRound = lessonHistoryRounds.length > 0
                ? Math.max(...lessonHistoryRounds)
                : 0;

              const computedRound = Math.min(Math.max(lastPassedRound + 1, 1), 3);
              round = computedRound;

              console.log(`ğŸ” [P0-A] lessonId: ${lessonId}, backendCurrentRound: ${progress.currentRound || 'N/A'}, computedRound: ${computedRound}, lessonHistoryRounds: [${lessonHistoryRounds.join(',')}]`);
            }

            mode = progress.letterCompleted ? 'free-play' : 'learning';
            console.log(`âœ… AlphabetLearningMode: ${mode}`);
          } else {
            console.log('âš ï¸ æœªè·å–åˆ° progressï¼Œé»˜è®¤ä½¿ç”¨ learning æ¨¡å¼');
          }
        } catch (e) {
          console.warn('âš ï¸ è¯»å– user_alphabet_progress å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼:', e);
        }

        try {
          const response = await callCloudFunction<TodayLettersResponse>(
            'getTodayMemories',
            {
              userId,
              entityType: 'letter',
              limit,
              includeNew: true,
              lessonId,
              roundNumber: round, // ğŸ”¥ ä¼ é€’ roundNumber
            },
            {
              endpoint: API_ENDPOINTS.MEMORY.GET_TODAY_MEMORIES.cloudbase,
            }
          );

          if (!response.success || !response.data) {
            throw new Error(response.error ?? 'è·å–ä»Šæ—¥å­—æ¯å¤±è´¥');
          }

          const { items, lessonMetadata, phonicsRule } = response.data;

          if (!items || items.length === 0) {
            set({
              phase: LearningPhase.COMPLETED,
              queue: [],
              currentItem: null,
              currentIndex: 0,
              completedCount: 0,
              totalCount: 0,
              isLoading: false,
              lessonMetadata: lessonMetadata ?? null,
              phonicsRule: phonicsRule ?? null,
            });
            return;
          }

          const learningItems = items.map((item) =>
            mapLetterToState(item, item.memoryState)
          );

          // ğŸ”¥ P0-D: æŒ‰ lessonId åˆ‡åˆ†ï¼ˆä¸ä¾èµ– isNewï¼‰
          // ç¡®ä¿å››æ®µç»“æ„æ°¸è¿œå­˜åœ¨ï¼Œä¸”ç¬¦åˆäº§å“è§„åˆ™
          const currentLessonLetters = learningItems.filter(
            (item) => lessonId && item.letter.curriculumLessonIds?.includes(lessonId)
          );

          const nonCurrentLessonLetters = learningItems.filter(
            (item) => lessonId && !item.letter.curriculumLessonIds?.includes(lessonId)
          );

          let reviewLetters: AlphabetLearningState[];
          let newLetters: AlphabetLearningState[];

          if (round === 1) {
            // Round1: previous = éæœ¬è¯¾å­—æ¯ï¼ˆè·¨è¯¾ï¼‰ï¼Œnew = æœ¬è¯¾å­—æ¯
            reviewLetters = nonCurrentLessonLetters;
            newLetters = currentLessonLetters;
          } else {
            // Round2/3: previous = æœ¬è¯¾å­—æ¯ï¼ˆåŒè¯¾å¤ä¹ ï¼‰ï¼Œnew = æœ¬è¯¾å­—æ¯ï¼ˆä¿è¯ new-learning/mini/final å­˜åœ¨ï¼‰
            reviewLetters = currentLessonLetters;
            newLetters = currentLessonLetters;
          }

          const queue = buildAlphabetQueue({
            lessonLetters: newLetters,           // ğŸ”¥ ä¿è¯ new-learning/mini/final æ°¸è¿œæœ‰å†…å®¹
            round,
            mode,
            previousRoundLetters: reviewLetters, // ğŸ”¥ Round1=è·¨è¯¾ï¼ŒRound2/3=æœ¬è¯¾
          });

          // ğŸ”¥ å¼€å‘ç¯å¢ƒæ—¥å¿— + å››æ®µç»“æ„éªŒè¯ï¼ˆåœ¨æ„å»ºåç»Ÿè®¡ï¼‰
          if (__DEV__) {
            const sourceCounts = queue.reduce((acc, item) => {
              acc[item.source] = (acc[item.source] || 0) + 1;
              return acc;
            }, {} as Record<string, number>);

            console.log('ğŸ“Š [buildQueue] é˜Ÿåˆ—åˆ†æ:', {
              round,
              mode,
              lessonId,
              total: learningItems.length,
              currentLessonCount: currentLessonLetters.length,
              nonCurrentLessonCount: nonCurrentLessonLetters.length,
              reviewCount: reviewLetters.length,
              newCount: newLetters.length,
              queueTotal: queue.length,
              sourceCounts,  // ğŸ”¥ å››æ®µç»Ÿè®¡ {'previous-review': 5, 'new-learning': 12, ...}
              reviewIds: reviewLetters.map(l => l.thaiChar).slice(0, 5),
              newIds: newLetters.map(l => l.thaiChar).slice(0, 5),
            });
          }

          // ğŸ› P0-3 DEBUG: æ£€æŸ¥åç«¯è¿”å›çš„é˜Ÿåˆ—æ˜¯å¦åŒ…å«ä¸‰æ–°ä¸€å¤é€»è¾‘
          console.log('=== åç«¯è¿”å›çš„é˜Ÿåˆ—åˆ†æ ===');
          console.log('æ€»å­—æ¯æ•°:', queue.length);
          console.log(
            'todayQueue:',
            queue.map((item, index) => ({
              index,
              letterId: item.alphabetId,
              thaiChar: item.thaiChar,
              isNew: item.memoryState?.isNew ?? null,
              reviewStage: item.memoryState?.reviewStage ?? null,
              source: item.source,
              round: item.round,
            }))
          );

          // ç»Ÿè®¡æ–°å­—æ¯å’Œå¤ä¹ å­—æ¯çš„åˆ†å¸ƒ
          // ğŸ”¥ TODO-03: ç»Ÿä¸€ä½¿ç”¨ 'new-learning'
          const newLettersInQueue = queue.filter((item) => item.source === 'new-learning');
          const reviewLettersInQueue = queue.filter((item) => item.source !== 'new-learning');
          console.log('æ–°å­—æ¯æ•°é‡:', newLettersInQueue.length);
          console.log('å¤ä¹ å­—æ¯æ•°é‡:', reviewLettersInQueue.length);

          set({
            phase: LearningPhase.IDLE,
            queue,
            currentItem: queue[0],
            currentIndex: 0,
            completedCount: 0,
            totalCount: queue.length,
            currentRound: round as 1 | 2 | 3, // ğŸ”¥ Bug 2 ä¿®å¤ï¼šä¿å­˜ currentRound
            isLoading: false,
            lessonMetadata: lessonMetadata ?? null,
            phonicsRule: phonicsRule ?? null,
          });

          // é¢„ä¸‹è½½æœ¬è¯¾æ‰€æœ‰å­—æ¯éŸ³é¢‘åˆ°æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿï¼ˆé¦–æ¬¡è¿›å…¥è¯¥è¯¾æ—¶ï¼‰
          (async () => {
            try {
              const cacheDir = `${
                // expo-file-system åœ¨ç±»å‹å®šä¹‰é‡Œæ²¡æœ‰æš´éœ² cacheDirectoryï¼Œ
                // è¿™é‡Œé€šè¿‡ any è®¿é—®ä»¥é¿å… TS æŠ¥é”™ã€‚
                (FileSystem as any).cacheDirectory ??
                (FileSystem as any).documentDirectory ??
                ''
                }alphabet-audio/`;
              const dirInfo = await FileSystem.getInfoAsync(cacheDir);
              if (!dirInfo.exists) {
                await FileSystem.makeDirectoryAsync(cacheDir, {
                  intermediates: true,
                });
              }

              const updatedQueue = [...queue];
              const urlToLocalPath = new Map<string, string>();

              const toHttpUrl = (path?: string | null): string => {
                if (!path) return '';
                if (path.startsWith('http://') || path.startsWith('https://')) {
                  return path;
                }
                let finalPath = path;
                if (!/\.mp3($|\?)/.test(finalPath)) {
                  finalPath = `${finalPath}.mp3`;
                }
                return `https://636c-cloud1-1gjcyrdd7ab927c6-1387301748.tcb.qcloud.la/alphabet/${finalPath}`;
              };

              // eslint-disable-next-line no-console
              console.log(
                'ğŸ§ å¼€å§‹é¢„ä¸‹è½½æœ¬è¯¾å­—æ¯éŸ³é¢‘, é˜Ÿåˆ—é•¿åº¦:',
                updatedQueue.length,
              );

              for (let index = 0; index < updatedQueue.length; index += 1) {
                const current = updatedQueue[index];
                const letter = { ...current.letter };

                const fieldEntries: Array<{
                  key: 'full' | 'syllable' | 'end' | 'letter';
                  raw?: string;
                }> = [
                    { key: 'full', raw: letter.fullSoundUrl },
                    { key: 'syllable', raw: letter.syllableSoundUrl },
                    { key: 'end', raw: letter.endSyllableSoundUrl },
                    { key: 'letter', raw: letter.letterPronunciationUrl },
                  ];

                for (const entry of fieldEntries) {
                  if (!entry.raw) continue;
                  const httpUrl = toHttpUrl(entry.raw);
                  if (!httpUrl) continue;

                  let localPath = urlToLocalPath.get(httpUrl);
                  if (!localPath) {
                    const fileName = encodeURIComponent(httpUrl);
                    localPath = `${cacheDir}${fileName}`;

                    let success = false;
                    for (
                      let attempt = 0;
                      attempt < 3 && !success;
                      attempt += 1
                    ) {
                      try {
                        const info = await FileSystem.getInfoAsync(localPath);
                        if (!info.exists) {
                          // eslint-disable-next-line no-console
                          console.log(
                            `ğŸ“¥ ä¸‹è½½éŸ³é¢‘(ç¬¬ ${attempt + 1} æ¬¡):`
                          );
                          await FileSystem.downloadAsync(httpUrl, localPath);
                        }
                        success = true;
                      } catch (err) {
                        console.warn(
                          `âš ï¸ ä¸‹è½½å­—æ¯éŸ³é¢‘å¤±è´¥(ç¬¬ ${attempt + 1} æ¬¡):`,
                          httpUrl,
                          err,
                        );
                        await new Promise((resolve) =>
                          setTimeout(resolve, 500 * (attempt + 1)),
                        );
                      }
                    }

                    if (!success) {
                      // eslint-disable-next-line no-console
                      console.warn('âŒ å¤šæ¬¡ä¸‹è½½å¤±è´¥,æ”¾å¼ƒè¯¥éŸ³é¢‘:', httpUrl);
                      continue;
                    }

                    urlToLocalPath.set(httpUrl, localPath);
                  }

                  if (entry.key === 'full') {
                    letter.fullSoundLocalPath = localPath;
                  } else if (entry.key === 'syllable') {
                    letter.syllableSoundLocalPath = localPath;
                  } else if (entry.key === 'end') {
                    letter.endSyllableSoundLocalPath = localPath;
                  } else if (entry.key === 'letter') {
                    letter.letterPronunciationLocalPath = localPath;
                  }
                }

                const primaryAudio =
                  letter.fullSoundLocalPath ||
                  letter.letterPronunciationLocalPath ||
                  letter.syllableSoundLocalPath ||
                  letter.endSyllableSoundLocalPath ||
                  current.audioUrl;

                updatedQueue[index] = {
                  ...current,
                  letter,
                  audioUrl: primaryAudio && primaryAudio.startsWith('file://')
                    ? primaryAudio
                    : primaryAudio,
                };
              }

              set((state) => {
                const { currentIndex } = state;
                const currentItem = updatedQueue[currentIndex] ?? state.currentItem;

                // è°ƒè¯•ï¼šå½“å‰é¡¹åœ¨é¢„ä¸‹è½½åçš„éŸ³é¢‘æƒ…å†µ
                if (currentItem) {
                  // eslint-disable-next-line no-console
                  console.log('ğŸ¯ é¢„ä¸‹è½½åå½“å‰å­—æ¯çŠ¶æ€:', {
                    id: currentItem.letter._id,
                    thaiChar: currentItem.letter.thaiChar,
                  });
                }

                return {
                  queue: updatedQueue,
                  currentItem,
                };
              });
              // eslint-disable-next-line no-console
              console.log('ğŸ§ é¢„ä¸‹è½½å…¨éƒ¨å®Œæˆ, é˜Ÿåˆ—æ›´æ–°æˆåŠŸ');
            } catch (err) {
              console.warn('âš ï¸ é¢„ä¸‹è½½å­—æ¯éŸ³é¢‘ä»»åŠ¡å¤±è´¥:', err);
            }
          })();
        } catch (e: any) {
          console.error('âŒ initializeSession error:', e);
          set({
            isLoading: false,
            error: e?.message ?? 'åŠ è½½å¤±è´¥',
          });
        }
      },

      // å¤ä¹ æäº¤ï¼šåªæ›´æ–°æœ¬åœ°ä¼šè¯çŠ¶æ€ï¼Œè®°å¿†å†™å…¥ç”± round å®Œæˆæ—¶ç»Ÿä¸€å¤„ç†
      submitResult: async (userId: string, isCorrect: boolean) => {
        const { currentItem, currentIndex, queue } = get();
        if (!currentItem) return;

        // è‡ªåŠ¨æ˜ å°„ä¸ºè´¨é‡æšä¸¾
        const quality: QualityButton = isCorrect
          ? QualityButton.KNOW
          : QualityButton.FORGET;

        try {
          const updatedQueue = [...queue];
          const item = updatedQueue[currentIndex];

          if (item) {
            item.currentAttempts += ATTEMPTS_INCREMENT_MAP[quality];
            item.qualityHistory.push(QUALITY_SCORE_MAP[quality]);

            if (item.currentAttempts >= item.requiredAttempts) {
              item.isCompleted = true;
            }

            item.timestamp = new Date().toISOString();
          }

          const completedCount = updatedQueue.filter(
            (it) => it.isCompleted
          ).length;

          set({
            queue: updatedQueue,
            completedCount,
          });

        } catch (e: any) {
          console.error('âŒ submitResult error:', e);
          set({
            error: e?.message ?? 'æäº¤å¤±è´¥',
          });
        }
      },

      // æäº¤å­—æ¯æ¨¡å—ä¸‰è½®è¯„ä¼°ç»“æœï¼ˆä»…è®°å½•ç»Ÿè®¡ä¿¡æ¯ï¼Œä¸å½±å“è®°å¿†ç®—æ³•ï¼‰
      submitRoundEvaluation: async ({
        userId,
        lessonId,
        roundNumber,
        totalQuestions,
        correctCount,
        accuracy,
      }) => {
        try {
          await callCloudFunction(
            'submitRoundEvaluation',
            {
              userId,
              entityType: 'letter',
              lessonId,
              roundNumber,
              totalQuestions,
              correctCount,
              accuracy,
            },
            {
              endpoint: API_ENDPOINTS.MEMORY.SUBMIT_ROUND_EVALUATION.cloudbase,
            },
          );
        } catch (e: any) {
          console.error('âŒ submitRoundEvaluation error:', e);
          // ä¸å½±å“å‰ç«¯æµç¨‹ï¼Œå‡ºé”™æ—¶åªè®°å½•æ—¥å¿—
        }
      },

      // ä¸‹ä¸€ä¸ªå­—æ¯
      next: () => {
        const { currentIndex, queue } = get();
        const nextIndex = currentIndex + 1;

        if (nextIndex < queue.length) {
          set({
            currentIndex: nextIndex,
            currentItem: queue[nextIndex],
          });
        } else {
          set({
            phase: LearningPhase.COMPLETED,
            currentItem: null,
          });
        }
      },

      // è¿½åŠ é˜Ÿåˆ—ï¼ˆç”¨äºé”™é¢˜å›é¡¾ç­‰åŠ¨æ€æ’å…¥ï¼‰
      appendQueue: (items: AlphabetQueueItem[]) => {
        const { queue, currentIndex } = get();
        const newQueue = [...queue, ...items];
        set({
          queue: newQueue,
          totalCount: newQueue.length,
          currentItem: newQueue[currentIndex] ?? null,
        });
      },

      // ä¸Šä¸€ä¸ªå­—æ¯ï¼ˆä¸»è¦ç”¨äºè°ƒè¯•æˆ–æŸäº› UIï¼‰
      previous: () => {
        const { currentIndex, queue } = get();
        const prevIndex = Math.max(0, currentIndex - 1);

        set({
          currentIndex: prevIndex,
          currentItem: queue[prevIndex] ?? null,
        });
      },

      // ğŸ”¥ Bug 3 ä¿®å¤ï¼šè®¾ç½®é˜Ÿåˆ—ä½ç½®
      setCurrentIndex: (index: number) => {
        const { queue } = get();
        set({
          currentIndex: index,
          currentItem: queue[index] ?? null,
        });
      },

      // ğŸ”¥ Bug 2 ä¿®å¤ï¼šè®¾ç½®å½“å‰è½®æ¬¡
      setCurrentRound: (round: 1 | 2 | 3) => {
        set({ currentRound: round });
      },

      // é‡ç½®ï¼ˆä¾‹å¦‚åˆ‡æ¢ç”¨æˆ·ï¼‰
      reset: () =>
        set({
          phase: LearningPhase.IDLE,
          queue: [],
          currentIndex: 0,
          currentItem: null,
          completedCount: 0,
          totalCount: 0,
          isLoading: false,
          error: null,
          cachedAudioKeys: [],
        }),

      clearError: () => set({ error: null }),
    }),
    {
      name: 'alphabet-storage',
      storage: createJSONStorage(() => AsyncStorage),
      // åªæŒä¹…åŒ–ç»Ÿè®¡æ•°æ®ï¼Œé˜Ÿåˆ—ä¿æŒä¼šè¯çº§åˆ«
      partialize: (state) => ({
        completedCount: state.completedCount,
        totalCount: state.totalCount,
        cachedAudioKeys: state.cachedAudioKeys,
      }),
    }
  )
);

// ==================== ä¸€äº›ä¾¿æ· Hooks ====================

export const useAlphabetProgress = () => {
  const { completedCount, totalCount } = useAlphabetStore();
  if (!totalCount) return 0;
  return (completedCount / totalCount) * 100;
};

export const useCurrentAlphabet = () =>
  useAlphabetStore((s) => s.currentItem);

export const useAlphabetPhase = () => useAlphabetStore((s) => s.phase);
````

## File: package.json
````json
{
  "name": "thailearningapp",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo-google-fonts/noto-serif-sc": "^0.4.2",
    "@expo-google-fonts/playfair-display": "^0.4.2",
    "@expo-google-fonts/sarabun": "^0.4.1",
    "@expo/cli": "^54.0.18",
    "@expo/vector-icons": "15.0.3",
    "@react-native-async-storage/async-storage": "2.2.0",
    "@react-native-community/slider": "5.0.1",
    "axios": "^1.13.2",
    "expo": "54.0.27",
    "expo-asset": "12.0.11",
    "expo-av": "16.0.8",
    "expo-blur": "15.0.8",
    "expo-constants": "18.0.11",
    "expo-file-system": "19.0.20",
    "expo-font": "14.0.10",
    "expo-linear-gradient": "15.0.8",
    "expo-linking": "8.0.10",
    "expo-localization": "17.0.8",
    "expo-router": "6.0.17",
    "expo-splash-screen": "31.0.12",
    "expo-status-bar": "3.0.9",
    "i18next": "^25.6.3",
    "lucide-react-native": "^0.554.0",
    "react": "19.1.0",
    "react-i18next": "^16.3.4",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-linear-gradient": "^2.8.3",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "5.6.2",
    "react-native-screens": "~4.16.0",
    "react-native-svg": "15.12.1",
    "react-native-worklets": "0.5.1",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "@testing-library/react-native": "^13.0.0",
    "@types/react": "~19.1.10",
    "@types/react-native": "^0.72.8",
    "babel-plugin-module-resolver": "^5.0.2",
    "react-test-renderer": "^19.2.1",
    "typescript": "^5.1.3"
  },
  "private": true
}
````
